#define UNITY_EDITOR
#define ENABLE_DIAGNOSTICS
using Amplitude;
using Amplitude.Extensions;
using Amplitude.Interop;
using Amplitude.IO;
using Amplitude.Unity.Achievement;
using Amplitude.Unity.Audio;
using Amplitude.Unity.Framework;
using Amplitude.Unity.Game;
using Amplitude.Unity.Game.Orders;
using Amplitude.Unity.Gui;
using Amplitude.Unity.Gui.SimulationEffect;
using Amplitude.Unity.Localization;
using Amplitude.Unity.Messaging;
using Amplitude.Unity.Networking;
using Amplitude.Unity.Platform;
using Amplitude.Unity.Runtime;
using Amplitude.Unity.Serialization;
using Amplitude.Unity.Session;
using Amplitude.Unity.Simulation;
using Amplitude.Unity.Simulation.SimulationModifierDescriptors;
using Amplitude.Unity.Steam;
using Amplitude.Unity.Video;
using Amplitude.Unity.View;
using Amplitude.Unity.XboxOne;
using ConsoleUtils;
using DataPlatform;
using FMOD;
using Microsoft.Win32;
using Multiplayer;
using Pathfinding;
using Pathfinding.ClipperLib;
using Pathfinding.Ionic.Zip;
using Pathfinding.Poly2Tri;
using Pathfinding.RVO;
using Pathfinding.RVO.Sampled;
using Pathfinding.Serialization;
using Pathfinding.Serialization.JsonFx;
using Pathfinding.Util;
using Pathfinding.Voxels;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using System.Xml.Serialization;
using UnityEngine;
using UnityEngine.Serialization;
using Users;
using WyrmTale;

[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[AddComponentMenu("Pathfinding/AI/AIPath (generic)")]
[RequireComponent(typeof(Seeker))]
public class AIPath : MonoBehaviour
{
	public float repathRate = 0.5f;

	public Transform target;

	public bool canSearch = true;

	public bool canMove = true;

	public float speed = 3f;

	public float turningSpeed = 5f;

	public float slowdownDistance = 0.6f;

	public float pickNextWaypointDist = 2f;

	public float forwardLook = 1f;

	public float endReachedDistance = 0.2f;

	public bool closestOnPathCheck = true;

	protected float minMoveScale = 0.05f;

	protected Seeker seeker;

	protected Transform tr;

	private float lastRepath = -9999f;

	protected Pathfinding.Path path;

	protected CharacterController controller;

	protected NavmeshController navController;

	protected RVOController rvoController;

	protected Rigidbody rigid;

	protected int currentWaypointIndex;

	protected bool targetReached;

	protected bool canSearchAgain = true;

	protected Vector3 lastFoundWaypointPosition;

	protected float lastFoundWaypointTime = -9999f;

	private bool startHasRun;

	protected Vector3 targetPoint;

	protected Vector3 targetDirection;

	public bool TargetReached => targetReached;

	protected virtual void Awake()
	{
		seeker = GetComponent<Seeker>();
		tr = base.transform;
		controller = GetComponent<CharacterController>();
		navController = GetComponent<NavmeshController>();
		rvoController = GetComponent<RVOController>();
		if (rvoController != null)
		{
			rvoController.enableRotation = false;
		}
		rigid = GetComponent<Rigidbody>();
	}

	protected virtual void Start()
	{
		startHasRun = true;
		OnEnable();
	}

	protected virtual void OnEnable()
	{
		lastRepath = -9999f;
		canSearchAgain = true;
		lastFoundWaypointPosition = GetFeetPosition();
		if (startHasRun)
		{
			Seeker obj = seeker;
			obj.pathCallback = (OnPathDelegate)Delegate.Combine(obj.pathCallback, new OnPathDelegate(OnPathComplete));
			StartCoroutine(RepeatTrySearchPath());
		}
	}

	public void OnDisable()
	{
		if (seeker != null && !seeker.IsDone())
		{
			seeker.GetCurrentPath().Error();
		}
		if (path != null)
		{
			path.Release(this);
		}
		path = null;
		Seeker obj = seeker;
		obj.pathCallback = (OnPathDelegate)Delegate.Remove(obj.pathCallback, new OnPathDelegate(OnPathComplete));
	}

	protected IEnumerator RepeatTrySearchPath()
	{
		while (true)
		{
			float v = TrySearchPath();
			yield return new WaitForSeconds(v);
		}
	}

	public float TrySearchPath()
	{
		if (Time.time - lastRepath >= repathRate && canSearchAgain && canSearch && target != null)
		{
			SearchPath();
			return repathRate;
		}
		float num = repathRate - (Time.time - lastRepath);
		return (!(num < 0f)) ? num : 0f;
	}

	public virtual void SearchPath()
	{
		if (target == null)
		{
			throw new InvalidOperationException("Target is null");
		}
		lastRepath = Time.time;
		Vector3 position = target.position;
		canSearchAgain = false;
		seeker.StartPath(GetFeetPosition(), position);
	}

	public virtual void OnTargetReached()
	{
	}

	public virtual void OnPathComplete(Pathfinding.Path _p)
	{
		ABPath aBPath = _p as ABPath;
		if (aBPath == null)
		{
			throw new Exception("This function only handles ABPaths, do not use special path types");
		}
		canSearchAgain = true;
		aBPath.Claim(this);
		if (aBPath.error)
		{
			aBPath.Release(this);
			return;
		}
		if (path != null)
		{
			path.Release(this);
		}
		path = aBPath;
		currentWaypointIndex = 0;
		targetReached = false;
		if (closestOnPathCheck)
		{
			Vector3 vector = (!(Time.time - lastFoundWaypointTime < 0.3f)) ? aBPath.originalStartPoint : lastFoundWaypointPosition;
			Vector3 feetPosition = GetFeetPosition();
			Vector3 vector2 = feetPosition - vector;
			float magnitude = vector2.magnitude;
			vector2 /= magnitude;
			int num = (int)(magnitude / pickNextWaypointDist);
			for (int i = 0; i <= num; i++)
			{
				CalculateVelocity(vector);
				vector += vector2;
			}
		}
	}

	public virtual Vector3 GetFeetPosition()
	{
		if (rvoController != null)
		{
			return tr.position - Vector3.up * rvoController.height * 0.5f;
		}
		if (controller != null)
		{
			return tr.position - Vector3.up * controller.height * 0.5f;
		}
		return tr.position;
	}

	public virtual void Update()
	{
		if (!canMove)
		{
			return;
		}
		Vector3 vector = CalculateVelocity(GetFeetPosition());
		RotateTowards(targetDirection);
		if (rvoController != null)
		{
			rvoController.Move(vector);
		}
		else if (!(navController != null))
		{
			if (controller != null)
			{
				controller.SimpleMove(vector);
			}
			else if (rigid != null)
			{
				rigid.AddForce(vector);
			}
			else
			{
				base.transform.Translate(vector * Time.deltaTime, Space.World);
			}
		}
	}

	protected float XZSqrMagnitude(Vector3 a, Vector3 b)
	{
		float num = b.x - a.x;
		float num2 = b.z - a.z;
		return num * num + num2 * num2;
	}

	protected Vector3 CalculateVelocity(Vector3 currentPosition)
	{
		if (path == null || path.vectorPath == null || path.vectorPath.Count == 0)
		{
			return Vector3.zero;
		}
		List<Vector3> vectorPath = path.vectorPath;
		if (vectorPath.Count == 1)
		{
			vectorPath.Insert(0, currentPosition);
		}
		if (currentWaypointIndex >= vectorPath.Count)
		{
			currentWaypointIndex = vectorPath.Count - 1;
		}
		if (currentWaypointIndex <= 1)
		{
			currentWaypointIndex = 1;
		}
		while (currentWaypointIndex < vectorPath.Count - 1)
		{
			float num = XZSqrMagnitude(vectorPath[currentWaypointIndex], currentPosition);
			if (num < pickNextWaypointDist * pickNextWaypointDist)
			{
				lastFoundWaypointPosition = currentPosition;
				lastFoundWaypointTime = Time.time;
				currentWaypointIndex++;
				continue;
			}
			break;
		}
		Vector3 vector = vectorPath[currentWaypointIndex] - vectorPath[currentWaypointIndex - 1];
		Vector3 a = CalculateTargetPoint(currentPosition, vectorPath[currentWaypointIndex - 1], vectorPath[currentWaypointIndex]);
		vector = a - currentPosition;
		vector.y = 0f;
		float magnitude = vector.magnitude;
		float num2 = Mathf.Clamp01(magnitude / slowdownDistance);
		targetDirection = vector;
		targetPoint = a;
		if (currentWaypointIndex == vectorPath.Count - 1 && magnitude <= endReachedDistance)
		{
			if (!targetReached)
			{
				targetReached = true;
				OnTargetReached();
			}
			return Vector3.zero;
		}
		Vector3 forward = tr.forward;
		float a2 = Vector3.Dot(vector.normalized, forward);
		float num3 = speed * Mathf.Max(a2, minMoveScale) * num2;
		if (Time.deltaTime > 0f)
		{
			num3 = Mathf.Clamp(num3, 0f, magnitude / (Time.deltaTime * 2f));
		}
		return forward * num3;
	}

	protected virtual void RotateTowards(Vector3 dir)
	{
		if (!(dir == Vector3.zero))
		{
			Quaternion rotation = tr.rotation;
			Quaternion to = Quaternion.LookRotation(dir);
			Vector3 eulerAngles = Quaternion.Slerp(rotation, to, turningSpeed * Time.deltaTime).eulerAngles;
			eulerAngles.z = 0f;
			eulerAngles.x = 0f;
			rotation = Quaternion.Euler(eulerAngles);
			tr.rotation = rotation;
		}
	}

	protected Vector3 CalculateTargetPoint(Vector3 p, Vector3 a, Vector3 b)
	{
		a.y = p.y;
		b.y = p.y;
		float magnitude = (a - b).magnitude;
		if (magnitude == 0f)
		{
			return a;
		}
		float num = AstarMath.Clamp01(AstarMath.NearestPointFactor(a, b, p));
		Vector3 a2 = (b - a) * num + a;
		float magnitude2 = (a2 - p).magnitude;
		float num2 = Mathf.Clamp(forwardLook - magnitude2, 0f, forwardLook);
		float num3 = num2 / magnitude;
		num3 = Mathf.Clamp(num3 + num, 0f, 1f);
		return (b - a) * num3 + a;
	}
}
public class NavmeshController : MonoBehaviour
{
}
namespace Pathfinding
{
	[AddComponentMenu("Pathfinding/AI/RichAI (for navmesh)")]
	[RequireComponent(typeof(Seeker))]
	public class RichAI : MonoBehaviour
	{
		public Transform target;

		public bool drawGizmos = true;

		public bool repeatedlySearchPaths;

		public float repathRate = 0.5f;

		public float maxSpeed = 1f;

		public float acceleration = 5f;

		public float slowdownTime = 0.5f;

		public float rotationSpeed = 360f;

		public float endReachedDistance = 0.01f;

		public float wallForce = 3f;

		public float wallDist = 1f;

		public Vector3 gravity = new Vector3(0f, -9.82f, 0f);

		public bool raycastingForGroundPlacement = true;

		public LayerMask groundMask = -1;

		public float centerOffset = 1f;

		public RichFunnel.FunnelSimplification funnelSimplification;

		public Animation anim;

		public bool preciseSlowdown = true;

		public bool slowWhenNotFacingTarget = true;

		private Vector3 velocity;

		protected RichPath rp;

		protected Seeker seeker;

		protected Transform tr;

		private CharacterController controller;

		private RVOController rvoController;

		private Vector3 lastTargetPoint;

		private Vector3 currentTargetDirection;

		protected bool waitingForPathCalc;

		protected bool canSearchPath;

		protected bool delayUpdatePath;

		protected bool traversingSpecialPath;

		protected bool lastCorner;

		private float distanceToWaypoint = 999f;

		protected List<Vector3> buffer = new List<Vector3>();

		protected List<Vector3> wallBuffer = new List<Vector3>();

		private bool startHasRun;

		protected float lastRepath = -9999f;

		private static float deltaTime = 0f;

		public static readonly Color GizmoColorRaycast = new Color(118f / 255f, 206f / 255f, 112f / 255f);

		public static readonly Color GizmoColorPath = new Color(8f / 255f, 26f / 85f, 194f / 255f);

		public Vector3 Velocity => velocity;

		public bool TraversingSpecial => traversingSpecialPath;

		public Vector3 TargetPoint => lastTargetPoint;

		public bool ApproachingPartEndpoint => lastCorner;

		public bool ApproachingPathEndpoint => rp != null && ApproachingPartEndpoint && !rp.PartsLeft();

		public float DistanceToNextWaypoint => distanceToWaypoint;

		private void Awake()
		{
			seeker = GetComponent<Seeker>();
			controller = GetComponent<CharacterController>();
			rvoController = GetComponent<RVOController>();
			if (rvoController != null)
			{
				rvoController.enableRotation = false;
			}
			tr = base.transform;
		}

		protected virtual void Start()
		{
			startHasRun = true;
			OnEnable();
		}

		protected virtual void OnEnable()
		{
			lastRepath = -9999f;
			waitingForPathCalc = false;
			canSearchPath = true;
			if (startHasRun)
			{
				Seeker obj = seeker;
				obj.pathCallback = (OnPathDelegate)Delegate.Combine(obj.pathCallback, new OnPathDelegate(OnPathComplete));
				StartCoroutine(SearchPaths());
			}
		}

		public void OnDisable()
		{
			if (seeker != null && !seeker.IsDone())
			{
				seeker.GetCurrentPath().Error();
			}
			Seeker obj = seeker;
			obj.pathCallback = (OnPathDelegate)Delegate.Remove(obj.pathCallback, new OnPathDelegate(OnPathComplete));
		}

		public virtual void UpdatePath()
		{
			canSearchPath = true;
			waitingForPathCalc = false;
			Path currentPath = seeker.GetCurrentPath();
			if (currentPath != null && !seeker.IsDone())
			{
				currentPath.Error();
				currentPath.Claim(this);
				currentPath.Release(this);
			}
			waitingForPathCalc = true;
			lastRepath = Time.time;
			seeker.StartPath(tr.position, target.position);
		}

		private IEnumerator SearchPaths()
		{
			while (true)
			{
				if (!repeatedlySearchPaths || waitingForPathCalc || !canSearchPath || Time.time - lastRepath < repathRate)
				{
					yield return null;
					continue;
				}
				UpdatePath();
				yield return null;
			}
		}

		private void OnPathComplete(Path p)
		{
			waitingForPathCalc = false;
			p.Claim(this);
			if (p.error)
			{
				p.Release(this);
				return;
			}
			if (traversingSpecialPath)
			{
				delayUpdatePath = true;
			}
			else
			{
				if (rp == null)
				{
					rp = new RichPath();
				}
				rp.Initialize(seeker, p, mergePartEndpoints: true, funnelSimplification);
			}
			p.Release(this);
		}

		private void NextPart()
		{
			rp.NextPart();
			lastCorner = false;
			if (!rp.PartsLeft())
			{
				OnTargetReached();
			}
		}

		protected virtual void OnTargetReached()
		{
		}

		protected virtual Vector3 UpdateTarget(RichFunnel fn)
		{
			buffer.Clear();
			Vector3 position = tr.position;
			position = fn.Update(position, buffer, 2, out lastCorner, out bool requiresRepath);
			if (requiresRepath && !waitingForPathCalc)
			{
				UpdatePath();
			}
			return position;
		}

		protected virtual void Update()
		{
			deltaTime = Mathf.Min(Time.smoothDeltaTime * 2f, Time.deltaTime);
			if (rp != null)
			{
				RichPathPart currentPart = rp.GetCurrentPart();
				RichFunnel richFunnel = currentPart as RichFunnel;
				if (richFunnel != null)
				{
					Vector3 vector = UpdateTarget(richFunnel);
					if (Time.frameCount % 5 == 0)
					{
						wallBuffer.Clear();
						richFunnel.FindWalls(wallBuffer, wallDist);
					}
					int num = 0;
					Vector3 vector2 = buffer[num];
					Vector3 vector3 = vector2 - vector;
					vector3.y = 0f;
					if (Vector3.Dot(vector3, currentTargetDirection) < 0f && buffer.Count - num > 1)
					{
						num++;
						vector2 = buffer[num];
					}
					if (vector2 != lastTargetPoint)
					{
						currentTargetDirection = vector2 - vector;
						currentTargetDirection.y = 0f;
						currentTargetDirection.Normalize();
						lastTargetPoint = vector2;
					}
					vector3 = vector2 - vector;
					vector3.y = 0f;
					float num2 = distanceToWaypoint = vector3.magnitude;
					vector3 = ((num2 != 0f) ? (vector3 / num2) : Vector3.zero);
					Vector3 lhs = vector3;
					Vector3 a = Vector3.zero;
					if (wallForce > 0f && wallDist > 0f)
					{
						float num3 = 0f;
						float num4 = 0f;
						for (int i = 0; i < wallBuffer.Count; i += 2)
						{
							Vector3 a2 = AstarMath.NearestPointStrict(wallBuffer[i], wallBuffer[i + 1], tr.position);
							float sqrMagnitude = (a2 - vector).sqrMagnitude;
							if (!(sqrMagnitude > wallDist * wallDist))
							{
								Vector3 normalized = (wallBuffer[i + 1] - wallBuffer[i]).normalized;
								float num5 = Vector3.Dot(vector3, normalized) * (1f - Math.Max(0f, 2f * (sqrMagnitude / (wallDist * wallDist)) - 1f));
								if (num5 > 0f)
								{
									num4 = Math.Max(num4, num5);
								}
								else
								{
									num3 = Math.Max(num3, 0f - num5);
								}
							}
						}
						Vector3 a3 = Vector3.Cross(Vector3.up, vector3);
						a = a3 * (num4 - num3);
					}
					bool flag = lastCorner && buffer.Count - num == 1;
					if (flag)
					{
						if (slowdownTime < 0.001f)
						{
							slowdownTime = 0.001f;
						}
						Vector3 a4 = vector2 - vector;
						a4.y = 0f;
						vector3 = ((!preciseSlowdown) ? (2f * (a4 - slowdownTime * velocity) / (slowdownTime * slowdownTime)) : ((6f * a4 - 4f * slowdownTime * velocity) / (slowdownTime * slowdownTime)));
						vector3 = Vector3.ClampMagnitude(vector3, acceleration);
						a *= Math.Min(num2 / 0.5f, 1f);
						if (num2 < endReachedDistance)
						{
							NextPart();
						}
					}
					else
					{
						vector3 *= acceleration;
					}
					velocity += (vector3 + a * wallForce) * deltaTime;
					if (slowWhenNotFacingTarget)
					{
						float a5 = (Vector3.Dot(lhs, tr.forward) + 0.5f) * (2f / 3f);
						float a6 = Mathf.Sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
						float y = velocity.y;
						velocity.y = 0f;
						float d = Mathf.Min(a6, maxSpeed * Mathf.Max(a5, 0.2f));
						velocity = Vector3.Lerp(tr.forward * d, velocity.normalized * d, Mathf.Clamp((!flag) ? 0f : (num2 * 2f), 0.5f, 1f));
						velocity.y = y;
					}
					else
					{
						float num6 = Mathf.Sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
						num6 = maxSpeed / num6;
						if (num6 < 1f)
						{
							velocity.x *= num6;
							velocity.z *= num6;
						}
					}
					if (flag)
					{
						Vector3 trotdir = Vector3.Lerp(velocity, currentTargetDirection, Math.Max(1f - num2 * 2f, 0f));
						RotateTowards(trotdir);
					}
					else
					{
						RotateTowards(velocity);
					}
					velocity += deltaTime * gravity;
					if (rvoController != null && rvoController.enabled)
					{
						tr.position = vector;
						rvoController.Move(velocity);
					}
					else if (controller != null && controller.enabled)
					{
						tr.position = vector;
						controller.Move(velocity * deltaTime);
					}
					else
					{
						float y2 = vector.y;
						vector += velocity * deltaTime;
						vector = RaycastPosition(vector, y2);
						tr.position = vector;
					}
				}
				else if (rvoController != null && rvoController.enabled)
				{
					rvoController.Move(Vector3.zero);
				}
				if (currentPart is RichSpecial)
				{
					RichSpecial rs = currentPart as RichSpecial;
					if (!traversingSpecialPath)
					{
						StartCoroutine(TraverseSpecial(rs));
					}
				}
			}
			else if (rvoController != null && rvoController.enabled)
			{
				rvoController.Move(Vector3.zero);
			}
			else if (!(controller != null) || !controller.enabled)
			{
				Transform transform = tr;
				Vector3 position = tr.position;
				Vector3 position2 = tr.position;
				transform.position = RaycastPosition(position, position2.y);
			}
		}

		private Vector3 RaycastPosition(Vector3 position, float lasty)
		{
			if (raycastingForGroundPlacement)
			{
				float num = Mathf.Max(centerOffset, lasty - position.y + centerOffset);
				if (Physics.Raycast(position + Vector3.up * num, Vector3.down, out RaycastHit hitInfo, num, groundMask) && hitInfo.distance < num)
				{
					position = hitInfo.point;
					velocity.y = 0f;
				}
			}
			return position;
		}

		private bool RotateTowards(Vector3 trotdir)
		{
			Quaternion rotation = tr.rotation;
			trotdir.y = 0f;
			if (trotdir != Vector3.zero)
			{
				Vector3 eulerAngles = Quaternion.LookRotation(trotdir).eulerAngles;
				Vector3 eulerAngles2 = rotation.eulerAngles;
				eulerAngles2.y = Mathf.MoveTowardsAngle(eulerAngles2.y, eulerAngles.y, rotationSpeed * deltaTime);
				tr.rotation = Quaternion.Euler(eulerAngles2);
				return Mathf.Abs(eulerAngles2.y - eulerAngles.y) < 5f;
			}
			return false;
		}

		public void OnDrawGizmos()
		{
			if (!drawGizmos)
			{
				return;
			}
			if (raycastingForGroundPlacement)
			{
				Gizmos.color = GizmoColorRaycast;
				Gizmos.DrawLine(base.transform.position, base.transform.position + Vector3.up * centerOffset);
				Gizmos.DrawLine(base.transform.position + Vector3.left * 0.1f, base.transform.position + Vector3.right * 0.1f);
				Gizmos.DrawLine(base.transform.position + Vector3.back * 0.1f, base.transform.position + Vector3.forward * 0.1f);
			}
			if (tr != null && buffer != null)
			{
				Gizmos.color = GizmoColorPath;
				Vector3 from = tr.position;
				for (int i = 0; i < buffer.Count; i++)
				{
					Gizmos.DrawLine(from, buffer[i]);
					from = buffer[i];
				}
			}
		}

		private IEnumerator TraverseSpecial(RichSpecial rs)
		{
			traversingSpecialPath = true;
			velocity = Vector3.zero;
			AnimationLink al = rs.nodeLink as AnimationLink;
			if (al == null)
			{
				UnityEngine.Debug.LogError("Unhandled RichSpecial");
				yield break;
			}
			while (!RotateTowards(rs.first.forward))
			{
				yield return null;
			}
			tr.parent.position = tr.position;
			tr.parent.rotation = tr.rotation;
			tr.localPosition = Vector3.zero;
			tr.localRotation = Quaternion.identity;
			if (rs.reverse && al.reverseAnim)
			{
				anim[al.clip].speed = 0f - al.animSpeed;
				anim[al.clip].normalizedTime = 1f;
				anim.Play(al.clip);
				anim.Sample();
			}
			else
			{
				anim[al.clip].speed = al.animSpeed;
				anim.Rewind(al.clip);
				anim.Play(al.clip);
			}
			tr.parent.position -= tr.position - tr.parent.position;
			yield return new WaitForSeconds(Mathf.Abs(anim[al.clip].length / al.animSpeed));
			traversingSpecialPath = false;
			NextPart();
			if (delayUpdatePath)
			{
				delayUpdatePath = false;
				UpdatePath();
			}
		}
	}
	public class RichPath
	{
		private int currentPart;

		private List<RichPathPart> parts = new List<RichPathPart>();

		public Seeker seeker;

		public void Initialize(Seeker s, Path p, bool mergePartEndpoints, RichFunnel.FunnelSimplification simplificationMode)
		{
			if (p.error)
			{
				throw new ArgumentException("Path has an error");
			}
			List<GraphNode> path = p.path;
			if (path.Count == 0)
			{
				throw new ArgumentException("Path traverses no nodes");
			}
			seeker = s;
			for (int i = 0; i < parts.Count; i++)
			{
				if (parts[i] is RichFunnel)
				{
					ObjectPool<RichFunnel>.Release(parts[i] as RichFunnel);
				}
				else if (parts[i] is RichSpecial)
				{
					ObjectPool<RichSpecial>.Release(parts[i] as RichSpecial);
				}
			}
			parts.Clear();
			currentPart = 0;
			int j = 0;
			int num2;
			while (true)
			{
				if (j >= path.Count)
				{
					return;
				}
				if (path[j] is TriangleMeshNode)
				{
					IFunnelGraph graph = AstarData.GetGraph(path[j]) as IFunnelGraph;
					RichFunnel richFunnel = ObjectPool<RichFunnel>.Claim().Initialize(this, graph);
					richFunnel.funnelSimplificationMode = simplificationMode;
					int num = j;
					for (uint graphIndex = path[num].GraphIndex; j < path.Count && (path[j].GraphIndex == graphIndex || path[j] is NodeLink3Node); j++)
					{
					}
					j--;
					if (num == 0)
					{
						richFunnel.exactStart = p.vectorPath[0];
					}
					else if (mergePartEndpoints)
					{
						richFunnel.exactStart = (Vector3)path[num - 1].position;
					}
					else
					{
						richFunnel.exactStart = (Vector3)path[num].position;
					}
					if (j == path.Count - 1)
					{
						richFunnel.exactEnd = p.vectorPath[p.vectorPath.Count - 1];
					}
					else if (mergePartEndpoints)
					{
						richFunnel.exactEnd = (Vector3)path[j + 1].position;
					}
					else
					{
						richFunnel.exactEnd = (Vector3)path[j].position;
					}
					richFunnel.BuildFunnelCorridor(path, num, j);
					parts.Add(richFunnel);
				}
				else if (path[j] is GraphNode && NodeLink2.GetNodeLink(path[j]) != null)
				{
					NodeLink2 nodeLink = NodeLink2.GetNodeLink(path[j]);
					num2 = j;
					uint graphIndex2 = path[num2].GraphIndex;
					for (j++; j < path.Count && path[j].GraphIndex == graphIndex2; j++)
					{
					}
					j--;
					if (j - num2 > 1)
					{
						break;
					}
					if (j - num2 != 0)
					{
						RichSpecial item = ObjectPool<RichSpecial>.Claim().Initialize(nodeLink, path[num2]);
						parts.Add(item);
					}
				}
				j++;
			}
			throw new Exception("NodeLink2 path length greater than two (2) nodes. " + (j - num2));
		}

		public bool PartsLeft()
		{
			return currentPart < parts.Count;
		}

		public void NextPart()
		{
			currentPart++;
			if (currentPart >= parts.Count)
			{
				currentPart = parts.Count;
			}
		}

		public RichPathPart GetCurrentPart()
		{
			if (currentPart >= parts.Count)
			{
				return null;
			}
			return parts[currentPart];
		}
	}
	public abstract class RichPathPart : IAstarPooledObject
	{
		public abstract void OnEnterPool();
	}
	public class RichFunnel : RichPathPart
	{
		public enum FunnelSimplification
		{
			None,
			Iterative,
			RecursiveBinary,
			RecursiveTrinary
		}

		private List<Vector3> left;

		private List<Vector3> right;

		private List<TriangleMeshNode> nodes;

		public Vector3 exactStart;

		public Vector3 exactEnd;

		private IFunnelGraph graph;

		private int currentNode;

		private Vector3 currentPosition;

		private int tmpCounter;

		private RichPath path;

		private int[] triBuffer = new int[3];

		public FunnelSimplification funnelSimplificationMode = FunnelSimplification.Iterative;

		public RichFunnel()
		{
			left = ListPool<Vector3>.Claim();
			right = ListPool<Vector3>.Claim();
			nodes = new List<TriangleMeshNode>();
			graph = null;
		}

		public RichFunnel Initialize(RichPath path, IFunnelGraph graph)
		{
			if (graph == null)
			{
				throw new ArgumentNullException("graph");
			}
			if (this.graph != null)
			{
				throw new InvalidOperationException("Trying to initialize an already initialized object. " + graph);
			}
			this.graph = graph;
			this.path = path;
			return this;
		}

		public override void OnEnterPool()
		{
			left.Clear();
			right.Clear();
			nodes.Clear();
			graph = null;
			currentNode = 0;
			tmpCounter = 0;
		}

		public void BuildFunnelCorridor(List<GraphNode> nodes, int start, int end)
		{
			exactStart = (nodes[start] as MeshNode).ClosestPointOnNode(exactStart);
			exactEnd = (nodes[end] as MeshNode).ClosestPointOnNode(exactEnd);
			left.Clear();
			right.Clear();
			left.Add(exactStart);
			right.Add(exactStart);
			this.nodes.Clear();
			IRaycastableGraph raycastableGraph = graph as IRaycastableGraph;
			if (raycastableGraph != null && funnelSimplificationMode != 0)
			{
				List<GraphNode> list = ListPool<GraphNode>.Claim(end - start);
				switch (funnelSimplificationMode)
				{
				case FunnelSimplification.Iterative:
					SimplifyPath(raycastableGraph, nodes, start, end, list, exactStart, exactEnd);
					break;
				case FunnelSimplification.RecursiveBinary:
					SimplifyPath2(raycastableGraph, nodes, start, end, list, exactStart, exactEnd);
					break;
				case FunnelSimplification.RecursiveTrinary:
					SimplifyPath3(raycastableGraph, nodes, start, end, list, exactStart, exactEnd);
					break;
				}
				if (this.nodes.Capacity < list.Count)
				{
					this.nodes.Capacity = list.Count;
				}
				for (int i = 0; i < list.Count; i++)
				{
					TriangleMeshNode triangleMeshNode = list[i] as TriangleMeshNode;
					if (triangleMeshNode != null)
					{
						this.nodes.Add(triangleMeshNode);
					}
				}
				ListPool<GraphNode>.Release(list);
			}
			else
			{
				if (this.nodes.Capacity < end - start)
				{
					this.nodes.Capacity = end - start;
				}
				for (int j = start; j <= end; j++)
				{
					TriangleMeshNode triangleMeshNode2 = nodes[j] as TriangleMeshNode;
					if (triangleMeshNode2 != null)
					{
						this.nodes.Add(triangleMeshNode2);
					}
				}
			}
			for (int k = 0; k < this.nodes.Count - 1; k++)
			{
				this.nodes[k].GetPortal(this.nodes[k + 1], left, right, backwards: false);
			}
			left.Add(exactEnd);
			right.Add(exactEnd);
		}

		public static void SimplifyPath3(IRaycastableGraph rcg, List<GraphNode> nodes, int start, int end, List<GraphNode> result, Vector3 startPoint, Vector3 endPoint, int depth = 0)
		{
			if (start == end)
			{
				result.Add(nodes[start]);
				return;
			}
			if (start + 1 == end)
			{
				result.Add(nodes[start]);
				result.Add(nodes[end]);
				return;
			}
			int count = result.Count;
			if (!rcg.Linecast(startPoint, endPoint, nodes[start], out GraphHitInfo _, result) && result[result.Count - 1] == nodes[end])
			{
				return;
			}
			result.RemoveRange(count, result.Count - count);
			int num = 0;
			float num2 = 0f;
			for (int i = start + 1; i < end - 1; i++)
			{
				float num3 = AstarMath.DistancePointSegmentStrict(startPoint, endPoint, (Vector3)nodes[i].position);
				if (num3 > num2)
				{
					num = i;
					num2 = num3;
				}
			}
			int num4 = (num + start) / 2;
			int num5 = (num + end) / 2;
			if (num4 == num5)
			{
				SimplifyPath3(rcg, nodes, start, num4, result, startPoint, (Vector3)nodes[num4].position);
				result.RemoveAt(result.Count - 1);
				SimplifyPath3(rcg, nodes, num4, end, result, (Vector3)nodes[num4].position, endPoint, depth + 1);
			}
			else
			{
				SimplifyPath3(rcg, nodes, start, num4, result, startPoint, (Vector3)nodes[num4].position, depth + 1);
				result.RemoveAt(result.Count - 1);
				SimplifyPath3(rcg, nodes, num4, num5, result, (Vector3)nodes[num4].position, (Vector3)nodes[num5].position, depth + 1);
				result.RemoveAt(result.Count - 1);
				SimplifyPath3(rcg, nodes, num5, end, result, (Vector3)nodes[num5].position, endPoint, depth + 1);
			}
		}

		public static void SimplifyPath2(IRaycastableGraph rcg, List<GraphNode> nodes, int start, int end, List<GraphNode> result, Vector3 startPoint, Vector3 endPoint)
		{
			int count = result.Count;
			if (end <= start + 1)
			{
				result.Add(nodes[start]);
				result.Add(nodes[end]);
			}
			else
			{
				if (!rcg.Linecast(startPoint, endPoint, nodes[start], out GraphHitInfo _, result) && result[result.Count - 1] == nodes[end])
				{
					return;
				}
				result.RemoveRange(count, result.Count - count);
				int num = -1;
				float num2 = float.PositiveInfinity;
				for (int i = start + 1; i < end; i++)
				{
					float num3 = AstarMath.DistancePointSegmentStrict(startPoint, endPoint, (Vector3)nodes[i].position);
					if (num == -1 || num3 < num2)
					{
						num = i;
						num2 = num3;
					}
				}
				SimplifyPath2(rcg, nodes, start, num, result, startPoint, (Vector3)nodes[num].position);
				result.RemoveAt(result.Count - 1);
				SimplifyPath2(rcg, nodes, num, end, result, (Vector3)nodes[num].position, endPoint);
			}
		}

		public void SimplifyPath(IRaycastableGraph graph, List<GraphNode> nodes, int start, int end, List<GraphNode> result, Vector3 startPoint, Vector3 endPoint)
		{
			if (start > end)
			{
				throw new ArgumentException("start >= end");
			}
			if (graph == null)
			{
				throw new InvalidOperationException("graph is not a IRaycastableGraph");
			}
			int num = start;
			int num2 = 0;
			while (true)
			{
				if (num2++ > 1000)
				{
					UnityEngine.Debug.LogError("!!!");
					return;
				}
				if (start == end)
				{
					break;
				}
				int count = result.Count;
				int num3 = end + 1;
				int num4 = start + 1;
				bool flag = false;
				while (num3 > num4 + 1)
				{
					int num5 = (num3 + num4) / 2;
					Vector3 start2 = (start != num) ? ((Vector3)nodes[start].position) : startPoint;
					Vector3 end2 = (num5 != end) ? ((Vector3)nodes[num5].position) : endPoint;
					if (graph.Linecast(start2, end2, nodes[start], out GraphHitInfo _))
					{
						num3 = num5;
						continue;
					}
					flag = true;
					num4 = num5;
				}
				if (!flag)
				{
					result.Add(nodes[start]);
					start = num4;
					continue;
				}
				Vector3 start3 = (start != num) ? ((Vector3)nodes[start].position) : startPoint;
				Vector3 end3 = (num4 != end) ? ((Vector3)nodes[num4].position) : endPoint;
				graph.Linecast(start3, end3, nodes[start], out GraphHitInfo _, result);
				long num6 = 0L;
				long num7 = 0L;
				for (int i = start; i <= num4; i++)
				{
					num6 += nodes[i].Penalty + ((path.seeker != null) ? path.seeker.tagPenalties[nodes[i].Tag] : 0);
				}
				for (int j = count; j < result.Count; j++)
				{
					num7 += result[j].Penalty + ((path.seeker != null) ? path.seeker.tagPenalties[result[j].Tag] : 0);
				}
				if ((double)num6 * 1.4 * (double)(num4 - start + 1) < (double)(num7 * (result.Count - count)) || result[result.Count - 1] != nodes[num4])
				{
					result.RemoveRange(count, result.Count - count);
					result.Add(nodes[start]);
					start++;
				}
				else
				{
					result.RemoveAt(result.Count - 1);
					start = num4;
				}
			}
			result.Add(nodes[end]);
		}

		public void UpdateFunnelCorridor(int splitIndex, TriangleMeshNode prefix)
		{
			if (splitIndex > 0)
			{
				nodes.RemoveRange(0, splitIndex - 1);
				nodes[0] = prefix;
			}
			else
			{
				nodes.Insert(0, prefix);
			}
			left.Clear();
			right.Clear();
			left.Add(exactStart);
			right.Add(exactStart);
			for (int i = 0; i < nodes.Count - 1; i++)
			{
				nodes[i].GetPortal(nodes[i + 1], left, right, backwards: false);
			}
			left.Add(exactEnd);
			right.Add(exactEnd);
		}

		public Vector3 Update(Vector3 position, List<Vector3> buffer, int numCorners, out bool lastCorner, out bool requiresRepath)
		{
			lastCorner = false;
			requiresRepath = false;
			Int3 @int = (Int3)position;
			if (nodes[currentNode].Destroyed)
			{
				requiresRepath = true;
				lastCorner = false;
				buffer.Add(position);
				return position;
			}
			if (nodes[currentNode].ContainsPoint(@int))
			{
				if (tmpCounter >= 10)
				{
					tmpCounter = 0;
					int i = 0;
					for (int count = nodes.Count; i < count; i++)
					{
						if (nodes[i].Destroyed)
						{
							requiresRepath = true;
							break;
						}
					}
				}
				else
				{
					tmpCounter++;
				}
			}
			else
			{
				bool flag = false;
				int j = currentNode + 1;
				for (int num = Math.Min(currentNode + 3, nodes.Count); j < num; j++)
				{
					if (flag)
					{
						break;
					}
					if (nodes[j].Destroyed)
					{
						requiresRepath = true;
						lastCorner = false;
						buffer.Add(position);
						return position;
					}
					if (nodes[j].ContainsPoint(@int))
					{
						currentNode = j;
						flag = true;
					}
				}
				int num2 = currentNode - 1;
				int num3 = Math.Max(currentNode - 3, 0);
				while (num2 > num3 && !flag)
				{
					if (nodes[num2].Destroyed)
					{
						requiresRepath = true;
						lastCorner = false;
						buffer.Add(position);
						return position;
					}
					if (nodes[num2].ContainsPoint(@int))
					{
						currentNode = num2;
						flag = true;
					}
					num2--;
				}
				int num4 = 0;
				float num5 = float.PositiveInfinity;
				Vector3 vector = Vector3.zero;
				int k = 0;
				for (int count2 = nodes.Count; k < count2; k++)
				{
					if (flag)
					{
						break;
					}
					if (nodes[k].Destroyed)
					{
						requiresRepath = true;
						lastCorner = false;
						buffer.Add(position);
						return position;
					}
					if (nodes[k].ContainsPoint(@int))
					{
						currentNode = k;
						flag = true;
						vector = position;
						continue;
					}
					Vector3 vector2 = nodes[k].ClosestPointOnNodeXZ(position);
					float sqrMagnitude = (vector2 - position).sqrMagnitude;
					if (sqrMagnitude < num5)
					{
						num5 = sqrMagnitude;
						num4 = k;
						vector = vector2;
					}
				}
				tmpCounter = 0;
				int l = 0;
				for (int count3 = nodes.Count; l < count3; l++)
				{
					if (nodes[l].Destroyed)
					{
						requiresRepath = true;
						break;
					}
				}
				if (!flag)
				{
					vector.y = position.y;
					MeshNode containingPoint = null;
					int containingIndex = nodes.Count - 1;
					Int3 i3Copy = @int;
					GraphNodeDelegate del = delegate(GraphNode node)
					{
						if ((containingIndex <= 0 || node != nodes[containingIndex - 1]) && (containingIndex >= nodes.Count - 1 || node != nodes[containingIndex + 1]))
						{
							MeshNode meshNode2 = node as MeshNode;
							if (meshNode2 != null && meshNode2.ContainsPoint(i3Copy))
							{
								containingPoint = meshNode2;
							}
						}
					};
					for (; containingIndex >= 0; containingIndex--)
					{
						if (containingPoint != null)
						{
							break;
						}
						MeshNode meshNode = nodes[containingIndex];
						meshNode.GetConnections(del);
					}
					if (containingPoint != null)
					{
						containingIndex++;
						exactStart = position;
						UpdateFunnelCorridor(containingIndex, containingPoint as TriangleMeshNode);
						currentNode = 0;
						flag = true;
					}
					else
					{
						position = vector;
						flag = true;
						currentNode = num4;
					}
				}
			}
			currentPosition = position;
			if (!FindNextCorners(position, currentNode, buffer, numCorners, out lastCorner))
			{
				UnityEngine.Debug.LogError("Oh oh");
				buffer.Add(position);
				return position;
			}
			return position;
		}

		public void FindWalls(List<Vector3> wallBuffer, float range)
		{
			FindWalls(currentNode, wallBuffer, currentPosition, range);
		}

		private void FindWalls(int nodeIndex, List<Vector3> wallBuffer, Vector3 position, float range)
		{
			if (range <= 0f)
			{
				return;
			}
			bool flag = false;
			bool flag2 = false;
			range *= range;
			position.y = 0f;
			int num = 0;
			while (!flag || !flag2)
			{
				if ((num >= 0 || !flag) && (num <= 0 || !flag2))
				{
					if (num < 0 && nodeIndex + num < 0)
					{
						flag = true;
					}
					else if (num > 0 && nodeIndex + num >= nodes.Count)
					{
						flag2 = true;
					}
					else
					{
						TriangleMeshNode triangleMeshNode = (nodeIndex + num - 1 >= 0) ? nodes[nodeIndex + num - 1] : null;
						TriangleMeshNode triangleMeshNode2 = nodes[nodeIndex + num];
						TriangleMeshNode triangleMeshNode3 = (nodeIndex + num + 1 < nodes.Count) ? nodes[nodeIndex + num + 1] : null;
						if (triangleMeshNode2.Destroyed)
						{
							break;
						}
						if ((triangleMeshNode2.ClosestPointOnNodeXZ(position) - position).sqrMagnitude > range)
						{
							if (num < 0)
							{
								flag = true;
							}
							else
							{
								flag2 = true;
							}
						}
						else
						{
							for (int i = 0; i < 3; i++)
							{
								triBuffer[i] = 0;
							}
							for (int j = 0; j < triangleMeshNode2.connections.Length; j++)
							{
								TriangleMeshNode triangleMeshNode4 = triangleMeshNode2.connections[j] as TriangleMeshNode;
								if (triangleMeshNode4 == null)
								{
									continue;
								}
								int num2 = -1;
								for (int k = 0; k < 3; k++)
								{
									for (int l = 0; l < 3; l++)
									{
										if (triangleMeshNode2.GetVertex(k) == triangleMeshNode4.GetVertex((l + 1) % 3) && triangleMeshNode2.GetVertex((k + 1) % 3) == triangleMeshNode4.GetVertex(l))
										{
											num2 = k;
											k = 3;
											break;
										}
									}
								}
								if (num2 != -1)
								{
									triBuffer[num2] = ((triangleMeshNode4 != triangleMeshNode && triangleMeshNode4 != triangleMeshNode3) ? 1 : 2);
								}
							}
							for (int m = 0; m < 3; m++)
							{
								if (triBuffer[m] == 0)
								{
									wallBuffer.Add((Vector3)triangleMeshNode2.GetVertex(m));
									wallBuffer.Add((Vector3)triangleMeshNode2.GetVertex((m + 1) % 3));
								}
							}
						}
					}
				}
				num = ((num >= 0) ? (-num - 1) : (-num));
			}
		}

		public bool FindNextCorners(Vector3 origin, int startIndex, List<Vector3> funnelPath, int numCorners, out bool lastCorner)
		{
			lastCorner = false;
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			if (funnelPath == null)
			{
				throw new ArgumentNullException("funnelPath");
			}
			if (left.Count != right.Count)
			{
				throw new ArgumentException("left and right lists must have equal length");
			}
			int count = left.Count;
			if (count == 0)
			{
				throw new ArgumentException("no diagonals");
			}
			if (count - startIndex < 3)
			{
				funnelPath.Add(left[count - 1]);
				lastCorner = true;
				return true;
			}
			while (left[startIndex + 1] == left[startIndex + 2] && right[startIndex + 1] == right[startIndex + 2])
			{
				startIndex++;
				if (count - startIndex <= 3)
				{
					return false;
				}
			}
			Vector3 vector = left[startIndex + 2];
			if (vector == left[startIndex + 1])
			{
				vector = right[startIndex + 2];
			}
			while (Polygon.IsColinear(origin, left[startIndex + 1], right[startIndex + 1]) || Polygon.Left(left[startIndex + 1], right[startIndex + 1], vector) == Polygon.Left(left[startIndex + 1], right[startIndex + 1], origin))
			{
				startIndex++;
				if (count - startIndex < 3)
				{
					funnelPath.Add(left[count - 1]);
					lastCorner = true;
					return true;
				}
				vector = left[startIndex + 2];
				if (vector == left[startIndex + 1])
				{
					vector = right[startIndex + 2];
				}
			}
			Vector3 vector2 = origin;
			Vector3 vector3 = left[startIndex + 1];
			Vector3 vector4 = right[startIndex + 1];
			int num = startIndex;
			int num2 = startIndex + 1;
			int num3 = startIndex + 1;
			for (int i = startIndex + 2; i < count; i++)
			{
				if (funnelPath.Count >= numCorners)
				{
					return true;
				}
				if (funnelPath.Count > 2000)
				{
					UnityEngine.Debug.LogWarning("Avoiding infinite loop. Remove this check if you have this long paths.");
					break;
				}
				Vector3 vector5 = left[i];
				Vector3 vector6 = right[i];
				if (Polygon.TriangleArea2(vector2, vector4, vector6) >= 0f)
				{
					if (!(vector2 == vector4) && !(Polygon.TriangleArea2(vector2, vector3, vector6) <= 0f))
					{
						funnelPath.Add(vector3);
						vector2 = vector3;
						num = num3;
						vector3 = vector2;
						vector4 = vector2;
						num3 = num;
						num2 = num;
						i = num;
						continue;
					}
					vector4 = vector6;
					num2 = i;
				}
				if (Polygon.TriangleArea2(vector2, vector3, vector5) <= 0f)
				{
					if (vector2 == vector3 || Polygon.TriangleArea2(vector2, vector4, vector5) >= 0f)
					{
						vector3 = vector5;
						num3 = i;
						continue;
					}
					funnelPath.Add(vector4);
					vector2 = vector4;
					num = num2;
					vector3 = vector2;
					vector4 = vector2;
					num3 = num;
					num2 = num;
					i = num;
				}
			}
			lastCorner = true;
			funnelPath.Add(left[count - 1]);
			return true;
		}
	}
	public class RichSpecial : RichPathPart
	{
		public NodeLink2 nodeLink;

		public Transform first;

		public Transform second;

		public bool reverse;

		public override void OnEnterPool()
		{
			nodeLink = null;
		}

		public RichSpecial Initialize(NodeLink2 nodeLink, GraphNode first)
		{
			this.nodeLink = nodeLink;
			if (first == nodeLink.StartNode)
			{
				this.first = nodeLink.StartTransform;
				second = nodeLink.EndTransform;
				reverse = false;
			}
			else
			{
				this.first = nodeLink.EndTransform;
				second = nodeLink.StartTransform;
				reverse = true;
			}
			return this;
		}
	}
}
[AddComponentMenu("Pathfinding/Seeker")]
public class Seeker : MonoBehaviour
{
	public enum ModifierPass
	{
		PreProcess,
		PostProcessOriginal,
		PostProcess
	}

	public bool drawGizmos = true;

	public bool detailedGizmos;

	[HideInInspector]
	public bool saveGetNearestHints = true;

	public StartEndModifier startEndModifier = new StartEndModifier();

	[HideInInspector]
	public TagMask traversableTags = new TagMask(-1, -1);

	[HideInInspector]
	public int[] tagPenalties = new int[32];

	public OnPathDelegate pathCallback;

	public OnPathDelegate preProcessPath;

	public OnPathDelegate postProcessOriginalPath;

	public OnPathDelegate postProcessPath;

	[NonSerialized]
	public List<Vector3> lastCompletedVectorPath;

	[NonSerialized]
	public List<GraphNode> lastCompletedNodePath;

	[NonSerialized]
	protected Pathfinding.Path path;

	private Pathfinding.Path prevPath;

	private GraphNode startHint;

	private GraphNode endHint;

	private OnPathDelegate onPathDelegate;

	private OnPathDelegate onPartialPathDelegate;

	private OnPathDelegate tmpPathCallback;

	protected uint lastPathID;

	private List<IPathModifier> modifiers = new List<IPathModifier>();

	public Pathfinding.Path GetCurrentPath()
	{
		return path;
	}

	public void Awake()
	{
		onPathDelegate = OnPathComplete;
		onPartialPathDelegate = OnPartialPathComplete;
		startEndModifier.Awake(this);
	}

	public void OnDestroy()
	{
		ReleaseClaimedPath();
		startEndModifier.OnDestroy(this);
	}

	public void ReleaseClaimedPath()
	{
		if (prevPath != null)
		{
			prevPath.ReleaseSilent(this);
			prevPath = null;
		}
	}

	public void RegisterModifier(IPathModifier mod)
	{
		if (modifiers == null)
		{
			modifiers = new List<IPathModifier>(1);
		}
		modifiers.Add(mod);
	}

	public void DeregisterModifier(IPathModifier mod)
	{
		if (modifiers != null)
		{
			modifiers.Remove(mod);
		}
	}

	public void PostProcess(Pathfinding.Path p)
	{
		RunModifiers(ModifierPass.PostProcess, p);
	}

	public void RunModifiers(ModifierPass pass, Pathfinding.Path p)
	{
		bool flag = true;
		while (flag)
		{
			flag = false;
			for (int i = 0; i < modifiers.Count - 1; i++)
			{
				if (modifiers[i].Priority < modifiers[i + 1].Priority)
				{
					IPathModifier value = modifiers[i];
					modifiers[i] = modifiers[i + 1];
					modifiers[i + 1] = value;
					flag = true;
				}
			}
		}
		switch (pass)
		{
		case ModifierPass.PreProcess:
			if (preProcessPath != null)
			{
				preProcessPath(p);
			}
			break;
		case ModifierPass.PostProcessOriginal:
			if (postProcessOriginalPath != null)
			{
				postProcessOriginalPath(p);
			}
			break;
		case ModifierPass.PostProcess:
			if (postProcessPath != null)
			{
				postProcessPath(p);
			}
			break;
		}
		if (modifiers.Count == 0)
		{
			return;
		}
		ModifierData modifierData = ModifierData.All;
		IPathModifier pathModifier = modifiers[0];
		for (int j = 0; j < modifiers.Count; j++)
		{
			MonoModifier monoModifier = modifiers[j] as MonoModifier;
			if (monoModifier != null && !monoModifier.enabled)
			{
				continue;
			}
			switch (pass)
			{
			case ModifierPass.PreProcess:
				modifiers[j].PreProcess(p);
				break;
			case ModifierPass.PostProcessOriginal:
				modifiers[j].ApplyOriginal(p);
				break;
			case ModifierPass.PostProcess:
			{
				ModifierData modifierData2 = ModifierConverter.Convert(p, modifierData, modifiers[j].input);
				if (modifierData2 != 0)
				{
					modifiers[j].Apply(p, modifierData2);
					modifierData = modifiers[j].output;
				}
				else
				{
					UnityEngine.Debug.Log("Error converting " + ((j <= 0) ? "original" : pathModifier.GetType().Name) + "'s output to " + modifiers[j].GetType().Name + "'s input.\nTry rearranging the modifier priorities on the Seeker.");
					modifierData = ModifierData.None;
				}
				pathModifier = modifiers[j];
				break;
			}
			}
			if (modifierData == ModifierData.None)
			{
				break;
			}
		}
	}

	public bool IsDone()
	{
		return path == null || path.GetState() >= PathState.Returned;
	}

	public void OnPathComplete(Pathfinding.Path p)
	{
		OnPathComplete(p, runModifiers: true, sendCallbacks: true);
	}

	public void OnPathComplete(Pathfinding.Path p, bool runModifiers, bool sendCallbacks)
	{
		if ((p != null && p != path && sendCallbacks) || this == null || p == null || p != path)
		{
			return;
		}
		if (!path.error && runModifiers)
		{
			RunModifiers(ModifierPass.PostProcessOriginal, path);
			RunModifiers(ModifierPass.PostProcess, path);
		}
		if (sendCallbacks)
		{
			p.Claim(this);
			lastCompletedNodePath = p.path;
			lastCompletedVectorPath = p.vectorPath;
			if (tmpPathCallback != null)
			{
				tmpPathCallback(p);
			}
			if (pathCallback != null)
			{
				pathCallback(p);
			}
			if (prevPath != null)
			{
				prevPath.ReleaseSilent(this);
			}
			prevPath = p;
			if (!drawGizmos)
			{
				ReleaseClaimedPath();
			}
		}
	}

	public void OnPartialPathComplete(Pathfinding.Path p)
	{
		OnPathComplete(p, runModifiers: true, sendCallbacks: false);
	}

	public void OnMultiPathComplete(Pathfinding.Path p)
	{
		OnPathComplete(p, runModifiers: false, sendCallbacks: true);
	}

	public ABPath GetNewPath(Vector3 start, Vector3 end)
	{
		return ABPath.Construct(start, end);
	}

	public Pathfinding.Path StartPath(Vector3 start, Vector3 end)
	{
		return StartPath(start, end, null, -1);
	}

	public Pathfinding.Path StartPath(Vector3 start, Vector3 end, OnPathDelegate callback)
	{
		return StartPath(start, end, callback, -1);
	}

	public Pathfinding.Path StartPath(Vector3 start, Vector3 end, OnPathDelegate callback, int graphMask)
	{
		Pathfinding.Path newPath = GetNewPath(start, end);
		return StartPath(newPath, callback, graphMask);
	}

	public Pathfinding.Path StartPath(Pathfinding.Path p, OnPathDelegate callback = null, int graphMask = -1)
	{
		p.enabledTags = traversableTags.tagsChange;
		p.tagPenalties = tagPenalties;
		if (path != null && path.GetState() <= PathState.Processing && lastPathID == path.pathID)
		{
			path.Error();
			path.LogError("Canceled path because a new one was requested.\nThis happens when a new path is requested from the seeker when one was already being calculated.\nFor example if a unit got a new order, you might request a new path directly instead of waiting for the now invalid path to be calculated. Which is probably what you want.\nIf you are getting this a lot, you might want to consider how you are scheduling path requests.");
		}
		path = p;
		Pathfinding.Path obj = path;
		obj.callback = (OnPathDelegate)Delegate.Combine(obj.callback, onPathDelegate);
		path.nnConstraint.graphMask = graphMask;
		tmpPathCallback = callback;
		lastPathID = path.pathID;
		RunModifiers(ModifierPass.PreProcess, path);
		AstarPath.StartPath(path);
		return path;
	}

	public MultiTargetPath StartMultiTargetPath(Vector3 start, Vector3[] endPoints, bool pathsForAll, OnPathDelegate callback = null, int graphMask = -1)
	{
		MultiTargetPath multiTargetPath = MultiTargetPath.Construct(start, endPoints, null);
		multiTargetPath.pathsForAll = pathsForAll;
		return StartMultiTargetPath(multiTargetPath, callback, graphMask);
	}

	public MultiTargetPath StartMultiTargetPath(Vector3[] startPoints, Vector3 end, bool pathsForAll, OnPathDelegate callback = null, int graphMask = -1)
	{
		MultiTargetPath multiTargetPath = MultiTargetPath.Construct(startPoints, end, null);
		multiTargetPath.pathsForAll = pathsForAll;
		return StartMultiTargetPath(multiTargetPath, callback, graphMask);
	}

	public MultiTargetPath StartMultiTargetPath(MultiTargetPath p, OnPathDelegate callback = null, int graphMask = -1)
	{
		if (path != null && path.GetState() <= PathState.Processing && lastPathID == path.pathID)
		{
			path.ForceLogError("Canceled path because a new one was requested");
		}
		OnPathDelegate[] array = new OnPathDelegate[p.targetPoints.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = onPartialPathDelegate;
		}
		p.callbacks = array;
		p.callback = (OnPathDelegate)Delegate.Combine(p.callback, new OnPathDelegate(OnMultiPathComplete));
		p.nnConstraint.graphMask = graphMask;
		path = p;
		tmpPathCallback = callback;
		lastPathID = path.pathID;
		RunModifiers(ModifierPass.PreProcess, path);
		AstarPath.StartPath(path);
		return p;
	}

	public IEnumerator DelayPathStart(Pathfinding.Path p)
	{
		yield return null;
		RunModifiers(ModifierPass.PreProcess, p);
		AstarPath.StartPath(p);
	}

	public void OnDrawGizmos()
	{
		if (lastCompletedNodePath == null || !drawGizmos)
		{
			return;
		}
		if (detailedGizmos)
		{
			Gizmos.color = new Color(0.7f, 0.5f, 0.1f, 0.5f);
			if (lastCompletedNodePath != null)
			{
				for (int i = 0; i < lastCompletedNodePath.Count - 1; i++)
				{
					Gizmos.DrawLine((Vector3)lastCompletedNodePath[i].position, (Vector3)lastCompletedNodePath[i + 1].position);
				}
			}
		}
		Gizmos.color = new Color(0f, 1f, 0f, 1f);
		if (lastCompletedVectorPath != null)
		{
			for (int j = 0; j < lastCompletedVectorPath.Count - 1; j++)
			{
				Gizmos.DrawLine(lastCompletedVectorPath[j], lastCompletedVectorPath[j + 1]);
			}
		}
	}
}
namespace Pathfinding
{
	[Serializable]
	public class AstarData
	{
		[NonSerialized]
		public NavMeshGraph navmesh;

		[NonSerialized]
		public GridGraph gridGraph;

		[NonSerialized]
		public PointGraph pointGraph;

		[NonSerialized]
		public RecastGraph recastGraph;

		public Type[] graphTypes;

		[NonSerialized]
		public NavGraph[] graphs = new NavGraph[0];

		[NonSerialized]
		public UserConnection[] userConnections = new UserConnection[0];

		public bool hasBeenReverted;

		[SerializeField]
		private byte[] data;

		public uint dataChecksum;

		public byte[] data_backup;

		public byte[] data_cachedStartup;

		public byte[] revertData;

		[SerializeField]
		public bool cacheStartup;

		public bool compress;

		public AstarPath active => AstarPath.active;

		public byte[] GetData()
		{
			return data;
		}

		public void SetData(byte[] data, uint checksum)
		{
			this.data = data;
			dataChecksum = checksum;
		}

		public void Awake()
		{
			userConnections = new UserConnection[0];
			graphs = new NavGraph[0];
			if (cacheStartup && data_cachedStartup != null)
			{
				LoadFromCache();
			}
			else
			{
				DeserializeGraphs();
			}
		}

		public void UpdateShortcuts()
		{
			navmesh = (NavMeshGraph)FindGraphOfType(typeof(NavMeshGraph));
			gridGraph = (GridGraph)FindGraphOfType(typeof(GridGraph));
			pointGraph = (PointGraph)FindGraphOfType(typeof(PointGraph));
			recastGraph = (RecastGraph)FindGraphOfType(typeof(RecastGraph));
		}

		public void LoadFromCache()
		{
			AstarPath.active.BlockUntilPathQueueBlocked();
			if (data_cachedStartup != null && data_cachedStartup.Length > 0)
			{
				DeserializeGraphs(data_cachedStartup);
				GraphModifier.TriggerEvent(GraphModifier.EventType.PostCacheLoad);
			}
			else
			{
				UnityEngine.Debug.LogError("Can't load from cache since the cache is empty");
			}
		}

		public void SaveCacheData(SerializeSettings settings)
		{
			data_cachedStartup = SerializeGraphs(settings);
			cacheStartup = true;
		}

		public byte[] SerializeGraphs()
		{
			return SerializeGraphs(SerializeSettings.Settings);
		}

		public byte[] SerializeGraphs(SerializeSettings settings)
		{
			uint checksum;
			return SerializeGraphs(settings, out checksum);
		}

		public byte[] SerializeGraphs(SerializeSettings settings, out uint checksum)
		{
			AstarPath.active.BlockUntilPathQueueBlocked();
			AstarSerializer astarSerializer = new AstarSerializer(this, settings);
			astarSerializer.OpenSerialize();
			SerializeGraphsPart(astarSerializer);
			byte[] result = astarSerializer.CloseSerialize();
			checksum = astarSerializer.GetChecksum();
			return result;
		}

		public void SerializeGraphsPart(AstarSerializer sr)
		{
			sr.SerializeGraphs(graphs);
			sr.SerializeUserConnections(userConnections);
			sr.SerializeNodes();
			sr.SerializeExtraInfo();
		}

		public void DeserializeGraphs()
		{
			if (data != null)
			{
				DeserializeGraphs(data);
			}
		}

		private void ClearGraphs()
		{
			if (graphs == null)
			{
				return;
			}
			for (int i = 0; i < graphs.Length; i++)
			{
				if (graphs[i] != null)
				{
					graphs[i].OnDestroy();
				}
			}
			graphs = null;
			UpdateShortcuts();
		}

		public void OnDestroy()
		{
			ClearGraphs();
		}

		public void DeserializeGraphs(byte[] bytes)
		{
			AstarPath.active.BlockUntilPathQueueBlocked();
			try
			{
				if (bytes == null)
				{
					throw new ArgumentNullException("Bytes should not be null when passed to DeserializeGraphs");
				}
				AstarSerializer astarSerializer = new AstarSerializer(this);
				if (astarSerializer.OpenDeserialize(bytes))
				{
					DeserializeGraphsPart(astarSerializer);
					astarSerializer.CloseDeserialize();
				}
				else
				{
					UnityEngine.Debug.Log("Invalid data file (cannot read zip).\nThe data is either corrupt or it was saved using a 3.0.x or earlier version of the system");
				}
				active.VerifyIntegrity();
			}
			catch (Exception arg)
			{
				UnityEngine.Debug.LogWarning("Caught exception while deserializing data.\n" + arg);
				data_backup = bytes;
			}
		}

		public void DeserializeGraphsAdditive(byte[] bytes)
		{
			AstarPath.active.BlockUntilPathQueueBlocked();
			try
			{
				if (bytes == null)
				{
					throw new ArgumentNullException("Bytes should not be null when passed to DeserializeGraphs");
				}
				AstarSerializer astarSerializer = new AstarSerializer(this);
				if (astarSerializer.OpenDeserialize(bytes))
				{
					DeserializeGraphsPartAdditive(astarSerializer);
					astarSerializer.CloseDeserialize();
				}
				else
				{
					UnityEngine.Debug.Log("Invalid data file (cannot read zip).");
				}
				active.VerifyIntegrity();
			}
			catch (Exception arg)
			{
				UnityEngine.Debug.LogWarning("Caught exception while deserializing data.\n" + arg);
			}
		}

		public void DeserializeGraphsPart(AstarSerializer sr)
		{
			ClearGraphs();
			graphs = sr.DeserializeGraphs();
			if (graphs != null)
			{
				for (int i = 0; i < graphs.Length; i++)
				{
					if (graphs[i] != null)
					{
						graphs[i].graphIndex = (uint)i;
					}
				}
			}
			userConnections = sr.DeserializeUserConnections();
			sr.DeserializeExtraInfo();
			sr.PostDeserialization();
		}

		public void DeserializeGraphsPartAdditive(AstarSerializer sr)
		{
			if (graphs == null)
			{
				graphs = new NavGraph[0];
			}
			if (userConnections == null)
			{
				userConnections = new UserConnection[0];
			}
			List<NavGraph> list = new List<NavGraph>(graphs);
			list.AddRange(sr.DeserializeGraphs());
			graphs = list.ToArray();
			if (graphs != null)
			{
				for (int j = 0; j < graphs.Length; j++)
				{
					if (graphs[j] != null)
					{
						graphs[j].graphIndex = (uint)j;
					}
				}
			}
			List<UserConnection> list2 = new List<UserConnection>(userConnections);
			list2.AddRange(sr.DeserializeUserConnections());
			userConnections = list2.ToArray();
			sr.DeserializeNodes();
			int i;
			for (i = 0; i < graphs.Length; i++)
			{
				if (graphs[i] != null)
				{
					graphs[i].GetNodes(delegate(GraphNode node)
					{
						node.GraphIndex = (uint)i;
						return true;
					});
				}
			}
			sr.DeserializeExtraInfo();
			sr.PostDeserialization();
			for (int k = 0; k < graphs.Length; k++)
			{
				for (int l = k + 1; l < graphs.Length; l++)
				{
					if (graphs[k] != null && graphs[l] != null && graphs[k].guid == graphs[l].guid)
					{
						UnityEngine.Debug.LogWarning("Guid Conflict when importing graphs additively. Imported graph will get a new Guid.\nThis message is (relatively) harmless.");
						graphs[k].guid = Pathfinding.Util.Guid.NewGuid();
						break;
					}
				}
			}
		}

		public void FindGraphTypes()
		{
			Assembly assembly = Assembly.GetAssembly(typeof(AstarPath));
			Type[] types = assembly.GetTypes();
			List<Type> list = new List<Type>();
			Type[] array = types;
			foreach (Type type in array)
			{
				for (Type baseType = type.BaseType; baseType != null; baseType = baseType.BaseType)
				{
					if (object.Equals(baseType, typeof(NavGraph)))
					{
						list.Add(type);
						break;
					}
				}
			}
			graphTypes = list.ToArray();
		}

		public Type GetGraphType(string type)
		{
			for (int i = 0; i < graphTypes.Length; i++)
			{
				if (graphTypes[i].Name == type)
				{
					return graphTypes[i];
				}
			}
			return null;
		}

		public NavGraph CreateGraph(string type)
		{
			UnityEngine.Debug.Log("Creating Graph of type '" + type + "'");
			for (int i = 0; i < graphTypes.Length; i++)
			{
				if (graphTypes[i].Name == type)
				{
					return CreateGraph(graphTypes[i]);
				}
			}
			UnityEngine.Debug.LogError("Graph type (" + type + ") wasn't found");
			return null;
		}

		public NavGraph CreateGraph(Type type)
		{
			NavGraph navGraph = Activator.CreateInstance(type) as NavGraph;
			navGraph.active = active;
			return navGraph;
		}

		public NavGraph AddGraph(string type)
		{
			NavGraph navGraph = null;
			for (int i = 0; i < graphTypes.Length; i++)
			{
				if (graphTypes[i].Name == type)
				{
					navGraph = CreateGraph(graphTypes[i]);
				}
			}
			if (navGraph == null)
			{
				UnityEngine.Debug.LogError("No NavGraph of type '" + type + "' could be found");
				return null;
			}
			AddGraph(navGraph);
			return navGraph;
		}

		public NavGraph AddGraph(Type type)
		{
			NavGraph navGraph = null;
			for (int i = 0; i < graphTypes.Length; i++)
			{
				if (object.Equals(graphTypes[i], type))
				{
					navGraph = CreateGraph(graphTypes[i]);
				}
			}
			if (navGraph == null)
			{
				UnityEngine.Debug.LogError("No NavGraph of type '" + type + "' could be found, " + graphTypes.Length + " graph types are avaliable");
				return null;
			}
			AddGraph(navGraph);
			return navGraph;
		}

		public void AddGraph(NavGraph graph)
		{
			AstarPath.active.BlockUntilPathQueueBlocked();
			for (int i = 0; i < graphs.Length; i++)
			{
				if (graphs[i] == null)
				{
					graphs[i] = graph;
					return;
				}
			}
			if (graphs != null && (long)graphs.Length >= 2L)
			{
				throw new Exception("Graph Count Limit Reached. You cannot have more than " + 3u + " graphs. Some compiler directives can change this limit, e.g ASTAR_MORE_AREAS, look under the 'Optimizations' tab in the A* Inspector");
			}
			List<NavGraph> list = new List<NavGraph>(graphs);
			list.Add(graph);
			graphs = list.ToArray();
			UpdateShortcuts();
			graph.active = active;
			graph.Awake();
			graph.graphIndex = (uint)(graphs.Length - 1);
		}

		public bool RemoveGraph(NavGraph graph)
		{
			graph.SafeOnDestroy();
			int i;
			for (i = 0; i < graphs.Length && graphs[i] != graph; i++)
			{
			}
			if (i == graphs.Length)
			{
				return false;
			}
			graphs[i] = null;
			UpdateShortcuts();
			return true;
		}

		public static NavGraph GetGraph(GraphNode node)
		{
			if (node == null)
			{
				return null;
			}
			AstarPath active = AstarPath.active;
			if (active == null)
			{
				return null;
			}
			AstarData astarData = active.astarData;
			if (astarData == null)
			{
				return null;
			}
			if (astarData.graphs == null)
			{
				return null;
			}
			uint graphIndex = node.GraphIndex;
			if (graphIndex >= astarData.graphs.Length)
			{
				return null;
			}
			return astarData.graphs[graphIndex];
		}

		public GraphNode GetNode(int graphIndex, int nodeIndex)
		{
			return GetNode(graphIndex, nodeIndex, graphs);
		}

		public GraphNode GetNode(int graphIndex, int nodeIndex, NavGraph[] graphs)
		{
			throw new NotImplementedException();
		}

		public NavGraph FindGraphOfType(Type type)
		{
			if (graphs != null)
			{
				for (int i = 0; i < graphs.Length; i++)
				{
					if (graphs[i] != null && object.Equals(graphs[i].GetType(), type))
					{
						return graphs[i];
					}
				}
			}
			return null;
		}

		public IEnumerable FindGraphsOfType(Type type)
		{
			if (graphs == null)
			{
				yield break;
			}
			for (int i = 0; i < graphs.Length; i++)
			{
				if (graphs[i] != null && object.Equals(graphs[i].GetType(), type))
				{
					yield return graphs[i];
				}
			}
		}

		public IEnumerable GetUpdateableGraphs()
		{
			if (graphs == null)
			{
				yield break;
			}
			for (int i = 0; i < graphs.Length; i++)
			{
				if (graphs[i] != null && graphs[i] is IUpdatableGraph)
				{
					yield return graphs[i];
				}
			}
		}

		public IEnumerable GetRaycastableGraphs()
		{
			if (graphs == null)
			{
				yield break;
			}
			for (int i = 0; i < graphs.Length; i++)
			{
				if (graphs[i] != null && graphs[i] is IRaycastableGraph)
				{
					yield return graphs[i];
				}
			}
		}

		public int GetGraphIndex(NavGraph graph)
		{
			if (graph == null)
			{
				throw new ArgumentNullException("graph");
			}
			if (graphs != null)
			{
				for (int i = 0; i < graphs.Length; i++)
				{
					if (graph == graphs[i])
					{
						return i;
					}
				}
			}
			UnityEngine.Debug.LogError("Graph doesn't exist");
			return -1;
		}

		public int GuidToIndex(Pathfinding.Util.Guid guid)
		{
			if (graphs == null)
			{
				return -1;
			}
			for (int i = 0; i < graphs.Length; i++)
			{
				if (graphs[i] != null && graphs[i].guid == guid)
				{
					return i;
				}
			}
			return -1;
		}

		public NavGraph GuidToGraph(Pathfinding.Util.Guid guid)
		{
			if (graphs == null)
			{
				return null;
			}
			for (int i = 0; i < graphs.Length; i++)
			{
				if (graphs[i] != null && graphs[i].guid == guid)
				{
					return graphs[i];
				}
			}
			return null;
		}
	}
	internal class AstarSplines
	{
		public static Vector3 CatmullRom(Vector3 previous, Vector3 start, Vector3 end, Vector3 next, float elapsedTime)
		{
			float num = elapsedTime * elapsedTime;
			float num2 = num * elapsedTime;
			return previous * (-0.5f * num2 + num - 0.5f * elapsedTime) + start * (1.5f * num2 + -2.5f * num + 1f) + end * (-1.5f * num2 + 2f * num + 0.5f * elapsedTime) + next * (0.5f * num2 - 0.5f * num);
		}

		public static Vector3 CatmullRomOLD(Vector3 previous, Vector3 start, Vector3 end, Vector3 next, float elapsedTime)
		{
			float num = elapsedTime * elapsedTime;
			float num2 = num * elapsedTime;
			return previous * (-0.5f * num2 + num - 0.5f * elapsedTime) + start * (1.5f * num2 + -2.5f * num + 1f) + end * (-1.5f * num2 + 2f * num + 0.5f * elapsedTime) + next * (0.5f * num2 - 0.5f * num);
		}
	}
	public class AstarMath
	{
		public static int ComputeVertexHash(int x, int y, int z)
		{
			uint num = 2376512323u;
			uint num2 = 3625334849u;
			uint num3 = 3407524639u;
			uint num4 = (uint)(num * x + num2 * y + num3 * z);
			return (int)(num4 & 0x3FFFFFFF);
		}

		public static Vector3 NearestPoint(Vector3 lineStart, Vector3 lineEnd, Vector3 point)
		{
			Vector3 vector = Vector3.Normalize(lineEnd - lineStart);
			float d = Vector3.Dot(point - lineStart, vector);
			return lineStart + d * vector;
		}

		public static float NearestPointFactor(Vector3 lineStart, Vector3 lineEnd, Vector3 point)
		{
			Vector3 rhs = lineEnd - lineStart;
			float magnitude = rhs.magnitude;
			rhs /= magnitude;
			float num = Vector3.Dot(point - lineStart, rhs);
			return num / magnitude;
		}

		public static float NearestPointFactor(Int3 lineStart, Int3 lineEnd, Int3 point)
		{
			Int3 rhs = lineEnd - lineStart;
			float sqrMagnitude = rhs.sqrMagnitude;
			return (float)Int3.Dot(point - lineStart, rhs) / sqrMagnitude;
		}

		public static float NearestPointFactor(Int2 lineStart, Int2 lineEnd, Int2 point)
		{
			Int2 b = lineEnd - lineStart;
			double num = b.sqrMagnitudeLong;
			double num2 = (double)Int2.DotLong(point - lineStart, b) / num;
			return (float)num2;
		}

		public static Vector3 NearestPointStrict(Vector3 lineStart, Vector3 lineEnd, Vector3 point)
		{
			Vector3 a = lineEnd - lineStart;
			float magnitude = a.magnitude;
			Vector3 vector = a / magnitude;
			float value = Vector3.Dot(point - lineStart, vector);
			return lineStart + Mathf.Clamp(value, 0f, magnitude) * vector;
		}

		public static Vector3 NearestPointStrictXZ(Vector3 lineStart, Vector3 lineEnd, Vector3 point)
		{
			lineStart.y = point.y;
			lineEnd.y = point.y;
			Vector3 vector = lineEnd - lineStart;
			Vector3 value = vector;
			value.y = 0f;
			Vector3 vector2 = Vector3.Normalize(value);
			float value2 = Vector3.Dot(point - lineStart, vector2);
			return lineStart + Mathf.Clamp(value2, 0f, value.magnitude) * vector2;
		}

		public static float DistancePointSegment(int x, int z, int px, int pz, int qx, int qz)
		{
			float num = qx - px;
			float num2 = qz - pz;
			float num3 = x - px;
			float num4 = z - pz;
			float num5 = num * num + num2 * num2;
			float num6 = num * num3 + num2 * num4;
			if (num5 > 0f)
			{
				num6 /= num5;
			}
			if (num6 < 0f)
			{
				num6 = 0f;
			}
			else if (num6 > 1f)
			{
				num6 = 1f;
			}
			num3 = (float)px + num6 * num - (float)x;
			num4 = (float)pz + num6 * num2 - (float)z;
			return num3 * num3 + num4 * num4;
		}

		public static float DistancePointSegment(Int3 a, Int3 b, Int3 p)
		{
			float num = b.x - a.x;
			float num2 = b.z - a.z;
			float num3 = p.x - a.x;
			float num4 = p.z - a.z;
			float num5 = num * num + num2 * num2;
			float num6 = num * num3 + num2 * num4;
			if (num5 > 0f)
			{
				num6 /= num5;
			}
			if (num6 < 0f)
			{
				num6 = 0f;
			}
			else if (num6 > 1f)
			{
				num6 = 1f;
			}
			num3 = (float)a.x + num6 * num - (float)p.x;
			num4 = (float)a.z + num6 * num2 - (float)p.z;
			return num3 * num3 + num4 * num4;
		}

		public static float DistancePointSegment2(int x, int z, int px, int pz, int qx, int qz)
		{
			Vector3 p = new Vector3(x, 0f, z);
			Vector3 a = new Vector3(px, 0f, pz);
			Vector3 b = new Vector3(qx, 0f, qz);
			return DistancePointSegment2(a, b, p);
		}

		public static float DistancePointSegment2(Vector3 a, Vector3 b, Vector3 p)
		{
			float num = b.x - a.x;
			float num2 = b.z - a.z;
			float num3 = Mathf.Abs(num * (p.z - a.z) - (p.x - a.x) * num2);
			float num4 = num * num + num2 * num2;
			if (num4 > 0f)
			{
				return num3 / Mathf.Sqrt(num4);
			}
			return (a - p).magnitude;
		}

		public static float DistancePointSegmentStrict(Vector3 a, Vector3 b, Vector3 p)
		{
			Vector3 a2 = NearestPointStrict(a, b, p);
			return (a2 - p).sqrMagnitude;
		}

		public static float Hermite(float start, float end, float value)
		{
			return Mathf.Lerp(start, end, value * value * (3f - 2f * value));
		}

		public static Vector3 CubicBezier(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
		{
			t = Mathf.Clamp01(t);
			float num = 1f - t;
			return num * num * num * p0 + 3f * num * num * t * p1 + 3f * num * t * t * p2 + t * t * t * p3;
		}

		public static float MapTo(float startMin, float startMax, float value)
		{
			value -= startMin;
			value /= startMax - startMin;
			value = Mathf.Clamp01(value);
			return value;
		}

		public static float MapToRange(float targetMin, float targetMax, float value)
		{
			value *= targetMax - targetMin;
			value += targetMin;
			return value;
		}

		public static float MapTo(float startMin, float startMax, float targetMin, float targetMax, float value)
		{
			value -= startMin;
			value /= startMax - startMin;
			value = Mathf.Clamp01(value);
			value *= targetMax - targetMin;
			value += targetMin;
			return value;
		}

		public static string FormatBytes(int bytes)
		{
			double num = (bytes < 0) ? (-1.0) : 1.0;
			bytes = ((bytes < 0) ? (-bytes) : bytes);
			if (bytes < 1000)
			{
				return ((double)bytes * num).ToString() + " bytes";
			}
			if (bytes < 1000000)
			{
				return ((double)bytes / 1000.0 * num).ToString("0.0") + " kb";
			}
			if (bytes < 1000000000)
			{
				return ((double)bytes / 1000000.0 * num).ToString("0.0") + " mb";
			}
			return ((double)bytes / 1000000000.0 * num).ToString("0.0") + " gb";
		}

		public static string FormatBytesBinary(int bytes)
		{
			double num = (bytes < 0) ? (-1.0) : 1.0;
			bytes = ((bytes < 0) ? (-bytes) : bytes);
			if (bytes < 1024)
			{
				return ((double)bytes * num).ToString() + " bytes";
			}
			if (bytes < 1048576)
			{
				return ((double)bytes / 1024.0 * num).ToString("0.0") + " kb";
			}
			if (bytes < 1073741824)
			{
				return ((double)bytes / 1048576.0 * num).ToString("0.0") + " mb";
			}
			return ((double)bytes / 1073741824.0 * num).ToString("0.0") + " gb";
		}

		public static int Bit(int a, int b)
		{
			return (a >> b) & 1;
		}

		public static Color IntToColor(int i, float a)
		{
			int num = Bit(i, 1) + Bit(i, 3) * 2 + 1;
			int num2 = Bit(i, 2) + Bit(i, 4) * 2 + 1;
			int num3 = Bit(i, 0) + Bit(i, 5) * 2 + 1;
			return new Color((float)num * 0.25f, (float)num2 * 0.25f, (float)num3 * 0.25f, a);
		}

		public static float MagnitudeXZ(Vector3 a, Vector3 b)
		{
			Vector3 vector = a - b;
			return (float)Math.Sqrt(vector.x * vector.x + vector.z * vector.z);
		}

		public static float SqrMagnitudeXZ(Vector3 a, Vector3 b)
		{
			Vector3 vector = a - b;
			return vector.x * vector.x + vector.z * vector.z;
		}

		public static int Repeat(int i, int n)
		{
			while (i >= n)
			{
				i -= n;
			}
			return i;
		}

		public static float Abs(float a)
		{
			if (a < 0f)
			{
				return 0f - a;
			}
			return a;
		}

		public static int Abs(int a)
		{
			if (a < 0)
			{
				return -a;
			}
			return a;
		}

		public static float Min(float a, float b)
		{
			return (!(a < b)) ? b : a;
		}

		public static int Min(int a, int b)
		{
			return (a >= b) ? b : a;
		}

		public static uint Min(uint a, uint b)
		{
			return (a >= b) ? b : a;
		}

		public static float Max(float a, float b)
		{
			return (!(a > b)) ? b : a;
		}

		public static int Max(int a, int b)
		{
			return (a <= b) ? b : a;
		}

		public static uint Max(uint a, uint b)
		{
			return (a <= b) ? b : a;
		}

		public static ushort Max(ushort a, ushort b)
		{
			return (a <= b) ? b : a;
		}

		public static float Sign(float a)
		{
			return (!(a < 0f)) ? 1f : (-1f);
		}

		public static int Sign(int a)
		{
			return (a >= 0) ? 1 : (-1);
		}

		public static float Clamp(float a, float b, float c)
		{
			return (a > c) ? c : ((!(a < b)) ? a : b);
		}

		public static int Clamp(int a, int b, int c)
		{
			return (a > c) ? c : ((a >= b) ? a : b);
		}

		public static float Clamp01(float a)
		{
			return (a > 1f) ? 1f : ((!(a < 0f)) ? a : 0f);
		}

		public static int Clamp01(int a)
		{
			return (a > 1) ? 1 : ((a >= 0) ? a : 0);
		}

		public static float Lerp(float a, float b, float t)
		{
			return a + (b - a) * ((t > 1f) ? 1f : ((!(t < 0f)) ? t : 0f));
		}

		public static int RoundToInt(float v)
		{
			return (int)(v + 0.5f);
		}

		public static int RoundToInt(double v)
		{
			return (int)(v + 0.5);
		}
	}
	public class Polygon
	{
		public static List<Vector3> hullCache = new List<Vector3>();

		public static long TriangleArea2(Int3 a, Int3 b, Int3 c)
		{
			return (long)(b.x - a.x) * (long)(c.z - a.z) - (long)(c.x - a.x) * (long)(b.z - a.z);
		}

		public static float TriangleArea2(Vector3 a, Vector3 b, Vector3 c)
		{
			return (b.x - a.x) * (c.z - a.z) - (c.x - a.x) * (b.z - a.z);
		}

		public static long TriangleArea(Int3 a, Int3 b, Int3 c)
		{
			return (long)(b.x - a.x) * (long)(c.z - a.z) - (long)(c.x - a.x) * (long)(b.z - a.z);
		}

		public static float TriangleArea(Vector3 a, Vector3 b, Vector3 c)
		{
			return (b.x - a.x) * (c.z - a.z) - (c.x - a.x) * (b.z - a.z);
		}

		public static bool ContainsPoint(Vector3 a, Vector3 b, Vector3 c, Vector3 p)
		{
			return IsClockwiseMargin(a, b, p) && IsClockwiseMargin(b, c, p) && IsClockwiseMargin(c, a, p);
		}

		public static bool ContainsPoint(Int2 a, Int2 b, Int2 c, Int2 p)
		{
			return IsClockwiseMargin(a, b, p) && IsClockwiseMargin(b, c, p) && IsClockwiseMargin(c, a, p);
		}

		public static bool ContainsPoint(Int3 a, Int3 b, Int3 c, Int3 p)
		{
			return IsClockwiseMargin(a, b, p) && IsClockwiseMargin(b, c, p) && IsClockwiseMargin(c, a, p);
		}

		public static bool ContainsPoint(Vector2[] polyPoints, Vector2 p)
		{
			int num = polyPoints.Length - 1;
			bool flag = false;
			int num2 = 0;
			while (num2 < polyPoints.Length)
			{
				if (((polyPoints[num2].y <= p.y && p.y < polyPoints[num].y) || (polyPoints[num].y <= p.y && p.y < polyPoints[num2].y)) && p.x < (polyPoints[num].x - polyPoints[num2].x) * (p.y - polyPoints[num2].y) / (polyPoints[num].y - polyPoints[num2].y) + polyPoints[num2].x)
				{
					flag = !flag;
				}
				num = num2++;
			}
			return flag;
		}

		public static bool ContainsPoint(Vector3[] polyPoints, Vector3 p)
		{
			int num = polyPoints.Length - 1;
			bool flag = false;
			int num2 = 0;
			while (num2 < polyPoints.Length)
			{
				if (((polyPoints[num2].z <= p.z && p.z < polyPoints[num].z) || (polyPoints[num].z <= p.z && p.z < polyPoints[num2].z)) && p.x < (polyPoints[num].x - polyPoints[num2].x) * (p.z - polyPoints[num2].z) / (polyPoints[num].z - polyPoints[num2].z) + polyPoints[num2].x)
				{
					flag = !flag;
				}
				num = num2++;
			}
			return flag;
		}

		public static bool LeftNotColinear(Vector3 a, Vector3 b, Vector3 p)
		{
			return (b.x - a.x) * (p.z - a.z) - (p.x - a.x) * (b.z - a.z) < -1.401298E-45f;
		}

		public static bool Left(Vector3 a, Vector3 b, Vector3 p)
		{
			return (b.x - a.x) * (p.z - a.z) - (p.x - a.x) * (b.z - a.z) <= 0f;
		}

		public static bool Left(Vector2 a, Vector2 b, Vector2 p)
		{
			return (b.x - a.x) * (p.y - a.y) - (p.x - a.x) * (b.y - a.y) <= 0f;
		}

		public static bool Left(Int3 a, Int3 b, Int3 c)
		{
			return (long)(b.x - a.x) * (long)(c.z - a.z) - (long)(c.x - a.x) * (long)(b.z - a.z) <= 0;
		}

		public static bool LeftNotColinear(Int3 a, Int3 b, Int3 c)
		{
			return (long)(b.x - a.x) * (long)(c.z - a.z) - (long)(c.x - a.x) * (long)(b.z - a.z) < 0;
		}

		public static bool Left(Int2 a, Int2 b, Int2 c)
		{
			return (long)(b.x - a.x) * (long)(c.y - a.y) - (long)(c.x - a.x) * (long)(b.y - a.y) <= 0;
		}

		public static bool IsClockwiseMargin(Vector3 a, Vector3 b, Vector3 c)
		{
			return (b.x - a.x) * (c.z - a.z) - (c.x - a.x) * (b.z - a.z) <= float.Epsilon;
		}

		public static bool IsClockwise(Vector3 a, Vector3 b, Vector3 c)
		{
			return (b.x - a.x) * (c.z - a.z) - (c.x - a.x) * (b.z - a.z) < 0f;
		}

		public static bool IsClockwise(Int3 a, Int3 b, Int3 c)
		{
			return (long)(b.x - a.x) * (long)(c.z - a.z) - (long)(c.x - a.x) * (long)(b.z - a.z) < 0;
		}

		public static bool IsClockwiseMargin(Int3 a, Int3 b, Int3 c)
		{
			return (long)(b.x - a.x) * (long)(c.z - a.z) - (long)(c.x - a.x) * (long)(b.z - a.z) <= 0;
		}

		public static bool IsClockwiseMargin(Int2 a, Int2 b, Int2 c)
		{
			return (long)(b.x - a.x) * (long)(c.y - a.y) - (long)(c.x - a.x) * (long)(b.y - a.y) <= 0;
		}

		public static bool IsColinear(Int3 a, Int3 b, Int3 c)
		{
			return (long)(b.x - a.x) * (long)(c.z - a.z) - (long)(c.x - a.x) * (long)(b.z - a.z) == 0;
		}

		public static bool IsColinearAlmost(Int3 a, Int3 b, Int3 c)
		{
			long num = (long)(b.x - a.x) * (long)(c.z - a.z) - (long)(c.x - a.x) * (long)(b.z - a.z);
			return num > -1 && num < 1;
		}

		public static bool IsColinear(Vector3 a, Vector3 b, Vector3 c)
		{
			float num = (b.x - a.x) * (c.z - a.z) - (c.x - a.x) * (b.z - a.z);
			return num <= 1E-07f && num >= -1E-07f;
		}

		public static bool IntersectsUnclamped(Vector3 a, Vector3 b, Vector3 a2, Vector3 b2)
		{
			return Left(a, b, a2) != Left(a, b, b2);
		}

		public static bool Intersects(Int2 a, Int2 b, Int2 a2, Int2 b2)
		{
			return Left(a, b, a2) != Left(a, b, b2) && Left(a2, b2, a) != Left(a2, b2, b);
		}

		public static bool Intersects(Int3 a, Int3 b, Int3 a2, Int3 b2)
		{
			return Left(a, b, a2) != Left(a, b, b2) && Left(a2, b2, a) != Left(a2, b2, b);
		}

		public static bool Intersects(Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2)
		{
			Vector3 vector = end1 - start1;
			Vector3 vector2 = end2 - start2;
			float num = vector2.z * vector.x - vector2.x * vector.z;
			if (num == 0f)
			{
				return false;
			}
			float num2 = vector2.x * (start1.z - start2.z) - vector2.z * (start1.x - start2.x);
			float num3 = vector.x * (start1.z - start2.z) - vector.z * (start1.x - start2.x);
			float num4 = num2 / num;
			float num5 = num3 / num;
			if (num4 < 0f || num4 > 1f || num5 < 0f || num5 > 1f)
			{
				return false;
			}
			return true;
		}

		public static Vector3 IntersectionPointOptimized(Vector3 start1, Vector3 dir1, Vector3 start2, Vector3 dir2)
		{
			float num = dir2.z * dir1.x - dir2.x * dir1.z;
			if (num == 0f)
			{
				return start1;
			}
			float num2 = dir2.x * (start1.z - start2.z) - dir2.z * (start1.x - start2.x);
			float d = num2 / num;
			return start1 + dir1 * d;
		}

		public static Vector3 IntersectionPointOptimized(Vector3 start1, Vector3 dir1, Vector3 start2, Vector3 dir2, out bool intersects)
		{
			float num = dir2.z * dir1.x - dir2.x * dir1.z;
			if (num == 0f)
			{
				intersects = false;
				return start1;
			}
			float num2 = dir2.x * (start1.z - start2.z) - dir2.z * (start1.x - start2.x);
			float d = num2 / num;
			intersects = true;
			return start1 + dir1 * d;
		}

		public static bool IntersectionFactorRaySegment(Int3 start1, Int3 end1, Int3 start2, Int3 end2)
		{
			Int3 @int = end1 - start1;
			Int3 int2 = end2 - start2;
			long num = int2.z * @int.x - int2.x * @int.z;
			if (num == 0L)
			{
				return false;
			}
			long num2 = int2.x * (start1.z - start2.z) - int2.z * (start1.x - start2.x);
			long num3 = @int.x * (start1.z - start2.z) - @int.z * (start1.x - start2.x);
			if (!((num2 < 0) ^ (num < 0)))
			{
				return false;
			}
			if (!((num3 < 0) ^ (num < 0)))
			{
				return false;
			}
			if ((num >= 0 && num3 > num) || (num < 0 && num3 <= num))
			{
				return false;
			}
			return true;
		}

		public static bool IntersectionFactor(Int3 start1, Int3 end1, Int3 start2, Int3 end2, out float factor1, out float factor2)
		{
			Int3 @int = end1 - start1;
			Int3 int2 = end2 - start2;
			long num = int2.z * @int.x - int2.x * @int.z;
			if (num == 0L)
			{
				factor1 = 0f;
				factor2 = 0f;
				return false;
			}
			long num2 = int2.x * (start1.z - start2.z) - int2.z * (start1.x - start2.x);
			long num3 = @int.x * (start1.z - start2.z) - @int.z * (start1.x - start2.x);
			factor1 = (float)num2 / (float)num;
			factor2 = (float)num3 / (float)num;
			return true;
		}

		public static bool IntersectionFactor(Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2, out float factor1, out float factor2)
		{
			Vector3 vector = end1 - start1;
			Vector3 vector2 = end2 - start2;
			float num = vector2.z * vector.x - vector2.x * vector.z;
			if (num <= 1E-05f && num >= -1E-05f)
			{
				factor1 = 0f;
				factor2 = 0f;
				return false;
			}
			float num2 = vector2.x * (start1.z - start2.z) - vector2.z * (start1.x - start2.x);
			float num3 = vector.x * (start1.z - start2.z) - vector.z * (start1.x - start2.x);
			float num4 = num2 / num;
			float num5 = num3 / num;
			factor1 = num4;
			factor2 = num5;
			return true;
		}

		public static float IntersectionFactorRay(Int3 start1, Int3 end1, Int3 start2, Int3 end2)
		{
			Int3 @int = end1 - start1;
			Int3 int2 = end2 - start2;
			int num = int2.z * @int.x - int2.x * @int.z;
			if (num == 0)
			{
				return float.NaN;
			}
			int num2 = int2.x * (start1.z - start2.z) - int2.z * (start1.x - start2.x);
			int num3 = @int.x * (start1.z - start2.z) - @int.z * (start1.x - start2.x);
			if ((float)num3 / (float)num < 0f)
			{
				return float.NaN;
			}
			return (float)num2 / (float)num;
		}

		public static float IntersectionFactor(Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2)
		{
			Vector3 vector = end1 - start1;
			Vector3 vector2 = end2 - start2;
			float num = vector2.z * vector.x - vector2.x * vector.z;
			if (num == 0f)
			{
				return -1f;
			}
			float num2 = vector2.x * (start1.z - start2.z) - vector2.z * (start1.x - start2.x);
			return num2 / num;
		}

		public static Vector3 IntersectionPoint(Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2)
		{
			bool intersects;
			return IntersectionPoint(start1, end1, start2, end2, out intersects);
		}

		public static Vector3 IntersectionPoint(Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2, out bool intersects)
		{
			Vector3 a = end1 - start1;
			Vector3 vector = end2 - start2;
			float num = vector.z * a.x - vector.x * a.z;
			if (num == 0f)
			{
				intersects = false;
				return start1;
			}
			float num2 = vector.x * (start1.z - start2.z) - vector.z * (start1.x - start2.x);
			float d = num2 / num;
			intersects = true;
			return start1 + a * d;
		}

		public static Vector2 IntersectionPoint(Vector2 start1, Vector2 end1, Vector2 start2, Vector2 end2)
		{
			bool intersects;
			return IntersectionPoint(start1, end1, start2, end2, out intersects);
		}

		public static Vector2 IntersectionPoint(Vector2 start1, Vector2 end1, Vector2 start2, Vector2 end2, out bool intersects)
		{
			Vector2 a = end1 - start1;
			Vector2 vector = end2 - start2;
			float num = vector.y * a.x - vector.x * a.y;
			if (num == 0f)
			{
				intersects = false;
				return start1;
			}
			float num2 = vector.x * (start1.y - start2.y) - vector.y * (start1.x - start2.x);
			float d = num2 / num;
			intersects = true;
			return start1 + a * d;
		}

		public static Vector3 SegmentIntersectionPoint(Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2, out bool intersects)
		{
			Vector3 a = end1 - start1;
			Vector3 vector = end2 - start2;
			float num = vector.z * a.x - vector.x * a.z;
			if (num == 0f)
			{
				intersects = false;
				return start1;
			}
			float num2 = vector.x * (start1.z - start2.z) - vector.z * (start1.x - start2.x);
			float num3 = a.x * (start1.z - start2.z) - a.z * (start1.x - start2.x);
			float num4 = num2 / num;
			float num5 = num3 / num;
			if (num4 < 0f || num4 > 1f || num5 < 0f || num5 > 1f)
			{
				intersects = false;
				return start1;
			}
			intersects = true;
			return start1 + a * num4;
		}

		public static Vector3[] ConvexHull(Vector3[] points)
		{
			//Discarded unreachable code: IL_0104
			if (points.Length == 0)
			{
				return new Vector3[0];
			}
			lock (hullCache)
			{
				List<Vector3> list = hullCache;
				list.Clear();
				int num = 0;
				for (int i = 1; i < points.Length; i++)
				{
					if (points[i].x < points[num].x)
					{
						num = i;
					}
				}
				int num2 = num;
				int num3 = 0;
				do
				{
					list.Add(points[num]);
					int num4 = 0;
					for (int j = 0; j < points.Length; j++)
					{
						if (num4 == num || !Left(points[num], points[num4], points[j]))
						{
							num4 = j;
						}
					}
					num = num4;
					num3++;
					if (num3 > 10000)
					{
						UnityEngine.Debug.LogWarning("Infinite Loop in Convex Hull Calculation");
						break;
					}
				}
				while (num != num2);
				return list.ToArray();
			}
		}

		public static bool LineIntersectsBounds(Bounds bounds, Vector3 a, Vector3 b)
		{
			a -= bounds.center;
			b -= bounds.center;
			Vector3 b2 = (a + b) * 0.5f;
			Vector3 vector = a - b2;
			Vector3 vector2 = new Vector3(Math.Abs(vector.x), Math.Abs(vector.y), Math.Abs(vector.z));
			Vector3 extents = bounds.extents;
			if (Math.Abs(b2.x) > extents.x + vector2.x)
			{
				return false;
			}
			if (Math.Abs(b2.y) > extents.y + vector2.y)
			{
				return false;
			}
			if (Math.Abs(b2.z) > extents.z + vector2.z)
			{
				return false;
			}
			if (Math.Abs(b2.y * vector.z - b2.z * vector.y) > extents.y * vector2.z + extents.z * vector2.y)
			{
				return false;
			}
			if (Math.Abs(b2.x * vector.z - b2.z * vector.x) > extents.x * vector2.z + extents.z * vector2.x)
			{
				return false;
			}
			if (Math.Abs(b2.x * vector.y - b2.y * vector.x) > extents.x * vector2.y + extents.y * vector2.x)
			{
				return false;
			}
			return true;
		}

		public static Vector3[] Subdivide(Vector3[] path, int subdivisions)
		{
			subdivisions = ((subdivisions >= 0) ? subdivisions : 0);
			if (subdivisions == 0)
			{
				return path;
			}
			Vector3[] array = new Vector3[(path.Length - 1) * (int)Mathf.Pow(2f, subdivisions) + 1];
			int num = 0;
			for (int i = 0; i < path.Length - 1; i++)
			{
				float num2 = 1f / Mathf.Pow(2f, subdivisions);
				for (float num3 = 0f; num3 < 1f; num3 += num2)
				{
					array[num] = Vector3.Lerp(path[i], path[i + 1], Mathf.SmoothStep(0f, 1f, num3));
					num++;
				}
			}
			array[num] = path[path.Length - 1];
			return array;
		}

		public static Vector3 ClosestPointOnTriangle(Vector3[] triangle, Vector3 point)
		{
			return ClosestPointOnTriangle(triangle[0], triangle[1], triangle[2], point);
		}

		public static Vector3 ClosestPointOnTriangle(Vector3 tr0, Vector3 tr1, Vector3 tr2, Vector3 point)
		{
			Vector3 lhs = tr0 - point;
			Vector3 vector = tr1 - tr0;
			Vector3 vector2 = tr2 - tr0;
			float sqrMagnitude = vector.sqrMagnitude;
			float num = Vector3.Dot(vector, vector2);
			float sqrMagnitude2 = vector2.sqrMagnitude;
			float num2 = Vector3.Dot(lhs, vector);
			float num3 = Vector3.Dot(lhs, vector2);
			float num4 = sqrMagnitude * sqrMagnitude2 - num * num;
			float num5 = num * num3 - sqrMagnitude2 * num2;
			float num6 = num * num2 - sqrMagnitude * num3;
			if (num5 + num6 <= num4)
			{
				if (num5 < 0f)
				{
					if (num6 < 0f)
					{
						if (num2 < 0f)
						{
							num6 = 0f;
							num5 = ((!(0f - num2 >= sqrMagnitude)) ? ((0f - num2) / sqrMagnitude) : 1f);
						}
						else
						{
							num5 = 0f;
							num6 = ((num3 >= 0f) ? 0f : ((!(0f - num3 >= sqrMagnitude2)) ? ((0f - num3) / sqrMagnitude2) : 1f));
						}
					}
					else
					{
						num5 = 0f;
						num6 = ((num3 >= 0f) ? 0f : ((!(0f - num3 >= sqrMagnitude2)) ? ((0f - num3) / sqrMagnitude2) : 1f));
					}
				}
				else if (num6 < 0f)
				{
					num6 = 0f;
					num5 = ((num2 >= 0f) ? 0f : ((!(0f - num2 >= sqrMagnitude)) ? ((0f - num2) / sqrMagnitude) : 1f));
				}
				else
				{
					float num7 = 1f / num4;
					num5 *= num7;
					num6 *= num7;
				}
			}
			else if (num5 < 0f)
			{
				float num8 = num + num2;
				float num9 = sqrMagnitude2 + num3;
				if (num9 > num8)
				{
					float num10 = num9 - num8;
					float num11 = sqrMagnitude - 2f * num + sqrMagnitude2;
					if (num10 >= num11)
					{
						num5 = 1f;
						num6 = 0f;
					}
					else
					{
						num5 = num10 / num11;
						num6 = 1f - num5;
					}
				}
				else
				{
					num5 = 0f;
					num6 = ((num9 <= 0f) ? 1f : ((!(num3 >= 0f)) ? ((0f - num3) / sqrMagnitude2) : 0f));
				}
			}
			else if (num6 < 0f)
			{
				float num8 = num + num3;
				float num9 = sqrMagnitude + num2;
				if (num9 > num8)
				{
					float num10 = num9 - num8;
					float num11 = sqrMagnitude - 2f * num + sqrMagnitude2;
					if (num10 >= num11)
					{
						num6 = 1f;
						num5 = 0f;
					}
					else
					{
						num6 = num10 / num11;
						num5 = 1f - num6;
					}
				}
				else
				{
					num6 = 0f;
					num5 = ((num9 <= 0f) ? 1f : ((!(num2 >= 0f)) ? ((0f - num2) / sqrMagnitude) : 0f));
				}
			}
			else
			{
				float num10 = sqrMagnitude2 + num3 - num - num2;
				if (num10 <= 0f)
				{
					num5 = 0f;
					num6 = 1f;
				}
				else
				{
					float num11 = sqrMagnitude - 2f * num + sqrMagnitude2;
					if (num10 >= num11)
					{
						num5 = 1f;
						num6 = 0f;
					}
					else
					{
						num5 = num10 / num11;
						num6 = 1f - num5;
					}
				}
			}
			return tr0 + num5 * vector + num6 * vector2;
		}

		public static float DistanceSegmentSegment3D(Vector3 s1, Vector3 e1, Vector3 s2, Vector3 e2)
		{
			Vector3 vector = e1 - s1;
			Vector3 vector2 = e2 - s2;
			Vector3 vector3 = s1 - s2;
			float num = Vector3.Dot(vector, vector);
			float num2 = Vector3.Dot(vector, vector2);
			float num3 = Vector3.Dot(vector2, vector2);
			float num4 = Vector3.Dot(vector, vector3);
			float num5 = Vector3.Dot(vector2, vector3);
			float num6 = num * num3 - num2 * num2;
			float num7 = num6;
			float num8 = num6;
			float num9;
			float num10;
			if (num6 < 1E-06f)
			{
				num9 = 0f;
				num7 = 1f;
				num10 = num5;
				num8 = num3;
			}
			else
			{
				num9 = num2 * num5 - num3 * num4;
				num10 = num * num5 - num2 * num4;
				if (num9 < 0f)
				{
					num9 = 0f;
					num10 = num5;
					num8 = num3;
				}
				else if (num9 > num7)
				{
					num9 = num7;
					num10 = num5 + num2;
					num8 = num3;
				}
			}
			if (num10 < 0f)
			{
				num10 = 0f;
				if (0f - num4 < 0f)
				{
					num9 = 0f;
				}
				else if (0f - num4 > num)
				{
					num9 = num7;
				}
				else
				{
					num9 = 0f - num4;
					num7 = num;
				}
			}
			else if (num10 > num8)
			{
				num10 = num8;
				if (0f - num4 + num2 < 0f)
				{
					num9 = 0f;
				}
				else if (0f - num4 + num2 > num)
				{
					num9 = num7;
				}
				else
				{
					num9 = 0f - num4 + num2;
					num7 = num;
				}
			}
			float d = (!(Math.Abs(num9) < 1E-06f)) ? (num9 / num7) : 0f;
			float d2 = (!(Math.Abs(num10) < 1E-06f)) ? (num10 / num8) : 0f;
			return (vector3 + d * vector - d2 * vector2).sqrMagnitude;
		}
	}
}
[AddComponentMenu("Pathfinding/Pathfinder")]
public class AstarPath : MonoBehaviour
{
	public enum AstarDistribution
	{
		WebsiteDownload,
		AssetStore
	}

	public struct AstarWorkItem
	{
		public OnVoidDelegate init;

		public Func<bool, bool> update;

		public AstarWorkItem(Func<bool, bool> update)
		{
			init = null;
			this.update = update;
		}

		public AstarWorkItem(OnVoidDelegate init, Func<bool, bool> update)
		{
			this.init = init;
			this.update = update;
		}
	}

	private enum GraphUpdateOrder
	{
		GraphUpdate,
		FloodFill
	}

	private struct GUOSingle
	{
		public GraphUpdateOrder order;

		public IUpdatableGraph graph;

		public GraphUpdateObject obj;
	}

	public static readonly AstarDistribution Distribution = AstarDistribution.AssetStore;

	public static readonly string Branch = "master_Pro";

	public static readonly bool HasPro = true;

	public AstarData astarData;

	public static AstarPath active;

	public bool showNavGraphs = true;

	public bool showUnwalkableNodes = true;

	public GraphDebugMode debugMode;

	public float debugFloor;

	public float debugRoof = 20000f;

	public bool showSearchTree;

	public float unwalkableNodeDebugSize = 0.3f;

	public PathLog logPathResults = PathLog.Normal;

	public float maxNearestNodeDistance = 100f;

	public bool scanOnStartup = true;

	public bool fullGetNearestSearch;

	public bool prioritizeGraphs;

	public float prioritizeGraphsLimit = 1f;

	public AstarColor colorSettings;

	[SerializeField]
	protected string[] tagNames;

	public Heuristic heuristic = Heuristic.Euclidean;

	public float heuristicScale = 1f;

	public ThreadCount threadCount;

	public float maxFrameTime = 1f;

	public int minAreaSize = 10;

	public bool limitGraphUpdates = true;

	public float maxGraphUpdateFreq = 0.2f;

	public static int PathsCompleted = 0;

	public static long TotalSearchedNodes = 0L;

	public static long TotalSearchTime = 0L;

	public float lastScanTime;

	public Pathfinding.Path debugPath;

	public string inGameDebugPath;

	public bool isScanning;

	private bool graphUpdateRoutineRunning;

	private bool isRegisteredForUpdate;

	public static OnVoidDelegate OnAwakeSettings;

	public static OnGraphDelegate OnGraphPreScan;

	public static OnGraphDelegate OnGraphPostScan;

	public static OnPathDelegate OnPathPreSearch;

	public static OnPathDelegate OnPathPostSearch;

	public static OnScanDelegate OnPreScan;

	public static OnScanDelegate OnPostScan;

	public static OnScanDelegate OnLatePostScan;

	public static OnScanDelegate OnGraphsUpdated;

	public static OnVoidDelegate On65KOverflow;

	private static OnVoidDelegate OnSafeCallback;

	private static OnVoidDelegate OnThreadSafeCallback;

	public OnVoidDelegate OnDrawGizmosCallback;

	[Obsolete]
	public OnVoidDelegate OnGraphsWillBeUpdated;

	[Obsolete]
	public OnVoidDelegate OnGraphsWillBeUpdated2;

	[NonSerialized]
	public Queue<GraphUpdateObject> graphUpdateQueue;

	[NonSerialized]
	public Stack<GraphNode> floodStack;

	private ThreadControlQueue pathQueue = new ThreadControlQueue(0);

	private static Thread[] threads;

	private static PathThreadInfo[] threadInfos = new PathThreadInfo[0];

	private static IEnumerator threadEnumerator;

	private static LockFreeStack pathReturnStack = new LockFreeStack();

	public bool showGraphs;

	public static bool isEditor = true;

	public uint lastUniqueAreaIndex;

	private static readonly object safeUpdateLock = new object();

	private float lastGraphUpdate = -9999f;

	private ushort nextFreePathID = 1;

	private Queue<AstarWorkItem> workItems = new Queue<AstarWorkItem>();

	private bool workItemsQueued;

	private bool queuedWorkItemFloodFill;

	private bool processingWorkItems;

	private AutoResetEvent graphUpdateAsyncEvent = new AutoResetEvent(initialState: false);

	private ManualResetEvent processingGraphUpdatesAsync = new ManualResetEvent(initialState: true);

	private Queue<GUOSingle> graphUpdateQueueAsync = new Queue<GUOSingle>();

	private Queue<GUOSingle> graphUpdateQueueRegular = new Queue<GUOSingle>();

	private int nextNodeIndex = 1;

	private Stack<int> nodeIndexPool = new Stack<int>();

	private static int waitForPathDepth = 0;

	private Pathfinding.Path pathReturnPop;

	public static System.Version Version => new System.Version(3, 5, 1);

	public Type[] graphTypes => astarData.graphTypes;

	public NavGraph[] graphs
	{
		get
		{
			if (astarData == null)
			{
				astarData = new AstarData();
			}
			return astarData.graphs;
		}
		set
		{
			if (astarData == null)
			{
				astarData = new AstarData();
			}
			astarData.graphs = value;
		}
	}

	public float maxNearestNodeDistanceSqr => maxNearestNodeDistance * maxNearestNodeDistance;

	public PathHandler debugPathData
	{
		get
		{
			if (debugPath == null)
			{
				return null;
			}
			return debugPath.pathHandler;
		}
	}

	public static int NumParallelThreads => (threadInfos != null) ? threadInfos.Length : 0;

	public static bool IsUsingMultithreading
	{
		get
		{
			if (threads != null && threads.Length > 0)
			{
				return true;
			}
			if (threads != null && threads.Length == 0 && threadEnumerator != null)
			{
				return false;
			}
			if (UnityEngine.Application.isPlaying)
			{
				throw new Exception("Not 'using threading' and not 'not using threading'... Are you sure pathfinding is set up correctly?\nIf scripts are reloaded in unity editor during play this could happen.\n" + ((threads == null) ? "NULL" : (string.Empty + threads.Length)) + " " + (threadEnumerator != null));
			}
			return false;
		}
	}

	public bool IsAnyGraphUpdatesQueued => graphUpdateQueue != null && graphUpdateQueue.Count > 0;

	public string[] GetTagNames()
	{
		if (tagNames == null || tagNames.Length != 32)
		{
			tagNames = new string[32];
			for (int i = 0; i < tagNames.Length; i++)
			{
				tagNames[i] = string.Empty + i;
			}
			tagNames[0] = "Basic Ground";
		}
		return tagNames;
	}

	public static string[] FindTagNames()
	{
		if (active != null)
		{
			return active.GetTagNames();
		}
		AstarPath astarPath = UnityEngine.Object.FindObjectOfType(typeof(AstarPath)) as AstarPath;
		if (astarPath != null)
		{
			active = astarPath;
			return astarPath.GetTagNames();
		}
		return new string[1]
		{
			"There is no AstarPath component in the scene"
		};
	}

	public ushort GetNextPathID()
	{
		if (nextFreePathID == 0)
		{
			nextFreePathID++;
			UnityEngine.Debug.Log("65K cleanup");
			if (On65KOverflow != null)
			{
				OnVoidDelegate on65KOverflow = On65KOverflow;
				On65KOverflow = null;
				on65KOverflow();
			}
		}
		return nextFreePathID++;
	}

	private void OnDrawGizmos()
	{
		if (active == null)
		{
			active = this;
		}
		else if (active != this)
		{
			return;
		}
		if (graphs == null || (pathQueue != null && pathQueue.AllReceiversBlocked && workItems.Count > 0))
		{
			return;
		}
		for (int i = 0; i < graphs.Length; i++)
		{
			if (graphs[i] != null && graphs[i].drawGizmos)
			{
				graphs[i].OnDrawGizmos(showNavGraphs);
			}
		}
		if (showUnwalkableNodes && showNavGraphs)
		{
			Gizmos.color = AstarColor.UnwalkableNode;
			GraphNodeDelegateCancelable del = DrawUnwalkableNode;
			for (int j = 0; j < graphs.Length; j++)
			{
				if (graphs[j] != null)
				{
					graphs[j].GetNodes(del);
				}
			}
		}
		if (OnDrawGizmosCallback != null)
		{
			OnDrawGizmosCallback();
		}
	}

	private bool DrawUnwalkableNode(GraphNode node)
	{
		if (!node.Walkable)
		{
			Gizmos.DrawCube((Vector3)node.position, Vector3.one * unwalkableNodeDebugSize);
		}
		return true;
	}

	private static void AstarLog(string s)
	{
		if (object.ReferenceEquals(active, null))
		{
			UnityEngine.Debug.Log("No AstarPath object was found : " + s);
		}
		else if (active.logPathResults != 0 && active.logPathResults != PathLog.OnlyErrors)
		{
			UnityEngine.Debug.Log(s);
		}
	}

	private static void AstarLogError(string s)
	{
		if (active == null)
		{
			UnityEngine.Debug.Log("No AstarPath object was found : " + s);
		}
		else if (active.logPathResults != 0)
		{
			UnityEngine.Debug.LogError(s);
		}
	}

	private void LogPathResults(Pathfinding.Path p)
	{
		if (logPathResults != 0 && (logPathResults != PathLog.OnlyErrors || p.error))
		{
			string message = p.DebugString(logPathResults);
			if (logPathResults == PathLog.InGame)
			{
				inGameDebugPath = message;
			}
			else
			{
				UnityEngine.Debug.Log(message);
			}
		}
	}

	private void Update()
	{
		PerformBlockingActions();
		if (threadEnumerator != null)
		{
			try
			{
				threadEnumerator.MoveNext();
			}
			catch (Exception ex)
			{
				threadEnumerator = null;
				if (!(ex is ThreadControlQueue.QueueTerminationException))
				{
					UnityEngine.Debug.LogException(ex);
					UnityEngine.Debug.LogError("Unhandled exception during pathfinding. Terminating.");
					pathQueue.TerminateReceivers();
					try
					{
						pathQueue.PopNoBlock(blockedBefore: false);
					}
					catch
					{
					}
				}
			}
		}
		ReturnPaths(timeSlice: true);
	}

	private void PerformBlockingActions(bool force = false, bool unblockOnComplete = true)
	{
		if (!pathQueue.AllReceiversBlocked)
		{
			return;
		}
		ReturnPaths(timeSlice: false);
		if (OnThreadSafeCallback != null)
		{
			OnVoidDelegate onThreadSafeCallback = OnThreadSafeCallback;
			OnThreadSafeCallback = null;
			onThreadSafeCallback();
		}
		if (ProcessWorkItems(force) == 2)
		{
			workItemsQueued = false;
			if (unblockOnComplete)
			{
				pathQueue.Unblock();
			}
		}
	}

	public void QueueWorkItemFloodFill()
	{
		if (!pathQueue.AllReceiversBlocked)
		{
			throw new Exception("You are calling QueueWorkItemFloodFill from outside a WorkItem. This might cause unexpected behaviour.");
		}
		queuedWorkItemFloodFill = true;
	}

	public void EnsureValidFloodFill()
	{
		if (queuedWorkItemFloodFill)
		{
			FloodFill();
		}
	}

	public void AddWorkItem(AstarWorkItem itm)
	{
		workItems.Enqueue(itm);
		if (!workItemsQueued)
		{
			workItemsQueued = true;
			if (!isScanning)
			{
				InterruptPathfinding();
			}
		}
	}

	private int ProcessWorkItems(bool force)
	{
		//Discarded unreachable code: IL_0099
		if (pathQueue.AllReceiversBlocked)
		{
			if (processingWorkItems)
			{
				throw new Exception("Processing work items recursively. Please do not wait for other work items to be completed inside work items. If you think this is not caused by any of your scripts, this might be a bug.");
			}
			processingWorkItems = true;
			while (workItems.Count > 0)
			{
				AstarWorkItem astarWorkItem = workItems.Peek();
				if (astarWorkItem.init != null)
				{
					astarWorkItem.init();
					astarWorkItem.init = null;
				}
				bool flag;
				try
				{
					flag = (astarWorkItem.update == null || astarWorkItem.update(force));
				}
				catch
				{
					workItems.Dequeue();
					processingWorkItems = false;
					throw;
				}
				if (!flag)
				{
					processingWorkItems = false;
					return 1;
				}
				workItems.Dequeue();
			}
			EnsureValidFloodFill();
			processingWorkItems = false;
			return 2;
		}
		return 0;
	}

	public void QueueGraphUpdates()
	{
		if (!isRegisteredForUpdate)
		{
			isRegisteredForUpdate = true;
			AstarWorkItem itm = default(AstarWorkItem);
			itm.init = QueueGraphUpdatesInternal;
			itm.update = ProcessGraphUpdates;
			AddWorkItem(itm);
		}
	}

	private IEnumerator DelayedGraphUpdate()
	{
		graphUpdateRoutineRunning = true;
		yield return new WaitForSeconds(maxGraphUpdateFreq - (Time.time - lastGraphUpdate));
		QueueGraphUpdates();
		graphUpdateRoutineRunning = false;
	}

	public void UpdateGraphs(Bounds bounds, float t)
	{
		UpdateGraphs(new GraphUpdateObject(bounds), t);
	}

	public void UpdateGraphs(GraphUpdateObject ob, float t)
	{
		StartCoroutine(UpdateGraphsInteral(ob, t));
	}

	private IEnumerator UpdateGraphsInteral(GraphUpdateObject ob, float t)
	{
		yield return new WaitForSeconds(t);
		UpdateGraphs(ob);
	}

	public void UpdateGraphs(Bounds bounds)
	{
		UpdateGraphs(new GraphUpdateObject(bounds));
	}

	public void UpdateGraphs(GraphUpdateObject ob)
	{
		if (graphUpdateQueue == null)
		{
			graphUpdateQueue = new Queue<GraphUpdateObject>();
		}
		graphUpdateQueue.Enqueue(ob);
		if (limitGraphUpdates && Time.time - lastGraphUpdate < maxGraphUpdateFreq)
		{
			if (!graphUpdateRoutineRunning)
			{
				StartCoroutine(DelayedGraphUpdate());
			}
		}
		else
		{
			QueueGraphUpdates();
		}
	}

	public void FlushGraphUpdates()
	{
		if (IsAnyGraphUpdatesQueued)
		{
			QueueGraphUpdates();
			FlushWorkItems();
		}
	}

	public void FlushWorkItems()
	{
		BlockUntilPathQueueBlocked();
		PerformBlockingActions(force: true);
	}

	private void QueueGraphUpdatesInternal()
	{
		isRegisteredForUpdate = false;
		bool flag = false;
		while (graphUpdateQueue.Count > 0)
		{
			GraphUpdateObject graphUpdateObject = graphUpdateQueue.Dequeue();
			if (graphUpdateObject.requiresFloodFill)
			{
				flag = true;
			}
			foreach (IUpdatableGraph updateableGraph in astarData.GetUpdateableGraphs())
			{
				NavGraph graph = updateableGraph as NavGraph;
				if (graphUpdateObject.nnConstraint == null || graphUpdateObject.nnConstraint.SuitableGraph(active.astarData.GetGraphIndex(graph), graph))
				{
					GUOSingle item = default(GUOSingle);
					item.order = GraphUpdateOrder.GraphUpdate;
					item.obj = graphUpdateObject;
					item.graph = updateableGraph;
					graphUpdateQueueRegular.Enqueue(item);
				}
			}
		}
		if (flag)
		{
			GUOSingle item2 = default(GUOSingle);
			item2.order = GraphUpdateOrder.FloodFill;
			graphUpdateQueueRegular.Enqueue(item2);
		}
		debugPath = null;
		GraphModifier.TriggerEvent(GraphModifier.EventType.PreUpdate);
	}

	private bool ProcessGraphUpdates(bool force)
	{
		if (force)
		{
			processingGraphUpdatesAsync.WaitOne();
		}
		else if (!processingGraphUpdatesAsync.WaitOne(0))
		{
			return false;
		}
		if (graphUpdateQueueAsync.Count != 0)
		{
			throw new Exception("Queue should be empty at this stage");
		}
		while (graphUpdateQueueRegular.Count > 0)
		{
			GUOSingle item = graphUpdateQueueRegular.Peek();
			GraphUpdateThreading graphUpdateThreading = (item.order == GraphUpdateOrder.FloodFill) ? GraphUpdateThreading.SeparateThread : item.graph.CanUpdateAsync(item.obj);
			if (!force && graphUpdateThreading == GraphUpdateThreading.SeparateAndUnityInit)
			{
				if (graphUpdateQueueAsync.Count > 0)
				{
					processingGraphUpdatesAsync.Reset();
					graphUpdateAsyncEvent.Set();
					return false;
				}
				item.graph.UpdateAreaInit(item.obj);
				graphUpdateQueueRegular.Dequeue();
				graphUpdateQueueAsync.Enqueue(item);
				processingGraphUpdatesAsync.Reset();
				graphUpdateAsyncEvent.Set();
				return false;
			}
			if (!force && graphUpdateThreading == GraphUpdateThreading.SeparateThread)
			{
				graphUpdateQueueRegular.Dequeue();
				graphUpdateQueueAsync.Enqueue(item);
				continue;
			}
			if (graphUpdateQueueAsync.Count > 0)
			{
				if (force)
				{
					throw new Exception("This should not happen");
				}
				processingGraphUpdatesAsync.Reset();
				graphUpdateAsyncEvent.Set();
				return false;
			}
			graphUpdateQueueRegular.Dequeue();
			if (item.order == GraphUpdateOrder.FloodFill)
			{
				FloodFill();
				continue;
			}
			if (graphUpdateThreading == GraphUpdateThreading.SeparateAndUnityInit)
			{
				try
				{
					item.graph.UpdateAreaInit(item.obj);
				}
				catch (Exception arg)
				{
					UnityEngine.Debug.LogError("Error while initializing GraphUpdates\n" + arg);
				}
			}
			try
			{
				item.graph.UpdateArea(item.obj);
			}
			catch (Exception arg2)
			{
				UnityEngine.Debug.LogError("Error while updating graphs\n" + arg2);
			}
		}
		if (graphUpdateQueueAsync.Count > 0)
		{
			processingGraphUpdatesAsync.Reset();
			graphUpdateAsyncEvent.Set();
			return false;
		}
		GraphModifier.TriggerEvent(GraphModifier.EventType.PostUpdate);
		if (OnGraphsUpdated != null)
		{
			OnGraphsUpdated(this);
		}
		return true;
	}

	private void ProcessGraphUpdatesAsync(object _astar)
	{
		AstarPath astarPath = _astar as AstarPath;
		if (object.ReferenceEquals(astarPath, null))
		{
			UnityEngine.Debug.LogError("ProcessGraphUpdatesAsync started with invalid parameter _astar (was no AstarPath object)");
			return;
		}
		while (true)
		{
			if (!astarPath.pathQueue.IsTerminating)
			{
				graphUpdateAsyncEvent.WaitOne();
				if (astarPath.pathQueue.IsTerminating)
				{
					break;
				}
				while (graphUpdateQueueAsync.Count > 0)
				{
					GUOSingle gUOSingle = graphUpdateQueueAsync.Dequeue();
					try
					{
						if (gUOSingle.order == GraphUpdateOrder.GraphUpdate)
						{
							gUOSingle.graph.UpdateArea(gUOSingle.obj);
						}
						else
						{
							if (gUOSingle.order != GraphUpdateOrder.FloodFill)
							{
								throw new NotSupportedException(string.Empty + gUOSingle.order);
							}
							astarPath.FloodFill();
						}
					}
					catch (Exception arg)
					{
						UnityEngine.Debug.LogError("Exception while updating graphs:\n" + arg);
					}
				}
				processingGraphUpdatesAsync.Set();
				continue;
			}
			return;
		}
		graphUpdateQueueAsync.Clear();
		processingGraphUpdatesAsync.Set();
	}

	public void FlushThreadSafeCallbacks()
	{
		if (OnThreadSafeCallback != null)
		{
			BlockUntilPathQueueBlocked();
			PerformBlockingActions();
		}
	}

	[ContextMenu("Log Profiler")]
	public void LogProfiler()
	{
	}

	[ContextMenu("Reset Profiler")]
	public void ResetProfiler()
	{
	}

	public static int CalculateThreadCount(ThreadCount count)
	{
		if (count == ThreadCount.AutomaticLowLoad || count == ThreadCount.AutomaticHighLoad)
		{
			int num = Mathf.Max(1, SystemInfo.processorCount);
			int num2 = SystemInfo.systemMemorySize;
			if (num2 <= 0)
			{
				UnityEngine.Debug.LogError("Machine reporting that is has <= 0 bytes of RAM. This is definitely not true, assuming 1 GiB");
				num2 = 1024;
			}
			if (num <= 1)
			{
				return 0;
			}
			if (num2 <= 512)
			{
				return 0;
			}
			if (count == ThreadCount.AutomaticHighLoad)
			{
				if (num2 <= 1024)
				{
					num = Math.Min(num, 2);
				}
			}
			else
			{
				num /= 2;
				num = Mathf.Max(1, num);
				if (num2 <= 1024)
				{
					num = Math.Min(num, 2);
				}
				num = Math.Min(num, 6);
			}
			return num;
		}
		return (int)count;
	}

	public void Awake()
	{
		active = this;
		if (UnityEngine.Object.FindObjectsOfType(typeof(AstarPath)).Length > 1)
		{
			UnityEngine.Debug.LogError("You should NOT have more than one AstarPath component in the scene at any time.\nThis can cause serious errors since the AstarPath component builds around a singleton pattern.");
		}
		base.useGUILayout = false;
		isEditor = UnityEngine.Application.isEditor;
		if (OnAwakeSettings != null)
		{
			OnAwakeSettings();
		}
		GraphModifier.FindAllModifiers();
		RelevantGraphSurface.FindAllGraphSurfaces();
		int num = CalculateThreadCount(threadCount);
		threads = new Thread[num];
		threadInfos = new PathThreadInfo[Math.Max(num, 1)];
		pathQueue = new ThreadControlQueue(threadInfos.Length);
		for (int i = 0; i < threadInfos.Length; i++)
		{
			threadInfos[i] = new PathThreadInfo(i, this, new PathHandler());
		}
		for (int j = 0; j < threads.Length; j++)
		{
			threads[j] = new Thread(CalculatePathsThreaded);
			threads[j].Name = "Pathfinding Thread " + j;
			threads[j].IsBackground = true;
		}
		if (num == 0)
		{
			threadEnumerator = CalculatePaths(threadInfos[0]);
		}
		else
		{
			threadEnumerator = null;
		}
		for (int k = 0; k < threads.Length; k++)
		{
			if (logPathResults == PathLog.Heavy)
			{
				UnityEngine.Debug.Log("Starting pathfinding thread " + k);
			}
			threads[k].Start(threadInfos[k]);
		}
		Thread thread = new Thread(ProcessGraphUpdatesAsync);
		thread.IsBackground = true;
		thread.Start(this);
		Initialize();
		FlushWorkItems();
		if (scanOnStartup && (!astarData.cacheStartup || astarData.data_cachedStartup == null))
		{
			Scan();
		}
	}

	public void VerifyIntegrity()
	{
		if (active != this)
		{
			throw new Exception("Singleton pattern broken. Make sure you only have one AstarPath object in the scene");
		}
		if (astarData == null)
		{
			throw new NullReferenceException("AstarData is null... Astar not set up correctly?");
		}
		if (astarData.graphs == null)
		{
			astarData.graphs = new NavGraph[0];
		}
		if (pathQueue == null && !UnityEngine.Application.isPlaying)
		{
			pathQueue = new ThreadControlQueue(0);
		}
		if (threadInfos == null && !UnityEngine.Application.isPlaying)
		{
			threadInfos = new PathThreadInfo[0];
		}
		if (!IsUsingMultithreading)
		{
		}
	}

	public void SetUpReferences()
	{
		active = this;
		if (astarData == null)
		{
			astarData = new AstarData();
		}
		if (astarData.userConnections == null)
		{
			astarData.userConnections = new UserConnection[0];
		}
		if (colorSettings == null)
		{
			colorSettings = new AstarColor();
		}
		colorSettings.OnEnable();
	}

	private void Initialize()
	{
		SetUpReferences();
		astarData.FindGraphTypes();
		astarData.Awake();
		astarData.UpdateShortcuts();
		for (int i = 0; i < astarData.graphs.Length; i++)
		{
			if (astarData.graphs[i] != null)
			{
				astarData.graphs[i].Awake();
			}
		}
	}

	public void OnDestroy()
	{
		if (logPathResults == PathLog.Heavy)
		{
			UnityEngine.Debug.Log("+++ AstarPath Component Destroyed - Cleaning Up Pathfinding Data +++");
		}
		if (active != this)
		{
			return;
		}
		pathQueue.TerminateReceivers();
		BlockUntilPathQueueBlocked();
		FlushWorkItems();
		if (logPathResults == PathLog.Heavy)
		{
			UnityEngine.Debug.Log("Processing Eventual Work Items");
		}
		graphUpdateAsyncEvent.Set();
		if (threads != null)
		{
			for (int i = 0; i < threads.Length; i++)
			{
				if (!threads[i].Join(50))
				{
					threads[i].Abort();
				}
			}
		}
		if (logPathResults == PathLog.Heavy)
		{
			UnityEngine.Debug.Log("Returning Paths");
		}
		ReturnPaths(timeSlice: false);
		pathReturnStack.PopAll();
		if (logPathResults == PathLog.Heavy)
		{
			UnityEngine.Debug.Log("Destroying Graphs");
		}
		astarData.OnDestroy();
		if (logPathResults == PathLog.Heavy)
		{
			UnityEngine.Debug.Log("Cleaning up variables");
		}
		floodStack = null;
		graphUpdateQueue = null;
		OnDrawGizmosCallback = null;
		OnAwakeSettings = null;
		OnGraphPreScan = null;
		OnGraphPostScan = null;
		OnPathPreSearch = null;
		OnPathPostSearch = null;
		OnPreScan = null;
		OnPostScan = null;
		OnLatePostScan = null;
		On65KOverflow = null;
		OnGraphsUpdated = null;
		OnSafeCallback = null;
		OnThreadSafeCallback = null;
		threads = null;
		threadInfos = null;
		PathsCompleted = 0;
		active = null;
	}

	public void FloodFill(GraphNode seed)
	{
		FloodFill(seed, lastUniqueAreaIndex + 1);
		lastUniqueAreaIndex++;
	}

	public void FloodFill(GraphNode seed, uint area)
	{
		if (area > 65535)
		{
			UnityEngine.Debug.LogError("Too high area index - The maximum area index is " + 65535u);
			return;
		}
		if (area < 0)
		{
			UnityEngine.Debug.LogError("Too low area index - The minimum area index is 0");
			return;
		}
		if (floodStack == null)
		{
			floodStack = new Stack<GraphNode>(1024);
		}
		Stack<GraphNode> stack = floodStack;
		stack.Clear();
		stack.Push(seed);
		seed.Area = area;
		while (stack.Count > 0)
		{
			stack.Pop().FloodFill(stack, area);
		}
	}

	public void FloodFill()
	{
		queuedWorkItemFloodFill = false;
		if (astarData.graphs == null)
		{
			return;
		}
		uint area = 0u;
		lastUniqueAreaIndex = 0u;
		if (floodStack == null)
		{
			floodStack = new Stack<GraphNode>(1024);
		}
		Stack<GraphNode> stack = floodStack;
		for (int i = 0; i < graphs.Length; i++)
		{
			graphs[i]?.GetNodes(delegate(GraphNode node)
			{
				node.Area = 0u;
				return true;
			});
		}
		int smallAreasDetected = 0;
		bool warnAboutAreas = false;
		List<GraphNode> smallAreaList = ListPool<GraphNode>.Claim();
		for (int j = 0; j < graphs.Length; j++)
		{
			NavGraph navGraph = graphs[j];
			if (navGraph != null)
			{
				GraphNodeDelegateCancelable del = delegate(GraphNode node)
				{
					if (node.Walkable && node.Area == 0)
					{
						area++;
						uint num = area;
						if (area > 65535)
						{
							if (smallAreaList.Count > 0)
							{
								GraphNode graphNode = smallAreaList[smallAreaList.Count - 1];
								num = graphNode.Area;
								smallAreaList.RemoveAt(smallAreaList.Count - 1);
								stack.Clear();
								stack.Push(graphNode);
								graphNode.Area = 65535u;
								while (stack.Count > 0)
								{
									stack.Pop().FloodFill(stack, 65535u);
								}
								smallAreasDetected++;
							}
							else
							{
								area--;
								num = area;
								warnAboutAreas = true;
							}
						}
						stack.Clear();
						stack.Push(node);
						int num2 = 1;
						node.Area = num;
						while (stack.Count > 0)
						{
							num2++;
							stack.Pop().FloodFill(stack, num);
						}
						if (num2 < minAreaSize)
						{
							smallAreaList.Add(node);
						}
					}
					return true;
				};
				navGraph.GetNodes(del);
			}
		}
		lastUniqueAreaIndex = area;
		if (warnAboutAreas)
		{
			UnityEngine.Debug.LogError("Too many areas - The maximum number of areas is " + 65535u + ". Try raising the A* Inspector -> Settings -> Min Area Size value. Enable the optimization ASTAR_MORE_AREAS under the Optimizations tab.");
		}
		if (smallAreasDetected > 0)
		{
			AstarLog(smallAreasDetected + " small areas were detected (fewer than " + minAreaSize + " nodes),these might have the same IDs as other areas, but it shouldn't affect pathfinding in any significant way (you might get All Nodes Searched as a reason for path failure).\nWhich areas are defined as 'small' is controlled by the 'Min Area Size' variable, it can be changed in the A* inspector-->Settings-->Min Area Size\nThe small areas will use the area id 254");
		}
		ListPool<GraphNode>.Release(smallAreaList);
	}

	public int GetNewNodeIndex()
	{
		if (nodeIndexPool.Count > 0)
		{
			return nodeIndexPool.Pop();
		}
		return nextNodeIndex++;
	}

	public void InitializeNode(GraphNode node)
	{
		if (!pathQueue.AllReceiversBlocked)
		{
			throw new Exception("Trying to initialize a node when it is not safe to initialize any nodes. Must be done during a graph update");
		}
		if (threadInfos == null)
		{
			threadInfos = new PathThreadInfo[0];
		}
		for (int i = 0; i < threadInfos.Length; i++)
		{
			threadInfos[i].runData.InitializeNode(node);
		}
	}

	public void DestroyNode(GraphNode node)
	{
		if (node.NodeIndex != -1)
		{
			nodeIndexPool.Push(node.NodeIndex);
			if (threadInfos == null)
			{
				threadInfos = new PathThreadInfo[0];
			}
			for (int i = 0; i < threadInfos.Length; i++)
			{
				threadInfos[i].runData.DestroyNode(node);
			}
		}
	}

	public void BlockUntilPathQueueBlocked()
	{
		if (pathQueue == null)
		{
			return;
		}
		pathQueue.Block();
		while (!pathQueue.AllReceiversBlocked)
		{
			if (IsUsingMultithreading)
			{
				Thread.Sleep(1);
			}
			else
			{
				threadEnumerator.MoveNext();
			}
		}
	}

	public void Scan()
	{
		ScanLoop(null);
	}

	public void ScanLoop(OnScanStatus statusCallback)
	{
		if (graphs == null)
		{
			return;
		}
		isScanning = true;
		VerifyIntegrity();
		BlockUntilPathQueueBlocked();
		if (!UnityEngine.Application.isPlaying)
		{
			GraphModifier.FindAllModifiers();
			RelevantGraphSurface.FindAllGraphSurfaces();
		}
		RelevantGraphSurface.UpdateAllPositions();
		astarData.UpdateShortcuts();
		if (statusCallback != null)
		{
			statusCallback(new Progress(0.05f, "Pre processing graphs"));
		}
		if (OnPreScan != null)
		{
			OnPreScan(this);
		}
		GraphModifier.TriggerEvent(GraphModifier.EventType.PreScan);
		DateTime utcNow = DateTime.UtcNow;
		for (int j = 0; j < graphs.Length; j++)
		{
			if (graphs[j] != null)
			{
				graphs[j].GetNodes(delegate(GraphNode node)
				{
					node.Destroy();
					return true;
				});
			}
		}
		for (int i = 0; i < graphs.Length; i++)
		{
			NavGraph navGraph = graphs[i];
			if (navGraph == null)
			{
				if (statusCallback != null)
				{
					statusCallback(new Progress(AstarMath.MapTo(0.05f, 0.7f, ((float)i + 0.5f) / (float)(graphs.Length + 1)), "Skipping graph " + (i + 1) + " of " + graphs.Length + " because it is null"));
				}
				continue;
			}
			if (OnGraphPreScan != null)
			{
				if (statusCallback != null)
				{
					statusCallback(new Progress(AstarMath.MapToRange(0.1f, 0.7f, (float)i / (float)graphs.Length), "Scanning graph " + (i + 1) + " of " + graphs.Length + " - Pre processing"));
				}
				OnGraphPreScan(navGraph);
			}
			float minp = AstarMath.MapToRange(0.1f, 0.7f, (float)i / (float)graphs.Length);
			float maxp = AstarMath.MapToRange(0.1f, 0.7f, ((float)i + 0.95f) / (float)graphs.Length);
			if (statusCallback != null)
			{
				statusCallback(new Progress(minp, "Scanning graph " + (i + 1) + " of " + graphs.Length));
			}
			OnScanStatus statusCallback2 = null;
			if (statusCallback != null)
			{
				statusCallback2 = delegate(Progress p)
				{
					p.progress = AstarMath.MapToRange(minp, maxp, p.progress);
					statusCallback(p);
				};
			}
			navGraph.ScanInternal(statusCallback2);
			navGraph.GetNodes(delegate(GraphNode node)
			{
				node.GraphIndex = (uint)i;
				return true;
			});
			if (OnGraphPostScan != null)
			{
				if (statusCallback != null)
				{
					statusCallback(new Progress(AstarMath.MapToRange(0.1f, 0.7f, ((float)i + 0.95f) / (float)graphs.Length), "Scanning graph " + (i + 1) + " of " + graphs.Length + " - Post processing"));
				}
				OnGraphPostScan(navGraph);
			}
		}
		if (statusCallback != null)
		{
			statusCallback(new Progress(0.8f, "Post processing graphs"));
		}
		if (OnPostScan != null)
		{
			OnPostScan(this);
		}
		GraphModifier.TriggerEvent(GraphModifier.EventType.PostScan);
		ApplyLinks();
		try
		{
			FlushWorkItems();
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
		isScanning = false;
		if (statusCallback != null)
		{
			statusCallback(new Progress(0.9f, "Computing areas"));
		}
		FloodFill();
		VerifyIntegrity();
		if (statusCallback != null)
		{
			statusCallback(new Progress(0.95f, "Late post processing"));
		}
		if (OnLatePostScan != null)
		{
			OnLatePostScan(this);
		}
		GraphModifier.TriggerEvent(GraphModifier.EventType.LatePostScan);
		PerformBlockingActions(force: true);
		lastScanTime = (float)(DateTime.UtcNow - utcNow).TotalSeconds;
		GC.Collect();
		AstarLog("Scanning - Process took " + (lastScanTime * 1000f).ToString("0") + " ms to complete");
	}

	public void ApplyLinks()
	{
		if (astarData.userConnections != null && astarData.userConnections.Length > 0)
		{
			UnityEngine.Debug.LogWarning("<b>Deleting all links now</b>, but saving graph data in backup variable.\nCreating replacement links using the new system, stored under the <i>Links</i> GameObject.");
			GameObject gameObject = new GameObject("Links");
			Dictionary<Int3, GameObject> dictionary = new Dictionary<Int3, GameObject>();
			for (int i = 0; i < astarData.userConnections.Length; i++)
			{
				UserConnection userConnection = astarData.userConnections[i];
				GameObject gameObject2 = (!dictionary.ContainsKey((Int3)userConnection.p1)) ? new GameObject("Link " + i) : dictionary[(Int3)userConnection.p1];
				GameObject gameObject3 = (!dictionary.ContainsKey((Int3)userConnection.p2)) ? new GameObject("Link " + i) : dictionary[(Int3)userConnection.p2];
				gameObject2.transform.parent = gameObject.transform;
				gameObject3.transform.parent = gameObject.transform;
				dictionary[(Int3)userConnection.p1] = gameObject2;
				dictionary[(Int3)userConnection.p2] = gameObject3;
				gameObject2.transform.position = userConnection.p1;
				gameObject3.transform.position = userConnection.p2;
				NodeLink nodeLink = gameObject2.AddComponent<NodeLink>();
				nodeLink.end = gameObject3.transform;
				nodeLink.deleteConnection = !userConnection.enable;
			}
			astarData.userConnections = null;
			astarData.data_backup = astarData.GetData();
			throw new NotSupportedException("<b>Links have been deprecated</b>. Please use the component <b>NodeLink</b> instead. Create two GameObjects around the points you want to link, then press <b>Cmd+Alt+L</b> ( <b>Ctrl+Alt+L</b> on windows) to link them. See <b>Menubar -> Edit -> Pathfinding</b>.");
		}
	}

	public static void WaitForPath(Pathfinding.Path p)
	{
		if (active == null)
		{
			throw new Exception("Pathfinding is not correctly initialized in this scene (yet?). AstarPath.active is null.\nDo not call this function in Awake");
		}
		if (p == null)
		{
			throw new ArgumentNullException("Path must not be null");
		}
		if (active.pathQueue.IsTerminating)
		{
			return;
		}
		if (p.GetState() == PathState.Created)
		{
			throw new Exception("The specified path has not been started yet.");
		}
		waitForPathDepth++;
		if (waitForPathDepth == 5)
		{
			UnityEngine.Debug.LogError("You are calling the WaitForPath function recursively (maybe from a path callback). Please don't do this.");
		}
		if (p.GetState() < PathState.ReturnQueue)
		{
			if (IsUsingMultithreading)
			{
				while (p.GetState() < PathState.ReturnQueue)
				{
					if (active.pathQueue.IsTerminating)
					{
						waitForPathDepth--;
						throw new Exception("Pathfinding Threads seems to have crashed.");
					}
					Thread.Sleep(1);
					active.PerformBlockingActions();
				}
			}
			else
			{
				while (p.GetState() < PathState.ReturnQueue)
				{
					if (active.pathQueue.IsEmpty && p.GetState() != PathState.Processing)
					{
						waitForPathDepth--;
						throw new Exception("Critical error. Path Queue is empty but the path state is '" + p.GetState() + "'");
					}
					threadEnumerator.MoveNext();
					active.PerformBlockingActions();
				}
			}
		}
		active.ReturnPaths(timeSlice: false);
		waitForPathDepth--;
	}

	public static void RegisterSafeUpdate(OnVoidDelegate callback, bool threadSafe)
	{
		if (callback != null && UnityEngine.Application.isPlaying)
		{
			if (active.pathQueue.AllReceiversBlocked)
			{
				active.pathQueue.Lock();
				try
				{
					if (active.pathQueue.AllReceiversBlocked)
					{
						callback();
						return;
					}
				}
				finally
				{
					active.pathQueue.Unlock();
				}
			}
			lock (safeUpdateLock)
			{
				if (threadSafe)
				{
					OnThreadSafeCallback = (OnVoidDelegate)Delegate.Combine(OnThreadSafeCallback, callback);
				}
				else
				{
					OnSafeCallback = (OnVoidDelegate)Delegate.Combine(OnSafeCallback, callback);
				}
			}
			active.pathQueue.Block();
		}
	}

	private static void InterruptPathfinding()
	{
		active.pathQueue.Block();
	}

	public static void StartPath(Pathfinding.Path p, bool pushToFront = false)
	{
		if (active == null)
		{
			UnityEngine.Debug.LogError("There is no AstarPath object in the scene");
			return;
		}
		if (p.GetState() != 0)
		{
			throw new Exception("The path has an invalid state. Expected " + PathState.Created + " found " + p.GetState() + "\nMake sure you are not requesting the same path twice");
		}
		if (active.pathQueue.IsTerminating)
		{
			p.Error();
			p.LogError("No new paths are accepted");
			return;
		}
		if (active.graphs == null || active.graphs.Length == 0)
		{
			UnityEngine.Debug.LogError("There are no graphs in the scene");
			p.Error();
			p.LogError("There are no graphs in the scene");
			UnityEngine.Debug.LogError(p.errorLog);
			return;
		}
		p.Claim(active);
		p.AdvanceState(PathState.PathQueue);
		if (pushToFront)
		{
			active.pathQueue.PushFront(p);
		}
		else
		{
			active.pathQueue.Push(p);
		}
	}

	public void OnApplicationQuit()
	{
		if (logPathResults == PathLog.Heavy)
		{
			UnityEngine.Debug.Log("+++ Application Quitting - Cleaning Up +++");
		}
		OnDestroy();
		if (threads == null)
		{
			return;
		}
		for (int i = 0; i < threads.Length; i++)
		{
			if (threads[i] != null && threads[i].IsAlive)
			{
				threads[i].Abort();
			}
		}
	}

	public void ReturnPaths(bool timeSlice)
	{
		Pathfinding.Path next = pathReturnStack.PopAll();
		if (pathReturnPop == null)
		{
			pathReturnPop = next;
		}
		else
		{
			Pathfinding.Path next2 = pathReturnPop;
			while (next2.next != null)
			{
				next2 = next2.next;
			}
			next2.next = next;
		}
		long num = (!timeSlice) ? 0 : (DateTime.UtcNow.Ticks + 10000);
		int num2 = 0;
		while (pathReturnPop != null)
		{
			Pathfinding.Path path = pathReturnPop;
			pathReturnPop = pathReturnPop.next;
			path.next = null;
			path.ReturnPath();
			path.AdvanceState(PathState.Returned);
			path.ReleaseSilent(this);
			num2++;
			if (num2 > 5 && timeSlice)
			{
				num2 = 0;
				if (DateTime.UtcNow.Ticks >= num)
				{
					break;
				}
			}
		}
	}

	private static void CalculatePathsThreaded(object _threadInfo)
	{
		//Discarded unreachable code: IL_0029, IL_0204
		PathThreadInfo pathThreadInfo;
		try
		{
			pathThreadInfo = (PathThreadInfo)_threadInfo;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("Arguments to pathfinding threads must be of type ThreadStartInfo\n" + ex);
			throw new ArgumentException("Argument must be of type ThreadStartInfo", ex);
		}
		AstarPath astar = pathThreadInfo.astar;
		try
		{
			PathHandler runData = pathThreadInfo.runData;
			if (runData.nodes == null)
			{
				throw new NullReferenceException("NodeRuns must be assigned to the threadInfo.runData.nodes field before threads are started\nthreadInfo is an argument to the thread functions");
			}
			long num = (long)(astar.maxFrameTime * 10000f);
			long num2 = DateTime.UtcNow.Ticks + num;
			while (true)
			{
				Pathfinding.Path path = astar.pathQueue.Pop();
				num = (long)(astar.maxFrameTime * 10000f);
				path.PrepareBase(runData);
				path.AdvanceState(PathState.Processing);
				if (OnPathPreSearch != null)
				{
					OnPathPreSearch(path);
				}
				long ticks = DateTime.UtcNow.Ticks;
				long num3 = 0L;
				path.Prepare();
				if (!path.IsDone())
				{
					astar.debugPath = path;
					path.Initialize();
					while (!path.IsDone())
					{
						path.CalculateStep(num2);
						path.searchIterations++;
						if (path.IsDone())
						{
							break;
						}
						num3 += DateTime.UtcNow.Ticks - ticks;
						Thread.Sleep(0);
						ticks = DateTime.UtcNow.Ticks;
						num2 = ticks + num;
						if (astar.pathQueue.IsTerminating)
						{
							path.Error();
						}
					}
					num3 += DateTime.UtcNow.Ticks - ticks;
					path.duration = (float)num3 * 0.0001f;
				}
				path.Cleanup();
				astar.LogPathResults(path);
				if (OnPathPostSearch != null)
				{
					OnPathPostSearch(path);
				}
				pathReturnStack.Push(path);
				path.AdvanceState(PathState.ReturnQueue);
				if (DateTime.UtcNow.Ticks > num2)
				{
					Thread.Sleep(1);
					num2 = DateTime.UtcNow.Ticks + num;
				}
			}
		}
		catch (Exception ex2)
		{
			if (ex2 is ThreadAbortException || ex2 is ThreadControlQueue.QueueTerminationException)
			{
				if (astar.logPathResults == PathLog.Heavy)
				{
					UnityEngine.Debug.LogWarning("Shutting down pathfinding thread #" + pathThreadInfo.threadIndex + " with Thread.Abort call");
				}
				return;
			}
			UnityEngine.Debug.LogException(ex2);
			UnityEngine.Debug.LogError("Unhandled exception during pathfinding. Terminating.");
			astar.pathQueue.TerminateReceivers();
		}
		UnityEngine.Debug.LogError("Error : This part should never be reached.");
		astar.pathQueue.ReceiverTerminated();
	}

	private static IEnumerator CalculatePaths(object _threadInfo)
	{
		PathThreadInfo threadInfo;
		try
		{
			threadInfo = (PathThreadInfo)_threadInfo;
		}
		catch (Exception ex)
		{
			Exception e = ex;
			UnityEngine.Debug.LogError("Arguments to pathfinding threads must be of type ThreadStartInfo\n" + e);
			throw new ArgumentException("Argument must be of type ThreadStartInfo", e);
		}
		int numPaths = 0;
		PathHandler runData = threadInfo.runData;
		AstarPath astar = threadInfo.astar;
		if (runData.nodes == null)
		{
			throw new NullReferenceException("NodeRuns must be assigned to the threadInfo.runData.nodes field before threads are started\nthreadInfo is an argument to the thread functions");
		}
		long maxTicks2 = (long)(active.maxFrameTime * 10000f);
		long targetTick = DateTime.UtcNow.Ticks + maxTicks2;
		while (true)
		{
			Pathfinding.Path p = null;
			bool blockedBefore = false;
			while (p == null)
			{
				try
				{
					p = astar.pathQueue.PopNoBlock(blockedBefore);
					if (p == null)
					{
						blockedBefore = true;
					}
				}
				catch (ThreadControlQueue.QueueTerminationException)
				{
					yield break;
				}
				if (p == null)
				{
					yield return null;
				}
			}
			maxTicks2 = (long)(active.maxFrameTime * 10000f);
			p.PrepareBase(runData);
			p.AdvanceState(PathState.Processing);
			if (OnPathPreSearch != null)
			{
				OnPathPreSearch(p);
			}
			numPaths++;
			long startTicks = DateTime.UtcNow.Ticks;
			long totalTicks2 = 0L;
			p.Prepare();
			if (!p.IsDone())
			{
				active.debugPath = p;
				p.Initialize();
				while (!p.IsDone())
				{
					p.CalculateStep(targetTick);
					p.searchIterations++;
					if (p.IsDone())
					{
						break;
					}
					totalTicks2 += DateTime.UtcNow.Ticks - startTicks;
					yield return null;
					startTicks = DateTime.UtcNow.Ticks;
					if (astar.pathQueue.IsTerminating)
					{
						p.Error();
					}
					targetTick = DateTime.UtcNow.Ticks + maxTicks2;
				}
				totalTicks2 += DateTime.UtcNow.Ticks - startTicks;
				p.duration = (float)totalTicks2 * 0.0001f;
			}
			p.Cleanup();
			active.LogPathResults(p);
			if (OnPathPostSearch != null)
			{
				OnPathPostSearch(p);
			}
			pathReturnStack.Push(p);
			p.AdvanceState(PathState.ReturnQueue);
			if (DateTime.UtcNow.Ticks > targetTick)
			{
				yield return null;
				targetTick = DateTime.UtcNow.Ticks + maxTicks2;
				numPaths = 0;
			}
		}
	}

	public NNInfo GetNearest(Vector3 position)
	{
		return GetNearest(position, NNConstraint.None);
	}

	public NNInfo GetNearest(Vector3 position, NNConstraint constraint)
	{
		return GetNearest(position, constraint, null);
	}

	public NNInfo GetNearest(Vector3 position, NNConstraint constraint, GraphNode hint)
	{
		if (graphs == null)
		{
			return default(NNInfo);
		}
		float num = float.PositiveInfinity;
		NNInfo result = default(NNInfo);
		int num2 = -1;
		for (int i = 0; i < graphs.Length; i++)
		{
			NavGraph navGraph = graphs[i];
			if (navGraph == null || !constraint.SuitableGraph(i, navGraph))
			{
				continue;
			}
			NNInfo nNInfo = (!fullGetNearestSearch) ? navGraph.GetNearest(position, constraint) : navGraph.GetNearestForce(position, constraint);
			GraphNode node = nNInfo.node;
			if (node != null)
			{
				float magnitude = (nNInfo.clampedPosition - position).magnitude;
				if (prioritizeGraphs && magnitude < prioritizeGraphsLimit)
				{
					num = magnitude;
					result = nNInfo;
					num2 = i;
					break;
				}
				if (magnitude < num)
				{
					num = magnitude;
					result = nNInfo;
					num2 = i;
				}
			}
		}
		if (num2 == -1)
		{
			return result;
		}
		if (result.constrainedNode != null)
		{
			result.node = result.constrainedNode;
			result.clampedPosition = result.constClampedPosition;
		}
		if (!fullGetNearestSearch && result.node != null && !constraint.Suitable(result.node))
		{
			NNInfo nearestForce = graphs[num2].GetNearestForce(position, constraint);
			if (nearestForce.node != null)
			{
				result = nearestForce;
			}
		}
		if (!constraint.Suitable(result.node) || (constraint.constrainDistance && (result.clampedPosition - position).sqrMagnitude > maxNearestNodeDistanceSqr))
		{
			return default(NNInfo);
		}
		return result;
	}

	public GraphNode GetNearest(Ray ray)
	{
		if (graphs == null)
		{
			return null;
		}
		float minDist = float.PositiveInfinity;
		GraphNode nearestNode = null;
		Vector3 lineDirection = ray.direction;
		Vector3 lineOrigin = ray.origin;
		for (int i = 0; i < graphs.Length; i++)
		{
			NavGraph navGraph = graphs[i];
			navGraph.GetNodes(delegate(GraphNode node)
			{
				Vector3 vector = (Vector3)node.position;
				Vector3 a = lineOrigin + Vector3.Dot(vector - lineOrigin, lineDirection) * lineDirection;
				float num = Mathf.Abs(a.x - vector.x);
				num *= num;
				if (num > minDist)
				{
					return true;
				}
				num = Mathf.Abs(a.z - vector.z);
				num *= num;
				if (num > minDist)
				{
					return true;
				}
				float sqrMagnitude = (a - vector).sqrMagnitude;
				if (sqrMagnitude < minDist)
				{
					minDist = sqrMagnitude;
					nearestNode = node;
				}
				return true;
			});
		}
		return nearestNode;
	}
}
namespace Pathfinding
{
	[AddComponentMenu("Pathfinding/GraphUpdateScene")]
	public class GraphUpdateScene : GraphModifier
	{
		public Vector3[] points;

		private Vector3[] convexPoints;

		[HideInInspector]
		public bool convex = true;

		[HideInInspector]
		public float minBoundsHeight = 1f;

		[HideInInspector]
		public int penaltyDelta;

		[HideInInspector]
		public bool modifyWalkability;

		[HideInInspector]
		public bool setWalkability;

		[HideInInspector]
		public bool applyOnStart = true;

		[HideInInspector]
		public bool applyOnScan = true;

		[HideInInspector]
		public bool useWorldSpace;

		[HideInInspector]
		public bool updatePhysics;

		[HideInInspector]
		public bool resetPenaltyOnPhysics = true;

		[HideInInspector]
		public bool updateErosion = true;

		[HideInInspector]
		public bool lockToY;

		[HideInInspector]
		public float lockToYValue;

		[HideInInspector]
		public bool modifyTag;

		[HideInInspector]
		public int setTag;

		private int setTagInvert;

		private bool firstApplied;

		public void Start()
		{
			if (!firstApplied && applyOnStart)
			{
				Apply();
			}
		}

		public override void OnPostScan()
		{
			if (applyOnScan)
			{
				Apply();
			}
		}

		public virtual void InvertSettings()
		{
			setWalkability = !setWalkability;
			penaltyDelta = -penaltyDelta;
			if (setTagInvert == 0)
			{
				setTagInvert = setTag;
				setTag = 0;
			}
			else
			{
				setTag = setTagInvert;
				setTagInvert = 0;
			}
		}

		public void RecalcConvex()
		{
			if (convex)
			{
				convexPoints = Polygon.ConvexHull(points);
			}
			else
			{
				convexPoints = null;
			}
		}

		public void ToggleUseWorldSpace()
		{
			useWorldSpace = !useWorldSpace;
			if (points != null)
			{
				convexPoints = null;
				Matrix4x4 matrix4x = (!useWorldSpace) ? base.transform.worldToLocalMatrix : base.transform.localToWorldMatrix;
				for (int i = 0; i < points.Length; i++)
				{
					points[i] = matrix4x.MultiplyPoint3x4(points[i]);
				}
			}
		}

		public void LockToY()
		{
			if (points != null)
			{
				for (int i = 0; i < points.Length; i++)
				{
					points[i].y = lockToYValue;
				}
			}
		}

		public void Apply(AstarPath active)
		{
			if (applyOnScan)
			{
				Apply();
			}
		}

		public Bounds GetBounds()
		{
			Bounds result;
			if (points == null || points.Length == 0)
			{
				if (GetComponent<Collider>() != null)
				{
					result = GetComponent<Collider>().bounds;
				}
				else
				{
					if (!(GetComponent<Renderer>() != null))
					{
						return new Bounds(Vector3.zero, Vector3.zero);
					}
					result = GetComponent<Renderer>().bounds;
				}
			}
			else
			{
				Matrix4x4 matrix4x = Matrix4x4.identity;
				if (!useWorldSpace)
				{
					matrix4x = base.transform.localToWorldMatrix;
				}
				Vector3 vector = matrix4x.MultiplyPoint3x4(points[0]);
				Vector3 vector2 = matrix4x.MultiplyPoint3x4(points[0]);
				for (int i = 0; i < points.Length; i++)
				{
					Vector3 rhs = matrix4x.MultiplyPoint3x4(points[i]);
					vector = Vector3.Min(vector, rhs);
					vector2 = Vector3.Max(vector2, rhs);
				}
				result = new Bounds((vector + vector2) * 0.5f, vector2 - vector);
			}
			Vector3 size = result.size;
			if (size.y < minBoundsHeight)
			{
				Vector3 size2 = result.size;
				float x = size2.x;
				float y = minBoundsHeight;
				Vector3 size3 = result.size;
				result.size = new Vector3(x, y, size3.z);
			}
			return result;
		}

		public void Apply()
		{
			if (AstarPath.active == null)
			{
				UnityEngine.Debug.LogError("There is no AstarPath object in the scene");
				return;
			}
			GraphUpdateObject graphUpdateObject;
			if (points == null || points.Length == 0)
			{
				Bounds bounds;
				if (GetComponent<Collider>() != null)
				{
					bounds = GetComponent<Collider>().bounds;
				}
				else
				{
					if (!(GetComponent<Renderer>() != null))
					{
						UnityEngine.Debug.LogWarning("Cannot apply GraphUpdateScene, no points defined and no renderer or collider attached");
						return;
					}
					bounds = GetComponent<Renderer>().bounds;
				}
				Vector3 size = bounds.size;
				if (size.y < minBoundsHeight)
				{
					Vector3 size2 = bounds.size;
					float x = size2.x;
					float y = minBoundsHeight;
					Vector3 size3 = bounds.size;
					bounds.size = new Vector3(x, y, size3.z);
				}
				graphUpdateObject = new GraphUpdateObject(bounds);
			}
			else
			{
				GraphUpdateShape graphUpdateShape = new GraphUpdateShape();
				graphUpdateShape.convex = convex;
				Vector3[] array = points;
				if (!useWorldSpace)
				{
					array = new Vector3[points.Length];
					Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = localToWorldMatrix.MultiplyPoint3x4(points[i]);
					}
				}
				graphUpdateShape.points = array;
				Bounds bounds2 = graphUpdateShape.GetBounds();
				Vector3 size4 = bounds2.size;
				if (size4.y < minBoundsHeight)
				{
					Vector3 size5 = bounds2.size;
					float x2 = size5.x;
					float y2 = minBoundsHeight;
					Vector3 size6 = bounds2.size;
					bounds2.size = new Vector3(x2, y2, size6.z);
				}
				graphUpdateObject = new GraphUpdateObject(bounds2);
				graphUpdateObject.shape = graphUpdateShape;
			}
			firstApplied = true;
			graphUpdateObject.modifyWalkability = modifyWalkability;
			graphUpdateObject.setWalkability = setWalkability;
			graphUpdateObject.addPenalty = penaltyDelta;
			graphUpdateObject.updatePhysics = updatePhysics;
			graphUpdateObject.updateErosion = updateErosion;
			graphUpdateObject.resetPenaltyOnPhysics = resetPenaltyOnPhysics;
			graphUpdateObject.modifyTag = modifyTag;
			graphUpdateObject.setTag = setTag;
			AstarPath.active.UpdateGraphs(graphUpdateObject);
		}

		public void OnDrawGizmos()
		{
			OnDrawGizmos(selected: false);
		}

		public void OnDrawGizmosSelected()
		{
			OnDrawGizmos(selected: true);
		}

		public void OnDrawGizmos(bool selected)
		{
			Color color = (!selected) ? new Color(227f / 255f, 61f / 255f, 22f / 255f, 0.9f) : new Color(227f / 255f, 61f / 255f, 22f / 255f, 1f);
			if (selected)
			{
				Gizmos.color = Color.Lerp(color, new Color(1f, 1f, 1f, 0.2f), 0.9f);
				Bounds bounds = GetBounds();
				Gizmos.DrawCube(bounds.center, bounds.size);
				Gizmos.DrawWireCube(bounds.center, bounds.size);
			}
			if (points == null)
			{
				return;
			}
			if (convex)
			{
				color.a *= 0.5f;
			}
			Gizmos.color = color;
			Matrix4x4 matrix4x = (!useWorldSpace) ? base.transform.localToWorldMatrix : Matrix4x4.identity;
			if (convex)
			{
				color.r -= 0.1f;
				color.g -= 0.2f;
				color.b -= 0.1f;
				Gizmos.color = color;
			}
			if (selected || !convex)
			{
				for (int i = 0; i < points.Length; i++)
				{
					Gizmos.DrawLine(matrix4x.MultiplyPoint3x4(points[i]), matrix4x.MultiplyPoint3x4(points[(i + 1) % points.Length]));
				}
			}
			if (convex)
			{
				if (convexPoints == null)
				{
					RecalcConvex();
				}
				Gizmos.color = ((!selected) ? new Color(227f / 255f, 61f / 255f, 22f / 255f, 0.9f) : new Color(227f / 255f, 61f / 255f, 22f / 255f, 1f));
				for (int j = 0; j < convexPoints.Length; j++)
				{
					Gizmos.DrawLine(matrix4x.MultiplyPoint3x4(convexPoints[j]), matrix4x.MultiplyPoint3x4(convexPoints[(j + 1) % convexPoints.Length]));
				}
			}
		}
	}
	public class GraphUpdateShape
	{
		private Vector3[] _points;

		private Vector3[] _convexPoints;

		private bool _convex;

		public Vector3[] points
		{
			get
			{
				return _points;
			}
			set
			{
				_points = value;
				if (convex)
				{
					CalculateConvexHull();
				}
			}
		}

		public bool convex
		{
			get
			{
				return _convex;
			}
			set
			{
				if (_convex != value && value)
				{
					_convex = value;
					CalculateConvexHull();
				}
				else
				{
					_convex = value;
				}
			}
		}

		private void CalculateConvexHull()
		{
			if (points == null)
			{
				_convexPoints = null;
				return;
			}
			_convexPoints = Polygon.ConvexHull(points);
			for (int i = 0; i < _convexPoints.Length; i++)
			{
				UnityEngine.Debug.DrawLine(_convexPoints[i], _convexPoints[(i + 1) % _convexPoints.Length], Color.green);
			}
		}

		public Bounds GetBounds()
		{
			if (points == null || points.Length == 0)
			{
				return default(Bounds);
			}
			Vector3 vector = points[0];
			Vector3 vector2 = points[0];
			for (int i = 0; i < points.Length; i++)
			{
				vector = Vector3.Min(vector, points[i]);
				vector2 = Vector3.Max(vector2, points[i]);
			}
			return new Bounds((vector + vector2) * 0.5f, vector2 - vector);
		}

		public bool Contains(GraphNode node)
		{
			Vector3 p = (Vector3)node.position;
			if (convex)
			{
				if (_convexPoints == null)
				{
					return false;
				}
				int i = 0;
				int num = _convexPoints.Length - 1;
				for (; i < _convexPoints.Length; i++)
				{
					if (Polygon.Left(_convexPoints[i], _convexPoints[num], p))
					{
						return false;
					}
					num = i;
				}
				return true;
			}
			if (_points == null)
			{
				return false;
			}
			return Polygon.ContainsPoint(_points, p);
		}

		public bool Contains(Vector3 point)
		{
			if (convex)
			{
				if (_convexPoints == null)
				{
					return false;
				}
				int i = 0;
				int num = _convexPoints.Length - 1;
				for (; i < _convexPoints.Length; i++)
				{
					if (Polygon.Left(_convexPoints[i], _convexPoints[num], point))
					{
						return false;
					}
					num = i;
				}
				return true;
			}
			if (_points == null)
			{
				return false;
			}
			return Polygon.ContainsPoint(_points, point);
		}
	}
	public class AnimationLink : NodeLink2
	{
		[Serializable]
		public class LinkClip
		{
			public AnimationClip clip;

			public Vector3 velocity;

			public int loopCount = 1;

			public string name => (!(clip != null)) ? string.Empty : clip.name;
		}

		public string clip;

		public float animSpeed = 1f;

		public bool reverseAnim = true;

		public GameObject referenceMesh;

		public LinkClip[] sequence;

		public string boneRoot = "bn_COG_Root";

		private static Transform SearchRec(Transform tr, string name)
		{
			int childCount = tr.childCount;
			for (int i = 0; i < childCount; i++)
			{
				Transform child = tr.GetChild(i);
				if (child.name == name)
				{
					return child;
				}
				Transform transform = SearchRec(child, name);
				if (transform != null)
				{
					return transform;
				}
			}
			return null;
		}

		public void CalculateOffsets(List<Vector3> trace, out Vector3 endPosition)
		{
			endPosition = base.transform.position;
			if (referenceMesh == null)
			{
				return;
			}
			GameObject gameObject = UnityEngine.Object.Instantiate(referenceMesh, base.transform.position, base.transform.rotation) as GameObject;
			gameObject.hideFlags = HideFlags.HideAndDontSave;
			Transform transform = SearchRec(gameObject.transform, boneRoot);
			if (transform == null)
			{
				throw new Exception("Could not find root transform");
			}
			Animation animation = gameObject.GetComponent<Animation>();
			if (animation == null)
			{
				animation = gameObject.AddComponent<Animation>();
			}
			for (int i = 0; i < sequence.Length; i++)
			{
				animation.AddClip(sequence[i].clip, sequence[i].clip.name);
			}
			Vector3 a = Vector3.zero;
			Vector3 position = base.transform.position;
			Vector3 b = Vector3.zero;
			for (int j = 0; j < sequence.Length; j++)
			{
				LinkClip linkClip = sequence[j];
				if (linkClip == null)
				{
					endPosition = position;
					return;
				}
				animation[linkClip.clip.name].enabled = true;
				animation[linkClip.clip.name].weight = 1f;
				for (int k = 0; k < linkClip.loopCount; k++)
				{
					animation[linkClip.clip.name].normalizedTime = 0f;
					animation.Sample();
					Vector3 vector = transform.position - base.transform.position;
					if (j > 0)
					{
						position += a - vector;
					}
					else
					{
						b = vector;
					}
					for (int l = 0; l <= 20; l++)
					{
						float num = (float)l / 20f;
						animation[linkClip.clip.name].normalizedTime = num;
						animation.Sample();
						Vector3 item = position + (transform.position - base.transform.position) + linkClip.velocity * num * linkClip.clip.length;
						trace.Add(item);
					}
					position += linkClip.velocity * 1f * linkClip.clip.length;
					animation[linkClip.clip.name].normalizedTime = 1f;
					animation.Sample();
					Vector3 vector2 = transform.position - base.transform.position;
					a = vector2;
				}
				animation[linkClip.clip.name].enabled = false;
				animation[linkClip.clip.name].weight = 0f;
			}
			position += a - b;
			UnityEngine.Object.DestroyImmediate(gameObject);
			endPosition = position;
		}

		public override void OnDrawGizmosSelected()
		{
			base.OnDrawGizmosSelected();
			List<Vector3> list = ListPool<Vector3>.Claim();
			Vector3 endPosition = Vector3.zero;
			CalculateOffsets(list, out endPosition);
			Gizmos.color = Color.blue;
			for (int i = 0; i < list.Count - 1; i++)
			{
				Gizmos.DrawLine(list[i], list[i + 1]);
			}
		}
	}
}
[AddComponentMenu("Pathfinding/Debugger")]
[ExecuteInEditMode]
public class AstarDebugger : MonoBehaviour
{
	private struct GraphPoint
	{
		public float fps;

		public float memory;

		public bool collectEvent;
	}

	private struct PathTypeDebug
	{
		private string name;

		private Func<int> getSize;

		private Func<int> getTotalCreated;

		public PathTypeDebug(string name, Func<int> getSize, Func<int> getTotalCreated)
		{
			this.name = name;
			this.getSize = getSize;
			this.getTotalCreated = getTotalCreated;
		}

		public void Print(StringBuilder text)
		{
			int num = getTotalCreated();
			if (num > 0)
			{
				text.Append("\n").Append(("  " + name).PadRight(25)).Append(getSize())
					.Append("/")
					.Append(num);
			}
		}
	}

	public int yOffset = 5;

	public bool show = true;

	public bool showInEditor;

	public bool showFPS;

	public bool showPathProfile;

	public bool showMemProfile;

	public bool showGraph;

	public int graphBufferSize = 200;

	public Font font;

	public int fontSize = 12;

	private StringBuilder text = new StringBuilder();

	private string cachedText;

	private float lastUpdate = -999f;

	private GraphPoint[] graph;

	private float delayedDeltaTime = 1f;

	private float lastCollect;

	private float lastCollectNum;

	private float delta;

	private float lastDeltaTime;

	private int allocRate;

	private int lastAllocMemory;

	private float lastAllocSet = -9999f;

	private int allocMem;

	private int collectAlloc;

	private int peakAlloc;

	private int fpsDropCounterSize = 200;

	private float[] fpsDrops;

	private Rect boxRect;

	private GUIStyle style;

	private Camera cam;

	private LineRenderer lineRend;

	private float graphWidth = 100f;

	private float graphHeight = 100f;

	private float graphOffset = 50f;

	private int maxVecPool;

	private int maxNodePool;

	private PathTypeDebug[] debugTypes = new PathTypeDebug[1]
	{
		new PathTypeDebug("ABPath", PathPool<ABPath>.GetSize, PathPool<ABPath>.GetTotalCreated)
	};

	public void Start()
	{
		base.useGUILayout = false;
		fpsDrops = new float[fpsDropCounterSize];
		if (GetComponent<Camera>() != null)
		{
			cam = GetComponent<Camera>();
		}
		else
		{
			cam = Camera.main;
		}
		graph = new GraphPoint[graphBufferSize];
		for (int i = 0; i < fpsDrops.Length; i++)
		{
			fpsDrops[i] = 1f / Time.deltaTime;
		}
	}

	public void Update()
	{
		if (!show || (!UnityEngine.Application.isPlaying && !showInEditor))
		{
			return;
		}
		int num = GC.CollectionCount(0);
		if (lastCollectNum != (float)num)
		{
			lastCollectNum = num;
			delta = Time.realtimeSinceStartup - lastCollect;
			lastCollect = Time.realtimeSinceStartup;
			lastDeltaTime = Time.deltaTime;
			collectAlloc = allocMem;
		}
		allocMem = (int)GC.GetTotalMemory(forceFullCollection: false);
		bool flag = allocMem < peakAlloc;
		peakAlloc = (flag ? peakAlloc : allocMem);
		if (Time.realtimeSinceStartup - lastAllocSet > 0.3f || !UnityEngine.Application.isPlaying)
		{
			int num2 = allocMem - lastAllocMemory;
			lastAllocMemory = allocMem;
			lastAllocSet = Time.realtimeSinceStartup;
			delayedDeltaTime = Time.deltaTime;
			if (num2 >= 0)
			{
				allocRate = num2;
			}
		}
		if (UnityEngine.Application.isPlaying)
		{
			fpsDrops[Time.frameCount % fpsDrops.Length] = ((Time.deltaTime == 0f) ? float.PositiveInfinity : (1f / Time.deltaTime));
			int num3 = Time.frameCount % graph.Length;
			graph[num3].fps = ((!(Time.deltaTime < Mathf.Epsilon)) ? (1f / Time.deltaTime) : 0f);
			graph[num3].collectEvent = flag;
			graph[num3].memory = allocMem;
		}
		if (!UnityEngine.Application.isPlaying || !(cam != null) || !showGraph)
		{
			return;
		}
		graphWidth = (float)cam.pixelWidth * 0.8f;
		float num4 = float.PositiveInfinity;
		float num5 = 0f;
		float num6 = float.PositiveInfinity;
		float num7 = 0f;
		for (int i = 0; i < graph.Length; i++)
		{
			num4 = Mathf.Min(graph[i].memory, num4);
			num5 = Mathf.Max(graph[i].memory, num5);
			num6 = Mathf.Min(graph[i].fps, num6);
			num7 = Mathf.Max(graph[i].fps, num7);
		}
		int num8 = Time.frameCount % graph.Length;
		Matrix4x4 m = Matrix4x4.TRS(new Vector3(((float)cam.pixelWidth - graphWidth) / 2f, graphOffset, 1f), Quaternion.identity, new Vector3(graphWidth, graphHeight, 1f));
		for (int j = 0; j < graph.Length - 1; j++)
		{
			if (j != num8)
			{
				DrawGraphLine(j, m, (float)j / (float)graph.Length, (float)(j + 1) / (float)graph.Length, AstarMath.MapTo(num4, num5, graph[j].memory), AstarMath.MapTo(num4, num5, graph[j + 1].memory), Color.blue);
				DrawGraphLine(j, m, (float)j / (float)graph.Length, (float)(j + 1) / (float)graph.Length, AstarMath.MapTo(num6, num7, graph[j].fps), AstarMath.MapTo(num6, num7, graph[j + 1].fps), Color.green);
			}
		}
	}

	public void DrawGraphLine(int index, Matrix4x4 m, float x1, float x2, float y1, float y2, Color col)
	{
		UnityEngine.Debug.DrawLine(cam.ScreenToWorldPoint(m.MultiplyPoint3x4(new Vector3(x1, y1))), cam.ScreenToWorldPoint(m.MultiplyPoint3x4(new Vector3(x2, y2))), col);
	}

	public void Cross(Vector3 p)
	{
		p = cam.cameraToWorldMatrix.MultiplyPoint(p);
		UnityEngine.Debug.DrawLine(p - Vector3.up * 0.2f, p + Vector3.up * 0.2f, Color.red);
		UnityEngine.Debug.DrawLine(p - Vector3.right * 0.2f, p + Vector3.right * 0.2f, Color.red);
	}

	public void OnGUI()
	{
		if (!show || (!UnityEngine.Application.isPlaying && !showInEditor))
		{
			return;
		}
		if (style == null)
		{
			style = new GUIStyle();
			style.normal.textColor = Color.white;
			style.padding = new RectOffset(5, 5, 5, 5);
		}
		if (Time.realtimeSinceStartup - lastUpdate > 0.5f || cachedText == null || !UnityEngine.Application.isPlaying)
		{
			lastUpdate = Time.realtimeSinceStartup;
			boxRect = new Rect(5f, yOffset, 310f, 40f);
			text.Length = 0;
			text.AppendLine("A* Pathfinding Project Debugger");
			text.Append("A* Version: ").Append(AstarPath.Version.ToString());
			if (showMemProfile)
			{
				boxRect.height += 200f;
				text.AppendLine();
				text.AppendLine();
				text.Append("Currently allocated".PadRight(25));
				text.Append(((float)allocMem / 1000000f).ToString("0.0 MB"));
				text.AppendLine();
				text.Append("Peak allocated".PadRight(25));
				text.Append(((float)peakAlloc / 1000000f).ToString("0.0 MB")).AppendLine();
				text.Append("Last collect peak".PadRight(25));
				text.Append(((float)collectAlloc / 1000000f).ToString("0.0 MB")).AppendLine();
				text.Append("Allocation rate".PadRight(25));
				text.Append(((float)allocRate / 1000000f).ToString("0.0 MB")).AppendLine();
				text.Append("Collection frequency".PadRight(25));
				text.Append(delta.ToString("0.00"));
				text.Append("s\n");
				text.Append("Last collect fps".PadRight(25));
				text.Append((1f / lastDeltaTime).ToString("0.0 fps"));
				text.Append(" (");
				text.Append(lastDeltaTime.ToString("0.000 s"));
				text.Append(")");
			}
			if (showFPS)
			{
				text.AppendLine();
				text.AppendLine();
				text.Append("FPS".PadRight(25)).Append((1f / delayedDeltaTime).ToString("0.0 fps"));
				float num = float.PositiveInfinity;
				for (int i = 0; i < fpsDrops.Length; i++)
				{
					if (fpsDrops[i] < num)
					{
						num = fpsDrops[i];
					}
				}
				text.AppendLine();
				text.Append(("Lowest fps (last " + fpsDrops.Length + ")").PadRight(25)).Append(num.ToString("0.0"));
			}
			if (showPathProfile)
			{
				AstarPath active = AstarPath.active;
				text.AppendLine();
				if (active == null)
				{
					text.Append("\nNo AstarPath Object In The Scene");
				}
				else
				{
					if (ListPool<Vector3>.GetSize() > maxVecPool)
					{
						maxVecPool = ListPool<Vector3>.GetSize();
					}
					if (ListPool<GraphNode>.GetSize() > maxNodePool)
					{
						maxNodePool = ListPool<GraphNode>.GetSize();
					}
					text.Append("\nPool Sizes (size/total created)");
					for (int j = 0; j < debugTypes.Length; j++)
					{
						debugTypes[j].Print(text);
					}
				}
			}
			cachedText = text.ToString();
		}
		if (font != null)
		{
			style.font = font;
			style.fontSize = fontSize;
		}
		boxRect.height = style.CalcHeight(new GUIContent(cachedText), boxRect.width);
		GUI.Box(boxRect, string.Empty);
		GUI.Label(boxRect, cachedText, style);
		if (showGraph)
		{
			float num2 = float.PositiveInfinity;
			float num3 = 0f;
			float num4 = float.PositiveInfinity;
			float num5 = 0f;
			for (int k = 0; k < graph.Length; k++)
			{
				num2 = Mathf.Min(graph[k].memory, num2);
				num3 = Mathf.Max(graph[k].memory, num3);
				num4 = Mathf.Min(graph[k].fps, num4);
				num5 = Mathf.Max(graph[k].fps, num5);
			}
			GUI.color = Color.blue;
			float num6 = Mathf.RoundToInt(num3 / 100000f);
			GUI.Label(new Rect(5f, (float)Screen.height - AstarMath.MapTo(num2, num3, 0f + graphOffset, graphHeight + graphOffset, num6 * 1000f * 100f) - 10f, 100f, 20f), (num6 / 10f).ToString("0.0 MB"));
			num6 = Mathf.Round(num2 / 100000f);
			GUI.Label(new Rect(5f, (float)Screen.height - AstarMath.MapTo(num2, num3, 0f + graphOffset, graphHeight + graphOffset, num6 * 1000f * 100f) - 10f, 100f, 20f), (num6 / 10f).ToString("0.0 MB"));
			GUI.color = Color.green;
			num6 = Mathf.Round(num5);
			GUI.Label(new Rect(55f, (float)Screen.height - AstarMath.MapTo(num4, num5, 0f + graphOffset, graphHeight + graphOffset, num6) - 10f, 100f, 20f), num6.ToString("0 FPS"));
			num6 = Mathf.Round(num4);
			GUI.Label(new Rect(55f, (float)Screen.height - AstarMath.MapTo(num4, num5, 0f + graphOffset, graphHeight + graphOffset, num6) - 10f, 100f, 20f), num6.ToString("0 FPS"));
		}
	}
}
namespace Pathfinding
{
	public class AstarEnumFlagAttribute : PropertyAttribute
	{
		public string enumName;

		public AstarEnumFlagAttribute()
		{
		}

		public AstarEnumFlagAttribute(string name)
		{
			enumName = name;
		}
	}
	public class BinaryHeapM
	{
		private struct Tuple
		{
			public uint F;

			public PathNode node;

			public Tuple(uint F, PathNode node)
			{
				this.F = F;
				this.node = node;
			}
		}

		public const int D = 4;

		public int numberOfItems;

		public float growthFactor = 2f;

		private Tuple[] binaryHeap;

		public BinaryHeapM(int numberOfElements)
		{
			binaryHeap = new Tuple[numberOfElements];
			numberOfItems = 0;
		}

		public void Clear()
		{
			numberOfItems = 0;
		}

		public PathNode GetNode(int i)
		{
			return binaryHeap[i].node;
		}

		public void Add(PathNode node)
		{
			if (node == null)
			{
				throw new ArgumentNullException("Sending null node to BinaryHeap");
			}
			if (numberOfItems == binaryHeap.Length)
			{
				int num = Math.Max(binaryHeap.Length + 4, (int)Math.Round((float)binaryHeap.Length * growthFactor));
				if (num > 262144)
				{
					throw new Exception("Binary Heap Size really large (2^18). A heap size this large is probably the cause of pathfinding running in an infinite loop. \nRemove this check (in BinaryHeap.cs) if you are sure that it is not caused by a bug");
				}
				Tuple[] array = new Tuple[num];
				for (int i = 0; i < binaryHeap.Length; i++)
				{
					array[i] = binaryHeap[i];
				}
				binaryHeap = array;
			}
			Tuple tuple = new Tuple(node.F, node);
			binaryHeap[numberOfItems] = tuple;
			int num2 = numberOfItems;
			uint f = node.F;
			while (num2 != 0)
			{
				int num3 = (num2 - 1) / 4;
				if (f < binaryHeap[num3].F)
				{
					binaryHeap[num2] = binaryHeap[num3];
					binaryHeap[num3] = tuple;
					num2 = num3;
					continue;
				}
				break;
			}
			numberOfItems++;
		}

		public PathNode Remove()
		{
			numberOfItems--;
			PathNode node = binaryHeap[0].node;
			binaryHeap[0] = binaryHeap[numberOfItems];
			int num = 0;
			int num2 = 0;
			while (true)
			{
				num2 = num;
				uint f = binaryHeap[num].F;
				int num3 = num2 * 4 + 1;
				if (num3 <= numberOfItems && binaryHeap[num3].F < f)
				{
					f = binaryHeap[num3].F;
					num = num3;
				}
				if (num3 + 1 <= numberOfItems && binaryHeap[num3 + 1].F < f)
				{
					f = binaryHeap[num3 + 1].F;
					num = num3 + 1;
				}
				if (num3 + 2 <= numberOfItems && binaryHeap[num3 + 2].F < f)
				{
					f = binaryHeap[num3 + 2].F;
					num = num3 + 2;
				}
				if (num3 + 3 <= numberOfItems && binaryHeap[num3 + 3].F < f)
				{
					f = binaryHeap[num3 + 3].F;
					num = num3 + 3;
				}
				if (num2 != num)
				{
					Tuple tuple = binaryHeap[num2];
					binaryHeap[num2] = binaryHeap[num];
					binaryHeap[num] = tuple;
					continue;
				}
				break;
			}
			return node;
		}

		private void Validate()
		{
			int num = 1;
			int num2;
			while (true)
			{
				if (num < numberOfItems)
				{
					num2 = (num - 1) / 4;
					if (binaryHeap[num2].F > binaryHeap[num].F)
					{
						break;
					}
					num++;
					continue;
				}
				return;
			}
			throw new Exception("Invalid state at " + num + ":" + num2 + " ( " + binaryHeap[num2].F + " > " + binaryHeap[num].F + " ) ");
		}

		public void Rebuild()
		{
			for (int i = 2; i < numberOfItems; i++)
			{
				int num = i;
				Tuple tuple = binaryHeap[i];
				uint f = tuple.F;
				while (num != 1)
				{
					int num2 = num / 4;
					if (f < binaryHeap[num2].F)
					{
						binaryHeap[num] = binaryHeap[num2];
						binaryHeap[num2] = tuple;
						num = num2;
						continue;
					}
					break;
				}
			}
		}
	}
	[JsonOptIn]
	public class GraphEditorBase
	{
		public NavGraph target;
	}
	public abstract class GraphModifier : MonoBehaviour
	{
		public enum EventType
		{
			PostScan = 1,
			PreScan = 2,
			LatePostScan = 4,
			PreUpdate = 8,
			PostUpdate = 0x10,
			PostCacheLoad = 0x20
		}

		private static GraphModifier root;

		private GraphModifier prev;

		private GraphModifier next;

		public static void FindAllModifiers()
		{
			GraphModifier[] array = UnityEngine.Object.FindObjectsOfType(typeof(GraphModifier)) as GraphModifier[];
			for (int i = 0; i < array.Length; i++)
			{
				array[i].OnEnable();
			}
		}

		public static void TriggerEvent(EventType type)
		{
			if (!UnityEngine.Application.isPlaying)
			{
				FindAllModifiers();
			}
			GraphModifier graphModifier = root;
			switch (type)
			{
			default:
				return;
			case EventType.PreScan:
				while (graphModifier != null)
				{
					graphModifier.OnPreScan();
					graphModifier = graphModifier.next;
				}
				return;
			case EventType.PostScan:
				while (graphModifier != null)
				{
					graphModifier.OnPostScan();
					graphModifier = graphModifier.next;
				}
				return;
			case EventType.LatePostScan:
				while (graphModifier != null)
				{
					graphModifier.OnLatePostScan();
					graphModifier = graphModifier.next;
				}
				return;
			case EventType.PreUpdate:
				while (graphModifier != null)
				{
					graphModifier.OnGraphsPreUpdate();
					graphModifier = graphModifier.next;
				}
				return;
			case EventType.PostUpdate:
				while (graphModifier != null)
				{
					graphModifier.OnGraphsPostUpdate();
					graphModifier = graphModifier.next;
				}
				return;
			case EventType.PostCacheLoad:
				break;
			}
			while (graphModifier != null)
			{
				graphModifier.OnPostCacheLoad();
				graphModifier = graphModifier.next;
			}
		}

		protected virtual void OnEnable()
		{
			OnDisable();
			if (root == null)
			{
				root = this;
				return;
			}
			next = root;
			root.prev = this;
			root = this;
		}

		protected virtual void OnDisable()
		{
			if (root == this)
			{
				root = next;
				if (root != null)
				{
					root.prev = null;
				}
			}
			else
			{
				if (prev != null)
				{
					prev.next = next;
				}
				if (next != null)
				{
					next.prev = prev;
				}
			}
			prev = null;
			next = null;
		}

		public virtual void OnPostScan()
		{
		}

		public virtual void OnPreScan()
		{
		}

		public virtual void OnLatePostScan()
		{
		}

		public virtual void OnPostCacheLoad()
		{
		}

		public virtual void OnGraphsPreUpdate()
		{
		}

		public virtual void OnGraphsPostUpdate()
		{
		}
	}
	public struct Int3
	{
		public const int Precision = 1000;

		public const float FloatPrecision = 1000f;

		public const float PrecisionFactor = 0.001f;

		public int x;

		public int y;

		public int z;

		private static Int3 _zero = new Int3(0, 0, 0);

		public static Int3 zero => _zero;

		public int this[int i]
		{
			get
			{
				int result;
				switch (i)
				{
				case 0:
					result = x;
					break;
				case 1:
					result = y;
					break;
				default:
					result = z;
					break;
				}
				return result;
			}
			set
			{
				switch (i)
				{
				case 0:
					x = value;
					break;
				case 1:
					y = value;
					break;
				default:
					z = value;
					break;
				}
			}
		}

		public float magnitude
		{
			get
			{
				double num = x;
				double num2 = y;
				double num3 = z;
				return (float)Math.Sqrt(num * num + num2 * num2 + num3 * num3);
			}
		}

		public int costMagnitude => (int)Math.Round(magnitude);

		public float worldMagnitude
		{
			get
			{
				double num = x;
				double num2 = y;
				double num3 = z;
				return (float)Math.Sqrt(num * num + num2 * num2 + num3 * num3) * 0.001f;
			}
		}

		public float sqrMagnitude
		{
			get
			{
				double num = x;
				double num2 = y;
				double num3 = z;
				return (float)(num * num + num2 * num2 + num3 * num3);
			}
		}

		public long sqrMagnitudeLong
		{
			get
			{
				long num = x;
				long num2 = y;
				long num3 = z;
				return num * num + num2 * num2 + num3 * num3;
			}
		}

		public int unsafeSqrMagnitude => x * x + y * y + z * z;

		[Obsolete("Same implementation as .magnitude")]
		public float safeMagnitude
		{
			get
			{
				double num = x;
				double num2 = y;
				double num3 = z;
				return (float)Math.Sqrt(num * num + num2 * num2 + num3 * num3);
			}
		}

		[Obsolete(".sqrMagnitude is now per default safe (.unsafeSqrMagnitude can be used for unsafe operations)")]
		public float safeSqrMagnitude
		{
			get
			{
				float num = (float)x * 0.001f;
				float num2 = (float)y * 0.001f;
				float num3 = (float)z * 0.001f;
				return num * num + num2 * num2 + num3 * num3;
			}
		}

		public Int3(Vector3 position)
		{
			x = (int)Math.Round(position.x * 1000f);
			y = (int)Math.Round(position.y * 1000f);
			z = (int)Math.Round(position.z * 1000f);
		}

		public Int3(int _x, int _y, int _z)
		{
			x = _x;
			y = _y;
			z = _z;
		}

		public Int3 DivBy2()
		{
			x >>= 1;
			y >>= 1;
			z >>= 1;
			return this;
		}

		public static float Angle(Int3 lhs, Int3 rhs)
		{
			double num = (double)Dot(lhs, rhs) / ((double)lhs.magnitude * (double)rhs.magnitude);
			num = ((num < -1.0) ? (-1.0) : ((!(num > 1.0)) ? num : 1.0));
			return (float)Math.Acos(num);
		}

		public static int Dot(Int3 lhs, Int3 rhs)
		{
			return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;
		}

		public static long DotLong(Int3 lhs, Int3 rhs)
		{
			return (long)lhs.x * (long)rhs.x + (long)lhs.y * (long)rhs.y + (long)lhs.z * (long)rhs.z;
		}

		public Int3 Normal2D()
		{
			return new Int3(z, y, -x);
		}

		public Int3 NormalizeTo(int newMagn)
		{
			float magnitude = this.magnitude;
			if (magnitude == 0f)
			{
				return this;
			}
			x *= newMagn;
			y *= newMagn;
			z *= newMagn;
			x = (int)Math.Round((float)x / magnitude);
			y = (int)Math.Round((float)y / magnitude);
			z = (int)Math.Round((float)z / magnitude);
			return this;
		}

		public override string ToString()
		{
			return "( " + x + ", " + y + ", " + z + ")";
		}

		public override bool Equals(object o)
		{
			if (o == null)
			{
				return false;
			}
			Int3 @int = (Int3)o;
			return x == @int.x && y == @int.y && z == @int.z;
		}

		public override int GetHashCode()
		{
			return (x * 73856093) ^ (y * 19349663) ^ (z * 83492791);
		}

		public static bool operator ==(Int3 lhs, Int3 rhs)
		{
			return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z;
		}

		public static bool operator !=(Int3 lhs, Int3 rhs)
		{
			return lhs.x != rhs.x || lhs.y != rhs.y || lhs.z != rhs.z;
		}

		public static explicit operator Int3(Vector3 ob)
		{
			return new Int3((int)Math.Round(ob.x * 1000f), (int)Math.Round(ob.y * 1000f), (int)Math.Round(ob.z * 1000f));
		}

		public static explicit operator Vector3(Int3 ob)
		{
			return new Vector3((float)ob.x * 0.001f, (float)ob.y * 0.001f, (float)ob.z * 0.001f);
		}

		public static Int3 operator -(Int3 lhs, Int3 rhs)
		{
			lhs.x -= rhs.x;
			lhs.y -= rhs.y;
			lhs.z -= rhs.z;
			return lhs;
		}

		public static Int3 operator -(Int3 lhs)
		{
			lhs.x = -lhs.x;
			lhs.y = -lhs.y;
			lhs.z = -lhs.z;
			return lhs;
		}

		public static Int3 operator +(Int3 lhs, Int3 rhs)
		{
			lhs.x += rhs.x;
			lhs.y += rhs.y;
			lhs.z += rhs.z;
			return lhs;
		}

		public static Int3 operator *(Int3 lhs, int rhs)
		{
			lhs.x *= rhs;
			lhs.y *= rhs;
			lhs.z *= rhs;
			return lhs;
		}

		public static Int3 operator *(Int3 lhs, float rhs)
		{
			lhs.x = (int)Math.Round((float)lhs.x * rhs);
			lhs.y = (int)Math.Round((float)lhs.y * rhs);
			lhs.z = (int)Math.Round((float)lhs.z * rhs);
			return lhs;
		}

		public static Int3 operator *(Int3 lhs, double rhs)
		{
			lhs.x = (int)Math.Round((double)lhs.x * rhs);
			lhs.y = (int)Math.Round((double)lhs.y * rhs);
			lhs.z = (int)Math.Round((double)lhs.z * rhs);
			return lhs;
		}

		public static Int3 operator *(Int3 lhs, Vector3 rhs)
		{
			lhs.x = (int)Math.Round((float)lhs.x * rhs.x);
			lhs.y = (int)Math.Round((float)lhs.y * rhs.y);
			lhs.z = (int)Math.Round((float)lhs.z * rhs.z);
			return lhs;
		}

		public static Int3 operator /(Int3 lhs, float rhs)
		{
			lhs.x = (int)Math.Round((float)lhs.x / rhs);
			lhs.y = (int)Math.Round((float)lhs.y / rhs);
			lhs.z = (int)Math.Round((float)lhs.z / rhs);
			return lhs;
		}

		public static implicit operator string(Int3 ob)
		{
			return ob.ToString();
		}
	}
	public struct Int2
	{
		public int x;

		public int y;

		private static readonly int[] Rotations = new int[16]
		{
			1,
			0,
			0,
			1,
			0,
			1,
			-1,
			0,
			-1,
			0,
			0,
			-1,
			0,
			-1,
			1,
			0
		};

		public int sqrMagnitude => x * x + y * y;

		public long sqrMagnitudeLong => (long)x * (long)x + (long)y * (long)y;

		public Int2(int x, int y)
		{
			this.x = x;
			this.y = y;
		}

		public static int Dot(Int2 a, Int2 b)
		{
			return a.x * b.x + a.y * b.y;
		}

		public static long DotLong(Int2 a, Int2 b)
		{
			return (long)a.x * (long)b.x + (long)a.y * (long)b.y;
		}

		public override bool Equals(object o)
		{
			if (o == null)
			{
				return false;
			}
			Int2 @int = (Int2)o;
			return x == @int.x && y == @int.y;
		}

		public override int GetHashCode()
		{
			return x * 49157 + y * 98317;
		}

		public static Int2 Rotate(Int2 v, int r)
		{
			r %= 4;
			return new Int2(v.x * Rotations[r * 4] + v.y * Rotations[r * 4 + 1], v.x * Rotations[r * 4 + 2] + v.y * Rotations[r * 4 + 3]);
		}

		public static Int2 Min(Int2 a, Int2 b)
		{
			return new Int2(Math.Min(a.x, b.x), Math.Min(a.y, b.y));
		}

		public static Int2 Max(Int2 a, Int2 b)
		{
			return new Int2(Math.Max(a.x, b.x), Math.Max(a.y, b.y));
		}

		public static Int2 FromInt3XZ(Int3 o)
		{
			return new Int2(o.x, o.z);
		}

		public static Int3 ToInt3XZ(Int2 o)
		{
			return new Int3(o.x, 0, o.y);
		}

		public override string ToString()
		{
			return "(" + x + ", " + y + ")";
		}

		public static Int2 operator +(Int2 a, Int2 b)
		{
			return new Int2(a.x + b.x, a.y + b.y);
		}

		public static Int2 operator -(Int2 a, Int2 b)
		{
			return new Int2(a.x - b.x, a.y - b.y);
		}

		public static bool operator ==(Int2 a, Int2 b)
		{
			return a.x == b.x && a.y == b.y;
		}

		public static bool operator !=(Int2 a, Int2 b)
		{
			return a.x != b.x || a.y != b.y;
		}
	}
}
namespace Pathfinding.Util
{
	public static class ListPool<T>
	{
		private const int MaxCapacitySearchLength = 8;

		private static List<List<T>> pool;

		static ListPool()
		{
			pool = new List<List<T>>();
		}

		public static List<T> Claim()
		{
			//Discarded unreachable code: IL_005b
			lock (pool)
			{
				if (pool.Count > 0)
				{
					List<T> result = pool[pool.Count - 1];
					pool.RemoveAt(pool.Count - 1);
					return result;
				}
				return new List<T>();
			}
		}

		public static List<T> Claim(int capacity)
		{
			//Discarded unreachable code: IL_00f2
			lock (pool)
			{
				if (pool.Count > 0)
				{
					List<T> list = null;
					int i;
					for (i = 0; i < pool.Count && i < 8; i++)
					{
						list = pool[pool.Count - 1 - i];
						if (list.Capacity >= capacity)
						{
							pool.RemoveAt(pool.Count - 1 - i);
							return list;
						}
					}
					if (list == null)
					{
						list = new List<T>(capacity);
					}
					else
					{
						list.Capacity = capacity;
						pool[pool.Count - i] = pool[pool.Count - 1];
						pool.RemoveAt(pool.Count - 1);
					}
					return list;
				}
				return new List<T>(capacity);
			}
		}

		public static void Warmup(int count, int size)
		{
			lock (pool)
			{
				List<T>[] array = new List<T>[count];
				for (int i = 0; i < count; i++)
				{
					array[i] = Claim(size);
				}
				for (int j = 0; j < count; j++)
				{
					Release(array[j]);
				}
			}
		}

		public static void Release(List<T> list)
		{
			list.Clear();
			lock (pool)
			{
				for (int i = 0; i < pool.Count; i++)
				{
					if (pool[i] == list)
					{
						throw new InvalidOperationException("The List is released even though it is in the pool");
					}
				}
				pool.Add(list);
			}
		}

		public static void Clear()
		{
			lock (pool)
			{
				pool.Clear();
			}
		}

		public static int GetSize()
		{
			return pool.Count;
		}
	}
}
namespace Pathfinding
{
	[AddComponentMenu("Pathfinding/Link")]
	public class NodeLink : GraphModifier
	{
		public Transform end;

		public float costFactor = 1f;

		public bool oneWay;

		public bool deleteConnection;

		public Transform Start => base.transform;

		public Transform End => end;

		public override void OnPostScan()
		{
			if (AstarPath.active.isScanning)
			{
				InternalOnPostScan();
			}
			else
			{
				AstarPath.active.AddWorkItem(new AstarPath.AstarWorkItem(delegate
				{
					InternalOnPostScan();
					return true;
				}));
			}
		}

		public void InternalOnPostScan()
		{
			Apply();
		}

		public override void OnGraphsPostUpdate()
		{
			if (!AstarPath.active.isScanning)
			{
				AstarPath.active.AddWorkItem(new AstarPath.AstarWorkItem(delegate
				{
					InternalOnPostScan();
					return true;
				}));
			}
		}

		public virtual void Apply()
		{
			if (Start == null || End == null || AstarPath.active == null)
			{
				return;
			}
			NNInfo nearest = AstarPath.active.GetNearest(Start.position);
			GraphNode node = nearest.node;
			NNInfo nearest2 = AstarPath.active.GetNearest(End.position);
			GraphNode node2 = nearest2.node;
			if (node == null || node2 == null)
			{
				return;
			}
			if (deleteConnection)
			{
				node.RemoveConnection(node2);
				if (!oneWay)
				{
					node2.RemoveConnection(node);
				}
				return;
			}
			uint cost = (uint)Math.Round((float)(node.position - node2.position).costMagnitude * costFactor);
			node.AddConnection(node2, cost);
			if (!oneWay)
			{
				node2.AddConnection(node, cost);
			}
		}

		public void OnDrawGizmos()
		{
			if (!(Start == null) && !(End == null))
			{
				Vector3 position = Start.position;
				Vector3 position2 = End.position;
				Gizmos.color = ((!deleteConnection) ? Color.green : Color.red);
				DrawGizmoBezier(position, position2);
			}
		}

		private void DrawGizmoBezier(Vector3 p1, Vector3 p2)
		{
			Vector3 vector = p2 - p1;
			if (!(vector == Vector3.zero))
			{
				Vector3 rhs = Vector3.Cross(Vector3.up, vector);
				Vector3 normalized = Vector3.Cross(vector, rhs).normalized;
				normalized *= vector.magnitude * 0.1f;
				Vector3 p3 = p1 + normalized;
				Vector3 p4 = p2 + normalized;
				Vector3 from = p1;
				for (int i = 1; i <= 20; i++)
				{
					float t = (float)i / 20f;
					Vector3 vector2 = AstarMath.CubicBezier(p1, p3, p4, p2, t);
					Gizmos.DrawLine(from, vector2);
					from = vector2;
				}
			}
		}
	}
	[AddComponentMenu("Pathfinding/Link2")]
	public class NodeLink2 : GraphModifier
	{
		protected static Dictionary<GraphNode, NodeLink2> reference = new Dictionary<GraphNode, NodeLink2>();

		public Transform end;

		public float costFactor = 1f;

		public bool oneWay;

		private PointNode startNode;

		private PointNode endNode;

		private MeshNode connectedNode1;

		private MeshNode connectedNode2;

		private Vector3 clamped1;

		private Vector3 clamped2;

		private bool postScanCalled;

		private static readonly Color GizmosColor = new Color(206f / 255f, 8f / 15f, 16f / 85f, 0.5f);

		private static readonly Color GizmosColorSelected = new Color(47f / 51f, 41f / 85f, 32f / 255f, 1f);

		public Transform StartTransform => base.transform;

		public Transform EndTransform => end;

		public GraphNode StartNode => startNode;

		public GraphNode EndNode => endNode;

		public static NodeLink2 GetNodeLink(GraphNode node)
		{
			reference.TryGetValue(node, out NodeLink2 value);
			return value;
		}

		public override void OnPostScan()
		{
			if (AstarPath.active.isScanning)
			{
				InternalOnPostScan();
			}
			else
			{
				AstarPath.active.AddWorkItem(new AstarPath.AstarWorkItem(delegate
				{
					InternalOnPostScan();
					return true;
				}));
			}
		}

		public void InternalOnPostScan()
		{
			if (AstarPath.active.astarData.pointGraph == null)
			{
				AstarPath.active.astarData.AddGraph(new PointGraph());
			}
			if (startNode != null && reference.TryGetValue(startNode, out NodeLink2 value) && value == this)
			{
				reference.Remove(startNode);
			}
			if (endNode != null && reference.TryGetValue(endNode, out NodeLink2 value2) && value2 == this)
			{
				reference.Remove(endNode);
			}
			startNode = AstarPath.active.astarData.pointGraph.AddNode((Int3)StartTransform.position);
			endNode = AstarPath.active.astarData.pointGraph.AddNode((Int3)EndTransform.position);
			connectedNode1 = null;
			connectedNode2 = null;
			if (startNode == null || endNode == null)
			{
				startNode = null;
				endNode = null;
				return;
			}
			postScanCalled = true;
			reference[startNode] = this;
			reference[endNode] = this;
			Apply(forceNewCheck: true);
		}

		public override void OnGraphsPostUpdate()
		{
			if (!AstarPath.active.isScanning)
			{
				if (connectedNode1 != null && connectedNode1.Destroyed)
				{
					connectedNode1 = null;
				}
				if (connectedNode2 != null && connectedNode2.Destroyed)
				{
					connectedNode2 = null;
				}
				if (!postScanCalled)
				{
					OnPostScan();
				}
				else
				{
					Apply(forceNewCheck: false);
				}
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			if (AstarPath.active != null && AstarPath.active.astarData != null && AstarPath.active.astarData.pointGraph != null)
			{
				OnGraphsPostUpdate();
			}
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			postScanCalled = false;
			if (startNode != null && reference.TryGetValue(startNode, out NodeLink2 value) && value == this)
			{
				reference.Remove(startNode);
			}
			if (endNode != null && reference.TryGetValue(endNode, out NodeLink2 value2) && value2 == this)
			{
				reference.Remove(endNode);
			}
			if (startNode != null && endNode != null)
			{
				startNode.RemoveConnection(endNode);
				endNode.RemoveConnection(startNode);
				if (connectedNode1 != null && connectedNode2 != null)
				{
					startNode.RemoveConnection(connectedNode1);
					connectedNode1.RemoveConnection(startNode);
					endNode.RemoveConnection(connectedNode2);
					connectedNode2.RemoveConnection(endNode);
				}
			}
		}

		private void RemoveConnections(GraphNode node)
		{
			node.ClearConnections(alsoReverse: true);
		}

		[ContextMenu("Recalculate neighbours")]
		private void ContextApplyForce()
		{
			if (UnityEngine.Application.isPlaying)
			{
				Apply(forceNewCheck: true);
				if (AstarPath.active != null)
				{
					AstarPath.active.FloodFill();
				}
			}
		}

		public void Apply(bool forceNewCheck)
		{
			NNConstraint none = NNConstraint.None;
			int graphIndex = (int)startNode.GraphIndex;
			none.graphMask = ~(1 << graphIndex);
			startNode.SetPosition((Int3)StartTransform.position);
			endNode.SetPosition((Int3)EndTransform.position);
			RemoveConnections(startNode);
			RemoveConnections(endNode);
			uint cost = (uint)Mathf.RoundToInt((float)((Int3)(StartTransform.position - EndTransform.position)).costMagnitude * costFactor);
			startNode.AddConnection(endNode, cost);
			endNode.AddConnection(startNode, cost);
			if (connectedNode1 == null || forceNewCheck)
			{
				NNInfo nearest = AstarPath.active.GetNearest(StartTransform.position, none);
				connectedNode1 = (nearest.node as MeshNode);
				clamped1 = nearest.clampedPosition;
			}
			if (connectedNode2 == null || forceNewCheck)
			{
				NNInfo nearest2 = AstarPath.active.GetNearest(EndTransform.position, none);
				connectedNode2 = (nearest2.node as MeshNode);
				clamped2 = nearest2.clampedPosition;
			}
			if (connectedNode2 != null && connectedNode1 != null)
			{
				connectedNode1.AddConnection(startNode, (uint)Mathf.RoundToInt((float)((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));
				connectedNode2.AddConnection(endNode, (uint)Mathf.RoundToInt((float)((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));
				startNode.AddConnection(connectedNode1, (uint)Mathf.RoundToInt((float)((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));
				endNode.AddConnection(connectedNode2, (uint)Mathf.RoundToInt((float)((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));
			}
		}

		private void DrawCircle(Vector3 o, float r, int detail, Color col)
		{
			Vector3 from = new Vector3(Mathf.Cos(0f) * r, 0f, Mathf.Sin(0f) * r) + o;
			Gizmos.color = col;
			for (int i = 0; i <= detail; i++)
			{
				float f = (float)i * (float)Math.PI * 2f / (float)detail;
				Vector3 vector = new Vector3(Mathf.Cos(f) * r, 0f, Mathf.Sin(f) * r) + o;
				Gizmos.DrawLine(from, vector);
				from = vector;
			}
		}

		private void DrawGizmoBezier(Vector3 p1, Vector3 p2)
		{
			Vector3 vector = p2 - p1;
			if (!(vector == Vector3.zero))
			{
				Vector3 rhs = Vector3.Cross(Vector3.up, vector);
				Vector3 normalized = Vector3.Cross(vector, rhs).normalized;
				normalized *= vector.magnitude * 0.1f;
				Vector3 p3 = p1 + normalized;
				Vector3 p4 = p2 + normalized;
				Vector3 from = p1;
				for (int i = 1; i <= 20; i++)
				{
					float t = (float)i / 20f;
					Vector3 vector2 = AstarMath.CubicBezier(p1, p3, p4, p2, t);
					Gizmos.DrawLine(from, vector2);
					from = vector2;
				}
			}
		}

		public virtual void OnDrawGizmosSelected()
		{
			OnDrawGizmos(selected: true);
		}

		public void OnDrawGizmos()
		{
			OnDrawGizmos(selected: false);
		}

		public void OnDrawGizmos(bool selected)
		{
			Color color = (!selected) ? GizmosColor : GizmosColorSelected;
			if (StartTransform != null)
			{
				DrawCircle(StartTransform.position, 0.4f, 10, color);
			}
			if (EndTransform != null)
			{
				DrawCircle(EndTransform.position, 0.4f, 10, color);
			}
			if (StartTransform != null && EndTransform != null)
			{
				Gizmos.color = color;
				DrawGizmoBezier(StartTransform.position, EndTransform.position);
				if (selected)
				{
					Vector3 normalized = Vector3.Cross(Vector3.up, EndTransform.position - StartTransform.position).normalized;
					DrawGizmoBezier(StartTransform.position + normalized * 0.1f, EndTransform.position + normalized * 0.1f);
					DrawGizmoBezier(StartTransform.position - normalized * 0.1f, EndTransform.position - normalized * 0.1f);
				}
			}
		}
	}
	public class NodeLink3Node : PointNode
	{
		public NodeLink3 link;

		public Vector3 portalA;

		public Vector3 portalB;

		public NodeLink3Node(AstarPath active)
			: base(active)
		{
		}

		public override bool GetPortal(GraphNode other, List<Vector3> left, List<Vector3> right, bool backwards)
		{
			if (connections.Length < 2)
			{
				return false;
			}
			if (connections.Length != 2)
			{
				throw new Exception("Invalid NodeLink3Node. Expected 2 connections, found " + connections.Length);
			}
			if (left != null)
			{
				left.Add(portalA);
				right.Add(portalB);
			}
			return true;
		}

		public GraphNode GetOther(GraphNode a)
		{
			if (connections.Length < 2)
			{
				return null;
			}
			if (connections.Length != 2)
			{
				throw new Exception("Invalid NodeLink3Node. Expected 2 connections, found " + connections.Length);
			}
			return (a != connections[0]) ? (connections[0] as NodeLink3Node).GetOtherInternal(this) : (connections[1] as NodeLink3Node).GetOtherInternal(this);
		}

		private GraphNode GetOtherInternal(GraphNode a)
		{
			if (connections.Length < 2)
			{
				return null;
			}
			return (a != connections[0]) ? connections[0] : connections[1];
		}
	}
	[AddComponentMenu("Pathfinding/Link3")]
	public class NodeLink3 : GraphModifier
	{
		protected static Dictionary<GraphNode, NodeLink3> reference = new Dictionary<GraphNode, NodeLink3>();

		public Transform end;

		public float costFactor = 1f;

		public bool oneWay;

		private NodeLink3Node startNode;

		private NodeLink3Node endNode;

		private MeshNode connectedNode1;

		private MeshNode connectedNode2;

		private Vector3 clamped1;

		private Vector3 clamped2;

		private bool postScanCalled;

		private static readonly Color GizmosColor = new Color(206f / 255f, 8f / 15f, 16f / 85f, 0.5f);

		private static readonly Color GizmosColorSelected = new Color(47f / 51f, 41f / 85f, 32f / 255f, 1f);

		public Transform StartTransform => base.transform;

		public Transform EndTransform => end;

		public GraphNode StartNode => startNode;

		public GraphNode EndNode => endNode;

		public static NodeLink3 GetNodeLink(GraphNode node)
		{
			reference.TryGetValue(node, out NodeLink3 value);
			return value;
		}

		public override void OnPostScan()
		{
			if (AstarPath.active.isScanning)
			{
				InternalOnPostScan();
			}
			else
			{
				AstarPath.active.AddWorkItem(new AstarPath.AstarWorkItem(delegate
				{
					InternalOnPostScan();
					return true;
				}));
			}
		}

		public void InternalOnPostScan()
		{
			if (AstarPath.active.astarData.pointGraph == null)
			{
				AstarPath.active.astarData.AddGraph(new PointGraph());
			}
			startNode = AstarPath.active.astarData.pointGraph.AddNode(new NodeLink3Node(AstarPath.active), (Int3)StartTransform.position);
			startNode.link = this;
			endNode = AstarPath.active.astarData.pointGraph.AddNode(new NodeLink3Node(AstarPath.active), (Int3)EndTransform.position);
			endNode.link = this;
			connectedNode1 = null;
			connectedNode2 = null;
			if (startNode == null || endNode == null)
			{
				startNode = null;
				endNode = null;
				return;
			}
			postScanCalled = true;
			reference[startNode] = this;
			reference[endNode] = this;
			Apply(forceNewCheck: true);
		}

		public override void OnGraphsPostUpdate()
		{
			if (!AstarPath.active.isScanning)
			{
				if (connectedNode1 != null && connectedNode1.Destroyed)
				{
					connectedNode1 = null;
				}
				if (connectedNode2 != null && connectedNode2.Destroyed)
				{
					connectedNode2 = null;
				}
				if (!postScanCalled)
				{
					OnPostScan();
				}
				else
				{
					Apply(forceNewCheck: false);
				}
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			if (AstarPath.active != null && AstarPath.active.astarData != null && AstarPath.active.astarData.pointGraph != null)
			{
				OnGraphsPostUpdate();
			}
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			postScanCalled = false;
			if (startNode != null)
			{
				reference.Remove(startNode);
			}
			if (endNode != null)
			{
				reference.Remove(endNode);
			}
			if (startNode != null && endNode != null)
			{
				startNode.RemoveConnection(endNode);
				endNode.RemoveConnection(startNode);
				if (connectedNode1 != null && connectedNode2 != null)
				{
					startNode.RemoveConnection(connectedNode1);
					connectedNode1.RemoveConnection(startNode);
					endNode.RemoveConnection(connectedNode2);
					connectedNode2.RemoveConnection(endNode);
				}
			}
		}

		private void RemoveConnections(GraphNode node)
		{
			node.ClearConnections(alsoReverse: true);
		}

		[ContextMenu("Recalculate neighbours")]
		private void ContextApplyForce()
		{
			if (UnityEngine.Application.isPlaying)
			{
				Apply(forceNewCheck: true);
				if (AstarPath.active != null)
				{
					AstarPath.active.FloodFill();
				}
			}
		}

		public void Apply(bool forceNewCheck)
		{
			NNConstraint none = NNConstraint.None;
			none.distanceXZ = true;
			int graphIndex = (int)startNode.GraphIndex;
			none.graphMask = ~(1 << graphIndex);
			bool flag = true;
			NNInfo nearest = AstarPath.active.GetNearest(StartTransform.position, none);
			flag &= (nearest.node == connectedNode1 && nearest.node != null);
			connectedNode1 = (nearest.node as MeshNode);
			clamped1 = nearest.clampedPosition;
			if (connectedNode1 != null)
			{
				UnityEngine.Debug.DrawRay((Vector3)connectedNode1.position, Vector3.up * 5f, Color.red);
			}
			NNInfo nearest2 = AstarPath.active.GetNearest(EndTransform.position, none);
			flag &= (nearest2.node == connectedNode2 && nearest2.node != null);
			connectedNode2 = (nearest2.node as MeshNode);
			clamped2 = nearest2.clampedPosition;
			if (connectedNode2 != null)
			{
				UnityEngine.Debug.DrawRay((Vector3)connectedNode2.position, Vector3.up * 5f, Color.cyan);
			}
			if (connectedNode2 == null || connectedNode1 == null)
			{
				return;
			}
			startNode.SetPosition((Int3)StartTransform.position);
			endNode.SetPosition((Int3)EndTransform.position);
			if (flag && !forceNewCheck)
			{
				return;
			}
			RemoveConnections(startNode);
			RemoveConnections(endNode);
			uint cost = (uint)Mathf.RoundToInt((float)((Int3)(StartTransform.position - EndTransform.position)).costMagnitude * costFactor);
			startNode.AddConnection(endNode, cost);
			endNode.AddConnection(startNode, cost);
			Int3 rhs = connectedNode2.position - connectedNode1.position;
			for (int i = 0; i < connectedNode1.GetVertexCount(); i++)
			{
				Int3 vertex = connectedNode1.GetVertex(i);
				Int3 vertex2 = connectedNode1.GetVertex((i + 1) % connectedNode1.GetVertexCount());
				if (Int3.DotLong((vertex2 - vertex).Normal2D(), rhs) > 0)
				{
					continue;
				}
				for (int j = 0; j < connectedNode2.GetVertexCount(); j++)
				{
					Int3 vertex3 = connectedNode2.GetVertex(j);
					Int3 vertex4 = connectedNode2.GetVertex((j + 1) % connectedNode2.GetVertexCount());
					if (Int3.DotLong((vertex4 - vertex3).Normal2D(), rhs) >= 0 && (double)Int3.Angle(vertex4 - vertex3, vertex2 - vertex) > 2.9670598109563189)
					{
						float val = 0f;
						float val2 = 1f;
						val2 = Math.Min(val2, AstarMath.NearestPointFactor(vertex, vertex2, vertex3));
						val = Math.Max(val, AstarMath.NearestPointFactor(vertex, vertex2, vertex4));
						if (!(val2 < val))
						{
							Vector3 vector = (Vector3)(vertex2 - vertex) * val + (Vector3)vertex;
							Vector3 vector2 = (Vector3)(vertex2 - vertex) * val2 + (Vector3)vertex;
							startNode.portalA = vector;
							startNode.portalB = vector2;
							endNode.portalA = vector2;
							endNode.portalB = vector;
							connectedNode1.AddConnection(startNode, (uint)Mathf.RoundToInt((float)((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));
							connectedNode2.AddConnection(endNode, (uint)Mathf.RoundToInt((float)((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));
							startNode.AddConnection(connectedNode1, (uint)Mathf.RoundToInt((float)((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));
							endNode.AddConnection(connectedNode2, (uint)Mathf.RoundToInt((float)((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));
							return;
						}
						UnityEngine.Debug.LogError("Wait wut!? " + val + " " + val2 + " " + (string)vertex + " " + (string)vertex2 + " " + (string)vertex3 + " " + (string)vertex4 + "\nTODO, fix this error");
					}
				}
			}
		}

		private void DrawCircle(Vector3 o, float r, int detail, Color col)
		{
			Vector3 from = new Vector3(Mathf.Cos(0f) * r, 0f, Mathf.Sin(0f) * r) + o;
			Gizmos.color = col;
			for (int i = 0; i <= detail; i++)
			{
				float f = (float)i * (float)Math.PI * 2f / (float)detail;
				Vector3 vector = new Vector3(Mathf.Cos(f) * r, 0f, Mathf.Sin(f) * r) + o;
				Gizmos.DrawLine(from, vector);
				from = vector;
			}
		}

		private void DrawGizmoBezier(Vector3 p1, Vector3 p2)
		{
			Vector3 vector = p2 - p1;
			if (!(vector == Vector3.zero))
			{
				Vector3 rhs = Vector3.Cross(Vector3.up, vector);
				Vector3 normalized = Vector3.Cross(vector, rhs).normalized;
				normalized *= vector.magnitude * 0.1f;
				Vector3 p3 = p1 + normalized;
				Vector3 p4 = p2 + normalized;
				Vector3 from = p1;
				for (int i = 1; i <= 20; i++)
				{
					float t = (float)i / 20f;
					Vector3 vector2 = AstarMath.CubicBezier(p1, p3, p4, p2, t);
					Gizmos.DrawLine(from, vector2);
					from = vector2;
				}
			}
		}

		public virtual void OnDrawGizmosSelected()
		{
			OnDrawGizmos(selected: true);
		}

		public void OnDrawGizmos()
		{
			OnDrawGizmos(selected: false);
		}

		public void OnDrawGizmos(bool selected)
		{
			Color color = (!selected) ? GizmosColor : GizmosColorSelected;
			if (StartTransform != null)
			{
				DrawCircle(StartTransform.position, 0.4f, 10, color);
			}
			if (EndTransform != null)
			{
				DrawCircle(EndTransform.position, 0.4f, 10, color);
			}
			if (StartTransform != null && EndTransform != null)
			{
				Gizmos.color = color;
				DrawGizmoBezier(StartTransform.position, EndTransform.position);
				if (selected)
				{
					Vector3 normalized = Vector3.Cross(Vector3.up, EndTransform.position - StartTransform.position).normalized;
					DrawGizmoBezier(StartTransform.position + normalized * 0.1f, EndTransform.position + normalized * 0.1f);
					DrawGizmoBezier(StartTransform.position - normalized * 0.1f, EndTransform.position - normalized * 0.1f);
				}
			}
		}
	}
}
namespace Pathfinding.Util
{
	public interface IAstarPooledObject
	{
		void OnEnterPool();
	}
	public static class ObjectPool<T> where T : class, IAstarPooledObject, new()
	{
		private static List<T> pool;

		static ObjectPool()
		{
			pool = new List<T>();
		}

		public static T Claim()
		{
			if (pool.Count > 0)
			{
				T result = pool[pool.Count - 1];
				pool.RemoveAt(pool.Count - 1);
				return result;
			}
			return new T();
		}

		public static void Warmup(int count)
		{
			T[] array = new T[count];
			for (int i = 0; i < count; i++)
			{
				array[i] = Claim();
			}
			for (int j = 0; j < count; j++)
			{
				Release(array[j]);
			}
		}

		public static void Release(T obj)
		{
			for (int i = 0; i < pool.Count; i++)
			{
				if (pool[i] == obj)
				{
					throw new InvalidOperationException("The object is released even though it is in the pool. Are you releasing it twice?");
				}
			}
			obj.OnEnterPool();
			pool.Add(obj);
		}

		public static void Clear()
		{
			pool.Clear();
		}

		public static int GetSize()
		{
			return pool.Count;
		}
	}
}
namespace Pathfinding
{
	public static class PathPool<T> where T : Path, new()
	{
		private static Stack<T> pool;

		private static int totalCreated;

		static PathPool()
		{
			pool = new Stack<T>();
		}

		public static void Recycle(T path)
		{
			lock (pool)
			{
				path.recycled = true;
				path.OnEnterPool();
				pool.Push(path);
			}
		}

		public static void Warmup(int count, int length)
		{
			ListPool<GraphNode>.Warmup(count, length);
			ListPool<Vector3>.Warmup(count, length);
			Path[] array = new Path[count];
			for (int i = 0; i < count; i++)
			{
				array[i] = GetPath();
				array[i].Claim(array);
			}
			for (int j = 0; j < count; j++)
			{
				array[j].Release(array);
			}
		}

		public static int GetTotalCreated()
		{
			return totalCreated;
		}

		public static int GetSize()
		{
			return pool.Count;
		}

		public static T GetPath()
		{
			//Discarded unreachable code: IL_005e
			lock (pool)
			{
				T val;
				if (pool.Count > 0)
				{
					val = pool.Pop();
				}
				else
				{
					val = new T();
					totalCreated++;
				}
				val.recycled = false;
				val.Reset();
				return val;
			}
		}
	}
}
namespace Pathfinding.Util
{
	public static class StackPool<T>
	{
		private static List<Stack<T>> pool;

		static StackPool()
		{
			pool = new List<Stack<T>>();
		}

		public static Stack<T> Claim()
		{
			if (pool.Count > 0)
			{
				Stack<T> result = pool[pool.Count - 1];
				pool.RemoveAt(pool.Count - 1);
				return result;
			}
			return new Stack<T>();
		}

		public static void Warmup(int count)
		{
			Stack<T>[] array = new Stack<T>[count];
			for (int i = 0; i < count; i++)
			{
				array[i] = Claim();
			}
			for (int j = 0; j < count; j++)
			{
				Release(array[j]);
			}
		}

		public static void Release(Stack<T> stack)
		{
			for (int i = 0; i < pool.Count; i++)
			{
				if (pool[i] == stack)
				{
					UnityEngine.Debug.LogError("The Stack is released even though it is inside the pool");
				}
			}
			stack.Clear();
			pool.Add(stack);
		}

		public static void Clear()
		{
			pool.Clear();
		}

		public static int GetSize()
		{
			return pool.Count;
		}
	}
}
namespace Pathfinding
{
	public class ThreadControlQueue
	{
		public class QueueTerminationException : Exception
		{
		}

		private Path head;

		private Path tail;

		private object lockObj = new object();

		private int numReceivers;

		private bool blocked;

		private int blockedReceivers;

		private bool starving;

		private bool terminate;

		private ManualResetEvent block = new ManualResetEvent(initialState: true);

		public bool IsEmpty => head == null;

		public bool IsTerminating => terminate;

		public bool AllReceiversBlocked => blocked && blockedReceivers == numReceivers;

		public ThreadControlQueue(int numReceivers)
		{
			this.numReceivers = numReceivers;
		}

		public void Block()
		{
			lock (lockObj)
			{
				blocked = true;
				block.Reset();
			}
		}

		public void Unblock()
		{
			lock (lockObj)
			{
				blocked = false;
				block.Set();
			}
		}

		public void Lock()
		{
			Monitor.Enter(lockObj);
		}

		public void Unlock()
		{
			Monitor.Exit(lockObj);
		}

		public void PushFront(Path p)
		{
			if (!terminate)
			{
				lock (lockObj)
				{
					if (tail == null)
					{
						head = p;
						tail = p;
						if (starving && !blocked)
						{
							starving = false;
							block.Set();
						}
						else
						{
							starving = false;
						}
					}
					else
					{
						p.next = head;
						head = p;
					}
				}
			}
		}

		public void Push(Path p)
		{
			if (!terminate)
			{
				lock (lockObj)
				{
					if (tail == null)
					{
						head = p;
						tail = p;
						if (starving && !blocked)
						{
							starving = false;
							block.Set();
						}
						else
						{
							starving = false;
						}
					}
					else
					{
						tail.next = p;
						tail = p;
					}
				}
			}
		}

		private void Starving()
		{
			starving = true;
			block.Reset();
		}

		public void TerminateReceivers()
		{
			terminate = true;
			block.Set();
		}

		public Path Pop()
		{
			//Discarded unreachable code: IL_0158
			Monitor.Enter(lockObj);
			try
			{
				if (terminate)
				{
					blockedReceivers++;
					throw new QueueTerminationException();
				}
				if (head == null)
				{
					Starving();
				}
				while (blocked || starving)
				{
					blockedReceivers++;
					if (terminate)
					{
						throw new QueueTerminationException();
					}
					if (blockedReceivers != numReceivers && blockedReceivers > numReceivers)
					{
						throw new InvalidOperationException("More receivers are blocked than specified in constructor (" + blockedReceivers + " > " + numReceivers + ")");
					}
					Monitor.Exit(lockObj);
					block.WaitOne();
					Monitor.Enter(lockObj);
					blockedReceivers--;
					if (head == null)
					{
						Starving();
					}
				}
				Path result = head;
				if (head.next == null)
				{
					tail = null;
				}
				head = head.next;
				return result;
			}
			finally
			{
				Monitor.Exit(lockObj);
			}
		}

		public void ReceiverTerminated()
		{
			Monitor.Enter(lockObj);
			blockedReceivers++;
			Monitor.Exit(lockObj);
		}

		public Path PopNoBlock(bool blockedBefore)
		{
			//Discarded unreachable code: IL_0133
			Monitor.Enter(lockObj);
			try
			{
				if (terminate)
				{
					blockedReceivers++;
					throw new QueueTerminationException();
				}
				if (head == null)
				{
					Starving();
				}
				if (blocked || starving)
				{
					if (!blockedBefore)
					{
						blockedReceivers++;
						if (terminate)
						{
							throw new QueueTerminationException();
						}
						if (blockedReceivers != numReceivers && blockedReceivers > numReceivers)
						{
							throw new InvalidOperationException("More receivers are blocked than specified in constructor (" + blockedReceivers + " > " + numReceivers + ")");
						}
					}
					return null;
				}
				if (blockedBefore)
				{
					blockedReceivers--;
				}
				Path result = head;
				if (head.next == null)
				{
					tail = null;
				}
				head = head.next;
				return result;
			}
			finally
			{
				Monitor.Exit(lockObj);
			}
		}
	}
}
namespace Pathfinding.WindowsStore
{
	public class WindowsStoreCompatibility
	{
		public static Type GetTypeFromInfo(Type type)
		{
			return type;
		}

		public static Type GetTypeInfo(Type type)
		{
			return type;
		}
	}
}
namespace Pathfinding
{
	[Obsolete("This class has been replaced with GraphNode, it may be removed in future versions", true)]
	public class Node
	{
	}
	public abstract class GraphNode
	{
		private const int FlagsWalkableOffset = 0;

		private const uint FlagsWalkableMask = 1u;

		private const int FlagsAreaOffset = 1;

		private const uint FlagsAreaMask = 131070u;

		private const int FlagsGraphOffset = 17;

		private const uint FlagsGraphMask = 393216u;

		public const uint MaxRegionCount = 65535u;

		public const uint MaxGraphCount = 3u;

		private const int FlagsTagOffset = 19;

		private const uint FlagsTagMask = 16252928u;

		private int nodeIndex;

		protected uint flags;

		private uint penalty;

		public Int3 position;

		[Obsolete("This attribute is deprecated. Please use .position (not a capital P)")]
		public Int3 Position => position;

		[Obsolete("This attribute is deprecated. Please use .Walkable (with a capital W)")]
		public bool walkable
		{
			get
			{
				return Walkable;
			}
			set
			{
				Walkable = value;
			}
		}

		[Obsolete("This attribute is deprecated. Please use .Tag (with a capital T)")]
		public uint tags
		{
			get
			{
				return Tag;
			}
			set
			{
				Tag = value;
			}
		}

		[Obsolete("This attribute is deprecated. Please use .GraphIndex (with a capital G)")]
		public uint graphIndex
		{
			get
			{
				return GraphIndex;
			}
			set
			{
				GraphIndex = value;
			}
		}

		public bool Destroyed => nodeIndex == -1;

		public int NodeIndex => nodeIndex;

		public uint Flags
		{
			get
			{
				return flags;
			}
			set
			{
				flags = value;
			}
		}

		public uint Penalty
		{
			get
			{
				return penalty;
			}
			set
			{
				if (value > 1048575)
				{
					UnityEngine.Debug.LogWarning("Very high penalty applied. Are you sure negative values haven't underflowed?\nPenalty values this high could with long paths cause overflows and in some cases infinity loops because of that.\nPenalty value applied: " + value);
				}
				penalty = value;
			}
		}

		public bool Walkable
		{
			get
			{
				return (flags & 1) != 0;
			}
			set
			{
				flags = (uint)(((int)flags & -2) | (value ? 1 : 0));
			}
		}

		public uint Area
		{
			get
			{
				return (flags & 0x1FFFE) >> 1;
			}
			set
			{
				flags = (uint)(((int)flags & -131071) | (int)(value << 1));
			}
		}

		public uint GraphIndex
		{
			get
			{
				return (flags & 0x60000) >> 17;
			}
			set
			{
				flags = (uint)(((int)flags & -393217) | (int)(value << 17));
			}
		}

		public uint Tag
		{
			get
			{
				return (flags & 0xF80000) >> 19;
			}
			set
			{
				flags = (uint)(((int)flags & -16252929) | (int)(value << 19));
			}
		}

		public GraphNode(AstarPath astar)
		{
			if (astar != null)
			{
				nodeIndex = astar.GetNewNodeIndex();
				astar.InitializeNode(this);
				return;
			}
			throw new Exception("No active AstarPath object to bind to");
		}

		public void Destroy()
		{
			if (nodeIndex != -1)
			{
				ClearConnections(alsoReverse: true);
				if (AstarPath.active != null)
				{
					AstarPath.active.DestroyNode(this);
				}
				nodeIndex = -1;
			}
		}

		public void UpdateG(Path path, PathNode pathNode)
		{
			pathNode.G = pathNode.parent.G + pathNode.cost + path.GetTraversalCost(this);
		}

		public virtual void UpdateRecursiveG(Path path, PathNode pathNode, PathHandler handler)
		{
			UpdateG(path, pathNode);
			handler.PushNode(pathNode);
			GetConnections(delegate(GraphNode other)
			{
				PathNode pathNode2 = handler.GetPathNode(other);
				if (pathNode2.parent == pathNode && pathNode2.pathID == handler.PathID)
				{
					other.UpdateRecursiveG(path, pathNode2, handler);
				}
			});
		}

		public virtual void FloodFill(Stack<GraphNode> stack, uint region)
		{
			GetConnections(delegate(GraphNode other)
			{
				if (other.Area != region)
				{
					other.Area = region;
					stack.Push(other);
				}
			});
		}

		public abstract void GetConnections(GraphNodeDelegate del);

		public abstract void AddConnection(GraphNode node, uint cost);

		public abstract void RemoveConnection(GraphNode node);

		public abstract void ClearConnections(bool alsoReverse);

		public virtual bool ContainsConnection(GraphNode node)
		{
			bool contains = false;
			GetConnections(delegate(GraphNode n)
			{
				if (n == node)
				{
					contains = true;
				}
			});
			return contains;
		}

		public virtual void RecalculateConnectionCosts()
		{
		}

		public virtual bool GetPortal(GraphNode other, List<Vector3> left, List<Vector3> right, bool backwards)
		{
			return false;
		}

		public abstract void Open(Path path, PathNode pathNode, PathHandler handler);

		public virtual void SerializeNode(GraphSerializationContext ctx)
		{
			ctx.writer.Write(Penalty);
			ctx.writer.Write(Flags);
		}

		public virtual void DeserializeNode(GraphSerializationContext ctx)
		{
			Penalty = ctx.reader.ReadUInt32();
			Flags = ctx.reader.ReadUInt32();
		}

		public virtual void SerializeReferences(GraphSerializationContext ctx)
		{
		}

		public virtual void DeserializeReferences(GraphSerializationContext ctx)
		{
		}
	}
	public abstract class MeshNode : GraphNode
	{
		public GraphNode[] connections;

		public uint[] connectionCosts;

		public MeshNode(AstarPath astar)
			: base(astar)
		{
		}

		public abstract Int3 GetVertex(int i);

		public abstract int GetVertexCount();

		public abstract Vector3 ClosestPointOnNode(Vector3 p);

		public abstract Vector3 ClosestPointOnNodeXZ(Vector3 p);

		public override void ClearConnections(bool alsoReverse)
		{
			if (alsoReverse && connections != null)
			{
				for (int i = 0; i < connections.Length; i++)
				{
					connections[i].RemoveConnection(this);
				}
			}
			connections = null;
			connectionCosts = null;
		}

		public override void GetConnections(GraphNodeDelegate del)
		{
			if (connections != null)
			{
				for (int i = 0; i < connections.Length; i++)
				{
					del(connections[i]);
				}
			}
		}

		public override void FloodFill(Stack<GraphNode> stack, uint region)
		{
			if (connections == null)
			{
				return;
			}
			for (int i = 0; i < connections.Length; i++)
			{
				GraphNode graphNode = connections[i];
				if (graphNode.Area != region)
				{
					graphNode.Area = region;
					stack.Push(graphNode);
				}
			}
		}

		public override bool ContainsConnection(GraphNode node)
		{
			for (int i = 0; i < connections.Length; i++)
			{
				if (connections[i] == node)
				{
					return true;
				}
			}
			return false;
		}

		public override void UpdateRecursiveG(Path path, PathNode pathNode, PathHandler handler)
		{
			UpdateG(path, pathNode);
			handler.PushNode(pathNode);
			for (int i = 0; i < connections.Length; i++)
			{
				GraphNode graphNode = connections[i];
				PathNode pathNode2 = handler.GetPathNode(graphNode);
				if (pathNode2.parent == pathNode && pathNode2.pathID == handler.PathID)
				{
					graphNode.UpdateRecursiveG(path, pathNode2, handler);
				}
			}
		}

		public override void AddConnection(GraphNode node, uint cost)
		{
			if (connections != null)
			{
				for (int i = 0; i < connections.Length; i++)
				{
					if (connections[i] == node)
					{
						connectionCosts[i] = cost;
						return;
					}
				}
			}
			int num = (connections != null) ? connections.Length : 0;
			GraphNode[] array = new GraphNode[num + 1];
			uint[] array2 = new uint[num + 1];
			for (int j = 0; j < num; j++)
			{
				array[j] = connections[j];
				array2[j] = connectionCosts[j];
			}
			array[num] = node;
			array2[num] = cost;
			connections = array;
			connectionCosts = array2;
		}

		public override void RemoveConnection(GraphNode node)
		{
			if (connections == null)
			{
				return;
			}
			int num = 0;
			while (true)
			{
				if (num < connections.Length)
				{
					if (connections[num] == node)
					{
						break;
					}
					num++;
					continue;
				}
				return;
			}
			int num2 = connections.Length;
			GraphNode[] array = new GraphNode[num2 - 1];
			uint[] array2 = new uint[num2 - 1];
			for (int i = 0; i < num; i++)
			{
				array[i] = connections[i];
				array2[i] = connectionCosts[i];
			}
			for (int j = num + 1; j < num2; j++)
			{
				array[j - 1] = connections[j];
				array2[j - 1] = connectionCosts[j];
			}
			connections = array;
			connectionCosts = array2;
		}

		public virtual bool ContainsPoint(Int3 p)
		{
			bool flag = false;
			int vertexCount = GetVertexCount();
			int num = 0;
			for (int i = vertexCount - 1; num < vertexCount; i = num++)
			{
				Int3 vertex = GetVertex(num);
				if (vertex.z <= p.z)
				{
					int z = p.z;
					Int3 vertex2 = GetVertex(i);
					if (z < vertex2.z)
					{
						goto IL_0084;
					}
				}
				Int3 vertex3 = GetVertex(i);
				if (vertex3.z > p.z)
				{
					continue;
				}
				int z2 = p.z;
				Int3 vertex4 = GetVertex(num);
				if (z2 >= vertex4.z)
				{
					continue;
				}
				goto IL_0084;
				IL_0084:
				int x = p.x;
				Int3 vertex5 = GetVertex(i);
				int x2 = vertex5.x;
				Int3 vertex6 = GetVertex(num);
				int num2 = x2 - vertex6.x;
				int z3 = p.z;
				Int3 vertex7 = GetVertex(num);
				int num3 = num2 * (z3 - vertex7.z);
				Int3 vertex8 = GetVertex(i);
				int z4 = vertex8.z;
				Int3 vertex9 = GetVertex(num);
				int num4 = num3 / (z4 - vertex9.z);
				Int3 vertex10 = GetVertex(num);
				if (x < num4 + vertex10.x)
				{
					flag = !flag;
				}
			}
			return flag;
		}

		public override void SerializeReferences(GraphSerializationContext ctx)
		{
			if (connections == null)
			{
				ctx.writer.Write(-1);
				return;
			}
			ctx.writer.Write(connections.Length);
			for (int i = 0; i < connections.Length; i++)
			{
				ctx.writer.Write(ctx.GetNodeIdentifier(connections[i]));
				ctx.writer.Write(connectionCosts[i]);
			}
		}

		public override void DeserializeReferences(GraphSerializationContext ctx)
		{
			int num = ctx.reader.ReadInt32();
			if (num == -1)
			{
				connections = null;
				connectionCosts = null;
				return;
			}
			connections = new GraphNode[num];
			connectionCosts = new uint[num];
			for (int i = 0; i < num; i++)
			{
				connections[i] = ctx.GetNodeFromIdentifier(ctx.reader.ReadInt32());
				connectionCosts[i] = ctx.reader.ReadUInt32();
			}
		}
	}
	public abstract class Path
	{
		public PathHandler pathHandler;

		public OnPathDelegate callback;

		private PathState state;

		private object stateLock = new object();

		private PathCompleteState pathCompleteState;

		private string _errorLog = string.Empty;

		private GraphNode[] _path;

		private Vector3[] _vectorPath;

		public List<GraphNode> path;

		public List<Vector3> vectorPath;

		protected float maxFrameTime;

		protected PathNode currentR;

		public float duration;

		public int searchIterations;

		public int searchedNodes;

		public DateTime callTime;

		public bool recycled;

		protected bool hasBeenReset;

		public NNConstraint nnConstraint = PathNNConstraint.Default;

		public Path next;

		public int radius;

		public int walkabilityMask = -1;

		public int height;

		public int turnRadius;

		public int speed;

		public Heuristic heuristic;

		public float heuristicScale = 1f;

		public ushort pathID;

		protected Int3 hTarget;

		public int enabledTags = -1;

		protected int[] _tagPenalties = new int[0];

		private List<object> claimed = new List<object>();

		private bool releasedNotSilent;

		public PathCompleteState CompleteState
		{
			get
			{
				return pathCompleteState;
			}
			protected set
			{
				pathCompleteState = value;
			}
		}

		public bool error => CompleteState == PathCompleteState.Error;

		public string errorLog => _errorLog;

		public int[] tagPenalties
		{
			get
			{
				return _tagPenalties;
			}
			set
			{
				if (value == null || value.Length != 32)
				{
					_tagPenalties = new int[0];
				}
				else
				{
					_tagPenalties = value;
				}
			}
		}

		public float GetTotalLength()
		{
			if (vectorPath == null)
			{
				return float.PositiveInfinity;
			}
			float num = 0f;
			for (int i = 0; i < vectorPath.Count - 1; i++)
			{
				num += Vector3.Distance(vectorPath[i], vectorPath[i + 1]);
			}
			return num;
		}

		public IEnumerator WaitForPath()
		{
			if (GetState() == PathState.Created)
			{
				throw new InvalidOperationException("This path has not been started yet");
			}
			while (GetState() != PathState.Returned)
			{
				yield return null;
			}
		}

		public uint CalculateHScore(GraphNode node)
		{
			switch (heuristic)
			{
			case Heuristic.Euclidean:
				return (uint)((float)(GetHTarget() - node.position).costMagnitude * heuristicScale);
			case Heuristic.Manhattan:
			{
				Int3 position = node.position;
				return (uint)((float)(Math.Abs(hTarget.x - position.x) + Math.Abs(hTarget.y - position.y) + Math.Abs(hTarget.z - position.z)) * heuristicScale);
			}
			case Heuristic.DiagonalManhattan:
			{
				Int3 @int = GetHTarget() - node.position;
				@int.x = Math.Abs(@int.x);
				@int.y = Math.Abs(@int.y);
				@int.z = Math.Abs(@int.z);
				int num = Math.Min(@int.x, @int.z);
				int num2 = Math.Max(@int.x, @int.z);
				return (uint)((float)(14 * num / 10 + (num2 - num) + @int.y) * heuristicScale);
			}
			default:
				return 0u;
			}
		}

		public uint GetTagPenalty(int tag)
		{
			return (uint)((tag < _tagPenalties.Length) ? _tagPenalties[tag] : 0);
		}

		public Int3 GetHTarget()
		{
			return hTarget;
		}

		public bool CanTraverse(GraphNode node)
		{
			return node.Walkable && ((enabledTags >> (int)node.Tag) & 1) != 0;
		}

		public uint GetTraversalCost(GraphNode node)
		{
			return GetTagPenalty((int)node.Tag) + node.Penalty;
		}

		public virtual uint GetConnectionSpecialCost(GraphNode a, GraphNode b, uint currentCost)
		{
			return currentCost;
		}

		public bool IsDone()
		{
			return CompleteState != PathCompleteState.NotCalculated;
		}

		public void AdvanceState(PathState s)
		{
			lock (stateLock)
			{
				state = (PathState)Math.Max((int)state, (int)s);
			}
		}

		public PathState GetState()
		{
			return state;
		}

		public void LogError(string msg)
		{
			if (AstarPath.isEditor || AstarPath.active.logPathResults != 0)
			{
				_errorLog += msg;
			}
			if (AstarPath.active.logPathResults != 0 && AstarPath.active.logPathResults != PathLog.InGame)
			{
				UnityEngine.Debug.LogWarning(msg);
			}
		}

		public void ForceLogError(string msg)
		{
			Error();
			_errorLog += msg;
			UnityEngine.Debug.LogError(msg);
		}

		public void Log(string msg)
		{
			if (AstarPath.isEditor || AstarPath.active.logPathResults != 0)
			{
				_errorLog += msg;
			}
		}

		public void Error()
		{
			CompleteState = PathCompleteState.Error;
		}

		private void ErrorCheck()
		{
			if (!hasBeenReset)
			{
				throw new Exception("The path has never been reset. Use pooling API or call Reset() after creating the path with the default constructor.");
			}
			if (recycled)
			{
				throw new Exception("The path is currently in a path pool. Are you sending the path for calculation twice?");
			}
			if (pathHandler == null)
			{
				throw new Exception("Field pathHandler is not set. Please report this bug.");
			}
			if (GetState() > PathState.Processing)
			{
				throw new Exception("This path has already been processed. Do not request a path with the same path object twice.");
			}
		}

		public virtual void OnEnterPool()
		{
			if (vectorPath != null)
			{
				ListPool<Vector3>.Release(vectorPath);
			}
			if (path != null)
			{
				ListPool<GraphNode>.Release(path);
			}
			vectorPath = null;
			path = null;
		}

		public virtual void Reset()
		{
			if (AstarPath.active == null)
			{
				throw new NullReferenceException("No AstarPath object found in the scene. Make sure there is one or do not create paths in Awake");
			}
			hasBeenReset = true;
			state = PathState.Created;
			releasedNotSilent = false;
			pathHandler = null;
			callback = null;
			_errorLog = string.Empty;
			pathCompleteState = PathCompleteState.NotCalculated;
			path = ListPool<GraphNode>.Claim();
			vectorPath = ListPool<Vector3>.Claim();
			currentR = null;
			duration = 0f;
			searchIterations = 0;
			searchedNodes = 0;
			nnConstraint = PathNNConstraint.Default;
			next = null;
			radius = 0;
			walkabilityMask = -1;
			height = 0;
			turnRadius = 0;
			speed = 0;
			heuristic = AstarPath.active.heuristic;
			heuristicScale = AstarPath.active.heuristicScale;
			pathID = 0;
			enabledTags = -1;
			tagPenalties = null;
			callTime = DateTime.UtcNow;
			pathID = AstarPath.active.GetNextPathID();
			hTarget = Int3.zero;
		}

		protected bool HasExceededTime(int searchedNodes, long targetTime)
		{
			return DateTime.UtcNow.Ticks >= targetTime;
		}

		protected abstract void Recycle();

		public void Claim(object o)
		{
			if (o == null)
			{
				throw new ArgumentNullException("o");
			}
			if (claimed.Contains(o))
			{
				throw new ArgumentException("You have already claimed the path with that object (" + o.ToString() + "). Are you claiming the path with the same object twice?");
			}
			claimed.Add(o);
		}

		public void ReleaseSilent(object o)
		{
			if (o == null)
			{
				throw new ArgumentNullException("o");
			}
			for (int i = 0; i < claimed.Count; i++)
			{
				if (claimed[i] == o)
				{
					claimed.RemoveAt(i);
					if (releasedNotSilent && claimed.Count == 0)
					{
						Recycle();
					}
					return;
				}
			}
			if (claimed.Count == 0)
			{
				throw new ArgumentException("You are releasing a path which is not claimed at all (most likely it has been pooled already). Are you releasing the path with the same object (" + o.ToString() + ") twice?");
			}
			throw new ArgumentException("You are releasing a path which has not been claimed with this object (" + o.ToString() + "). Are you releasing the path with the same object twice?");
		}

		public void Release(object o)
		{
			if (o == null)
			{
				throw new ArgumentNullException("o");
			}
			for (int i = 0; i < claimed.Count; i++)
			{
				if (claimed[i] == o)
				{
					claimed.RemoveAt(i);
					releasedNotSilent = true;
					if (claimed.Count == 0)
					{
						Recycle();
					}
					return;
				}
			}
			if (claimed.Count == 0)
			{
				throw new ArgumentException("You are releasing a path which is not claimed at all (most likely it has been pooled already). Are you releasing the path with the same object (" + o.ToString() + ") twice?");
			}
			throw new ArgumentException("You are releasing a path which has not been claimed with this object (" + o.ToString() + "). Are you releasing the path with the same object twice?");
		}

		protected virtual void Trace(PathNode from)
		{
			int num = 0;
			PathNode pathNode = from;
			while (pathNode != null)
			{
				pathNode = pathNode.parent;
				num++;
				if (num > 1024)
				{
					UnityEngine.Debug.LogWarning("Inifinity loop? >1024 node path. Remove this message if you really have that long paths (Path.cs, Trace function)");
					break;
				}
			}
			if (path.Capacity < num)
			{
				path.Capacity = num;
			}
			if (vectorPath.Capacity < num)
			{
				vectorPath.Capacity = num;
			}
			pathNode = from;
			for (int i = 0; i < num; i++)
			{
				path.Add(pathNode.node);
				pathNode = pathNode.parent;
			}
			int num2 = num / 2;
			for (int j = 0; j < num2; j++)
			{
				GraphNode value = path[j];
				path[j] = path[num - j - 1];
				path[num - j - 1] = value;
			}
			for (int k = 0; k < num; k++)
			{
				vectorPath.Add((Vector3)path[k].position);
			}
		}

		public virtual string DebugString(PathLog logMode)
		{
			if (logMode == PathLog.None || (!error && logMode == PathLog.OnlyErrors))
			{
				return string.Empty;
			}
			StringBuilder debugStringBuilder = pathHandler.DebugStringBuilder;
			debugStringBuilder.Length = 0;
			debugStringBuilder.Append((!error) ? "Path Completed : " : "Path Failed : ");
			debugStringBuilder.Append("Computation Time ");
			debugStringBuilder.Append(duration.ToString((logMode != PathLog.Heavy) ? "0.00 ms " : "0.000 ms "));
			debugStringBuilder.Append("Searched Nodes ");
			debugStringBuilder.Append(searchedNodes);
			if (!error)
			{
				debugStringBuilder.Append(" Path Length ");
				debugStringBuilder.Append((path != null) ? path.Count.ToString() : "Null");
				if (logMode == PathLog.Heavy)
				{
					debugStringBuilder.Append("\nSearch Iterations " + searchIterations);
				}
			}
			if (error)
			{
				debugStringBuilder.Append("\nError: ");
				debugStringBuilder.Append(errorLog);
			}
			if (logMode == PathLog.Heavy && !AstarPath.IsUsingMultithreading)
			{
				debugStringBuilder.Append("\nCallback references ");
				if (callback != null)
				{
					debugStringBuilder.Append(callback.Target.GetType().FullName).AppendLine();
				}
				else
				{
					debugStringBuilder.AppendLine("NULL");
				}
			}
			debugStringBuilder.Append("\nPath Number ");
			debugStringBuilder.Append(pathID);
			return debugStringBuilder.ToString();
		}

		public virtual void ReturnPath()
		{
			if (callback != null)
			{
				callback(this);
			}
		}

		public void PrepareBase(PathHandler pathHandler)
		{
			if (pathHandler.PathID > pathID)
			{
				pathHandler.ClearPathIDs();
			}
			this.pathHandler = pathHandler;
			pathHandler.InitializeForPath(this);
			try
			{
				ErrorCheck();
			}
			catch (Exception ex)
			{
				ForceLogError("Exception in path " + pathID + "\n" + ex.ToString());
			}
		}

		public abstract void Prepare();

		public virtual void Cleanup()
		{
		}

		public abstract void Initialize();

		public abstract void CalculateStep(long targetTick);
	}
	public class PathNode
	{
		private const uint CostMask = 268435455u;

		private const int Flag1Offset = 28;

		private const uint Flag1Mask = 268435456u;

		private const int Flag2Offset = 29;

		private const uint Flag2Mask = 536870912u;

		public GraphNode node;

		public PathNode parent;

		public ushort pathID;

		private uint flags;

		private uint g;

		private uint h;

		public uint cost
		{
			get
			{
				return flags & 0xFFFFFFF;
			}
			set
			{
				flags = (uint)(((int)flags & -268435456) | (int)value);
			}
		}

		public bool flag1
		{
			get
			{
				return (flags & 0x10000000) != 0;
			}
			set
			{
				flags = (uint)(((int)flags & -268435457) | (value ? 268435456 : 0));
			}
		}

		public bool flag2
		{
			get
			{
				return (flags & 0x20000000) != 0;
			}
			set
			{
				flags = (uint)(((int)flags & -536870913) | (value ? 536870912 : 0));
			}
		}

		public uint G
		{
			get
			{
				return g;
			}
			set
			{
				g = value;
			}
		}

		public uint H
		{
			get
			{
				return h;
			}
			set
			{
				h = value;
			}
		}

		public uint F => g + h;
	}
	public class PathHandler
	{
		private const int BucketSizeLog2 = 10;

		private const int BucketSize = 1024;

		private const int BucketIndexMask = 1023;

		private ushort pathID;

		private BinaryHeapM heap = new BinaryHeapM(128);

		public PathNode[][] nodes = new PathNode[0][];

		private bool[] bucketNew = new bool[0];

		private bool[] bucketCreated = new bool[0];

		private Stack<PathNode[]> bucketCache = new Stack<PathNode[]>();

		private int filledBuckets;

		public readonly StringBuilder DebugStringBuilder = new StringBuilder();

		public ushort PathID => pathID;

		public void PushNode(PathNode node)
		{
			heap.Add(node);
		}

		public PathNode PopNode()
		{
			return heap.Remove();
		}

		public BinaryHeapM GetHeap()
		{
			return heap;
		}

		public void RebuildHeap()
		{
			heap.Rebuild();
		}

		public bool HeapEmpty()
		{
			return heap.numberOfItems <= 0;
		}

		public void InitializeForPath(Path p)
		{
			pathID = p.pathID;
			heap.Clear();
		}

		public void DestroyNode(GraphNode node)
		{
			PathNode pathNode = GetPathNode(node);
			pathNode.node = null;
			pathNode.parent = null;
		}

		public void InitializeNode(GraphNode node)
		{
			int nodeIndex = node.NodeIndex;
			int num = nodeIndex >> 10;
			int num2 = nodeIndex & 0x3FF;
			if (num >= nodes.Length)
			{
				PathNode[][] array = new PathNode[Math.Max(Math.Max(nodes.Length * 3 / 2, num + 1), nodes.Length + 2)][];
				for (int i = 0; i < nodes.Length; i++)
				{
					array[i] = nodes[i];
				}
				bool[] array2 = new bool[array.Length];
				for (int j = 0; j < nodes.Length; j++)
				{
					array2[j] = bucketNew[j];
				}
				bool[] array3 = new bool[array.Length];
				for (int k = 0; k < nodes.Length; k++)
				{
					array3[k] = bucketCreated[k];
				}
				nodes = array;
				bucketNew = array2;
				bucketCreated = array3;
			}
			if (nodes[num] == null)
			{
				PathNode[] array4;
				if (bucketCache.Count > 0)
				{
					array4 = bucketCache.Pop();
				}
				else
				{
					array4 = new PathNode[1024];
					for (int l = 0; l < 1024; l++)
					{
						array4[l] = new PathNode();
					}
				}
				nodes[num] = array4;
				if (!bucketCreated[num])
				{
					bucketNew[num] = true;
					bucketCreated[num] = true;
				}
				filledBuckets++;
			}
			PathNode pathNode = nodes[num][num2];
			pathNode.node = node;
		}

		public PathNode GetPathNode(GraphNode node)
		{
			int nodeIndex = node.NodeIndex;
			return nodes[nodeIndex >> 10][nodeIndex & 0x3FF];
		}

		public void ClearPathIDs()
		{
			for (int i = 0; i < nodes.Length; i++)
			{
				PathNode[] array = nodes[i];
				if (nodes[i] != null)
				{
					for (int j = 0; j < 1024; j++)
					{
						array[j].pathID = 0;
					}
				}
			}
		}
	}
}
namespace Pathfinding.RVO.Sampled
{
	public class Agent : IAgent
	{
		public struct VO
		{
			public Vector2 origin;

			private Vector2 line1;

			private Vector2 line2;

			private Vector2 dir1;

			private Vector2 dir2;

			private Vector2 cutoffLine;

			private Vector2 cutoffDir;

			private float sqrCutoffDistance;

			private bool leftSide;

			private bool colliding;

			public VO(Vector2 center, Vector2 offset, float radius, Vector2 sideChooser, float inverseDt)
			{
				origin = offset;
				if (center.magnitude < radius)
				{
					colliding = true;
					leftSide = false;
					line1 = center.normalized * (center.magnitude - radius);
					dir1 = new Vector2(line1.y, 0f - line1.x).normalized;
					line1 += offset;
					return;
				}
				colliding = false;
				center *= inverseDt;
				radius *= inverseDt;
				Vector2 vector = center + offset;
				sqrCutoffDistance = center.magnitude - radius;
				cutoffLine = center.normalized * sqrCutoffDistance;
				cutoffDir = new Vector2(0f - cutoffLine.y, cutoffLine.x).normalized;
				cutoffLine += offset;
				sqrCutoffDistance *= sqrCutoffDistance;
				float num = Mathf.Atan2(0f - center.y, 0f - center.x);
				float num2 = Mathf.Abs(Mathf.Acos(radius / center.magnitude));
				leftSide = Polygon.Left(Vector2.zero, center, sideChooser);
				line1 = new Vector2(Mathf.Cos(num + num2), Mathf.Sin(num + num2)) * radius;
				dir1 = new Vector2(line1.y, 0f - line1.x).normalized;
				line2 = new Vector2(Mathf.Cos(num - num2), Mathf.Sin(num - num2)) * radius;
				dir2 = new Vector2(line2.y, 0f - line2.x).normalized;
				line1 += vector;
				line2 += vector;
			}

			private static bool Left(Vector2 a, Vector2 dir, Vector2 p)
			{
				return dir.x * (p.y - a.y) - (p.x - a.x) * dir.y <= 0f;
			}

			private static float Det(Vector2 a, Vector2 dir, Vector2 p)
			{
				return (p.x - a.x) * dir.y - dir.x * (p.y - a.y);
			}

			public Vector2 Sample(Vector2 p, out float weight)
			{
				if (colliding)
				{
					float num = Det(line1, dir1, p);
					if (num >= 0f)
					{
						weight = num * 0.5f;
						return new Vector2(0f - dir1.y, dir1.x) * weight * GlobalIncompressibility;
					}
					weight = 0f;
					return new Vector2(0f, 0f);
				}
				float num2 = Det(line1, dir1, p);
				float num3 = Det(line2, dir2, p);
				if (num2 >= 0f && num3 >= 0f)
				{
					float num4 = Det(cutoffLine, cutoffDir, p);
					if (num4 <= 0f)
					{
						weight = 0f;
						return Vector2.zero;
					}
					if (leftSide)
					{
						if (num4 < num2)
						{
							weight = num4 * 0.5f;
							return new Vector2(0f - cutoffDir.y, cutoffDir.x) * weight;
						}
						weight = num2 * 0.5f;
						return new Vector2(0f - dir1.y, dir1.x) * weight;
					}
					if (num3 < num2)
					{
						weight = num3 * 0.5f;
						return new Vector2(0f - cutoffDir.y, cutoffDir.x) * weight;
					}
					weight = num3 * 0.5f;
					return new Vector2(0f - dir2.y, dir2.x) * weight;
				}
				weight = 0f;
				return new Vector2(0f, 0f);
			}
		}

		private Vector3 smoothPos;

		public float radius;

		public float height;

		public float maxSpeed;

		public float neighbourDist;

		public float agentTimeHorizon;

		public float obstacleTimeHorizon;

		public float weight;

		public bool locked;

		private RVOLayer layer;

		private RVOLayer collidesWith;

		public int maxNeighbours;

		public Vector3 position;

		public Vector3 desiredVelocity;

		public Vector3 prevSmoothPos;

		internal Agent next;

		private Vector3 velocity;

		private Vector3 newVelocity;

		public Simulator simulator;

		public List<Agent> neighbours = new List<Agent>();

		public List<float> neighbourDists = new List<float>();

		private List<ObstacleVertex> obstaclesBuffered = new List<ObstacleVertex>();

		private List<ObstacleVertex> obstacles = new List<ObstacleVertex>();

		private List<float> obstacleDists = new List<float>();

		public static Stopwatch watch1 = new Stopwatch();

		public static Stopwatch watch2 = new Stopwatch();

		public static float DesiredVelocityWeight = 0.1f;

		public static float DesiredVelocityScale = 0.1f;

		public static float GlobalIncompressibility = 30f;

		public Vector3 Position
		{
			get;
			set;
		}

		public Vector3 InterpolatedPosition => smoothPos;

		public Vector3 DesiredVelocity
		{
			get;
			set;
		}

		public RVOLayer Layer
		{
			get;
			set;
		}

		public RVOLayer CollidesWith
		{
			get;
			set;
		}

		public bool Locked
		{
			get;
			set;
		}

		public float Radius
		{
			get;
			set;
		}

		public float Height
		{
			get;
			set;
		}

		public float MaxSpeed
		{
			get;
			set;
		}

		public float NeighbourDist
		{
			get;
			set;
		}

		public float AgentTimeHorizon
		{
			get;
			set;
		}

		public float ObstacleTimeHorizon
		{
			get;
			set;
		}

		public Vector3 Velocity
		{
			get;
			set;
		}

		public bool DebugDraw
		{
			get;
			set;
		}

		public int MaxNeighbours
		{
			get;
			set;
		}

		public List<ObstacleVertex> NeighbourObstacles => null;

		public Agent(Vector3 pos)
		{
			MaxSpeed = 2f;
			NeighbourDist = 15f;
			AgentTimeHorizon = 2f;
			ObstacleTimeHorizon = 2f;
			Height = 5f;
			Radius = 5f;
			MaxNeighbours = 10;
			Locked = false;
			position = pos;
			Position = position;
			prevSmoothPos = position;
			smoothPos = position;
			CollidesWith = (RVOLayer)(-1);
		}

		public void Teleport(Vector3 pos)
		{
			Position = pos;
			smoothPos = pos;
			prevSmoothPos = pos;
		}

		public void BufferSwitch()
		{
			radius = Radius;
			height = Height;
			maxSpeed = MaxSpeed;
			neighbourDist = NeighbourDist;
			agentTimeHorizon = AgentTimeHorizon;
			obstacleTimeHorizon = ObstacleTimeHorizon;
			maxNeighbours = MaxNeighbours;
			desiredVelocity = DesiredVelocity;
			locked = Locked;
			collidesWith = CollidesWith;
			layer = Layer;
			Velocity = velocity;
			List<ObstacleVertex> list = obstaclesBuffered;
			obstaclesBuffered = obstacles;
			obstacles = list;
		}

		public void Update()
		{
			velocity = newVelocity;
			prevSmoothPos = smoothPos;
			position = Position;
			position += velocity * simulator.DeltaTime;
			Position = position;
		}

		public void Interpolate(float t)
		{
			if (t == 1f)
			{
				smoothPos = Position;
			}
			else
			{
				smoothPos = prevSmoothPos + (Position - prevSmoothPos) * t;
			}
		}

		public void CalculateNeighbours()
		{
			neighbours.Clear();
			neighbourDists.Clear();
			if (!locked)
			{
				float num;
				if (MaxNeighbours > 0)
				{
					num = neighbourDist * neighbourDist;
					simulator.Quadtree.Query(new Vector2(position.x, position.z), neighbourDist, this);
				}
				obstacles.Clear();
				obstacleDists.Clear();
				num = obstacleTimeHorizon * maxSpeed + radius;
				num *= num;
			}
		}

		private float Sqr(float x)
		{
			return x * x;
		}

		public float InsertAgentNeighbour(Agent agent, float rangeSq)
		{
			if (this == agent)
			{
				return rangeSq;
			}
			if ((agent.layer & collidesWith) == 0)
			{
				return rangeSq;
			}
			float num = Sqr(agent.position.x - position.x) + Sqr(agent.position.z - position.z);
			if (num < rangeSq)
			{
				if (neighbours.Count < maxNeighbours)
				{
					neighbours.Add(agent);
					neighbourDists.Add(num);
				}
				int num2 = neighbours.Count - 1;
				if (num < neighbourDists[num2])
				{
					while (num2 != 0 && num < neighbourDists[num2 - 1])
					{
						neighbours[num2] = neighbours[num2 - 1];
						neighbourDists[num2] = neighbourDists[num2 - 1];
						num2--;
					}
					neighbours[num2] = agent;
					neighbourDists[num2] = num;
				}
				if (neighbours.Count == maxNeighbours)
				{
					rangeSq = neighbourDists[neighbourDists.Count - 1];
				}
			}
			return rangeSq;
		}

		public void InsertObstacleNeighbour(ObstacleVertex ob1, float rangeSq)
		{
			ObstacleVertex obstacleVertex = ob1.next;
			float num = AstarMath.DistancePointSegmentStrict(ob1.position, obstacleVertex.position, Position);
			if (num < rangeSq)
			{
				obstacles.Add(ob1);
				obstacleDists.Add(num);
				int num2 = obstacles.Count - 1;
				while (num2 != 0 && num < obstacleDists[num2 - 1])
				{
					obstacles[num2] = obstacles[num2 - 1];
					obstacleDists[num2] = obstacleDists[num2 - 1];
					num2--;
				}
				obstacles[num2] = ob1;
				obstacleDists[num2] = num;
			}
		}

		private static Vector3 To3D(Vector2 p)
		{
			return new Vector3(p.x, 0f, p.y);
		}

		private static void DrawCircle(Vector2 _p, float radius, Color col)
		{
			DrawCircle(_p, radius, 0f, (float)Math.PI * 2f, col);
		}

		private static void DrawCircle(Vector2 _p, float radius, float a0, float a1, Color col)
		{
			Vector3 a2 = To3D(_p);
			while (a0 > a1)
			{
				a0 -= (float)Math.PI * 2f;
			}
			Vector3 b = new Vector3(Mathf.Cos(a0) * radius, 0f, Mathf.Sin(a0) * radius);
			for (int i = 0; (float)i <= 40f; i++)
			{
				Vector3 vector = new Vector3(Mathf.Cos(Mathf.Lerp(a0, a1, (float)i / 40f)) * radius, 0f, Mathf.Sin(Mathf.Lerp(a0, a1, (float)i / 40f)) * radius);
				UnityEngine.Debug.DrawLine(a2 + b, a2 + vector, col);
				b = vector;
			}
		}

		private static void DrawVO(Vector2 circleCenter, float radius, Vector2 origin)
		{
			Vector2 vector = origin - circleCenter;
			float y = vector.y;
			Vector2 vector2 = origin - circleCenter;
			float num = Mathf.Atan2(y, vector2.x);
			float num2 = radius / (origin - circleCenter).magnitude;
			float num3 = (!(num2 <= 1f)) ? 0f : Mathf.Abs(Mathf.Acos(num2));
			DrawCircle(circleCenter, radius, num - num3, num + num3, Color.black);
			Vector2 p = new Vector2(Mathf.Cos(num - num3), Mathf.Sin(num - num3)) * radius;
			Vector2 p2 = new Vector2(Mathf.Cos(num + num3), Mathf.Sin(num + num3)) * radius;
			Vector2 p3 = -new Vector2(0f - p.y, p.x);
			Vector2 p4 = new Vector2(0f - p2.y, p2.x);
			p += circleCenter;
			p2 += circleCenter;
			UnityEngine.Debug.DrawRay(To3D(p), To3D(p3).normalized * 100f, Color.black);
			UnityEngine.Debug.DrawRay(To3D(p2), To3D(p4).normalized * 100f, Color.black);
		}

		private static void DrawCross(Vector2 p, float size = 1f)
		{
			DrawCross(p, Color.white, size);
		}

		private static void DrawCross(Vector2 p, Color col, float size = 1f)
		{
			size *= 0.5f;
			UnityEngine.Debug.DrawLine(new Vector3(p.x, 0f, p.y) - Vector3.right * size, new Vector3(p.x, 0f, p.y) + Vector3.right * size, col);
			UnityEngine.Debug.DrawLine(new Vector3(p.x, 0f, p.y) - Vector3.forward * size, new Vector3(p.x, 0f, p.y) + Vector3.forward * size, col);
		}

		internal void CalculateVelocity(Simulator.WorkerContext context)
		{
			if (locked)
			{
				newVelocity = Vector2.zero;
				return;
			}
			if (context.vos.Length < neighbours.Count)
			{
				context.vos = new VO[Mathf.Max(context.vos.Length * 2, neighbours.Count)];
			}
			Vector2 b = new Vector2(position.x, position.z);
			VO[] vos = context.vos;
			int num = 0;
			Vector2 a = new Vector2(velocity.x, velocity.z);
			float inverseDt = 1f / agentTimeHorizon;
			Vector2 b2 = default(Vector2);
			for (int i = 0; i < neighbours.Count; i++)
			{
				Agent agent = neighbours[i];
				if (agent != this)
				{
					float num2 = Math.Min(position.y + height, agent.position.y + agent.height);
					float num3 = Math.Max(position.y, agent.position.y);
					if (!(num2 - num3 < 0f))
					{
						Vector3 vector = agent.Velocity;
						b2 = new Vector2(vector.x, agent.velocity.z);
						float num4 = radius + agent.radius;
						Vector2 center = new Vector2(agent.position.x, agent.position.z) - b;
						Vector2 sideChooser = a - b2;
						vos[num] = new VO(center, (a + b2) * 0.5f, num4, sideChooser, inverseDt);
						num++;
					}
				}
			}
			if (DebugDraw)
			{
			}
			float score = float.PositiveInfinity;
			Vector2 zero = Vector2.zero;
			float cutoff = new Vector2(velocity.x, velocity.z).magnitude * simulator.qualityCutoff;
			zero = Trace(vos, num, new Vector2(desiredVelocity.x, desiredVelocity.z), cutoff, out score);
			Vector2 zero2 = Vector2.zero;
			float score2;
			Vector2 vector2 = Trace(vos, num, zero2, cutoff, out score2);
			if (score2 < score)
			{
				zero = vector2;
				score = score2;
			}
			if (DebugDraw)
			{
				DrawCross(zero + b, 1f);
			}
			newVelocity = To3D(Vector2.ClampMagnitude(zero, maxSpeed));
		}

		private static Color Rainbow(float v)
		{
			Color result = new Color(v, 0f, 0f);
			if (result.r > 1f)
			{
				result.g = result.r - 1f;
				result.r = 1f;
			}
			if (result.g > 1f)
			{
				result.b = result.g - 1f;
				result.g = 1f;
			}
			return result;
		}

		private Vector2 Trace(VO[] vos, int voCount, Vector2 p, float cutoff, out float score)
		{
			score = 0f;
			float stepScale = simulator.stepScale;
			for (int i = 0; i < 50; i++)
			{
				float num = 1f - (float)i / 50f;
				num *= stepScale;
				Vector2 zero = Vector2.zero;
				float num2 = 0f;
				for (int j = 0; j < voCount; j++)
				{
					float num3;
					Vector2 vector = vos[j].Sample(p, out num3);
					zero += vector;
					if (num3 > num2)
					{
						num2 = num3;
					}
				}
				Vector2 a = new Vector2(desiredVelocity.x, desiredVelocity.z) - p;
				float val = a.magnitude * DesiredVelocityWeight;
				zero += a * DesiredVelocityScale;
				num2 = (score = Math.Max(num2, val));
				float sqrMagnitude = zero.sqrMagnitude;
				if (sqrMagnitude > 0f)
				{
					zero *= num2 / Mathf.Sqrt(sqrMagnitude);
				}
				zero *= num;
				p += zero;
				if (score < cutoff)
				{
					break;
				}
			}
			return p;
		}

		public static bool IntersectionFactor(Vector2 start1, Vector2 dir1, Vector2 start2, Vector2 dir2, out float factor)
		{
			float num = dir2.y * dir1.x - dir2.x * dir1.y;
			if (num == 0f)
			{
				factor = 0f;
				return false;
			}
			float num2 = dir2.x * (start1.y - start2.y) - dir2.y * (start1.x - start2.x);
			factor = num2 / num;
			return true;
		}
	}
}
namespace Pathfinding.RVO
{
	public class ObstacleVertex
	{
		public bool convex;

		public Vector3 position;

		public Vector2 dir;

		public float height;

		public bool split;

		public bool thin;

		public ObstacleVertex next;

		public ObstacleVertex prev;
	}
	public interface IAgent
	{
		Vector3 InterpolatedPosition
		{
			get;
		}

		Vector3 Position
		{
			get;
			set;
		}

		Vector3 DesiredVelocity
		{
			get;
			set;
		}

		Vector3 Velocity
		{
			get;
			set;
		}

		bool Locked
		{
			get;
			set;
		}

		float Radius
		{
			get;
			set;
		}

		float Height
		{
			get;
			set;
		}

		float MaxSpeed
		{
			get;
			set;
		}

		float NeighbourDist
		{
			get;
			set;
		}

		float AgentTimeHorizon
		{
			get;
			set;
		}

		float ObstacleTimeHorizon
		{
			get;
			set;
		}

		RVOLayer Layer
		{
			get;
			set;
		}

		RVOLayer CollidesWith
		{
			get;
			set;
		}

		bool DebugDraw
		{
			get;
			set;
		}

		int MaxNeighbours
		{
			get;
			set;
		}

		List<ObstacleVertex> NeighbourObstacles
		{
			get;
		}

		void Teleport(Vector3 pos);
	}
	[Flags]
	public enum RVOLayer
	{
		DefaultAgent = 0x1,
		DefaultObstacle = 0x2,
		Layer2 = 0x4,
		Layer3 = 0x8,
		Layer4 = 0x10,
		Layer5 = 0x20,
		Layer6 = 0x40,
		Layer7 = 0x80,
		Layer8 = 0x100,
		Layer9 = 0x200,
		Layer10 = 0x400,
		Layer11 = 0x800,
		Layer12 = 0x1000,
		Layer13 = 0x2000,
		Layer14 = 0x4000,
		Layer15 = 0x8000,
		Layer16 = 0x10000,
		Layer17 = 0x20000,
		Layer18 = 0x40000,
		Layer19 = 0x80000,
		Layer20 = 0x100000,
		Layer21 = 0x200000,
		Layer22 = 0x400000,
		Layer23 = 0x800000,
		Layer24 = 0x1000000,
		Layer25 = 0x2000000,
		Layer26 = 0x4000000,
		Layer27 = 0x8000000,
		Layer28 = 0x10000000,
		Layer29 = 0x20000000,
		Layer30 = 0x40000000
	}
	public class Simulator
	{
		internal class WorkerContext
		{
			public Agent.VO[] vos = new Agent.VO[20];
		}

		private class Worker
		{
			public Thread thread;

			public int start;

			public int end;

			public int task;

			public AutoResetEvent runFlag = new AutoResetEvent(initialState: false);

			public ManualResetEvent waitFlag = new ManualResetEvent(initialState: true);

			public Simulator simulator;

			private bool terminate;

			private WorkerContext context = new WorkerContext();

			public Worker(Simulator sim)
			{
				simulator = sim;
				thread = new Thread(Run);
				thread.IsBackground = true;
				thread.Name = "RVO Simulator Thread";
				thread.Start();
			}

			public void Execute(int task)
			{
				this.task = task;
				waitFlag.Reset();
				runFlag.Set();
			}

			public void WaitOne()
			{
				waitFlag.WaitOne();
			}

			public void Terminate()
			{
				terminate = true;
			}

			public void Run()
			{
				runFlag.WaitOne();
				while (!terminate)
				{
					try
					{
						List<Agent> agents = simulator.GetAgents();
						if (task == 0)
						{
							for (int i = start; i < end; i++)
							{
								agents[i].CalculateNeighbours();
								agents[i].CalculateVelocity(context);
							}
						}
						else if (task == 1)
						{
							for (int j = start; j < end; j++)
							{
								agents[j].Update();
								agents[j].BufferSwitch();
							}
						}
						else
						{
							if (task != 2)
							{
								UnityEngine.Debug.LogError("Invalid Task Number: " + task);
								throw new Exception("Invalid Task Number: " + task);
							}
							simulator.BuildQuadtree();
						}
					}
					catch (Exception message)
					{
						UnityEngine.Debug.LogError(message);
					}
					waitFlag.Set();
					runFlag.WaitOne();
				}
			}
		}

		private bool doubleBuffering = true;

		private float desiredDeltaTime = 0.05f;

		private bool interpolation = true;

		private Worker[] workers;

		private List<Agent> agents;

		private List<ObstacleVertex> obstacles;

		private RVOQuadtree quadtree = new RVOQuadtree();

		public float qualityCutoff = 0.05f;

		public float stepScale = 1.5f;

		private float frameDeltaTime;

		private float deltaTime;

		private float prevDeltaTime;

		private float lastStep = -99999f;

		private float lastFrame;

		private bool doUpdateObstacles;

		private bool doCleanObstacles;

		private int frameTimeBufferIndex;

		private float[] frameTimeBuffer = new float[5];

		private WorkerContext coroutineWorkerContext = new WorkerContext();

		public RVOQuadtree Quadtree => quadtree;

		public float FrameDeltaTime => frameDeltaTime;

		public float DeltaTime => deltaTime;

		public float PrevDeltaTime => prevDeltaTime;

		public bool Multithreading => workers != null && workers.Length > 0;

		public float DesiredDeltaTime
		{
			get
			{
				return desiredDeltaTime;
			}
			set
			{
				desiredDeltaTime = Math.Max(value, 0f);
			}
		}

		public bool Interpolation
		{
			get
			{
				return interpolation;
			}
			set
			{
				interpolation = value;
			}
		}

		public Simulator(int workers, bool doubleBuffering)
		{
			this.workers = new Worker[workers];
			this.doubleBuffering = doubleBuffering;
			for (int i = 0; i < workers; i++)
			{
				this.workers[i] = new Worker(this);
			}
			agents = new List<Agent>();
			obstacles = new List<ObstacleVertex>();
		}

		public List<Agent> GetAgents()
		{
			return agents;
		}

		public List<ObstacleVertex> GetObstacles()
		{
			return obstacles;
		}

		public void ClearAgents()
		{
			if (Multithreading && doubleBuffering)
			{
				for (int i = 0; i < workers.Length; i++)
				{
					workers[i].WaitOne();
				}
			}
			for (int j = 0; j < agents.Count; j++)
			{
				agents[j].simulator = null;
			}
			agents.Clear();
		}

		public void OnDestroy()
		{
			if (workers != null)
			{
				for (int i = 0; i < workers.Length; i++)
				{
					workers[i].Terminate();
				}
			}
		}

		~Simulator()
		{
			OnDestroy();
		}

		public IAgent AddAgent(IAgent agent)
		{
			if (agent == null)
			{
				throw new ArgumentNullException("Agent must not be null");
			}
			Agent agent2 = agent as Agent;
			if (agent2 == null)
			{
				throw new ArgumentException("The agent must be of type Agent. Agent was of type " + agent.GetType());
			}
			if (agent2.simulator != null && agent2.simulator == this)
			{
				throw new ArgumentException("The agent is already in the simulation");
			}
			if (agent2.simulator != null)
			{
				throw new ArgumentException("The agent is already added to another simulation");
			}
			agent2.simulator = this;
			if (Multithreading && doubleBuffering)
			{
				for (int i = 0; i < workers.Length; i++)
				{
					workers[i].WaitOne();
				}
			}
			agents.Add(agent2);
			return agent;
		}

		public IAgent AddAgent(Vector3 position)
		{
			Agent agent = new Agent(position);
			if (Multithreading && doubleBuffering)
			{
				for (int i = 0; i < workers.Length; i++)
				{
					workers[i].WaitOne();
				}
			}
			agents.Add(agent);
			agent.simulator = this;
			return agent;
		}

		public void RemoveAgent(IAgent agent)
		{
			if (agent == null)
			{
				throw new ArgumentNullException("Agent must not be null");
			}
			Agent agent2 = agent as Agent;
			if (agent2 == null)
			{
				throw new ArgumentException("The agent must be of type Agent. Agent was of type " + agent.GetType());
			}
			if (agent2.simulator != this)
			{
				throw new ArgumentException("The agent is not added to this simulation");
			}
			if (Multithreading && doubleBuffering)
			{
				for (int i = 0; i < workers.Length; i++)
				{
					workers[i].WaitOne();
				}
			}
			agent2.simulator = null;
			if (!agents.Remove(agent2))
			{
				throw new ArgumentException("Critical Bug! This should not happen. Please report this.");
			}
		}

		public ObstacleVertex AddObstacle(ObstacleVertex v)
		{
			if (v == null)
			{
				throw new ArgumentNullException("Obstacle must not be null");
			}
			if (Multithreading && doubleBuffering)
			{
				for (int i = 0; i < workers.Length; i++)
				{
					workers[i].WaitOne();
				}
			}
			obstacles.Add(v);
			UpdateObstacles();
			return v;
		}

		public ObstacleVertex AddObstacle(Vector3[] vertices, float height)
		{
			return AddObstacle(vertices, height, Matrix4x4.identity);
		}

		public ObstacleVertex AddObstacle(Vector3[] vertices, float height, Matrix4x4 matrix)
		{
			if (vertices == null)
			{
				throw new ArgumentNullException("Vertices must not be null");
			}
			if (vertices.Length < 2)
			{
				throw new ArgumentException("Less than 2 vertices in an obstacle");
			}
			ObstacleVertex obstacleVertex = null;
			ObstacleVertex obstacleVertex2 = null;
			bool flag = matrix == Matrix4x4.identity;
			if (Multithreading && doubleBuffering)
			{
				for (int i = 0; i < workers.Length; i++)
				{
					workers[i].WaitOne();
				}
			}
			for (int j = 0; j < vertices.Length; j++)
			{
				ObstacleVertex obstacleVertex3 = new ObstacleVertex();
				if (obstacleVertex == null)
				{
					obstacleVertex = obstacleVertex3;
				}
				else
				{
					obstacleVertex2.next = obstacleVertex3;
				}
				obstacleVertex3.prev = obstacleVertex2;
				obstacleVertex3.position = ((!flag) ? matrix.MultiplyPoint3x4(vertices[j]) : vertices[j]);
				obstacleVertex3.height = height;
				obstacleVertex2 = obstacleVertex3;
			}
			obstacleVertex2.next = obstacleVertex;
			obstacleVertex.prev = obstacleVertex2;
			ObstacleVertex obstacleVertex4 = obstacleVertex;
			do
			{
				Vector3 vector = obstacleVertex4.next.position - obstacleVertex4.position;
				obstacleVertex4.dir = new Vector2(vector.x, vector.z).normalized;
				if (vertices.Length == 2)
				{
					obstacleVertex4.convex = true;
				}
				else
				{
					obstacleVertex4.convex = Polygon.IsClockwiseMargin(obstacleVertex4.next.position, obstacleVertex4.position, obstacleVertex4.prev.position);
				}
				obstacleVertex4 = obstacleVertex4.next;
			}
			while (obstacleVertex4 != obstacleVertex);
			obstacles.Add(obstacleVertex);
			UpdateObstacles();
			return obstacleVertex;
		}

		public ObstacleVertex AddObstacle(Vector3 a, Vector3 b, float height)
		{
			ObstacleVertex obstacleVertex = new ObstacleVertex();
			ObstacleVertex obstacleVertex2 = obstacleVertex.prev = new ObstacleVertex();
			obstacleVertex2.prev = obstacleVertex;
			obstacleVertex.next = obstacleVertex2;
			obstacleVertex2.next = obstacleVertex;
			obstacleVertex.position = a;
			obstacleVertex2.position = b;
			obstacleVertex.height = height;
			obstacleVertex2.height = height;
			obstacleVertex.convex = true;
			obstacleVertex2.convex = true;
			obstacleVertex.dir = new Vector2(b.x - a.x, b.z - a.z).normalized;
			obstacleVertex2.dir = -obstacleVertex.dir;
			if (Multithreading && doubleBuffering)
			{
				for (int i = 0; i < workers.Length; i++)
				{
					workers[i].WaitOne();
				}
			}
			obstacles.Add(obstacleVertex);
			UpdateObstacles();
			return obstacleVertex;
		}

		public void UpdateObstacle(ObstacleVertex obstacle, Vector3[] vertices, Matrix4x4 matrix)
		{
			if (vertices == null)
			{
				throw new ArgumentNullException("Vertices must not be null");
			}
			if (obstacle == null)
			{
				throw new ArgumentNullException("Obstacle must not be null");
			}
			if (vertices.Length < 2)
			{
				throw new ArgumentException("Less than 2 vertices in an obstacle");
			}
			if (obstacle.split)
			{
				throw new ArgumentException("Obstacle is not a start vertex. You should only pass those ObstacleVertices got from AddObstacle method calls");
			}
			if (Multithreading && doubleBuffering)
			{
				for (int i = 0; i < workers.Length; i++)
				{
					workers[i].WaitOne();
				}
			}
			int num = 0;
			ObstacleVertex obstacleVertex = obstacle;
			while (true)
			{
				if (obstacleVertex.next.split)
				{
					obstacleVertex.next = obstacleVertex.next.next;
					obstacleVertex.next.prev = obstacleVertex;
					continue;
				}
				if (num >= vertices.Length)
				{
					UnityEngine.Debug.DrawLine(obstacleVertex.prev.position, obstacleVertex.position, Color.red);
					throw new ArgumentException("Obstacle has more vertices than supplied for updating (" + vertices.Length + " supplied)");
				}
				obstacleVertex.position = matrix.MultiplyPoint3x4(vertices[num]);
				num++;
				obstacleVertex = obstacleVertex.next;
				if (obstacleVertex == obstacle)
				{
					break;
				}
			}
			obstacleVertex = obstacle;
			do
			{
				Vector3 vector = obstacleVertex.next.position - obstacleVertex.position;
				obstacleVertex.dir = new Vector2(vector.x, vector.z).normalized;
				if (vertices.Length == 2)
				{
					obstacleVertex.convex = true;
				}
				else
				{
					obstacleVertex.convex = Polygon.IsClockwiseMargin(obstacleVertex.next.position, obstacleVertex.position, obstacleVertex.prev.position);
				}
				obstacleVertex = obstacleVertex.next;
			}
			while (obstacleVertex != obstacle);
			ScheduleCleanObstacles();
			UpdateObstacles();
		}

		private void ScheduleCleanObstacles()
		{
			doCleanObstacles = true;
		}

		private void CleanObstacles()
		{
			for (int i = 0; i < obstacles.Count; i++)
			{
				ObstacleVertex obstacleVertex = obstacles[i];
				ObstacleVertex obstacleVertex2 = obstacleVertex;
				while (true)
				{
					if (obstacleVertex2.next.split)
					{
						obstacleVertex2.next = obstacleVertex2.next.next;
						obstacleVertex2.next.prev = obstacleVertex2;
						continue;
					}
					obstacleVertex2 = obstacleVertex2.next;
					if (obstacleVertex2 == obstacleVertex)
					{
						break;
					}
				}
			}
		}

		public void RemoveObstacle(ObstacleVertex v)
		{
			if (v == null)
			{
				throw new ArgumentNullException("Vertex must not be null");
			}
			if (Multithreading && doubleBuffering)
			{
				for (int i = 0; i < workers.Length; i++)
				{
					workers[i].WaitOne();
				}
			}
			obstacles.Remove(v);
			UpdateObstacles();
		}

		public void UpdateObstacles()
		{
			doUpdateObstacles = true;
		}

		private void BuildQuadtree()
		{
			quadtree.Clear();
			if (agents.Count > 0)
			{
				Rect bounds = Rect.MinMaxRect(agents[0].position.x, agents[0].position.y, agents[0].position.x, agents[0].position.y);
				for (int i = 1; i < agents.Count; i++)
				{
					Vector3 position = agents[i].position;
					bounds = Rect.MinMaxRect(Mathf.Min(bounds.xMin, position.x), Mathf.Min(bounds.yMin, position.z), Mathf.Max(bounds.xMax, position.x), Mathf.Max(bounds.yMax, position.z));
				}
				quadtree.SetBounds(bounds);
				for (int j = 0; j < agents.Count; j++)
				{
					quadtree.Insert(agents[j]);
				}
			}
		}

		public void Update()
		{
			if (lastStep < 0f)
			{
				lastStep = Time.time;
				deltaTime = DesiredDeltaTime;
			}
			if (Time.time - lastStep > DesiredDeltaTime)
			{
				prevDeltaTime = DeltaTime;
				deltaTime = Time.time - lastStep;
				lastStep = Time.time;
				frameTimeBufferIndex++;
				frameTimeBufferIndex %= frameTimeBuffer.Length;
				frameTimeBuffer[frameTimeBufferIndex] = deltaTime;
				float num = 0f;
				for (int i = 0; i < frameTimeBuffer.Length; i++)
				{
					num += frameTimeBuffer[i];
				}
				num = (deltaTime = num / (float)frameTimeBuffer.Length);
				deltaTime = Math.Max(deltaTime, 0.0005f);
				frameDeltaTime = DeltaTime;
				if (Multithreading)
				{
					if (doubleBuffering)
					{
						for (int j = 0; j < workers.Length; j++)
						{
							workers[j].WaitOne();
						}
						if (!Interpolation)
						{
							for (int k = 0; k < agents.Count; k++)
							{
								agents[k].Interpolate(1f);
							}
						}
					}
					if (doCleanObstacles)
					{
						CleanObstacles();
						doCleanObstacles = false;
						doUpdateObstacles = true;
					}
					if (doUpdateObstacles)
					{
						doUpdateObstacles = false;
					}
					BuildQuadtree();
					for (int l = 0; l < workers.Length; l++)
					{
						workers[l].start = l * agents.Count / workers.Length;
						workers[l].end = (l + 1) * agents.Count / workers.Length;
					}
					for (int m = 0; m < workers.Length; m++)
					{
						workers[m].Execute(1);
					}
					for (int n = 0; n < workers.Length; n++)
					{
						workers[n].WaitOne();
					}
					for (int num2 = 0; num2 < workers.Length; num2++)
					{
						workers[num2].Execute(0);
					}
					if (!doubleBuffering)
					{
						for (int num3 = 0; num3 < workers.Length; num3++)
						{
							workers[num3].WaitOne();
						}
						if (!Interpolation)
						{
							for (int num4 = 0; num4 < agents.Count; num4++)
							{
								agents[num4].Interpolate(1f);
							}
						}
					}
				}
				else
				{
					if (doCleanObstacles)
					{
						CleanObstacles();
						doCleanObstacles = false;
						doUpdateObstacles = true;
					}
					if (doUpdateObstacles)
					{
						doUpdateObstacles = false;
					}
					BuildQuadtree();
					for (int num5 = 0; num5 < agents.Count; num5++)
					{
						agents[num5].Update();
						agents[num5].BufferSwitch();
					}
					for (int num6 = 0; num6 < agents.Count; num6++)
					{
						agents[num6].CalculateNeighbours();
						agents[num6].CalculateVelocity(coroutineWorkerContext);
					}
					if (!Interpolation)
					{
						for (int num7 = 0; num7 < agents.Count; num7++)
						{
							agents[num7].Interpolate(1f);
						}
					}
				}
			}
			frameDeltaTime = Time.time - lastFrame;
			lastFrame = Time.time;
			if (Interpolation)
			{
				for (int num8 = 0; num8 < agents.Count; num8++)
				{
					agents[num8].Interpolate((Time.time + frameDeltaTime - lastStep) / DeltaTime);
				}
			}
		}
	}
	public struct Line
	{
		public Vector2 point;

		public Vector2 dir;
	}
	public class RVOQuadtree
	{
		private struct Node
		{
			public int child00;

			public int child01;

			public int child10;

			public int child11;

			public byte count;

			public Agent linkedList;

			public void Add(Agent agent)
			{
				agent.next = linkedList;
				linkedList = agent;
			}

			public void Distribute(Node[] nodes, Rect r)
			{
				Vector2 center = r.center;
				while (linkedList != null)
				{
					Agent next = linkedList.next;
					if (linkedList.position.x > center.x)
					{
						if (linkedList.position.z > center.y)
						{
							nodes[child11].Add(linkedList);
						}
						else
						{
							nodes[child10].Add(linkedList);
						}
					}
					else if (linkedList.position.z > center.y)
					{
						nodes[child01].Add(linkedList);
					}
					else
					{
						nodes[child00].Add(linkedList);
					}
					linkedList = next;
				}
				count = 0;
			}
		}

		private const int LeafSize = 15;

		private float maxRadius;

		private Node[] nodes = new Node[42];

		private int filledNodes = 1;

		private Rect bounds;

		public void Clear()
		{
			nodes[0] = default(Node);
			filledNodes = 1;
			maxRadius = 0f;
		}

		public void SetBounds(Rect r)
		{
			bounds = r;
		}

		public int GetNodeIndex()
		{
			if (filledNodes == nodes.Length)
			{
				Node[] array = new Node[nodes.Length * 2];
				for (int i = 0; i < nodes.Length; i++)
				{
					array[i] = nodes[i];
				}
				nodes = array;
			}
			nodes[filledNodes] = default(Node);
			nodes[filledNodes].child00 = filledNodes;
			filledNodes++;
			return filledNodes - 1;
		}

		public void Insert(Agent agent)
		{
			int num = 0;
			Rect r = bounds;
			Vector2 vector = new Vector2(agent.position.x, agent.position.z);
			agent.next = null;
			maxRadius = Math.Max(agent.radius, maxRadius);
			int num2 = 0;
			while (true)
			{
				num2++;
				if (nodes[num].child00 == num)
				{
					if (nodes[num].count < 15 || num2 > 10)
					{
						break;
					}
					Node node = nodes[num];
					node.child00 = GetNodeIndex();
					node.child01 = GetNodeIndex();
					node.child10 = GetNodeIndex();
					node.child11 = GetNodeIndex();
					nodes[num] = node;
					nodes[num].Distribute(nodes, r);
				}
				if (nodes[num].child00 == num)
				{
					continue;
				}
				Vector2 center = r.center;
				if (vector.x > center.x)
				{
					if (vector.y > center.y)
					{
						num = nodes[num].child11;
						r = Rect.MinMaxRect(center.x, center.y, r.xMax, r.yMax);
					}
					else
					{
						num = nodes[num].child10;
						r = Rect.MinMaxRect(center.x, r.yMin, r.xMax, center.y);
					}
				}
				else if (vector.y > center.y)
				{
					num = nodes[num].child01;
					r = Rect.MinMaxRect(r.xMin, center.y, center.x, r.yMax);
				}
				else
				{
					num = nodes[num].child00;
					r = Rect.MinMaxRect(r.xMin, r.yMin, center.x, center.y);
				}
			}
			nodes[num].Add(agent);
			nodes[num].count++;
		}

		public void Query(Vector2 p, float radius, Agent agent)
		{
			QueryRec(0, p, radius, agent, bounds);
		}

		private float QueryRec(int i, Vector2 p, float radius, Agent agent, Rect r)
		{
			if (nodes[i].child00 == i)
			{
				for (Agent agent2 = nodes[i].linkedList; agent2 != null; agent2 = agent2.next)
				{
					float num = agent.InsertAgentNeighbour(agent2, radius * radius);
					if (num < radius * radius)
					{
						radius = Mathf.Sqrt(num);
					}
				}
			}
			else
			{
				Vector2 center = r.center;
				if (p.x - radius < center.x)
				{
					if (p.y - radius < center.y)
					{
						radius = QueryRec(nodes[i].child00, p, radius, agent, Rect.MinMaxRect(r.xMin, r.yMin, center.x, center.y));
					}
					if (p.y + radius > center.y)
					{
						radius = QueryRec(nodes[i].child01, p, radius, agent, Rect.MinMaxRect(r.xMin, center.y, center.x, r.yMax));
					}
				}
				if (p.x + radius > center.x)
				{
					if (p.y - radius < center.y)
					{
						radius = QueryRec(nodes[i].child10, p, radius, agent, Rect.MinMaxRect(center.x, r.yMin, r.xMax, center.y));
					}
					if (p.y + radius > center.y)
					{
						radius = QueryRec(nodes[i].child11, p, radius, agent, Rect.MinMaxRect(center.x, center.y, r.xMax, r.yMax));
					}
				}
			}
			return radius;
		}

		public void DebugDraw()
		{
			DebugDrawRec(0, bounds);
		}

		private void DebugDrawRec(int i, Rect r)
		{
			UnityEngine.Debug.DrawLine(new Vector3(r.xMin, 0f, r.yMin), new Vector3(r.xMax, 0f, r.yMin), Color.white);
			UnityEngine.Debug.DrawLine(new Vector3(r.xMax, 0f, r.yMin), new Vector3(r.xMax, 0f, r.yMax), Color.white);
			UnityEngine.Debug.DrawLine(new Vector3(r.xMax, 0f, r.yMax), new Vector3(r.xMin, 0f, r.yMax), Color.white);
			UnityEngine.Debug.DrawLine(new Vector3(r.xMin, 0f, r.yMax), new Vector3(r.xMin, 0f, r.yMin), Color.white);
			if (nodes[i].child00 != i)
			{
				Vector2 center = r.center;
				DebugDrawRec(nodes[i].child11, Rect.MinMaxRect(center.x, center.y, r.xMax, r.yMax));
				DebugDrawRec(nodes[i].child10, Rect.MinMaxRect(center.x, r.yMin, r.xMax, center.y));
				DebugDrawRec(nodes[i].child01, Rect.MinMaxRect(r.xMin, center.y, center.x, r.yMax));
				DebugDrawRec(nodes[i].child00, Rect.MinMaxRect(r.xMin, r.yMin, center.x, center.y));
			}
			for (Agent agent = nodes[i].linkedList; agent != null; agent = agent.next)
			{
				UnityEngine.Debug.DrawLine(nodes[i].linkedList.position + Vector3.up, agent.position + Vector3.up, new Color(1f, 1f, 0f, 0.5f));
			}
		}
	}
}
namespace Pathfinding.Serialization
{
	public class UnityObjectConverter : JsonConverter
	{
		public override bool CanConvert(Type type)
		{
			return typeof(UnityEngine.Object).IsAssignableFrom(type);
		}

		public override object ReadJson(Type objectType, Dictionary<string, object> values)
		{
			if (values == null)
			{
				return null;
			}
			string text = (string)values["Name"];
			string text2 = (string)values["Type"];
			Type type = Type.GetType(text2);
			if (object.Equals(type, null))
			{
				UnityEngine.Debug.LogError("Could not find type '" + text2 + "'. Cannot deserialize Unity reference");
				return null;
			}
			if (values.ContainsKey("GUID"))
			{
				string b = (string)values["GUID"];
				UnityReferenceHelper[] array = UnityEngine.Object.FindObjectsOfType(typeof(UnityReferenceHelper)) as UnityReferenceHelper[];
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i].GetGUID() == b)
					{
						if (object.Equals(type, typeof(GameObject)))
						{
							return array[i].gameObject;
						}
						return array[i].GetComponent(type);
					}
				}
			}
			UnityEngine.Object[] array2 = Resources.LoadAll(text, type);
			for (int j = 0; j < array2.Length; j++)
			{
				if (array2[j].name == text || array2.Length == 1)
				{
					return array2[j];
				}
			}
			return null;
		}

		public override Dictionary<string, object> WriteJson(Type type, object value)
		{
			UnityEngine.Object @object = (UnityEngine.Object)value;
			Dictionary<string, object> dictionary = new Dictionary<string, object>();
			dictionary.Add("InstanceID", @object.GetInstanceID());
			dictionary.Add("Name", @object.name);
			dictionary.Add("Type", @object.GetType().AssemblyQualifiedName);
			UnityEngine.Component component = value as UnityEngine.Component;
			GameObject gameObject = value as GameObject;
			if (component != null || gameObject != null)
			{
				if (component != null && gameObject == null)
				{
					gameObject = component.gameObject;
				}
				UnityReferenceHelper unityReferenceHelper = gameObject.GetComponent<UnityReferenceHelper>();
				if (unityReferenceHelper == null)
				{
					UnityEngine.Debug.Log("Adding UnityReferenceHelper to Unity Reference '" + @object.name + "'");
					unityReferenceHelper = gameObject.AddComponent<UnityReferenceHelper>();
				}
				unityReferenceHelper.Reset();
				dictionary.Add("GUID", unityReferenceHelper.GetGUID());
			}
			return dictionary;
		}
	}
	public class GuidConverter : JsonConverter
	{
		public override bool CanConvert(Type type)
		{
			return object.Equals(type, typeof(Pathfinding.Util.Guid));
		}

		public override object ReadJson(Type objectType, Dictionary<string, object> values)
		{
			string str = (string)values["value"];
			return new Pathfinding.Util.Guid(str);
		}

		public override Dictionary<string, object> WriteJson(Type type, object value)
		{
			Pathfinding.Util.Guid guid = (Pathfinding.Util.Guid)value;
			Dictionary<string, object> dictionary = new Dictionary<string, object>();
			dictionary.Add("value", guid.ToString());
			return dictionary;
		}
	}
	public class MatrixConverter : JsonConverter
	{
		private float[] values = new float[16];

		public override bool CanConvert(Type type)
		{
			return object.Equals(type, typeof(Matrix4x4));
		}

		public override object ReadJson(Type objectType, Dictionary<string, object> values)
		{
			Matrix4x4 matrix4x = default(Matrix4x4);
			Array array = (Array)values["values"];
			if (array.Length != 16)
			{
				UnityEngine.Debug.LogError("Number of elements in matrix was not 16 (got " + array.Length + ")");
				return matrix4x;
			}
			for (int i = 0; i < 16; i++)
			{
				matrix4x[i] = Convert.ToSingle(array.GetValue(new int[1]
				{
					i
				}));
			}
			return matrix4x;
		}

		public override Dictionary<string, object> WriteJson(Type type, object value)
		{
			Matrix4x4 matrix4x = (Matrix4x4)value;
			for (int i = 0; i < values.Length; i++)
			{
				values[i] = matrix4x[i];
			}
			Dictionary<string, object> dictionary = new Dictionary<string, object>();
			dictionary.Add("values", values);
			return dictionary;
		}
	}
	public class BoundsConverter : JsonConverter
	{
		public override bool CanConvert(Type type)
		{
			return object.Equals(type, typeof(Bounds));
		}

		public override object ReadJson(Type objectType, Dictionary<string, object> values)
		{
			Bounds bounds = default(Bounds);
			bounds.center = new Vector3(CastFloat(values["cx"]), CastFloat(values["cy"]), CastFloat(values["cz"]));
			bounds.extents = new Vector3(CastFloat(values["ex"]), CastFloat(values["ey"]), CastFloat(values["ez"]));
			return bounds;
		}

		public override Dictionary<string, object> WriteJson(Type type, object value)
		{
			Bounds bounds = (Bounds)value;
			Dictionary<string, object> dictionary = new Dictionary<string, object>();
			Vector3 center = bounds.center;
			dictionary.Add("cx", center.x);
			Vector3 center2 = bounds.center;
			dictionary.Add("cy", center2.y);
			Vector3 center3 = bounds.center;
			dictionary.Add("cz", center3.z);
			Vector3 extents = bounds.extents;
			dictionary.Add("ex", extents.x);
			Vector3 extents2 = bounds.extents;
			dictionary.Add("ey", extents2.y);
			Vector3 extents3 = bounds.extents;
			dictionary.Add("ez", extents3.z);
			return dictionary;
		}
	}
	public class LayerMaskConverter : JsonConverter
	{
		public override bool CanConvert(Type type)
		{
			return object.Equals(type, typeof(LayerMask));
		}

		public override object ReadJson(Type type, Dictionary<string, object> values)
		{
			return (LayerMask)(int)values["value"];
		}

		public override Dictionary<string, object> WriteJson(Type type, object value)
		{
			Dictionary<string, object> dictionary = new Dictionary<string, object>();
			dictionary.Add("value", ((LayerMask)value).value);
			return dictionary;
		}
	}
	public class VectorConverter : JsonConverter
	{
		public override bool CanConvert(Type type)
		{
			return object.Equals(type, typeof(Vector2)) || object.Equals(type, typeof(Vector3)) || object.Equals(type, typeof(Vector4));
		}

		public override object ReadJson(Type type, Dictionary<string, object> values)
		{
			if (object.Equals(type, typeof(Vector2)))
			{
				return new Vector2(CastFloat(values["x"]), CastFloat(values["y"]));
			}
			if (object.Equals(type, typeof(Vector3)))
			{
				return new Vector3(CastFloat(values["x"]), CastFloat(values["y"]), CastFloat(values["z"]));
			}
			if (object.Equals(type, typeof(Vector4)))
			{
				return new Vector4(CastFloat(values["x"]), CastFloat(values["y"]), CastFloat(values["z"]), CastFloat(values["w"]));
			}
			throw new NotImplementedException("Can only read Vector2,3,4. Not objects of type " + type);
		}

		public override Dictionary<string, object> WriteJson(Type type, object value)
		{
			if (object.Equals(type, typeof(Vector2)))
			{
				Vector2 vector = (Vector2)value;
				Dictionary<string, object> dictionary = new Dictionary<string, object>();
				dictionary.Add("x", vector.x);
				dictionary.Add("y", vector.y);
				return dictionary;
			}
			if (object.Equals(type, typeof(Vector3)))
			{
				Vector3 vector2 = (Vector3)value;
				Dictionary<string, object> dictionary = new Dictionary<string, object>();
				dictionary.Add("x", vector2.x);
				dictionary.Add("y", vector2.y);
				dictionary.Add("z", vector2.z);
				return dictionary;
			}
			if (object.Equals(type, typeof(Vector4)))
			{
				Vector4 vector3 = (Vector4)value;
				Dictionary<string, object> dictionary = new Dictionary<string, object>();
				dictionary.Add("x", vector3.x);
				dictionary.Add("y", vector3.y);
				dictionary.Add("z", vector3.z);
				dictionary.Add("w", vector3.w);
				return dictionary;
			}
			throw new NotImplementedException("Can only write Vector2,3,4. Not objects of type " + type);
		}
	}
	public class IntKeyDictionaryConverter : JsonConverter
	{
		public override bool CanConvert(Type type)
		{
			return object.Equals(type, typeof(Dictionary<int, int>)) || object.Equals(type, typeof(SortedDictionary<int, int>));
		}

		public override object ReadJson(Type type, Dictionary<string, object> values)
		{
			Dictionary<int, int> dictionary = new Dictionary<int, int>();
			foreach (KeyValuePair<string, object> value in values)
			{
				dictionary.Add(Convert.ToInt32(value.Key), Convert.ToInt32(value.Value));
			}
			return dictionary;
		}

		public override Dictionary<string, object> WriteJson(Type type, object value)
		{
			Dictionary<string, object> dictionary = new Dictionary<string, object>();
			Dictionary<int, int> dictionary2 = (Dictionary<int, int>)value;
			foreach (KeyValuePair<int, int> item in dictionary2)
			{
				dictionary.Add(item.Key.ToString(), item.Value);
			}
			return dictionary;
		}
	}
	public class GraphSerializationContext
	{
		private readonly GraphNode[] id2NodeMapping;

		public readonly System.IO.BinaryReader reader;

		public readonly System.IO.BinaryWriter writer;

		public readonly int graphIndex;

		public GraphSerializationContext(System.IO.BinaryReader reader, GraphNode[] id2NodeMapping, int graphIndex)
		{
			this.reader = reader;
			this.id2NodeMapping = id2NodeMapping;
			this.graphIndex = graphIndex;
		}

		public GraphSerializationContext(System.IO.BinaryWriter writer)
		{
			this.writer = writer;
		}

		public int GetNodeIdentifier(GraphNode node)
		{
			return node?.NodeIndex ?? (-1);
		}

		public GraphNode GetNodeFromIdentifier(int id)
		{
			if (id2NodeMapping == null)
			{
				throw new Exception("Calling GetNodeFromIdentifier when serializing");
			}
			if (id == -1)
			{
				return null;
			}
			GraphNode graphNode = id2NodeMapping[id];
			if (graphNode == null)
			{
				throw new Exception("Invalid id");
			}
			return graphNode;
		}
	}
	public class AstarSerializer
	{
		private const string binaryExt = ".binary";

		private const string jsonExt = ".json";

		private AstarData data;

		public JsonWriterSettings writerSettings;

		public JsonReaderSettings readerSettings;

		private ZipFile zip;

		private MemoryStream str;

		private GraphMeta meta;

		private SerializeSettings settings;

		private NavGraph[] graphs;

		private uint checksum = uint.MaxValue;

		private UTF8Encoding encoding = new UTF8Encoding();

		private static StringBuilder _stringBuilder = new StringBuilder();

		public AstarSerializer(AstarData data)
		{
			this.data = data;
			settings = SerializeSettings.Settings;
		}

		public AstarSerializer(AstarData data, SerializeSettings settings)
		{
			this.data = data;
			this.settings = settings;
		}

		private static StringBuilder GetStringBuilder()
		{
			_stringBuilder.Length = 0;
			return _stringBuilder;
		}

		public void AddChecksum(byte[] bytes)
		{
			checksum = Checksum.GetChecksum(bytes, checksum);
		}

		public uint GetChecksum()
		{
			return checksum;
		}

		public void OpenSerialize()
		{
			zip = new ZipFile();
			zip.AlternateEncoding = Encoding.UTF8;
			zip.AlternateEncodingUsage = ZipOption.Always;
			writerSettings = new JsonWriterSettings();
			writerSettings.AddTypeConverter(new VectorConverter());
			writerSettings.AddTypeConverter(new BoundsConverter());
			writerSettings.AddTypeConverter(new LayerMaskConverter());
			writerSettings.AddTypeConverter(new MatrixConverter());
			writerSettings.AddTypeConverter(new GuidConverter());
			writerSettings.AddTypeConverter(new UnityObjectConverter());
			writerSettings.PrettyPrint = settings.prettyPrint;
			meta = new GraphMeta();
		}

		public byte[] CloseSerialize()
		{
			byte[] array = SerializeMeta();
			AddChecksum(array);
			zip.AddEntry("meta.json", array);
			MemoryStream memoryStream = new MemoryStream();
			zip.Save(memoryStream);
			array = memoryStream.ToArray();
			memoryStream.Dispose();
			zip.Dispose();
			zip = null;
			return array;
		}

		public void SerializeGraphs(NavGraph[] _graphs)
		{
			if (graphs != null)
			{
				throw new InvalidOperationException("Cannot serialize graphs multiple times.");
			}
			graphs = _graphs;
			if (zip == null)
			{
				throw new NullReferenceException("You must not call CloseSerialize before a call to this function");
			}
			if (graphs == null)
			{
				graphs = new NavGraph[0];
			}
			for (int i = 0; i < graphs.Length; i++)
			{
				if (graphs[i] != null)
				{
					byte[] array = Serialize(graphs[i]);
					AddChecksum(array);
					zip.AddEntry("graph" + i + ".json", array);
				}
			}
		}

		public void SerializeUserConnections(UserConnection[] conns)
		{
			if (conns == null)
			{
				conns = new UserConnection[0];
			}
			StringBuilder stringBuilder = GetStringBuilder();
			JsonWriter jsonWriter = new JsonWriter(stringBuilder, writerSettings);
			jsonWriter.Write(conns);
			byte[] bytes = encoding.GetBytes(stringBuilder.ToString());
			stringBuilder = null;
			if (bytes.Length > 2)
			{
				AddChecksum(bytes);
				zip.AddEntry("connections.json", bytes);
			}
		}

		private byte[] SerializeMeta()
		{
			meta.version = AstarPath.Version;
			meta.graphs = data.graphs.Length;
			meta.guids = new string[data.graphs.Length];
			meta.typeNames = new string[data.graphs.Length];
			meta.nodeCounts = new int[data.graphs.Length];
			for (int i = 0; i < data.graphs.Length; i++)
			{
				if (data.graphs[i] != null)
				{
					meta.guids[i] = data.graphs[i].guid.ToString();
					meta.typeNames[i] = data.graphs[i].GetType().FullName;
				}
			}
			StringBuilder stringBuilder = GetStringBuilder();
			JsonWriter jsonWriter = new JsonWriter(stringBuilder, writerSettings);
			jsonWriter.Write(meta);
			return encoding.GetBytes(stringBuilder.ToString());
		}

		public byte[] Serialize(NavGraph graph)
		{
			StringBuilder stringBuilder = GetStringBuilder();
			JsonWriter jsonWriter = new JsonWriter(stringBuilder, writerSettings);
			jsonWriter.Write(graph);
			return encoding.GetBytes(stringBuilder.ToString());
		}

		public void SerializeNodes()
		{
			if (settings.nodes)
			{
				if (graphs == null)
				{
					throw new InvalidOperationException("Cannot serialize nodes with no serialized graphs (call SerializeGraphs first)");
				}
				for (int i = 0; i < graphs.Length; i++)
				{
					byte[] array = SerializeNodes(i);
					AddChecksum(array);
					zip.AddEntry("graph" + i + "_nodes.binary", array);
				}
				for (int j = 0; j < graphs.Length; j++)
				{
					byte[] array2 = SerializeNodeConnections(j);
					AddChecksum(array2);
					zip.AddEntry("graph" + j + "_conns.binary", array2);
				}
			}
		}

		private byte[] SerializeNodes(int index)
		{
			return new byte[0];
		}

		public void SerializeExtraInfo()
		{
			if (!settings.nodes)
			{
				return;
			}
			int totCount = 0;
			for (int i = 0; i < graphs.Length; i++)
			{
				if (graphs[i] != null)
				{
					graphs[i].GetNodes(delegate(GraphNode node)
					{
						totCount = Math.Max(node.NodeIndex, totCount);
						if (node.NodeIndex == -1)
						{
							UnityEngine.Debug.LogError("Graph contains destroyed nodes. This is a bug.");
						}
						return true;
					});
				}
			}
			MemoryStream memoryStream = new MemoryStream();
			System.IO.BinaryWriter wr = new System.IO.BinaryWriter(memoryStream);
			wr.Write(totCount);
			int c = 0;
			for (int j = 0; j < graphs.Length; j++)
			{
				if (graphs[j] != null)
				{
					graphs[j].GetNodes(delegate(GraphNode node)
					{
						c = Math.Max(node.NodeIndex, c);
						wr.Write(node.NodeIndex);
						return true;
					});
				}
			}
			if (c != totCount)
			{
				throw new Exception("Some graphs are not consistent in their GetNodes calls, sequential calls give different results.");
			}
			byte[] array = memoryStream.ToArray();
			wr.Close();
			AddChecksum(array);
			zip.AddEntry("graph_references.binary", array);
			for (int k = 0; k < graphs.Length; k++)
			{
				if (graphs[k] != null)
				{
					MemoryStream memoryStream2 = new MemoryStream();
					System.IO.BinaryWriter binaryWriter = new System.IO.BinaryWriter(memoryStream2);
					GraphSerializationContext ctx = new GraphSerializationContext(binaryWriter);
					graphs[k].SerializeExtraInfo(ctx);
					byte[] array2 = memoryStream2.ToArray();
					binaryWriter.Close();
					AddChecksum(array2);
					zip.AddEntry("graph" + k + "_extra.binary", array2);
					memoryStream2 = new MemoryStream();
					binaryWriter = new System.IO.BinaryWriter(memoryStream2);
					ctx = new GraphSerializationContext(binaryWriter);
					graphs[k].GetNodes(delegate(GraphNode node)
					{
						node.SerializeReferences(ctx);
						return true;
					});
					binaryWriter.Close();
					array2 = memoryStream2.ToArray();
					AddChecksum(array2);
					zip.AddEntry("graph" + k + "_references.binary", array2);
				}
			}
		}

		private byte[] SerializeNodeConnections(int index)
		{
			return new byte[0];
		}

		public void SerializeEditorSettings(GraphEditorBase[] editors)
		{
			if (editors == null || !settings.editorSettings)
			{
				return;
			}
			for (int i = 0; i < editors.Length && editors[i] != null; i++)
			{
				StringBuilder stringBuilder = GetStringBuilder();
				JsonWriter jsonWriter = new JsonWriter(stringBuilder, writerSettings);
				jsonWriter.Write(editors[i]);
				byte[] bytes = encoding.GetBytes(stringBuilder.ToString());
				if (bytes.Length > 2)
				{
					AddChecksum(bytes);
					zip.AddEntry("graph" + i + "_editor.json", bytes);
				}
			}
		}

		public bool OpenDeserialize(byte[] bytes)
		{
			//Discarded unreachable code: IL_00cc
			readerSettings = new JsonReaderSettings();
			readerSettings.AddTypeConverter(new VectorConverter());
			readerSettings.AddTypeConverter(new BoundsConverter());
			readerSettings.AddTypeConverter(new LayerMaskConverter());
			readerSettings.AddTypeConverter(new MatrixConverter());
			readerSettings.AddTypeConverter(new GuidConverter());
			readerSettings.AddTypeConverter(new UnityObjectConverter());
			str = new MemoryStream();
			str.Write(bytes, 0, bytes.Length);
			str.Position = 0L;
			try
			{
				zip = ZipFile.Read(str);
			}
			catch (Exception arg)
			{
				UnityEngine.Debug.LogWarning("Caught exception when loading from zip\n" + arg);
				str.Dispose();
				return false;
			}
			meta = DeserializeMeta(zip["meta.json"]);
			if (meta.version > AstarPath.Version)
			{
				UnityEngine.Debug.LogWarning("Trying to load data from a newer version of the A* Pathfinding Project\nCurrent version: " + AstarPath.Version + " Data version: " + meta.version);
			}
			else if (meta.version < AstarPath.Version)
			{
				UnityEngine.Debug.LogWarning("Trying to load data from an older version of the A* Pathfinding Project\nCurrent version: " + AstarPath.Version + " Data version: " + meta.version + "\nThis is usually fine, it just means you have upgraded to a new version.\nHowever node data (not settings) can get corrupted between versions, so it is recommendedto recalculate any caches (those for faster startup) and resave any files. Even if it seems to load fine, it might cause subtle bugs.\n");
			}
			return true;
		}

		public void CloseDeserialize()
		{
			str.Dispose();
			zip.Dispose();
			zip = null;
			str = null;
		}

		public NavGraph[] DeserializeGraphs()
		{
			graphs = new NavGraph[meta.graphs];
			int num = 0;
			for (int i = 0; i < meta.graphs; i++)
			{
				Type graphType = meta.GetGraphType(i);
				if (!object.Equals(graphType, null))
				{
					num++;
					ZipEntry zipEntry = zip["graph" + i + ".json"];
					if (zipEntry == null)
					{
						throw new FileNotFoundException("Could not find data for graph " + i + " in zip. Entry 'graph+" + i + ".json' does not exist");
					}
					NavGraph obj = data.CreateGraph(graphType);
					string @string = GetString(zipEntry);
					JsonReader jsonReader = new JsonReader(@string, readerSettings);
					jsonReader.PopulateObject(ref obj);
					graphs[i] = obj;
					if (graphs[i].guid.ToString() != meta.guids[i])
					{
						throw new Exception("Guid in graph file not equal to guid defined in meta file. Have you edited the data manually?\n" + graphs[i].guid.ToString() + " != " + meta.guids[i]);
					}
				}
			}
			NavGraph[] array = new NavGraph[num];
			num = 0;
			for (int j = 0; j < graphs.Length; j++)
			{
				if (graphs[j] != null)
				{
					array[num] = graphs[j];
					num++;
				}
			}
			graphs = array;
			return graphs;
		}

		public UserConnection[] DeserializeUserConnections()
		{
			ZipEntry zipEntry = zip["connections.json"];
			if (zipEntry == null)
			{
				return new UserConnection[0];
			}
			string @string = GetString(zipEntry);
			JsonReader jsonReader = new JsonReader(@string, readerSettings);
			return (UserConnection[])jsonReader.Deserialize(typeof(UserConnection[]));
		}

		public void DeserializeNodes()
		{
			for (int i = 0; i < graphs.Length; i++)
			{
				if (graphs[i] == null || zip.ContainsEntry("graph" + i + "_nodes.binary"))
				{
				}
			}
			for (int j = 0; j < graphs.Length; j++)
			{
				if (graphs[j] != null)
				{
					ZipEntry zipEntry = zip["graph" + j + "_nodes.binary"];
					if (zipEntry != null)
					{
						MemoryStream memoryStream = new MemoryStream();
						zipEntry.Extract(memoryStream);
						memoryStream.Position = 0L;
						System.IO.BinaryReader reader = new System.IO.BinaryReader(memoryStream);
						DeserializeNodes(j, reader);
					}
				}
			}
			for (int k = 0; k < graphs.Length; k++)
			{
				if (graphs[k] != null)
				{
					ZipEntry zipEntry2 = zip["graph" + k + "_conns.binary"];
					if (zipEntry2 != null)
					{
						MemoryStream memoryStream2 = new MemoryStream();
						zipEntry2.Extract(memoryStream2);
						memoryStream2.Position = 0L;
						System.IO.BinaryReader reader2 = new System.IO.BinaryReader(memoryStream2);
						DeserializeNodeConnections(k, reader2);
					}
				}
			}
		}

		public void DeserializeExtraInfo()
		{
			//Discarded unreachable code: IL_01b4
			bool flag = false;
			for (int i = 0; i < graphs.Length; i++)
			{
				ZipEntry zipEntry = zip["graph" + i + "_extra.binary"];
				if (zipEntry != null)
				{
					flag = true;
					MemoryStream memoryStream = new MemoryStream();
					zipEntry.Extract(memoryStream);
					memoryStream.Seek(0L, SeekOrigin.Begin);
					System.IO.BinaryReader reader2 = new System.IO.BinaryReader(memoryStream);
					GraphSerializationContext ctx2 = new GraphSerializationContext(reader2, null, i);
					graphs[i].DeserializeExtraInfo(ctx2);
				}
			}
			if (!flag)
			{
				return;
			}
			int totCount = 0;
			for (int j = 0; j < graphs.Length; j++)
			{
				if (graphs[j] != null)
				{
					graphs[j].GetNodes(delegate(GraphNode node)
					{
						totCount = Math.Max(node.NodeIndex, totCount);
						if (node.NodeIndex == -1)
						{
							UnityEngine.Debug.LogError("Graph contains destroyed nodes. This is a bug.");
						}
						return true;
					});
				}
			}
			ZipEntry zipEntry2 = zip["graph_references.binary"];
			if (zipEntry2 == null)
			{
				throw new Exception("Node references not found in the data. Was this loaded from an older version of the A* Pathfinding Project?");
			}
			MemoryStream memoryStream2 = new MemoryStream();
			zipEntry2.Extract(memoryStream2);
			memoryStream2.Seek(0L, SeekOrigin.Begin);
			System.IO.BinaryReader reader = new System.IO.BinaryReader(memoryStream2);
			int num = reader.ReadInt32();
			GraphNode[] int2Node = new GraphNode[num + 1];
			try
			{
				for (int k = 0; k < graphs.Length; k++)
				{
					if (graphs[k] != null)
					{
						graphs[k].GetNodes(delegate(GraphNode node)
						{
							int2Node[reader.ReadInt32()] = node;
							return true;
						});
					}
				}
			}
			catch (Exception innerException)
			{
				throw new Exception("Some graph(s) has thrown an exception during GetNodes, or some graph(s) have deserialized more or fewer nodes than were serialized", innerException);
			}
			reader.Close();
			int num2 = 0;
			while (true)
			{
				if (num2 >= graphs.Length)
				{
					return;
				}
				if (graphs[num2] != null)
				{
					zipEntry2 = zip["graph" + num2 + "_references.binary"];
					if (zipEntry2 == null)
					{
						break;
					}
					memoryStream2 = new MemoryStream();
					zipEntry2.Extract(memoryStream2);
					memoryStream2.Seek(0L, SeekOrigin.Begin);
					reader = new System.IO.BinaryReader(memoryStream2);
					GraphSerializationContext ctx = new GraphSerializationContext(reader, int2Node, num2);
					graphs[num2].GetNodes(delegate(GraphNode node)
					{
						node.DeserializeReferences(ctx);
						return true;
					});
				}
				num2++;
			}
			throw new Exception("Node references for graph " + num2 + " not found in the data. Was this loaded from an older version of the A* Pathfinding Project?");
		}

		public void PostDeserialization()
		{
			for (int i = 0; i < graphs.Length; i++)
			{
				if (graphs[i] != null)
				{
					graphs[i].PostDeserialization();
				}
			}
		}

		private void DeserializeNodes(int index, System.IO.BinaryReader reader)
		{
		}

		private void DeserializeNodeConnections(int index, System.IO.BinaryReader reader)
		{
		}

		public void DeserializeEditorSettings(GraphEditorBase[] graphEditors)
		{
			if (graphEditors == null)
			{
				return;
			}
			for (int i = 0; i < graphEditors.Length; i++)
			{
				if (graphEditors[i] == null)
				{
					continue;
				}
				for (int j = 0; j < graphs.Length; j++)
				{
					if (graphs[j] != null && graphEditors[i].target == graphs[j])
					{
						ZipEntry zipEntry = zip["graph" + j + "_editor.json"];
						if (zipEntry != null)
						{
							string @string = GetString(zipEntry);
							JsonReader jsonReader = new JsonReader(@string, readerSettings);
							GraphEditorBase obj = graphEditors[i];
							jsonReader.PopulateObject(ref obj);
							graphEditors[i] = obj;
							break;
						}
					}
				}
			}
		}

		private string GetString(ZipEntry entry)
		{
			MemoryStream memoryStream = new MemoryStream();
			entry.Extract(memoryStream);
			memoryStream.Position = 0L;
			StreamReader streamReader = new StreamReader(memoryStream);
			string result = streamReader.ReadToEnd();
			memoryStream.Position = 0L;
			streamReader.Dispose();
			return result;
		}

		private GraphMeta DeserializeMeta(ZipEntry entry)
		{
			if (entry == null)
			{
				throw new Exception("No metadata found in serialized data.");
			}
			string @string = GetString(entry);
			JsonReader jsonReader = new JsonReader(@string, readerSettings);
			return (GraphMeta)jsonReader.Deserialize(typeof(GraphMeta));
		}

		public static void SaveToFile(string path, byte[] data)
		{
			using (FileStream fileStream = new FileStream(path, FileMode.Create))
			{
				fileStream.Write(data, 0, data.Length);
			}
		}

		public static byte[] LoadFromFile(string path)
		{
			//Discarded unreachable code: IL_002c
			using (FileStream fileStream = new FileStream(path, FileMode.Open))
			{
				byte[] array = new byte[(int)fileStream.Length];
				fileStream.Read(array, 0, (int)fileStream.Length);
				return array;
			}
		}
	}
	internal class GraphMeta
	{
		public System.Version version;

		public int graphs;

		public string[] guids;

		public string[] typeNames;

		public int[] nodeCounts;

		public Type GetGraphType(int i)
		{
			if (typeNames[i] == null)
			{
				return null;
			}
			Type type = Type.GetType(typeNames[i]);
			if (!object.Equals(type, null))
			{
				return type;
			}
			throw new Exception("No graph of type '" + typeNames[i] + "' could be created, type does not exist");
		}
	}
	public class SerializeSettings
	{
		public bool nodes = true;

		public bool prettyPrint;

		public bool editorSettings;

		public static SerializeSettings Settings
		{
			get
			{
				SerializeSettings serializeSettings = new SerializeSettings();
				serializeSettings.nodes = false;
				return serializeSettings;
			}
		}

		public static SerializeSettings All
		{
			get
			{
				SerializeSettings serializeSettings = new SerializeSettings();
				serializeSettings.nodes = true;
				return serializeSettings;
			}
		}
	}
}
namespace Pathfinding
{
	public class UserConnection
	{
		public Vector3 p1;

		public Vector3 p2;

		public ConnectionType type;

		[JsonName("doOverCost")]
		public bool doOverrideCost;

		[JsonName("overCost")]
		public int overrideCost;

		public bool oneWay;

		public bool enable = true;

		public float width;

		[JsonName("doOverWalkable")]
		public bool doOverrideWalkability = true;

		[JsonName("doOverCost")]
		public bool doOverridePenalty;

		[JsonName("overPenalty")]
		public uint overridePenalty;
	}
	[Serializable]
	public class AstarColor
	{
		public Color _NodeConnection;

		public Color _UnwalkableNode;

		public Color _BoundsHandles;

		public Color _ConnectionLowLerp;

		public Color _ConnectionHighLerp;

		public Color _MeshEdgeColor;

		public Color _MeshColor;

		public Color[] _AreaColors;

		public static Color NodeConnection = new Color(1f, 1f, 1f, 0.9f);

		public static Color UnwalkableNode = new Color(1f, 0f, 0f, 0.5f);

		public static Color BoundsHandles = new Color(0.29f, 0.454f, 0.741f, 0.9f);

		public static Color ConnectionLowLerp = new Color(0f, 1f, 0f, 0.5f);

		public static Color ConnectionHighLerp = new Color(1f, 0f, 0f, 0.5f);

		public static Color MeshEdgeColor = new Color(0f, 0f, 0f, 0.5f);

		public static Color MeshColor = new Color(0f, 0f, 0f, 0.5f);

		private static Color[] AreaColors;

		public AstarColor()
		{
			_NodeConnection = new Color(1f, 1f, 1f, 0.9f);
			_UnwalkableNode = new Color(1f, 0f, 0f, 0.5f);
			_BoundsHandles = new Color(0.29f, 0.454f, 0.741f, 0.9f);
			_ConnectionLowLerp = new Color(0f, 1f, 0f, 0.5f);
			_ConnectionHighLerp = new Color(1f, 0f, 0f, 0.5f);
			_MeshEdgeColor = new Color(0f, 0f, 0f, 0.5f);
			_MeshColor = new Color(0.125f, 0.686f, 0f, 0.19f);
		}

		public static Color GetAreaColor(uint area)
		{
			if (AreaColors == null || area >= AreaColors.Length)
			{
				return AstarMath.IntToColor((int)area, 1f);
			}
			return AreaColors[area];
		}

		public void OnEnable()
		{
			NodeConnection = _NodeConnection;
			UnwalkableNode = _UnwalkableNode;
			BoundsHandles = _BoundsHandles;
			ConnectionLowLerp = _ConnectionLowLerp;
			ConnectionHighLerp = _ConnectionHighLerp;
			MeshEdgeColor = _MeshEdgeColor;
			MeshColor = _MeshColor;
			AreaColors = _AreaColors;
		}
	}
	public struct GraphHitInfo
	{
		public Vector3 origin;

		public Vector3 point;

		public GraphNode node;

		public Vector3 tangentOrigin;

		public Vector3 tangent;

		public float distance => (point - origin).magnitude;

		public GraphHitInfo(Vector3 point)
		{
			tangentOrigin = Vector3.zero;
			origin = Vector3.zero;
			this.point = point;
			node = null;
			tangent = Vector3.zero;
		}
	}
	public class NNConstraint
	{
		public int graphMask = -1;

		public bool constrainArea;

		public int area = -1;

		public bool constrainWalkability = true;

		public bool walkable = true;

		public bool distanceXZ;

		public bool constrainTags = true;

		public int tags = -1;

		public bool constrainDistance = true;

		public static NNConstraint Default => new NNConstraint();

		public static NNConstraint None
		{
			get
			{
				NNConstraint nNConstraint = new NNConstraint();
				nNConstraint.constrainWalkability = false;
				nNConstraint.constrainArea = false;
				nNConstraint.constrainTags = false;
				nNConstraint.constrainDistance = false;
				nNConstraint.graphMask = -1;
				return nNConstraint;
			}
		}

		public virtual bool SuitableGraph(int graphIndex, NavGraph graph)
		{
			return ((graphMask >> graphIndex) & 1) != 0;
		}

		public virtual bool Suitable(GraphNode node)
		{
			if (constrainWalkability && node.Walkable != walkable)
			{
				return false;
			}
			if (constrainArea && area >= 0 && node.Area != area)
			{
				return false;
			}
			if (constrainTags && ((tags >> (int)node.Tag) & 1) == 0)
			{
				return false;
			}
			return true;
		}
	}
	public class PathNNConstraint : NNConstraint
	{
		public new static PathNNConstraint Default
		{
			get
			{
				PathNNConstraint pathNNConstraint = new PathNNConstraint();
				pathNNConstraint.constrainArea = true;
				return pathNNConstraint;
			}
		}

		public virtual void SetStart(GraphNode node)
		{
			if (node != null)
			{
				area = (int)node.Area;
			}
			else
			{
				constrainArea = false;
			}
		}
	}
	public struct NNInfo
	{
		public GraphNode node;

		public GraphNode constrainedNode;

		public Vector3 clampedPosition;

		public Vector3 constClampedPosition;

		public NNInfo(GraphNode node)
		{
			this.node = node;
			constrainedNode = null;
			constClampedPosition = Vector3.zero;
			if (node != null)
			{
				clampedPosition = (Vector3)node.position;
			}
			else
			{
				clampedPosition = Vector3.zero;
			}
		}

		public void SetConstrained(GraphNode constrainedNode, Vector3 clampedPosition)
		{
			this.constrainedNode = constrainedNode;
			constClampedPosition = clampedPosition;
		}

		public void UpdateInfo()
		{
			if (node != null)
			{
				clampedPosition = (Vector3)node.position;
			}
			else
			{
				clampedPosition = Vector3.zero;
			}
			if (constrainedNode != null)
			{
				constClampedPosition = (Vector3)constrainedNode.position;
			}
			else
			{
				constClampedPosition = Vector3.zero;
			}
		}

		public static explicit operator Vector3(NNInfo ob)
		{
			return ob.clampedPosition;
		}

		public static explicit operator GraphNode(NNInfo ob)
		{
			return ob.node;
		}

		public static explicit operator NNInfo(GraphNode ob)
		{
			return new NNInfo(ob);
		}
	}
	public struct Progress
	{
		public float progress;

		public string description;

		public Progress(float p, string d)
		{
			progress = p;
			description = d;
		}
	}
	public interface IUpdatableGraph
	{
		void UpdateArea(GraphUpdateObject o);

		void UpdateAreaInit(GraphUpdateObject o);

		GraphUpdateThreading CanUpdateAsync(GraphUpdateObject o);
	}
	[Serializable]
	public class TagMask
	{
		public int tagsChange;

		public int tagsSet;

		public TagMask()
		{
		}

		public TagMask(int change, int set)
		{
			tagsChange = change;
			tagsSet = set;
		}

		public void SetValues(object boxedTagMask)
		{
			TagMask tagMask = (TagMask)boxedTagMask;
			tagsChange = tagMask.tagsChange;
			tagsSet = tagMask.tagsSet;
		}

		public override string ToString()
		{
			return string.Empty + Convert.ToString(tagsChange, 2) + "\n" + Convert.ToString(tagsSet, 2);
		}
	}
	public class GraphUpdateObject
	{
		public Bounds bounds;

		public bool requiresFloodFill = true;

		public bool updatePhysics = true;

		public bool resetPenaltyOnPhysics = true;

		public bool updateErosion = true;

		public NNConstraint nnConstraint = NNConstraint.None;

		public int addPenalty;

		public bool modifyWalkability;

		public bool setWalkability;

		public bool modifyTag;

		public int setTag;

		public bool trackChangedNodes;

		private List<GraphNode> changedNodes;

		private List<ulong> backupData;

		private List<Int3> backupPositionData;

		public GraphUpdateShape shape;

		public GraphUpdateObject()
		{
		}

		public GraphUpdateObject(Bounds b)
		{
			bounds = b;
		}

		public virtual void WillUpdateNode(GraphNode node)
		{
			if (trackChangedNodes && node != null)
			{
				if (changedNodes == null)
				{
					changedNodes = ListPool<GraphNode>.Claim();
					backupData = ListPool<ulong>.Claim();
					backupPositionData = ListPool<Int3>.Claim();
				}
				changedNodes.Add(node);
				backupPositionData.Add(node.position);
				backupData.Add(((ulong)node.Penalty << 32) | node.Flags);
			}
		}

		public virtual void RevertFromBackup()
		{
			if (trackChangedNodes)
			{
				if (changedNodes == null)
				{
					return;
				}
				throw new NotSupportedException("Positions not supported yet");
			}
			throw new InvalidOperationException("Changed nodes have not been tracked, cannot revert from backup");
		}

		public virtual void Apply(GraphNode node)
		{
			if (shape == null || shape.Contains(node))
			{
				node.Penalty = (uint)(node.Penalty + addPenalty);
				if (modifyWalkability)
				{
					node.Walkable = setWalkability;
				}
				if (modifyTag)
				{
					node.Tag = (uint)setTag;
				}
			}
		}
	}
	public interface IRaycastableGraph
	{
		bool Linecast(Vector3 start, Vector3 end);

		bool Linecast(Vector3 start, Vector3 end, GraphNode hint);

		bool Linecast(Vector3 start, Vector3 end, GraphNode hint, out GraphHitInfo hit);

		bool Linecast(Vector3 start, Vector3 end, GraphNode hint, out GraphHitInfo hit, List<GraphNode> trace);
	}
	public struct PathThreadInfo
	{
		public int threadIndex;

		public AstarPath astar;

		public PathHandler runData;

		private object _lock;

		public object Lock => _lock;

		public PathThreadInfo(int index, AstarPath astar, PathHandler runData)
		{
			threadIndex = index;
			this.astar = astar;
			this.runData = runData;
			_lock = new object();
		}
	}
	public struct IntRect
	{
		public int xmin;

		public int ymin;

		public int xmax;

		public int ymax;

		private static readonly int[] Rotations = new int[16]
		{
			1,
			0,
			0,
			1,
			0,
			1,
			-1,
			0,
			-1,
			0,
			0,
			-1,
			0,
			-1,
			1,
			0
		};

		public int Width => xmax - xmin + 1;

		public int Height => ymax - ymin + 1;

		public IntRect(int xmin, int ymin, int xmax, int ymax)
		{
			this.xmin = xmin;
			this.xmax = xmax;
			this.ymin = ymin;
			this.ymax = ymax;
		}

		public bool Contains(int x, int y)
		{
			return x >= xmin && y >= ymin && x <= xmax && y <= ymax;
		}

		public bool IsValid()
		{
			return xmin <= xmax && ymin <= ymax;
		}

		public override bool Equals(object _b)
		{
			IntRect intRect = (IntRect)_b;
			return xmin == intRect.xmin && xmax == intRect.xmax && ymin == intRect.ymin && ymax == intRect.ymax;
		}

		public override int GetHashCode()
		{
			return (xmin * 131071) ^ (xmax * 3571) ^ (ymin * 3109) ^ (ymax * 7);
		}

		public static IntRect Intersection(IntRect a, IntRect b)
		{
			return new IntRect(Math.Max(a.xmin, b.xmin), Math.Max(a.ymin, b.ymin), Math.Min(a.xmax, b.xmax), Math.Min(a.ymax, b.ymax));
		}

		public static bool Intersects(IntRect a, IntRect b)
		{
			return a.xmin <= b.xmax && a.ymin <= b.ymax && a.xmax >= b.xmin && a.ymax >= b.ymin;
		}

		public static IntRect Union(IntRect a, IntRect b)
		{
			return new IntRect(Math.Min(a.xmin, b.xmin), Math.Min(a.ymin, b.ymin), Math.Max(a.xmax, b.xmax), Math.Max(a.ymax, b.ymax));
		}

		public IntRect ExpandToContain(int x, int y)
		{
			return new IntRect(Math.Min(xmin, x), Math.Min(ymin, y), Math.Max(xmax, x), Math.Max(ymax, y));
		}

		public IntRect Expand(int range)
		{
			return new IntRect(xmin - range, ymin - range, xmax + range, ymax + range);
		}

		public IntRect Rotate(int r)
		{
			int num = Rotations[r * 4];
			int num2 = Rotations[r * 4 + 1];
			int num3 = Rotations[r * 4 + 2];
			int num4 = Rotations[r * 4 + 3];
			int val = num * xmin + num2 * ymin;
			int val2 = num3 * xmin + num4 * ymin;
			int val3 = num * xmax + num2 * ymax;
			int val4 = num3 * xmax + num4 * ymax;
			return new IntRect(Math.Min(val, val3), Math.Min(val2, val4), Math.Max(val, val3), Math.Max(val2, val4));
		}

		public IntRect Offset(Int2 offset)
		{
			return new IntRect(xmin + offset.x, ymin + offset.y, xmax + offset.x, ymax + offset.y);
		}

		public IntRect Offset(int x, int y)
		{
			return new IntRect(xmin + x, ymin + y, xmax + x, ymax + y);
		}

		public override string ToString()
		{
			return "[x: " + xmin + "..." + xmax + ", y: " + ymin + "..." + ymax + "]";
		}

		public void DebugDraw(Matrix4x4 matrix, Color col)
		{
			Vector3 vector = matrix.MultiplyPoint3x4(new Vector3(xmin, 0f, ymin));
			Vector3 vector2 = matrix.MultiplyPoint3x4(new Vector3(xmin, 0f, ymax));
			Vector3 vector3 = matrix.MultiplyPoint3x4(new Vector3(xmax, 0f, ymax));
			Vector3 vector4 = matrix.MultiplyPoint3x4(new Vector3(xmax, 0f, ymin));
			UnityEngine.Debug.DrawLine(vector, vector2, col);
			UnityEngine.Debug.DrawLine(vector2, vector3, col);
			UnityEngine.Debug.DrawLine(vector3, vector4, col);
			UnityEngine.Debug.DrawLine(vector4, vector, col);
		}

		public static bool operator ==(IntRect a, IntRect b)
		{
			return a.xmin == b.xmin && a.xmax == b.xmax && a.ymin == b.ymin && a.ymax == b.ymax;
		}

		public static bool operator !=(IntRect a, IntRect b)
		{
			return a.xmin != b.xmin || a.xmax != b.xmax || a.ymin != b.ymin || a.ymax != b.ymax;
		}
	}
}
public enum GraphUpdateThreading
{
	UnityThread,
	SeparateThread,
	SeparateAndUnityInit
}
public enum PathLog
{
	None,
	Normal,
	Heavy,
	InGame,
	OnlyErrors
}
public enum Heuristic
{
	Manhattan,
	DiagonalManhattan,
	Euclidean,
	None
}
public enum GraphDebugMode
{
	Areas,
	G,
	H,
	F,
	Penalty,
	Connections,
	Tags
}
public enum ConnectionType
{
	Connection,
	ModifyNode
}
public enum ThreadCount
{
	AutomaticLowLoad = -1,
	AutomaticHighLoad = -2,
	None = 0,
	One = 1,
	Two = 2,
	Three = 3,
	Four = 4,
	Five = 5,
	Six = 6,
	Seven = 7,
	Eight = 8
}
public enum PathState
{
	Created,
	PathQueue,
	Processing,
	ReturnQueue,
	Returned
}
public enum PathCompleteState
{
	NotCalculated,
	Error,
	Complete,
	Partial
}
namespace Pathfinding
{
	public abstract class NavGraph
	{
		public byte[] _sguid;

		public AstarPath active;

		[JsonMember]
		public uint initialPenalty;

		[JsonMember]
		public bool open;

		public uint graphIndex;

		[JsonMember]
		public string name;

		[JsonMember]
		public bool drawGizmos = true;

		[JsonMember]
		public bool infoScreenOpen;

		[JsonMember]
		public Matrix4x4 matrix;

		public Matrix4x4 inverseMatrix;

		[JsonMember]
		public Pathfinding.Util.Guid guid
		{
			get
			{
				if (_sguid == null || _sguid.Length != 16)
				{
					_sguid = Pathfinding.Util.Guid.NewGuid().ToByteArray();
				}
				return new Pathfinding.Util.Guid(_sguid);
			}
			set
			{
				_sguid = value.ToByteArray();
			}
		}

		public virtual int CountNodes()
		{
			int count = 0;
			GraphNodeDelegateCancelable del = delegate
			{
				count++;
				return true;
			};
			GetNodes(del);
			return count;
		}

		public abstract void GetNodes(GraphNodeDelegateCancelable del);

		public void SetMatrix(Matrix4x4 m)
		{
			matrix = m;
			inverseMatrix = m.inverse;
		}

		public virtual void CreateNodes(int number)
		{
			throw new NotSupportedException();
		}

		public virtual void RelocateNodes(Matrix4x4 oldMatrix, Matrix4x4 newMatrix)
		{
			Matrix4x4 inverse = oldMatrix.inverse;
			Matrix4x4 i = inverse * newMatrix;
			GetNodes(delegate(GraphNode node)
			{
				node.position = (Int3)i.MultiplyPoint((Vector3)node.position);
				return true;
			});
			SetMatrix(newMatrix);
		}

		public NNInfo GetNearest(Vector3 position)
		{
			return GetNearest(position, NNConstraint.None);
		}

		public NNInfo GetNearest(Vector3 position, NNConstraint constraint)
		{
			return GetNearest(position, constraint, null);
		}

		public virtual NNInfo GetNearest(Vector3 position, NNConstraint constraint, GraphNode hint)
		{
			float maxDistSqr = (!constraint.constrainDistance) ? float.PositiveInfinity : AstarPath.active.maxNearestNodeDistanceSqr;
			float minDist = float.PositiveInfinity;
			GraphNode minNode = null;
			float minConstDist = float.PositiveInfinity;
			GraphNode minConstNode = null;
			GetNodes(delegate(GraphNode node)
			{
				float sqrMagnitude = (position - (Vector3)node.position).sqrMagnitude;
				if (sqrMagnitude < minDist)
				{
					minDist = sqrMagnitude;
					minNode = node;
				}
				if (sqrMagnitude < minConstDist && sqrMagnitude < maxDistSqr && constraint.Suitable(node))
				{
					minConstDist = sqrMagnitude;
					minConstNode = node;
				}
				return true;
			});
			NNInfo result = new NNInfo(minNode);
			result.constrainedNode = minConstNode;
			if (minConstNode != null)
			{
				result.constClampedPosition = (Vector3)minConstNode.position;
			}
			else if (minNode != null)
			{
				result.constrainedNode = minNode;
				result.constClampedPosition = (Vector3)minNode.position;
			}
			return result;
		}

		public virtual NNInfo GetNearestForce(Vector3 position, NNConstraint constraint)
		{
			return GetNearest(position, constraint);
		}

		public virtual void Awake()
		{
		}

		public void SafeOnDestroy()
		{
			AstarPath.RegisterSafeUpdate(OnDestroy, threadSafe: false);
		}

		public virtual void OnDestroy()
		{
			GetNodes(delegate(GraphNode node)
			{
				node.Destroy();
				return true;
			});
		}

		public void ScanGraph()
		{
			if (AstarPath.OnPreScan != null)
			{
				AstarPath.OnPreScan(AstarPath.active);
			}
			if (AstarPath.OnGraphPreScan != null)
			{
				AstarPath.OnGraphPreScan(this);
			}
			ScanInternal();
			if (AstarPath.OnGraphPostScan != null)
			{
				AstarPath.OnGraphPostScan(this);
			}
			if (AstarPath.OnPostScan != null)
			{
				AstarPath.OnPostScan(AstarPath.active);
			}
		}

		[Obsolete("Please use AstarPath.active.Scan or if you really want this.ScanInternal which has the same functionality as this method had")]
		public void Scan()
		{
			throw new Exception("This method is deprecated. Please use AstarPath.active.Scan or if you really want this.ScanInternal which has the same functionality as this method had.");
		}

		public void ScanInternal()
		{
			ScanInternal(null);
		}

		public abstract void ScanInternal(OnScanStatus statusCallback);

		public virtual Color NodeColor(GraphNode node, PathHandler data)
		{
			Color result = AstarColor.NodeConnection;
			bool flag = false;
			if (node == null)
			{
				return AstarColor.NodeConnection;
			}
			switch (AstarPath.active.debugMode)
			{
			case GraphDebugMode.Areas:
				result = AstarColor.GetAreaColor(node.Area);
				flag = true;
				break;
			case GraphDebugMode.Penalty:
				result = Color.Lerp(AstarColor.ConnectionLowLerp, AstarColor.ConnectionHighLerp, (float)(double)node.Penalty / AstarPath.active.debugRoof);
				flag = true;
				break;
			case GraphDebugMode.Tags:
				result = AstarMath.IntToColor((int)node.Tag, 0.5f);
				flag = true;
				break;
			}
			if (!flag)
			{
				if (data == null)
				{
					return AstarColor.NodeConnection;
				}
				PathNode pathNode = data.GetPathNode(node);
				switch (AstarPath.active.debugMode)
				{
				case GraphDebugMode.G:
					result = Color.Lerp(AstarColor.ConnectionLowLerp, AstarColor.ConnectionHighLerp, (float)(double)pathNode.G / AstarPath.active.debugRoof);
					break;
				case GraphDebugMode.H:
					result = Color.Lerp(AstarColor.ConnectionLowLerp, AstarColor.ConnectionHighLerp, (float)(double)pathNode.H / AstarPath.active.debugRoof);
					break;
				case GraphDebugMode.F:
					result = Color.Lerp(AstarColor.ConnectionLowLerp, AstarColor.ConnectionHighLerp, (float)(double)pathNode.F / AstarPath.active.debugRoof);
					break;
				}
			}
			result.a *= 0.5f;
			return result;
		}

		public virtual void SerializeExtraInfo(GraphSerializationContext ctx)
		{
		}

		public virtual void DeserializeExtraInfo(GraphSerializationContext ctx)
		{
		}

		public virtual void PostDeserialization()
		{
		}

		public bool InSearchTree(GraphNode node, Path path)
		{
			if (path == null || path.pathHandler == null)
			{
				return true;
			}
			PathNode pathNode = path.pathHandler.GetPathNode(node);
			return pathNode.pathID == path.pathID;
		}

		public virtual void OnDrawGizmos(bool drawNodes)
		{
			if (drawNodes)
			{
				PathHandler data = AstarPath.active.debugPathData;
				GraphNode node = null;
				GraphNodeDelegate del = delegate(GraphNode o)
				{
					Gizmos.DrawLine((Vector3)node.position, (Vector3)o.position);
				};
				GetNodes(delegate(GraphNode _node)
				{
					node = _node;
					Gizmos.color = NodeColor(node, AstarPath.active.debugPathData);
					if (AstarPath.active.showSearchTree && !InSearchTree(node, AstarPath.active.debugPath))
					{
						return true;
					}
					PathNode pathNode = (data == null) ? null : data.GetPathNode(node);
					if (AstarPath.active.showSearchTree && pathNode != null && pathNode.parent != null)
					{
						Gizmos.DrawLine((Vector3)node.position, (Vector3)pathNode.parent.node.position);
					}
					else
					{
						node.GetConnections(del);
					}
					return true;
				});
			}
		}
	}
	[Serializable]
	public class GraphCollision
	{
		public const float RaycastErrorMargin = 0.005f;

		public ColliderType type = ColliderType.Capsule;

		public float diameter = 1f;

		public float height = 2f;

		public float collisionOffset;

		public RayDirection rayDirection = RayDirection.Both;

		public LayerMask mask;

		public LayerMask heightMask = -1;

		public float fromHeight = 100f;

		public bool thickRaycast;

		public float thickRaycastDiameter = 1f;

		public Vector3 up;

		private Vector3 upheight;

		private float finalRadius;

		private float finalRaycastRadius;

		public bool collisionCheck = true;

		public bool heightCheck = true;

		public bool unwalkableWhenNoGround = true;

		public bool use2D;

		public void Initialize(Matrix4x4 matrix, float scale)
		{
			up = matrix.MultiplyVector(Vector3.up);
			upheight = up * height;
			finalRadius = diameter * scale * 0.5f;
			finalRaycastRadius = thickRaycastDiameter * scale * 0.5f;
		}

		public bool Check(Vector3 position)
		{
			if (!collisionCheck)
			{
				return true;
			}
			if (use2D)
			{
				switch (type)
				{
				case ColliderType.Capsule:
					throw new Exception("Capsule mode cannot be used with 2D since capsules don't exist in 2D");
				case ColliderType.Sphere:
					return Physics2D.OverlapCircle(position, finalRadius, mask) == null;
				default:
					return Physics2D.OverlapPoint(position, mask) == null;
				}
			}
			position += up * collisionOffset;
			switch (type)
			{
			case ColliderType.Capsule:
				return !Physics.CheckCapsule(position, position + upheight, finalRadius, mask);
			case ColliderType.Sphere:
				return !Physics.CheckSphere(position, finalRadius, mask);
			default:
				switch (rayDirection)
				{
				case RayDirection.Both:
					return !Physics.Raycast(position, up, height, mask) && !Physics.Raycast(position + upheight, -up, height, mask);
				case RayDirection.Up:
					return !Physics.Raycast(position, up, height, mask);
				default:
					return !Physics.Raycast(position + upheight, -up, height, mask);
				}
			}
		}

		public Vector3 CheckHeight(Vector3 position)
		{
			RaycastHit hit;
			bool walkable;
			return CheckHeight(position, out hit, out walkable);
		}

		public Vector3 CheckHeight(Vector3 position, out RaycastHit hit, out bool walkable)
		{
			walkable = true;
			if (!heightCheck || use2D)
			{
				hit = default(RaycastHit);
				return position;
			}
			if (thickRaycast)
			{
				Ray ray = new Ray(position + up * fromHeight, -up);
				if (Physics.SphereCast(ray, finalRaycastRadius, out hit, fromHeight + 0.005f, heightMask))
				{
					return AstarMath.NearestPoint(ray.origin, ray.origin + ray.direction, hit.point);
				}
				if (unwalkableWhenNoGround)
				{
					walkable = false;
				}
			}
			else
			{
				if (Physics.Raycast(position + up * fromHeight, -up, out hit, fromHeight + 0.005f, heightMask))
				{
					return hit.point;
				}
				if (unwalkableWhenNoGround)
				{
					walkable = false;
				}
			}
			return position;
		}

		public Vector3 Raycast(Vector3 origin, out RaycastHit hit, out bool walkable)
		{
			walkable = true;
			if (!heightCheck || use2D)
			{
				hit = default(RaycastHit);
				return origin - up * fromHeight;
			}
			if (thickRaycast)
			{
				Ray ray = new Ray(origin, -up);
				if (Physics.SphereCast(ray, finalRaycastRadius, out hit, fromHeight + 0.005f, heightMask))
				{
					return AstarMath.NearestPoint(ray.origin, ray.origin + ray.direction, hit.point);
				}
				if (unwalkableWhenNoGround)
				{
					walkable = false;
				}
			}
			else
			{
				if (Physics.Raycast(origin, -up, out hit, fromHeight + 0.005f, heightMask))
				{
					return hit.point;
				}
				if (unwalkableWhenNoGround)
				{
					walkable = false;
				}
			}
			return origin - up * fromHeight;
		}

		public RaycastHit[] CheckHeightAll(Vector3 position)
		{
			if (!heightCheck || use2D)
			{
				RaycastHit raycastHit = default(RaycastHit);
				raycastHit.point = position;
				raycastHit.distance = 0f;
				return new RaycastHit[1]
				{
					raycastHit
				};
			}
			if (thickRaycast)
			{
				UnityEngine.Debug.LogWarning("Thick raycast cannot be used with CheckHeightAll. Disabling thick raycast...");
				thickRaycast = false;
			}
			List<RaycastHit> list = new List<RaycastHit>();
			bool walkable = true;
			Vector3 vector = position + up * fromHeight;
			Vector3 vector2 = Vector3.zero;
			int num = 0;
			while (true)
			{
				Raycast(vector, out RaycastHit hit, out walkable);
				if (hit.transform == null)
				{
					break;
				}
				if (hit.point != vector2 || list.Count == 0)
				{
					vector = hit.point - up * 0.005f;
					vector2 = hit.point;
					num = 0;
					list.Add(hit);
					continue;
				}
				vector -= up * 0.001f;
				num++;
				if (num <= 10)
				{
					continue;
				}
				UnityEngine.Debug.LogError("Infinite Loop when raycasting. Please report this error (arongranberg.com)\n" + vector + " : " + vector2);
				break;
			}
			return list.ToArray();
		}
	}
	public enum ColliderType
	{
		Sphere,
		Capsule,
		Ray
	}
	public enum RayDirection
	{
		Up,
		Down,
		Both
	}
	[JsonOptIn]
	public class GridGraph : NavGraph, IUpdatableGraph, IRaycastableGraph
	{
		public class TextureData
		{
			public enum ChannelUse
			{
				None,
				Penalty,
				Position,
				WalkablePenalty
			}

			public bool enabled;

			public Texture2D source;

			public float[] factors = new float[3];

			public ChannelUse[] channels = new ChannelUse[3];

			private Color32[] data;

			public void Initialize()
			{
				if (!enabled || !(source != null))
				{
					return;
				}
				int num = 0;
				while (true)
				{
					if (num < channels.Length)
					{
						if (channels[num] != 0)
						{
							break;
						}
						num++;
						continue;
					}
					return;
				}
				try
				{
					data = source.GetPixels32();
				}
				catch (UnityException ex)
				{
					UnityEngine.Debug.LogWarning(ex.ToString());
					data = null;
				}
			}

			public void Apply(GridNode node, int x, int z)
			{
				if (enabled && data != null && x < source.width && z < source.height)
				{
					Color32 color = data[z * source.width + x];
					if (channels[0] != 0)
					{
						ApplyChannel(node, x, z, color.r, channels[0], factors[0]);
					}
					if (channels[1] != 0)
					{
						ApplyChannel(node, x, z, color.g, channels[1], factors[1]);
					}
					if (channels[2] != 0)
					{
						ApplyChannel(node, x, z, color.b, channels[2], factors[2]);
					}
				}
			}

			private void ApplyChannel(GridNode node, int x, int z, int value, ChannelUse channelUse, float factor)
			{
				switch (channelUse)
				{
				case ChannelUse.Penalty:
					node.Penalty += (uint)Mathf.RoundToInt((float)value * factor);
					break;
				case ChannelUse.Position:
					node.position = GridNode.GetGridGraph(node.GraphIndex).GetNodePosition(node.NodeInGridIndex, Mathf.RoundToInt((float)value * factor * 1000f));
					break;
				case ChannelUse.WalkablePenalty:
					if (value == 0)
					{
						node.Walkable = false;
					}
					else
					{
						node.Penalty += (uint)Mathf.RoundToInt((float)(value - 1) * factor);
					}
					break;
				}
			}
		}

		public const int getNearestForceOverlap = 2;

		public int width;

		public int depth;

		[JsonMember]
		public float aspectRatio = 1f;

		[JsonMember]
		public Vector3 rotation;

		public Bounds bounds;

		[JsonMember]
		public Vector3 center;

		[JsonMember]
		public Vector2 unclampedSize;

		[JsonMember]
		public float nodeSize = 1f;

		[JsonMember]
		public GraphCollision collision;

		[JsonMember]
		public float maxClimb = 0.4f;

		[JsonMember]
		public int maxClimbAxis = 1;

		[JsonMember]
		public float maxSlope = 90f;

		[JsonMember]
		public int erodeIterations;

		[JsonMember]
		public bool erosionUseTags;

		[JsonMember]
		public int erosionFirstTag = 1;

		[JsonMember]
		public bool autoLinkGrids;

		[JsonMember]
		public float autoLinkDistLimit = 10f;

		[JsonMember]
		public NumNeighbours neighbours = NumNeighbours.Eight;

		[JsonMember]
		public bool cutCorners = true;

		[JsonMember]
		public float penaltyPositionOffset;

		[JsonMember]
		public bool penaltyPosition;

		[JsonMember]
		public float penaltyPositionFactor = 1f;

		[JsonMember]
		public bool penaltyAngle;

		[JsonMember]
		public float penaltyAngleFactor = 100f;

		[JsonMember]
		public TextureData textureData = new TextureData();

		public Vector2 size;

		[NonSerialized]
		public readonly int[] neighbourOffsets = new int[8];

		[NonSerialized]
		public readonly uint[] neighbourCosts = new uint[8];

		[NonSerialized]
		public readonly int[] neighbourXOffsets = new int[8];

		[NonSerialized]
		public readonly int[] neighbourZOffsets = new int[8];

		public Matrix4x4 boundsMatrix;

		public Matrix4x4 boundsMatrix2;

		public int scans;

		public GridNode[] nodes;

		[NonSerialized]
		protected int[] corners;

		public virtual bool uniformWidthDepthGrid => true;

		public bool useRaycastNormal => Math.Abs(90f - maxSlope) > float.Epsilon;

		public int Width
		{
			get
			{
				return width;
			}
			set
			{
				width = value;
			}
		}

		public int Depth
		{
			get
			{
				return depth;
			}
			set
			{
				depth = value;
			}
		}

		public GridGraph()
		{
			unclampedSize = new Vector2(10f, 10f);
			nodeSize = 1f;
			collision = new GraphCollision();
		}

		public override void OnDestroy()
		{
			base.OnDestroy();
			RemoveGridGraphFromStatic();
		}

		public void RemoveGridGraphFromStatic()
		{
			GridNode.SetGridGraph(AstarPath.active.astarData.GetGraphIndex(this), null);
		}

		public override void GetNodes(GraphNodeDelegateCancelable del)
		{
			if (nodes != null)
			{
				for (int i = 0; i < nodes.Length && del(nodes[i]); i++)
				{
				}
			}
		}

		public Int3 GetNodePosition(int index, int yOffset)
		{
			int num = index / Width;
			int num2 = index - num * Width;
			return (Int3)matrix.MultiplyPoint3x4(new Vector3((float)num2 + 0.5f, (float)yOffset * 0.001f, (float)num + 0.5f));
		}

		public uint GetConnectionCost(int dir)
		{
			return neighbourCosts[dir];
		}

		public GridNode GetNodeConnection(GridNode node, int dir)
		{
			if (!node.GetConnectionInternal(dir))
			{
				return null;
			}
			if (!node.EdgeNode)
			{
				return nodes[node.NodeInGridIndex + neighbourOffsets[dir]];
			}
			int nodeInGridIndex = node.NodeInGridIndex;
			int num = nodeInGridIndex / Width;
			int x = nodeInGridIndex - num * Width;
			return GetNodeConnection(nodeInGridIndex, x, num, dir);
		}

		public bool HasNodeConnection(GridNode node, int dir)
		{
			if (!node.GetConnectionInternal(dir))
			{
				return false;
			}
			if (!node.EdgeNode)
			{
				return true;
			}
			int nodeInGridIndex = node.NodeInGridIndex;
			int num = nodeInGridIndex / Width;
			int x = nodeInGridIndex - num * Width;
			return HasNodeConnection(nodeInGridIndex, x, num, dir);
		}

		public void SetNodeConnection(GridNode node, int dir, bool value)
		{
			int nodeInGridIndex = node.NodeInGridIndex;
			int num = nodeInGridIndex / Width;
			int x = nodeInGridIndex - num * Width;
			SetNodeConnection(nodeInGridIndex, x, num, dir, value);
		}

		private GridNode GetNodeConnection(int index, int x, int z, int dir)
		{
			if (!nodes[index].GetConnectionInternal(dir))
			{
				return null;
			}
			int num = x + neighbourXOffsets[dir];
			if (num < 0 || num >= Width)
			{
				return null;
			}
			int num2 = z + neighbourZOffsets[dir];
			if (num2 < 0 || num2 >= Depth)
			{
				return null;
			}
			int num3 = index + neighbourOffsets[dir];
			return nodes[num3];
		}

		public void SetNodeConnection(int index, int x, int z, int dir, bool value)
		{
			nodes[index].SetConnectionInternal(dir, value);
		}

		public bool HasNodeConnection(int index, int x, int z, int dir)
		{
			if (!nodes[index].GetConnectionInternal(dir))
			{
				return false;
			}
			int num = x + neighbourXOffsets[dir];
			if (num < 0 || num >= Width)
			{
				return false;
			}
			int num2 = z + neighbourZOffsets[dir];
			if (num2 < 0 || num2 >= Depth)
			{
				return false;
			}
			return true;
		}

		public void UpdateSizeFromWidthDepth()
		{
			unclampedSize = new Vector2(width, depth) * nodeSize;
			GenerateMatrix();
		}

		public void GenerateMatrix()
		{
			size = unclampedSize;
			size.x *= Mathf.Sign(size.x);
			size.y *= Mathf.Sign(size.y);
			nodeSize = Mathf.Clamp(nodeSize, size.x / 1024f, float.PositiveInfinity);
			nodeSize = Mathf.Clamp(nodeSize, size.y / 1024f, float.PositiveInfinity);
			size.x = ((!(size.x < nodeSize)) ? size.x : nodeSize);
			size.y = ((!(size.y < nodeSize)) ? size.y : nodeSize);
			boundsMatrix.SetTRS(center, Quaternion.Euler(rotation), new Vector3(aspectRatio, 1f, 1f));
			width = Mathf.FloorToInt(size.x / nodeSize);
			depth = Mathf.FloorToInt(size.y / nodeSize);
			if (Mathf.Approximately(size.x / nodeSize, Mathf.CeilToInt(size.x / nodeSize)))
			{
				width = Mathf.CeilToInt(size.x / nodeSize);
			}
			if (Mathf.Approximately(size.y / nodeSize, Mathf.CeilToInt(size.y / nodeSize)))
			{
				depth = Mathf.CeilToInt(size.y / nodeSize);
			}
			SetMatrix(Matrix4x4.TRS(boundsMatrix.MultiplyPoint3x4(-new Vector3(size.x, 0f, size.y) * 0.5f), Quaternion.Euler(rotation), new Vector3(nodeSize * aspectRatio, 1f, nodeSize)));
		}

		public override NNInfo GetNearest(Vector3 position, NNConstraint constraint, GraphNode hint)
		{
			if (nodes == null || depth * width != nodes.Length)
			{
				return default(NNInfo);
			}
			position = inverseMatrix.MultiplyPoint3x4(position);
			float num = position.x - 0.5f;
			float num2 = position.z - 0.5f;
			int num3 = Mathf.Clamp(Mathf.RoundToInt(num), 0, width - 1);
			int num4 = Mathf.Clamp(Mathf.RoundToInt(num2), 0, depth - 1);
			NNInfo result = new NNInfo(nodes[num4 * width + num3]);
			Vector3 vector = inverseMatrix.MultiplyPoint3x4((Vector3)nodes[num4 * width + num3].position);
			float y = vector.y;
			result.clampedPosition = matrix.MultiplyPoint3x4(new Vector3(Mathf.Clamp(num, (float)num3 - 0.5f, (float)num3 + 0.5f) + 0.5f, y, Mathf.Clamp(num2, (float)num4 - 0.5f, (float)num4 + 0.5f) + 0.5f));
			return result;
		}

		public override NNInfo GetNearestForce(Vector3 position, NNConstraint constraint)
		{
			if (nodes == null || depth * width != nodes.Length)
			{
				return default(NNInfo);
			}
			Vector3 b = position;
			position = inverseMatrix.MultiplyPoint3x4(position);
			float num = position.x - 0.5f;
			float num2 = position.z - 0.5f;
			int num3 = Mathf.Clamp(Mathf.RoundToInt(num), 0, width - 1);
			int num4 = Mathf.Clamp(Mathf.RoundToInt(num2), 0, depth - 1);
			GridNode gridNode = nodes[num3 + num4 * width];
			GridNode gridNode2 = null;
			float num5 = float.PositiveInfinity;
			int num6 = 2;
			Vector3 clampedPosition = Vector3.zero;
			NNInfo result = new NNInfo(null);
			if (constraint.Suitable(gridNode))
			{
				gridNode2 = gridNode;
				num5 = ((Vector3)gridNode2.position - b).sqrMagnitude;
				Vector3 vector = inverseMatrix.MultiplyPoint3x4((Vector3)gridNode.position);
				float y = vector.y;
				clampedPosition = base.matrix.MultiplyPoint3x4(new Vector3(Mathf.Clamp(num, (float)num3 - 0.5f, (float)num3 + 0.5f) + 0.5f, y, Mathf.Clamp(num2, (float)num4 - 0.5f, (float)num4 + 0.5f) + 0.5f));
			}
			if (gridNode2 != null)
			{
				result.node = gridNode2;
				result.clampedPosition = clampedPosition;
				if (num6 == 0)
				{
					return result;
				}
				num6--;
			}
			float num7 = (!constraint.constrainDistance) ? float.PositiveInfinity : AstarPath.active.maxNearestNodeDistance;
			float num8 = num7 * num7;
			int num9 = 1;
			while (true)
			{
				if (nodeSize * (float)num9 > num7)
				{
					result.node = gridNode2;
					result.clampedPosition = clampedPosition;
					return result;
				}
				bool flag = false;
				int num10 = num3;
				int num11 = num4 + num9;
				int num12 = num11 * width;
				for (num10 = num3 - num9; num10 <= num3 + num9; num10++)
				{
					if (num10 < 0 || num11 < 0 || num10 >= width || num11 >= depth)
					{
						continue;
					}
					flag = true;
					if (constraint.Suitable(nodes[num10 + num12]))
					{
						float sqrMagnitude = ((Vector3)nodes[num10 + num12].position - b).sqrMagnitude;
						if (sqrMagnitude < num5 && sqrMagnitude < num8)
						{
							num5 = sqrMagnitude;
							gridNode2 = nodes[num10 + num12];
							ref Matrix4x4 matrix = ref base.matrix;
							float x = Mathf.Clamp(num, (float)num10 - 0.5f, (float)num10 + 0.5f) + 0.5f;
							Vector3 vector2 = inverseMatrix.MultiplyPoint3x4((Vector3)gridNode2.position);
							clampedPosition = matrix.MultiplyPoint3x4(new Vector3(x, vector2.y, Mathf.Clamp(num2, (float)num11 - 0.5f, (float)num11 + 0.5f) + 0.5f));
						}
					}
				}
				num11 = num4 - num9;
				num12 = num11 * width;
				for (num10 = num3 - num9; num10 <= num3 + num9; num10++)
				{
					if (num10 < 0 || num11 < 0 || num10 >= width || num11 >= depth)
					{
						continue;
					}
					flag = true;
					if (constraint.Suitable(nodes[num10 + num12]))
					{
						float sqrMagnitude2 = ((Vector3)nodes[num10 + num12].position - b).sqrMagnitude;
						if (sqrMagnitude2 < num5 && sqrMagnitude2 < num8)
						{
							num5 = sqrMagnitude2;
							gridNode2 = nodes[num10 + num12];
							ref Matrix4x4 matrix2 = ref base.matrix;
							float x2 = Mathf.Clamp(num, (float)num10 - 0.5f, (float)num10 + 0.5f) + 0.5f;
							Vector3 vector3 = inverseMatrix.MultiplyPoint3x4((Vector3)gridNode2.position);
							clampedPosition = matrix2.MultiplyPoint3x4(new Vector3(x2, vector3.y, Mathf.Clamp(num2, (float)num11 - 0.5f, (float)num11 + 0.5f) + 0.5f));
						}
					}
				}
				num10 = num3 - num9;
				num11 = num4 - num9 + 1;
				for (num11 = num4 - num9 + 1; num11 <= num4 + num9 - 1; num11++)
				{
					if (num10 < 0 || num11 < 0 || num10 >= width || num11 >= depth)
					{
						continue;
					}
					flag = true;
					if (constraint.Suitable(nodes[num10 + num11 * width]))
					{
						float sqrMagnitude3 = ((Vector3)nodes[num10 + num11 * width].position - b).sqrMagnitude;
						if (sqrMagnitude3 < num5 && sqrMagnitude3 < num8)
						{
							num5 = sqrMagnitude3;
							gridNode2 = nodes[num10 + num11 * width];
							ref Matrix4x4 matrix3 = ref base.matrix;
							float x3 = Mathf.Clamp(num, (float)num10 - 0.5f, (float)num10 + 0.5f) + 0.5f;
							Vector3 vector4 = inverseMatrix.MultiplyPoint3x4((Vector3)gridNode2.position);
							clampedPosition = matrix3.MultiplyPoint3x4(new Vector3(x3, vector4.y, Mathf.Clamp(num2, (float)num11 - 0.5f, (float)num11 + 0.5f) + 0.5f));
						}
					}
				}
				num10 = num3 + num9;
				for (num11 = num4 - num9 + 1; num11 <= num4 + num9 - 1; num11++)
				{
					if (num10 < 0 || num11 < 0 || num10 >= width || num11 >= depth)
					{
						continue;
					}
					flag = true;
					if (constraint.Suitable(nodes[num10 + num11 * width]))
					{
						float sqrMagnitude4 = ((Vector3)nodes[num10 + num11 * width].position - b).sqrMagnitude;
						if (sqrMagnitude4 < num5 && sqrMagnitude4 < num8)
						{
							num5 = sqrMagnitude4;
							gridNode2 = nodes[num10 + num11 * width];
							ref Matrix4x4 matrix4 = ref base.matrix;
							float x4 = Mathf.Clamp(num, (float)num10 - 0.5f, (float)num10 + 0.5f) + 0.5f;
							Vector3 vector5 = inverseMatrix.MultiplyPoint3x4((Vector3)gridNode2.position);
							clampedPosition = matrix4.MultiplyPoint3x4(new Vector3(x4, vector5.y, Mathf.Clamp(num2, (float)num11 - 0.5f, (float)num11 + 0.5f) + 0.5f));
						}
					}
				}
				if (gridNode2 != null)
				{
					if (num6 == 0)
					{
						result.node = gridNode2;
						result.clampedPosition = clampedPosition;
						return result;
					}
					num6--;
				}
				if (!flag)
				{
					break;
				}
				num9++;
			}
			result.node = gridNode2;
			result.clampedPosition = clampedPosition;
			return result;
		}

		public virtual void SetUpOffsetsAndCosts()
		{
			neighbourOffsets[0] = -width;
			neighbourOffsets[1] = 1;
			neighbourOffsets[2] = width;
			neighbourOffsets[3] = -1;
			neighbourOffsets[4] = -width + 1;
			neighbourOffsets[5] = width + 1;
			neighbourOffsets[6] = width - 1;
			neighbourOffsets[7] = -width - 1;
			uint num = (uint)Mathf.RoundToInt(nodeSize * 1000f);
			uint num2 = (uint)Mathf.RoundToInt(nodeSize * Mathf.Sqrt(2f) * 1000f);
			neighbourCosts[0] = num;
			neighbourCosts[1] = num;
			neighbourCosts[2] = num;
			neighbourCosts[3] = num;
			neighbourCosts[4] = num2;
			neighbourCosts[5] = num2;
			neighbourCosts[6] = num2;
			neighbourCosts[7] = num2;
			neighbourXOffsets[0] = 0;
			neighbourXOffsets[1] = 1;
			neighbourXOffsets[2] = 0;
			neighbourXOffsets[3] = -1;
			neighbourXOffsets[4] = 1;
			neighbourXOffsets[5] = 1;
			neighbourXOffsets[6] = -1;
			neighbourXOffsets[7] = -1;
			neighbourZOffsets[0] = -1;
			neighbourZOffsets[1] = 0;
			neighbourZOffsets[2] = 1;
			neighbourZOffsets[3] = 0;
			neighbourZOffsets[4] = -1;
			neighbourZOffsets[5] = 1;
			neighbourZOffsets[6] = 1;
			neighbourZOffsets[7] = -1;
		}

		public override void ScanInternal(OnScanStatus statusCallback)
		{
			AstarPath.OnPostScan = (OnScanDelegate)Delegate.Combine(AstarPath.OnPostScan, new OnScanDelegate(OnPostScan));
			scans++;
			if (nodeSize <= 0f)
			{
				return;
			}
			GenerateMatrix();
			if (width > 1024 || depth > 1024)
			{
				UnityEngine.Debug.LogError("One of the grid's sides is longer than 1024 nodes");
				return;
			}
			SetUpOffsetsAndCosts();
			int graphIndex = AstarPath.active.astarData.GetGraphIndex(this);
			GridNode.SetGridGraph(graphIndex, this);
			nodes = new GridNode[width * depth];
			for (int i = 0; i < nodes.Length; i++)
			{
				nodes[i] = new GridNode(active);
				nodes[i].GraphIndex = (uint)graphIndex;
			}
			if (collision == null)
			{
				collision = new GraphCollision();
			}
			collision.Initialize(matrix, nodeSize);
			textureData.Initialize();
			for (int j = 0; j < depth; j++)
			{
				for (int k = 0; k < width; k++)
				{
					GridNode gridNode = nodes[j * width + k];
					gridNode.NodeInGridIndex = j * width + k;
					UpdateNodePositionCollision(gridNode, k, j);
					textureData.Apply(gridNode, k, j);
				}
			}
			for (int l = 0; l < depth; l++)
			{
				for (int m = 0; m < width; m++)
				{
					GridNode node = nodes[l * width + m];
					CalculateConnections(nodes, m, l, node);
				}
			}
			ErodeWalkableArea();
		}

		public virtual void UpdateNodePositionCollision(GridNode node, int x, int z, bool resetPenalty = true)
		{
			node.position = GetNodePosition(node.NodeInGridIndex, 0);
			bool walkable = true;
			RaycastHit hit;
			Vector3 ob = collision.CheckHeight((Vector3)node.position, out hit, out walkable);
			node.position = (Int3)ob;
			if (resetPenalty)
			{
				node.Penalty = initialPenalty;
			}
			if (penaltyPosition && resetPenalty)
			{
				node.Penalty += (uint)Mathf.RoundToInt(((float)node.position.y - penaltyPositionOffset) * penaltyPositionFactor);
			}
			if (walkable && useRaycastNormal && collision.heightCheck && hit.normal != Vector3.zero)
			{
				float num = Vector3.Dot(hit.normal.normalized, collision.up);
				if (penaltyAngle && resetPenalty)
				{
					node.Penalty += (uint)Mathf.RoundToInt((1f - num) * penaltyAngleFactor);
				}
				float num2 = Mathf.Cos(maxSlope * ((float)Math.PI / 180f));
				if (num < num2)
				{
					walkable = false;
				}
			}
			if (walkable)
			{
				node.Walkable = collision.Check((Vector3)node.position);
			}
			else
			{
				node.Walkable = walkable;
			}
			node.WalkableErosion = node.Walkable;
		}

		public virtual void ErodeWalkableArea()
		{
			ErodeWalkableArea(0, 0, Width, Depth);
		}

		public virtual void ErodeWalkableArea(int xmin, int zmin, int xmax, int zmax)
		{
			xmin = ((xmin >= 0) ? ((xmin <= Width) ? xmin : Width) : 0);
			xmax = ((xmax >= 0) ? ((xmax <= Width) ? xmax : Width) : 0);
			zmin = ((zmin >= 0) ? ((zmin <= Depth) ? zmin : Depth) : 0);
			zmax = ((zmax >= 0) ? ((zmax <= Depth) ? zmax : Depth) : 0);
			if (!erosionUseTags)
			{
				for (int i = 0; i < erodeIterations; i++)
				{
					for (int j = zmin; j < zmax; j++)
					{
						for (int k = xmin; k < xmax; k++)
						{
							GridNode gridNode = nodes[j * Width + k];
							if (!gridNode.Walkable)
							{
								continue;
							}
							bool flag = false;
							for (int l = 0; l < 4; l++)
							{
								if (!HasNodeConnection(gridNode, l))
								{
									flag = true;
									break;
								}
							}
							if (flag)
							{
								gridNode.Walkable = false;
							}
						}
					}
					for (int m = zmin; m < zmax; m++)
					{
						for (int n = xmin; n < xmax; n++)
						{
							GridNode node = nodes[m * Width + n];
							CalculateConnections(nodes, n, m, node);
						}
					}
				}
				return;
			}
			if (erodeIterations + erosionFirstTag > 31)
			{
				UnityEngine.Debug.LogError("Too few tags available for " + erodeIterations + " erode iterations and starting with tag " + erosionFirstTag + " (erodeIterations+erosionFirstTag > 31)");
				return;
			}
			if (erosionFirstTag <= 0)
			{
				UnityEngine.Debug.LogError("First erosion tag must be greater or equal to 1");
				return;
			}
			for (int num = 0; num < erodeIterations; num++)
			{
				for (int num2 = zmin; num2 < zmax; num2++)
				{
					for (int num3 = xmin; num3 < xmax; num3++)
					{
						GridNode gridNode2 = nodes[num2 * width + num3];
						if (gridNode2.Walkable && gridNode2.Tag >= erosionFirstTag && gridNode2.Tag < erosionFirstTag + num)
						{
							for (int num4 = 0; num4 < 4; num4++)
							{
								GridNode nodeConnection = GetNodeConnection(gridNode2, num4);
								if (nodeConnection != null)
								{
									uint tag = nodeConnection.Tag;
									if (tag > erosionFirstTag + num || tag < erosionFirstTag)
									{
										nodeConnection.Tag = (uint)(erosionFirstTag + num);
									}
								}
							}
						}
						else
						{
							if (!gridNode2.Walkable || num != 0)
							{
								continue;
							}
							bool flag2 = false;
							for (int num5 = 0; num5 < 4; num5++)
							{
								if (!HasNodeConnection(gridNode2, num5))
								{
									flag2 = true;
									break;
								}
							}
							if (flag2)
							{
								gridNode2.Tag = (uint)(erosionFirstTag + num);
							}
						}
					}
				}
			}
		}

		public virtual bool IsValidConnection(GridNode n1, GridNode n2)
		{
			if (!n1.Walkable || !n2.Walkable)
			{
				return false;
			}
			if (maxClimb != 0f && (float)Mathf.Abs(n1.position[maxClimbAxis] - n2.position[maxClimbAxis]) > maxClimb * 1000f)
			{
				return false;
			}
			return true;
		}

		public static void CalculateConnections(GridNode node)
		{
			GridGraph gridGraph = AstarData.GetGraph(node) as GridGraph;
			if (gridGraph != null)
			{
				int nodeInGridIndex = node.NodeInGridIndex;
				int x = nodeInGridIndex % gridGraph.width;
				int z = nodeInGridIndex / gridGraph.width;
				gridGraph.CalculateConnections(gridGraph.nodes, x, z, node);
			}
		}

		public virtual void CalculateConnections(GridNode[] nodes, int x, int z, GridNode node)
		{
			node.ResetConnectionsInternal();
			if (!node.Walkable)
			{
				return;
			}
			int nodeInGridIndex = node.NodeInGridIndex;
			if (corners == null)
			{
				corners = new int[4];
			}
			else
			{
				for (int i = 0; i < 4; i++)
				{
					corners[i] = 0;
				}
			}
			int j = 0;
			int num = 3;
			for (; j < 4; j++)
			{
				int num2 = x + neighbourXOffsets[j];
				int num3 = z + neighbourZOffsets[j];
				if (num2 >= 0 && num3 >= 0 && num2 < width && num3 < depth)
				{
					GridNode n = nodes[nodeInGridIndex + neighbourOffsets[j]];
					if (IsValidConnection(node, n))
					{
						node.SetConnectionInternal(j, value: true);
						corners[j]++;
						corners[num]++;
					}
					else
					{
						node.SetConnectionInternal(j, value: false);
					}
				}
				num = j;
			}
			if (neighbours != NumNeighbours.Eight)
			{
				return;
			}
			if (cutCorners)
			{
				for (int k = 0; k < 4; k++)
				{
					if (corners[k] >= 1)
					{
						int num4 = x + neighbourXOffsets[k + 4];
						int num5 = z + neighbourZOffsets[k + 4];
						if (num4 >= 0 && num5 >= 0 && num4 < width && num5 < depth)
						{
							GridNode n2 = nodes[nodeInGridIndex + neighbourOffsets[k + 4]];
							node.SetConnectionInternal(k + 4, IsValidConnection(node, n2));
						}
					}
				}
				return;
			}
			for (int l = 0; l < 4; l++)
			{
				if (corners[l] == 2)
				{
					GridNode n3 = nodes[nodeInGridIndex + neighbourOffsets[l + 4]];
					node.SetConnectionInternal(l + 4, IsValidConnection(node, n3));
				}
			}
		}

		public void OnPostScan(AstarPath script)
		{
			AstarPath.OnPostScan = (OnScanDelegate)Delegate.Remove(AstarPath.OnPostScan, new OnScanDelegate(OnPostScan));
			if (!autoLinkGrids || autoLinkDistLimit <= 0f)
			{
				return;
			}
			throw new NotSupportedException();
		}

		public override void OnDrawGizmos(bool drawNodes)
		{
			Gizmos.matrix = boundsMatrix;
			Gizmos.color = Color.white;
			Gizmos.DrawWireCube(Vector3.zero, new Vector3(size.x, 0f, size.y));
			Gizmos.matrix = Matrix4x4.identity;
			if (!drawNodes || nodes == null || depth * width != nodes.Length)
			{
				return;
			}
			PathHandler debugPathData = AstarPath.active.debugPathData;
			GridNode gridNode = null;
			for (int i = 0; i < depth; i++)
			{
				for (int j = 0; j < width; j++)
				{
					gridNode = nodes[i * width + j];
					if (!gridNode.Walkable)
					{
						continue;
					}
					Gizmos.color = NodeColor(gridNode, AstarPath.active.debugPathData);
					if (AstarPath.active.showSearchTree && AstarPath.active.debugPathData != null)
					{
						if (InSearchTree(gridNode, AstarPath.active.debugPath))
						{
							PathNode pathNode = debugPathData.GetPathNode(gridNode);
							if (pathNode != null && pathNode.parent != null)
							{
								Gizmos.DrawLine((Vector3)gridNode.position, (Vector3)pathNode.parent.node.position);
							}
						}
						continue;
					}
					for (int k = 0; k < 8; k++)
					{
						GridNode nodeConnection = GetNodeConnection(gridNode, k);
						if (nodeConnection != null)
						{
							Gizmos.DrawLine((Vector3)gridNode.position, (Vector3)nodeConnection.position);
						}
					}
					if (gridNode.connections != null)
					{
						for (int l = 0; l < gridNode.connections.Length; l++)
						{
							GraphNode graphNode = gridNode.connections[l];
							Gizmos.DrawLine((Vector3)gridNode.position, (Vector3)graphNode.position);
						}
					}
				}
			}
		}

		public void GetBoundsMinMax(Bounds b, Matrix4x4 matrix, out Vector3 min, out Vector3 max)
		{
			Vector3[] array = new Vector3[8];
			ref Vector3 reference = ref array[0];
			Vector3 a = b.center;
			Vector3 extents = b.extents;
			float x = extents.x;
			Vector3 extents2 = b.extents;
			float y = extents2.y;
			Vector3 extents3 = b.extents;
			reference = matrix.MultiplyPoint3x4(a + new Vector3(x, y, extents3.z));
			ref Vector3 reference2 = ref array[1];
			Vector3 a2 = b.center;
			Vector3 extents4 = b.extents;
			float x2 = extents4.x;
			Vector3 extents5 = b.extents;
			float y2 = extents5.y;
			Vector3 extents6 = b.extents;
			reference2 = matrix.MultiplyPoint3x4(a2 + new Vector3(x2, y2, 0f - extents6.z));
			ref Vector3 reference3 = ref array[2];
			Vector3 a3 = b.center;
			Vector3 extents7 = b.extents;
			float x3 = extents7.x;
			Vector3 extents8 = b.extents;
			float y3 = 0f - extents8.y;
			Vector3 extents9 = b.extents;
			reference3 = matrix.MultiplyPoint3x4(a3 + new Vector3(x3, y3, extents9.z));
			ref Vector3 reference4 = ref array[3];
			Vector3 a4 = b.center;
			Vector3 extents10 = b.extents;
			float x4 = extents10.x;
			Vector3 extents11 = b.extents;
			float y4 = 0f - extents11.y;
			Vector3 extents12 = b.extents;
			reference4 = matrix.MultiplyPoint3x4(a4 + new Vector3(x4, y4, 0f - extents12.z));
			ref Vector3 reference5 = ref array[4];
			Vector3 a5 = b.center;
			Vector3 extents13 = b.extents;
			float x5 = 0f - extents13.x;
			Vector3 extents14 = b.extents;
			float y5 = extents14.y;
			Vector3 extents15 = b.extents;
			reference5 = matrix.MultiplyPoint3x4(a5 + new Vector3(x5, y5, extents15.z));
			ref Vector3 reference6 = ref array[5];
			Vector3 a6 = b.center;
			Vector3 extents16 = b.extents;
			float x6 = 0f - extents16.x;
			Vector3 extents17 = b.extents;
			float y6 = extents17.y;
			Vector3 extents18 = b.extents;
			reference6 = matrix.MultiplyPoint3x4(a6 + new Vector3(x6, y6, 0f - extents18.z));
			ref Vector3 reference7 = ref array[6];
			Vector3 a7 = b.center;
			Vector3 extents19 = b.extents;
			float x7 = 0f - extents19.x;
			Vector3 extents20 = b.extents;
			float y7 = 0f - extents20.y;
			Vector3 extents21 = b.extents;
			reference7 = matrix.MultiplyPoint3x4(a7 + new Vector3(x7, y7, extents21.z));
			ref Vector3 reference8 = ref array[7];
			Vector3 a8 = b.center;
			Vector3 extents22 = b.extents;
			float x8 = 0f - extents22.x;
			Vector3 extents23 = b.extents;
			float y8 = 0f - extents23.y;
			Vector3 extents24 = b.extents;
			reference8 = matrix.MultiplyPoint3x4(a8 + new Vector3(x8, y8, 0f - extents24.z));
			min = array[0];
			max = array[0];
			for (int i = 1; i < 8; i++)
			{
				min = Vector3.Min(min, array[i]);
				max = Vector3.Max(max, array[i]);
			}
		}

		public List<GraphNode> GetNodesInArea(Bounds b)
		{
			return GetNodesInArea(b, null);
		}

		public List<GraphNode> GetNodesInArea(GraphUpdateShape shape)
		{
			return GetNodesInArea(shape.GetBounds(), shape);
		}

		private List<GraphNode> GetNodesInArea(Bounds b, GraphUpdateShape shape)
		{
			if (nodes == null || width * depth != nodes.Length)
			{
				return null;
			}
			List<GraphNode> list = ListPool<GraphNode>.Claim();
			GetBoundsMinMax(b, inverseMatrix, out Vector3 min, out Vector3 max);
			int xmin = Mathf.RoundToInt(min.x - 0.5f);
			int xmax = Mathf.RoundToInt(max.x - 0.5f);
			int ymin = Mathf.RoundToInt(min.z - 0.5f);
			int ymax = Mathf.RoundToInt(max.z - 0.5f);
			IntRect a = new IntRect(xmin, ymin, xmax, ymax);
			IntRect b2 = new IntRect(0, 0, width - 1, depth - 1);
			IntRect intRect = IntRect.Intersection(a, b2);
			for (int i = intRect.xmin; i <= intRect.xmax; i++)
			{
				for (int j = intRect.ymin; j <= intRect.ymax; j++)
				{
					int num = j * width + i;
					GraphNode graphNode = nodes[num];
					if (b.Contains((Vector3)graphNode.position) && (shape == null || shape.Contains((Vector3)graphNode.position)))
					{
						list.Add(graphNode);
					}
				}
			}
			return list;
		}

		public GraphUpdateThreading CanUpdateAsync(GraphUpdateObject o)
		{
			return GraphUpdateThreading.UnityThread;
		}

		public void UpdateAreaInit(GraphUpdateObject o)
		{
		}

		public void UpdateArea(GraphUpdateObject o)
		{
			if (nodes == null || nodes.Length != width * depth)
			{
				UnityEngine.Debug.LogWarning("The Grid Graph is not scanned, cannot update area ");
				return;
			}
			Bounds b = o.bounds;
			GetBoundsMinMax(b, inverseMatrix, out Vector3 min, out Vector3 max);
			int xmin = Mathf.RoundToInt(min.x - 0.5f);
			int xmax = Mathf.RoundToInt(max.x - 0.5f);
			int ymin = Mathf.RoundToInt(min.z - 0.5f);
			int ymax = Mathf.RoundToInt(max.z - 0.5f);
			IntRect intRect = new IntRect(xmin, ymin, xmax, ymax);
			IntRect intRect2 = intRect;
			IntRect b2 = new IntRect(0, 0, width - 1, depth - 1);
			IntRect intRect3 = intRect;
			int num = o.updateErosion ? erodeIterations : 0;
			bool flag = o.updatePhysics || o.modifyWalkability;
			if (o.updatePhysics && !o.modifyWalkability && collision.collisionCheck)
			{
				Vector3 a = new Vector3(collision.diameter, 0f, collision.diameter) * 0.5f;
				min -= a * 1.02f;
				max += a * 1.02f;
				intRect3 = new IntRect(Mathf.RoundToInt(min.x - 0.5f), Mathf.RoundToInt(min.z - 0.5f), Mathf.RoundToInt(max.x - 0.5f), Mathf.RoundToInt(max.z - 0.5f));
				intRect2 = IntRect.Union(intRect3, intRect2);
			}
			if (flag || num > 0)
			{
				intRect2 = intRect2.Expand(num + 1);
			}
			IntRect intRect4 = IntRect.Intersection(intRect2, b2);
			for (int i = intRect4.xmin; i <= intRect4.xmax; i++)
			{
				for (int j = intRect4.ymin; j <= intRect4.ymax; j++)
				{
					o.WillUpdateNode(nodes[j * width + i]);
				}
			}
			if (o.updatePhysics && !o.modifyWalkability)
			{
				collision.Initialize(matrix, nodeSize);
				intRect4 = IntRect.Intersection(intRect3, b2);
				for (int k = intRect4.xmin; k <= intRect4.xmax; k++)
				{
					for (int l = intRect4.ymin; l <= intRect4.ymax; l++)
					{
						int num2 = l * width + k;
						GridNode node = nodes[num2];
						UpdateNodePositionCollision(node, k, l, o.resetPenaltyOnPhysics);
					}
				}
			}
			intRect4 = IntRect.Intersection(intRect, b2);
			for (int m = intRect4.xmin; m <= intRect4.xmax; m++)
			{
				for (int n = intRect4.ymin; n <= intRect4.ymax; n++)
				{
					int num3 = n * width + m;
					GridNode gridNode = nodes[num3];
					if (flag)
					{
						gridNode.Walkable = gridNode.WalkableErosion;
						if (o.bounds.Contains((Vector3)gridNode.position))
						{
							o.Apply(gridNode);
						}
						gridNode.WalkableErosion = gridNode.Walkable;
					}
					else if (o.bounds.Contains((Vector3)gridNode.position))
					{
						o.Apply(gridNode);
					}
				}
			}
			if (flag && num == 0)
			{
				intRect4 = IntRect.Intersection(intRect2, b2);
				for (int num4 = intRect4.xmin; num4 <= intRect4.xmax; num4++)
				{
					for (int num5 = intRect4.ymin; num5 <= intRect4.ymax; num5++)
					{
						int num6 = num5 * width + num4;
						GridNode node2 = nodes[num6];
						CalculateConnections(nodes, num4, num5, node2);
					}
				}
			}
			else
			{
				if (!flag || num <= 0)
				{
					return;
				}
				IntRect a2 = IntRect.Union(intRect, intRect3).Expand(num);
				IntRect a3 = a2.Expand(num);
				a2 = IntRect.Intersection(a2, b2);
				a3 = IntRect.Intersection(a3, b2);
				for (int num7 = a3.xmin; num7 <= a3.xmax; num7++)
				{
					for (int num8 = a3.ymin; num8 <= a3.ymax; num8++)
					{
						int num9 = num8 * width + num7;
						GridNode gridNode2 = nodes[num9];
						bool walkable = gridNode2.Walkable;
						gridNode2.Walkable = gridNode2.WalkableErosion;
						if (!a2.Contains(num7, num8))
						{
							gridNode2.TmpWalkable = walkable;
						}
					}
				}
				for (int num10 = a3.xmin; num10 <= a3.xmax; num10++)
				{
					for (int num11 = a3.ymin; num11 <= a3.ymax; num11++)
					{
						int num12 = num11 * width + num10;
						GridNode node3 = nodes[num12];
						CalculateConnections(nodes, num10, num11, node3);
					}
				}
				ErodeWalkableArea(a3.xmin, a3.ymin, a3.xmax + 1, a3.ymax + 1);
				for (int num13 = a3.xmin; num13 <= a3.xmax; num13++)
				{
					for (int num14 = a3.ymin; num14 <= a3.ymax; num14++)
					{
						if (!a2.Contains(num13, num14))
						{
							int num15 = num14 * width + num13;
							GridNode gridNode3 = nodes[num15];
							gridNode3.Walkable = gridNode3.TmpWalkable;
						}
					}
				}
				for (int num16 = a3.xmin; num16 <= a3.xmax; num16++)
				{
					for (int num17 = a3.ymin; num17 <= a3.ymax; num17++)
					{
						int num18 = num17 * width + num16;
						GridNode node4 = nodes[num18];
						CalculateConnections(nodes, num16, num17, node4);
					}
				}
			}
		}

		public bool Linecast(Vector3 _a, Vector3 _b)
		{
			GraphHitInfo hit;
			return Linecast(_a, _b, null, out hit);
		}

		public bool Linecast(Vector3 _a, Vector3 _b, GraphNode hint)
		{
			GraphHitInfo hit;
			return Linecast(_a, _b, hint, out hit);
		}

		public bool Linecast(Vector3 _a, Vector3 _b, GraphNode hint, out GraphHitInfo hit)
		{
			return Linecast(_a, _b, hint, out hit, null);
		}

		public bool Linecast(Vector3 _a, Vector3 _b, GraphNode hint, out GraphHitInfo hit, List<GraphNode> trace)
		{
			hit = default(GraphHitInfo);
			_a = inverseMatrix.MultiplyPoint3x4(_a);
			_a.x -= 0.5f;
			_a.z -= 0.5f;
			_b = inverseMatrix.MultiplyPoint3x4(_b);
			_b.x -= 0.5f;
			_b.z -= 0.5f;
			if (_a.x < -0.5f || _a.z < -0.5f || _a.x >= (float)width - 0.5f || _a.z >= (float)depth - 0.5f || _b.x < -0.5f || _b.z < -0.5f || _b.x >= (float)width - 0.5f || _b.z >= (float)depth - 0.5f)
			{
				Vector3 vector = new Vector3(-0.5f, 0f, -0.5f);
				Vector3 vector2 = new Vector3(-0.5f, 0f, (float)depth - 0.5f);
				Vector3 vector3 = new Vector3((float)width - 0.5f, 0f, (float)depth - 0.5f);
				Vector3 vector4 = new Vector3((float)width - 0.5f, 0f, -0.5f);
				int num = 0;
				bool intersects = false;
				Vector3 vector5 = Polygon.SegmentIntersectionPoint(vector, vector2, _a, _b, out intersects);
				if (intersects)
				{
					num++;
					if (!Polygon.Left(vector, vector2, _a))
					{
						_a = vector5;
					}
					else
					{
						_b = vector5;
					}
				}
				vector5 = Polygon.SegmentIntersectionPoint(vector2, vector3, _a, _b, out intersects);
				if (intersects)
				{
					num++;
					if (!Polygon.Left(vector2, vector3, _a))
					{
						_a = vector5;
					}
					else
					{
						_b = vector5;
					}
				}
				vector5 = Polygon.SegmentIntersectionPoint(vector3, vector4, _a, _b, out intersects);
				if (intersects)
				{
					num++;
					if (!Polygon.Left(vector3, vector4, _a))
					{
						_a = vector5;
					}
					else
					{
						_b = vector5;
					}
				}
				vector5 = Polygon.SegmentIntersectionPoint(vector4, vector, _a, _b, out intersects);
				if (intersects)
				{
					num++;
					if (!Polygon.Left(vector4, vector, _a))
					{
						_a = vector5;
					}
					else
					{
						_b = vector5;
					}
				}
				if (num == 0)
				{
					return false;
				}
			}
			Vector3 a = _b - _a;
			float magnitude = a.magnitude;
			if (magnitude == 0f)
			{
				return false;
			}
			float num2 = 0.2f;
			float num3 = nodeSize * num2;
			num3 -= nodeSize * 0.02f;
			a = a / magnitude * num3;
			int num4 = (int)(magnitude / num3);
			Vector3 a2 = _a + a * nodeSize * 0.01f;
			GraphNode graphNode = null;
			for (int i = 0; i <= num4; i++)
			{
				Vector3 vector6 = a2 + a * i;
				int num5 = Mathf.RoundToInt(vector6.x);
				int num6 = Mathf.RoundToInt(vector6.z);
				num5 = ((num5 >= 0) ? ((num5 < width) ? num5 : (width - 1)) : 0);
				num6 = ((num6 >= 0) ? ((num6 < depth) ? num6 : (depth - 1)) : 0);
				GraphNode graphNode2 = nodes[num6 * width + num5];
				if (graphNode2 == graphNode)
				{
					continue;
				}
				if (!graphNode2.Walkable)
				{
					if (i > 0)
					{
						hit.point = matrix.MultiplyPoint3x4(a2 + a * (i - 1) + new Vector3(0.5f, 0f, 0.5f));
					}
					else
					{
						hit.point = matrix.MultiplyPoint3x4(_a + new Vector3(0.5f, 0f, 0.5f));
					}
					hit.origin = matrix.MultiplyPoint3x4(_a + new Vector3(0.5f, 0f, 0.5f));
					hit.node = graphNode2;
					return true;
				}
				if (i > num4 - 1 && (Mathf.Abs(vector6.x - _b.x) <= 0.50001f || Mathf.Abs(vector6.z - _b.z) <= 0.50001f))
				{
					return false;
				}
				trace?.Add(graphNode2);
				graphNode = graphNode2;
			}
			return false;
		}

		public bool SnappedLinecast(Vector3 _a, Vector3 _b, GraphNode hint, out GraphHitInfo hit)
		{
			hit = default(GraphHitInfo);
			NNInfo nearest = GetNearest(_a, NNConstraint.None);
			GraphNode node = nearest.node;
			NNInfo nearest2 = GetNearest(_b, NNConstraint.None);
			GraphNode node2 = nearest2.node;
			_a = inverseMatrix.MultiplyPoint3x4((Vector3)node.position);
			_a.x -= 0.5f;
			_a.z -= 0.5f;
			_b = inverseMatrix.MultiplyPoint3x4((Vector3)node2.position);
			_b.x -= 0.5f;
			_b.z -= 0.5f;
			Int3 @int = new Int3(Mathf.RoundToInt(_a.x), Mathf.RoundToInt(_a.y), Mathf.RoundToInt(_a.z));
			Int3 int2 = new Int3(Mathf.RoundToInt(_b.x), Mathf.RoundToInt(_b.y), Mathf.RoundToInt(_b.z));
			hit.origin = (Vector3)@int;
			if (!nodes[@int.z * width + @int.x].Walkable)
			{
				hit.node = nodes[@int.z * width + @int.x];
				hit.point = matrix.MultiplyPoint3x4(new Vector3((float)@int.x + 0.5f, 0f, (float)@int.z + 0.5f));
				ref Vector3 point = ref hit.point;
				Vector3 vector = (Vector3)hit.node.position;
				point.y = vector.y;
				return true;
			}
			int num = Mathf.Abs(@int.x - int2.x);
			int num2 = Mathf.Abs(@int.z - int2.z);
			int num3 = 0;
			int num4 = 0;
			num3 = ((@int.x < int2.x) ? 1 : (-1));
			num4 = ((@int.z < int2.z) ? 1 : (-1));
			int num5 = num - num2;
			while (true)
			{
				if (@int.x == int2.x && @int.z == int2.z)
				{
					return false;
				}
				int num6 = num5 * 2;
				int num7 = 0;
				Int3 int3 = @int;
				if (num6 > -num2)
				{
					num5 -= num2;
					num7 = num3;
					int3.x += num3;
				}
				if (num6 < num)
				{
					num5 += num;
					num7 += width * num4;
					int3.z += num4;
				}
				if (num7 == 0)
				{
					break;
				}
				for (int i = 0; i < neighbourOffsets.Length; i++)
				{
					if (neighbourOffsets[i] != num7)
					{
						continue;
					}
					if (CheckConnection(nodes[@int.z * width + @int.x], i))
					{
						if (!nodes[int3.z * width + int3.x].Walkable)
						{
							hit.node = nodes[@int.z * width + @int.x];
							hit.point = matrix.MultiplyPoint3x4(new Vector3((float)@int.x + 0.5f, 0f, (float)@int.z + 0.5f));
							ref Vector3 point2 = ref hit.point;
							Vector3 vector2 = (Vector3)hit.node.position;
							point2.y = vector2.y;
							return true;
						}
						@int = int3;
						break;
					}
					hit.node = nodes[@int.z * width + @int.x];
					hit.point = matrix.MultiplyPoint3x4(new Vector3((float)@int.x + 0.5f, 0f, (float)@int.z + 0.5f));
					ref Vector3 point3 = ref hit.point;
					Vector3 vector3 = (Vector3)hit.node.position;
					point3.y = vector3.y;
					return true;
				}
			}
			UnityEngine.Debug.LogError("Offset is zero, this should not happen");
			return false;
		}

		public bool CheckConnection(GridNode node, int dir)
		{
			if (neighbours == NumNeighbours.Eight)
			{
				return HasNodeConnection(node, dir);
			}
			int num = (dir - 4 - 1) & 3;
			int num2 = (dir - 4 + 1) & 3;
			if (!HasNodeConnection(node, num) || !HasNodeConnection(node, num2))
			{
				return false;
			}
			GridNode gridNode = nodes[node.NodeInGridIndex + neighbourOffsets[num]];
			GridNode gridNode2 = nodes[node.NodeInGridIndex + neighbourOffsets[num2]];
			if (!gridNode.Walkable || !gridNode2.Walkable)
			{
				return false;
			}
			if (!HasNodeConnection(gridNode2, num) || !HasNodeConnection(gridNode, num2))
			{
				return false;
			}
			return true;
		}

		public override void SerializeExtraInfo(GraphSerializationContext ctx)
		{
			if (nodes == null)
			{
				ctx.writer.Write(-1);
				return;
			}
			ctx.writer.Write(nodes.Length);
			for (int i = 0; i < nodes.Length; i++)
			{
				nodes[i].SerializeNode(ctx);
			}
		}

		public override void DeserializeExtraInfo(GraphSerializationContext ctx)
		{
			int num = ctx.reader.ReadInt32();
			if (num == -1)
			{
				nodes = null;
				return;
			}
			nodes = new GridNode[num];
			for (int i = 0; i < nodes.Length; i++)
			{
				nodes[i] = new GridNode(active);
				nodes[i].DeserializeNode(ctx);
			}
		}

		public override void PostDeserialization()
		{
			GenerateMatrix();
			SetUpOffsetsAndCosts();
			if (nodes == null || nodes.Length == 0)
			{
				return;
			}
			if (width * depth != nodes.Length)
			{
				UnityEngine.Debug.LogWarning("Node data did not match with bounds data. Probably a change to the bounds/width/depth data was made after scanning the graph just prior to saving it. Nodes will be discarded");
				nodes = new GridNode[0];
				return;
			}
			GridNode.SetGridGraph(AstarPath.active.astarData.GetGraphIndex(this), this);
			for (int i = 0; i < depth; i++)
			{
				for (int j = 0; j < width; j++)
				{
					GridNode gridNode = nodes[i * width + j];
					if (gridNode == null)
					{
						UnityEngine.Debug.LogError("Deserialization Error : Couldn't cast the node to the appropriate type - GridGenerator. Check the CreateNodes function");
						return;
					}
					gridNode.NodeInGridIndex = i * width + j;
				}
			}
		}
	}
	public enum NumNeighbours
	{
		Four,
		Eight
	}
	public class LayerGridGraph : GridGraph, IUpdatableGraph, IRaycastableGraph
	{
		public int[] nodeCellIndices;

		[JsonMember]
		public int layerCount;

		[JsonMember]
		public float mergeSpanRange = 0.5f;

		[JsonMember]
		public float characterHeight = 0.4f;

		public new LevelGridNode[] nodes;

		public override bool uniformWidthDepthGrid => false;

		public override void OnDestroy()
		{
			base.OnDestroy();
			RemoveGridGraphFromStatic();
		}

		public new void RemoveGridGraphFromStatic()
		{
			LevelGridNode.SetGridGraph(active.astarData.GetGraphIndex(this), null);
		}

		public override void GetNodes(GraphNodeDelegateCancelable del)
		{
			if (nodes != null)
			{
				for (int i = 0; i < nodes.Length && (nodes[i] == null || del(nodes[i])); i++)
				{
				}
			}
		}

		public new void UpdateArea(GraphUpdateObject o)
		{
			if (nodes == null || nodes.Length != width * depth * layerCount)
			{
				UnityEngine.Debug.LogWarning("The Grid Graph is not scanned, cannot update area ");
				return;
			}
			Bounds bounds = o.bounds;
			GetBoundsMinMax(bounds, inverseMatrix, out Vector3 min, out Vector3 max);
			int xmin = Mathf.RoundToInt(min.x - 0.5f);
			int xmax = Mathf.RoundToInt(max.x - 0.5f);
			int ymin = Mathf.RoundToInt(min.z - 0.5f);
			int ymax = Mathf.RoundToInt(max.z - 0.5f);
			IntRect intRect = new IntRect(xmin, ymin, xmax, ymax);
			IntRect intRect2 = intRect;
			IntRect b = new IntRect(0, 0, width - 1, depth - 1);
			IntRect intRect3 = intRect;
			bool flag = o.updatePhysics || o.modifyWalkability;
			bool flag2 = o is LayerGridGraphUpdate && ((LayerGridGraphUpdate)o).recalculateNodes;
			bool preserveExistingNodes = !(o is LayerGridGraphUpdate) || ((LayerGridGraphUpdate)o).preserveExistingNodes;
			int num = o.updateErosion ? erodeIterations : 0;
			if (o.trackChangedNodes && flag2)
			{
				UnityEngine.Debug.LogError("Cannot track changed nodes when creating or deleting nodes.\nWill not update LayerGridGraph");
				return;
			}
			if (o.updatePhysics && !o.modifyWalkability && collision.collisionCheck)
			{
				Vector3 a = new Vector3(collision.diameter, 0f, collision.diameter) * 0.5f;
				min -= a * 1.02f;
				max += a * 1.02f;
				intRect3 = new IntRect(Mathf.RoundToInt(min.x - 0.5f), Mathf.RoundToInt(min.z - 0.5f), Mathf.RoundToInt(max.x - 0.5f), Mathf.RoundToInt(max.z - 0.5f));
				intRect2 = IntRect.Union(intRect3, intRect2);
			}
			if (flag || num > 0)
			{
				intRect2 = intRect2.Expand(num + 1);
			}
			IntRect intRect4 = IntRect.Intersection(intRect2, b);
			if (!flag2)
			{
				for (int i = intRect4.xmin; i <= intRect4.xmax; i++)
				{
					for (int j = intRect4.ymin; j <= intRect4.ymax; j++)
					{
						for (int k = 0; k < layerCount; k++)
						{
							o.WillUpdateNode(nodes[k * width * depth + j * width + i]);
						}
					}
				}
			}
			if (o.updatePhysics && !o.modifyWalkability)
			{
				collision.Initialize(matrix, nodeSize);
				intRect4 = IntRect.Intersection(intRect3, b);
				bool flag3 = false;
				for (int l = intRect4.xmin; l <= intRect4.xmax; l++)
				{
					for (int m = intRect4.ymin; m <= intRect4.ymax; m++)
					{
						flag3 |= RecalculateCell(l, m, preserveExistingNodes);
					}
				}
				for (int n = intRect4.xmin; n <= intRect4.xmax; n++)
				{
					for (int num2 = intRect4.ymin; num2 <= intRect4.ymax; num2++)
					{
						for (int num3 = 0; num3 < layerCount; num3++)
						{
							int num4 = num3 * width * depth + num2 * width + n;
							LevelGridNode levelGridNode = nodes[num4];
							if (levelGridNode != null)
							{
								CalculateConnections(nodes, levelGridNode, n, num2, num3);
							}
						}
					}
				}
			}
			intRect4 = IntRect.Intersection(intRect, b);
			for (int num5 = intRect4.xmin; num5 <= intRect4.xmax; num5++)
			{
				for (int num6 = intRect4.ymin; num6 <= intRect4.ymax; num6++)
				{
					for (int num7 = 0; num7 < layerCount; num7++)
					{
						int num8 = num7 * width * depth + num6 * width + num5;
						LevelGridNode levelGridNode2 = nodes[num8];
						if (levelGridNode2 == null)
						{
							continue;
						}
						if (flag)
						{
							levelGridNode2.Walkable = levelGridNode2.WalkableErosion;
							if (o.bounds.Contains((Vector3)levelGridNode2.position))
							{
								o.Apply(levelGridNode2);
							}
							levelGridNode2.WalkableErosion = levelGridNode2.Walkable;
						}
						else if (o.bounds.Contains((Vector3)levelGridNode2.position))
						{
							o.Apply(levelGridNode2);
						}
					}
				}
			}
			if (flag && num == 0)
			{
				intRect4 = IntRect.Intersection(intRect2, b);
				for (int num9 = intRect4.xmin; num9 <= intRect4.xmax; num9++)
				{
					for (int num10 = intRect4.ymin; num10 <= intRect4.ymax; num10++)
					{
						for (int num11 = 0; num11 < layerCount; num11++)
						{
							int num12 = num11 * width * depth + num10 * width + num9;
							LevelGridNode levelGridNode3 = nodes[num12];
							if (levelGridNode3 != null)
							{
								CalculateConnections(nodes, levelGridNode3, num9, num10, num11);
							}
						}
					}
				}
			}
			else
			{
				if (!flag || num <= 0)
				{
					return;
				}
				IntRect a2 = IntRect.Union(intRect, intRect3).Expand(num);
				IntRect a3 = a2.Expand(num);
				a2 = IntRect.Intersection(a2, b);
				a3 = IntRect.Intersection(a3, b);
				for (int num13 = a3.xmin; num13 <= a3.xmax; num13++)
				{
					for (int num14 = a3.ymin; num14 <= a3.ymax; num14++)
					{
						for (int num15 = 0; num15 < layerCount; num15++)
						{
							int num16 = num15 * width * depth + num14 * width + num13;
							LevelGridNode levelGridNode4 = nodes[num16];
							if (levelGridNode4 != null)
							{
								bool walkable = levelGridNode4.Walkable;
								levelGridNode4.Walkable = levelGridNode4.WalkableErosion;
								if (!a2.Contains(num13, num14))
								{
									levelGridNode4.TmpWalkable = walkable;
								}
							}
						}
					}
				}
				for (int num17 = a3.xmin; num17 <= a3.xmax; num17++)
				{
					for (int num18 = a3.ymin; num18 <= a3.ymax; num18++)
					{
						for (int num19 = 0; num19 < layerCount; num19++)
						{
							int num20 = num19 * width * depth + num18 * width + num17;
							LevelGridNode levelGridNode5 = nodes[num20];
							if (levelGridNode5 != null)
							{
								CalculateConnections(nodes, levelGridNode5, num17, num18, num19);
							}
						}
					}
				}
				ErodeWalkableArea(a3.xmin, a3.ymin, a3.xmax + 1, a3.ymax + 1);
				for (int num21 = a3.xmin; num21 <= a3.xmax; num21++)
				{
					for (int num22 = a3.ymin; num22 <= a3.ymax; num22++)
					{
						if (a2.Contains(num21, num22))
						{
							continue;
						}
						for (int num23 = 0; num23 < layerCount; num23++)
						{
							int num24 = num23 * width * depth + num22 * width + num21;
							LevelGridNode levelGridNode6 = nodes[num24];
							if (levelGridNode6 != null)
							{
								levelGridNode6.Walkable = levelGridNode6.TmpWalkable;
							}
						}
					}
				}
				for (int num25 = a3.xmin; num25 <= a3.xmax; num25++)
				{
					for (int num26 = a3.ymin; num26 <= a3.ymax; num26++)
					{
						for (int num27 = 0; num27 < layerCount; num27++)
						{
							int num28 = num27 * width * depth + num26 * width + num25;
							LevelGridNode levelGridNode7 = nodes[num28];
							if (levelGridNode7 != null)
							{
								CalculateConnections(nodes, levelGridNode7, num25, num26, num27);
							}
						}
					}
				}
			}
		}

		public override void ScanInternal(OnScanStatus status)
		{
			scans++;
			if (nodeSize <= 0f)
			{
				return;
			}
			GenerateMatrix();
			if (width > 1024 || depth > 1024)
			{
				UnityEngine.Debug.LogError("One of the grid's sides is longer than 1024 nodes");
				return;
			}
			SetUpOffsetsAndCosts();
			LevelGridNode.SetGridGraph(active.astarData.GetGraphIndex(this), this);
			maxClimb = Mathf.Clamp(maxClimb, 0f, characterHeight);
			LinkedLevelCell[] array = new LinkedLevelCell[width * depth];
			if (collision == null)
			{
				collision = new GraphCollision();
			}
			collision.Initialize(matrix, nodeSize);
			for (int i = 0; i < depth; i++)
			{
				for (int j = 0; j < width; j++)
				{
					array[i * width + j] = new LinkedLevelCell();
					LinkedLevelCell linkedLevelCell = array[i * width + j];
					Vector3 position = matrix.MultiplyPoint3x4(new Vector3((float)j + 0.5f, 0f, (float)i + 0.5f));
					RaycastHit[] array2 = collision.CheckHeightAll(position);
					for (int k = 0; k < array2.Length / 2; k++)
					{
						RaycastHit raycastHit = array2[k];
						array2[k] = array2[array2.Length - 1 - k];
						array2[array2.Length - 1 - k] = raycastHit;
					}
					if (array2.Length > 0)
					{
						LinkedLevelNode linkedLevelNode = null;
						for (int l = 0; l < array2.Length; l++)
						{
							LinkedLevelNode linkedLevelNode2 = new LinkedLevelNode();
							linkedLevelNode2.position = array2[l].point;
							if (linkedLevelNode != null && linkedLevelNode2.position.y - linkedLevelNode.position.y <= mergeSpanRange)
							{
								linkedLevelNode.position = linkedLevelNode2.position;
								linkedLevelNode.hit = array2[l];
								linkedLevelNode.walkable = collision.Check(linkedLevelNode2.position);
								continue;
							}
							linkedLevelNode2.walkable = collision.Check(linkedLevelNode2.position);
							linkedLevelNode2.hit = array2[l];
							linkedLevelNode2.height = float.PositiveInfinity;
							if (linkedLevelCell.first == null)
							{
								linkedLevelCell.first = linkedLevelNode2;
								linkedLevelNode = linkedLevelNode2;
							}
							else
							{
								linkedLevelNode.next = linkedLevelNode2;
								linkedLevelNode.height = linkedLevelNode2.position.y - linkedLevelNode.position.y;
								linkedLevelNode = linkedLevelNode.next;
							}
						}
					}
					else
					{
						LinkedLevelNode linkedLevelNode3 = new LinkedLevelNode();
						linkedLevelNode3.position = position;
						linkedLevelNode3.height = float.PositiveInfinity;
						linkedLevelNode3.walkable = !collision.unwalkableWhenNoGround;
						linkedLevelCell.first = linkedLevelNode3;
					}
				}
			}
			int num = 0;
			layerCount = 0;
			for (int m = 0; m < depth; m++)
			{
				for (int n = 0; n < width; n++)
				{
					LinkedLevelCell linkedLevelCell2 = array[m * width + n];
					LinkedLevelNode linkedLevelNode4 = linkedLevelCell2.first;
					int num2 = 0;
					do
					{
						num2++;
						num++;
						linkedLevelNode4 = linkedLevelNode4.next;
					}
					while (linkedLevelNode4 != null);
					layerCount = ((num2 <= layerCount) ? layerCount : num2);
				}
			}
			if (layerCount > 255)
			{
				UnityEngine.Debug.LogError("Too many layers, a maximum of LevelGridNode.MaxLayerCount are allowed (found " + layerCount + ")");
				return;
			}
			nodes = new LevelGridNode[width * depth * layerCount];
			for (int num3 = 0; num3 < nodes.Length; num3++)
			{
				nodes[num3] = new LevelGridNode(active);
				nodes[num3].Penalty = initialPenalty;
			}
			int num4 = 0;
			float num5 = Mathf.Cos(maxSlope * ((float)Math.PI / 180f));
			for (int num6 = 0; num6 < depth; num6++)
			{
				for (int num7 = 0; num7 < width; num7++)
				{
					LinkedLevelCell linkedLevelCell3 = array[num6 * width + num7];
					LinkedLevelNode linkedLevelNode5 = linkedLevelCell3.first;
					linkedLevelCell3.index = num4;
					int num8 = 0;
					int num9 = 0;
					do
					{
						LevelGridNode levelGridNode = nodes[num6 * width + num7 + width * depth * num9];
						levelGridNode.SetPosition((Int3)linkedLevelNode5.position);
						levelGridNode.Walkable = linkedLevelNode5.walkable;
						if (linkedLevelNode5.hit.normal != Vector3.zero && (penaltyAngle || num5 < 1f))
						{
							float num10 = Vector3.Dot(linkedLevelNode5.hit.normal.normalized, collision.up);
							if (penaltyAngle)
							{
								levelGridNode.Penalty += (uint)Mathf.RoundToInt((1f - num10) * penaltyAngleFactor);
							}
							if (num10 < num5)
							{
								levelGridNode.Walkable = false;
							}
						}
						levelGridNode.NodeInGridIndex = num6 * width + num7;
						if (linkedLevelNode5.height < characterHeight)
						{
							levelGridNode.Walkable = false;
						}
						levelGridNode.WalkableErosion = levelGridNode.Walkable;
						num4++;
						num8++;
						linkedLevelNode5 = linkedLevelNode5.next;
						num9++;
					}
					while (linkedLevelNode5 != null);
					for (; num9 < layerCount; num9++)
					{
						nodes[num6 * width + num7 + width * depth * num9] = null;
					}
					linkedLevelCell3.count = num8;
				}
			}
			num4 = 0;
			nodeCellIndices = new int[array.Length];
			for (int num11 = 0; num11 < depth; num11++)
			{
				for (int num12 = 0; num12 < width; num12++)
				{
					for (int num13 = 0; num13 < layerCount; num13++)
					{
						GraphNode node = nodes[num11 * width + num12 + width * depth * num13];
						CalculateConnections(nodes, node, num12, num11, num13);
					}
				}
			}
			uint graphIndex = (uint)active.astarData.GetGraphIndex(this);
			for (int num14 = 0; num14 < nodes.Length; num14++)
			{
				LevelGridNode levelGridNode2 = nodes[num14];
				if (levelGridNode2 != null)
				{
					UpdatePenalty(levelGridNode2);
					levelGridNode2.GraphIndex = graphIndex;
					if (!levelGridNode2.HasAnyGridConnections())
					{
						levelGridNode2.Walkable = false;
						levelGridNode2.WalkableErosion = levelGridNode2.Walkable;
					}
				}
			}
			ErodeWalkableArea(0, 0, width, depth);
		}

		public bool RecalculateCell(int x, int z, bool preserveExistingNodes)
		{
			LinkedLevelCell linkedLevelCell = new LinkedLevelCell();
			Vector3 position = matrix.MultiplyPoint3x4(new Vector3((float)x + 0.5f, 0f, (float)z + 0.5f));
			RaycastHit[] array = collision.CheckHeightAll(position);
			for (int i = 0; i < array.Length / 2; i++)
			{
				RaycastHit raycastHit = array[i];
				array[i] = array[array.Length - 1 - i];
				array[array.Length - 1 - i] = raycastHit;
			}
			bool result = false;
			if (array.Length > 0)
			{
				LinkedLevelNode linkedLevelNode = null;
				for (int j = 0; j < array.Length; j++)
				{
					LinkedLevelNode linkedLevelNode2 = new LinkedLevelNode();
					linkedLevelNode2.position = array[j].point;
					if (linkedLevelNode != null && linkedLevelNode2.position.y - linkedLevelNode.position.y <= mergeSpanRange)
					{
						linkedLevelNode.position = linkedLevelNode2.position;
						linkedLevelNode.hit = array[j];
						linkedLevelNode.walkable = collision.Check(linkedLevelNode2.position);
						continue;
					}
					linkedLevelNode2.walkable = collision.Check(linkedLevelNode2.position);
					linkedLevelNode2.hit = array[j];
					linkedLevelNode2.height = float.PositiveInfinity;
					if (linkedLevelCell.first == null)
					{
						linkedLevelCell.first = linkedLevelNode2;
						linkedLevelNode = linkedLevelNode2;
					}
					else
					{
						linkedLevelNode.next = linkedLevelNode2;
						linkedLevelNode.height = linkedLevelNode2.position.y - linkedLevelNode.position.y;
						linkedLevelNode = linkedLevelNode.next;
					}
				}
			}
			else
			{
				LinkedLevelNode linkedLevelNode3 = new LinkedLevelNode();
				linkedLevelNode3.position = position;
				linkedLevelNode3.height = float.PositiveInfinity;
				linkedLevelNode3.walkable = !collision.unwalkableWhenNoGround;
				linkedLevelCell.first = linkedLevelNode3;
			}
			uint graphIndex = (uint)active.astarData.GetGraphIndex(this);
			LinkedLevelNode linkedLevelNode4 = linkedLevelCell.first;
			int num = 0;
			int k = 0;
			do
			{
				if (k >= layerCount)
				{
					if (k + 1 > 255)
					{
						UnityEngine.Debug.LogError("Too many layers, a maximum of LevelGridNode.MaxLayerCount are allowed (required " + (k + 1) + ")");
						return result;
					}
					AddLayers(1);
					result = true;
				}
				LevelGridNode levelGridNode = nodes[z * width + x + width * depth * k];
				if (levelGridNode == null || !preserveExistingNodes)
				{
					nodes[z * width + x + width * depth * k] = new LevelGridNode(active);
					levelGridNode = nodes[z * width + x + width * depth * k];
					levelGridNode.Penalty = initialPenalty;
					levelGridNode.GraphIndex = graphIndex;
					result = true;
				}
				levelGridNode.SetPosition((Int3)linkedLevelNode4.position);
				levelGridNode.Walkable = linkedLevelNode4.walkable;
				levelGridNode.WalkableErosion = levelGridNode.Walkable;
				if (linkedLevelNode4.hit.normal != Vector3.zero)
				{
					float num2 = Vector3.Dot(linkedLevelNode4.hit.normal.normalized, collision.up);
					if (penaltyAngle)
					{
						levelGridNode.Penalty += (uint)Mathf.RoundToInt((1f - num2) * penaltyAngleFactor);
					}
					float num3 = Mathf.Cos(maxSlope * ((float)Math.PI / 180f));
					if (num2 < num3)
					{
						levelGridNode.Walkable = false;
					}
				}
				levelGridNode.NodeInGridIndex = z * width + x;
				if (linkedLevelNode4.height < characterHeight)
				{
					levelGridNode.Walkable = false;
				}
				num++;
				linkedLevelNode4 = linkedLevelNode4.next;
				k++;
			}
			while (linkedLevelNode4 != null);
			for (; k < layerCount; k++)
			{
				nodes[z * width + x + width * depth * k] = null;
			}
			linkedLevelCell.count = num;
			return result;
		}

		public void AddLayers(int count)
		{
			int num = layerCount + count;
			if (num > 255)
			{
				UnityEngine.Debug.LogError("Too many layers, a maximum of LevelGridNode.MaxLayerCount are allowed (required " + num + ")");
				return;
			}
			LevelGridNode[] array = nodes;
			nodes = new LevelGridNode[width * depth * num];
			for (int i = 0; i < array.Length; i++)
			{
				nodes[i] = array[i];
			}
			layerCount = num;
		}

		public virtual void UpdatePenalty(LevelGridNode node)
		{
			node.Penalty = 0u;
			node.Penalty = initialPenalty;
			if (penaltyPosition)
			{
				node.Penalty += (uint)Mathf.RoundToInt(((float)node.position.y - penaltyPositionOffset) * penaltyPositionFactor);
			}
		}

		public override void ErodeWalkableArea(int xmin, int zmin, int xmax, int zmax)
		{
			xmin = ((xmin >= 0) ? ((xmin <= width) ? xmin : width) : 0);
			xmax = ((xmax >= 0) ? ((xmax <= width) ? xmax : width) : 0);
			zmin = ((zmin >= 0) ? ((zmin <= depth) ? zmin : depth) : 0);
			zmax = ((zmax >= 0) ? ((zmax <= depth) ? zmax : depth) : 0);
			if (erosionUseTags)
			{
				UnityEngine.Debug.LogError("Erosion Uses Tags is not supported for LayerGridGraphs yet");
			}
			for (int i = 0; i < erodeIterations; i++)
			{
				for (int j = 0; j < layerCount; j++)
				{
					for (int k = zmin; k < zmax; k++)
					{
						for (int l = xmin; l < xmax; l++)
						{
							LevelGridNode levelGridNode = nodes[k * width + l + width * depth * j];
							if (levelGridNode == null || !levelGridNode.Walkable)
							{
								continue;
							}
							bool flag = false;
							for (int m = 0; m < 4; m++)
							{
								if (!levelGridNode.GetConnection(m))
								{
									flag = true;
									break;
								}
							}
							if (flag)
							{
								levelGridNode.Walkable = false;
							}
						}
					}
				}
				for (int n = 0; n < layerCount; n++)
				{
					for (int num = zmin; num < zmax; num++)
					{
						for (int num2 = xmin; num2 < xmax; num2++)
						{
							LevelGridNode levelGridNode2 = nodes[num * width + num2 + width * depth * n];
							if (levelGridNode2 != null)
							{
								CalculateConnections(nodes, levelGridNode2, num2, num, n);
							}
						}
					}
				}
			}
		}

		public void CalculateConnections(GraphNode[] nodes, GraphNode node, int x, int z, int layerIndex)
		{
			if (node == null)
			{
				return;
			}
			LevelGridNode levelGridNode = (LevelGridNode)node;
			levelGridNode.ResetAllGridConnections();
			if (!node.Walkable)
			{
				return;
			}
			float num = 0f;
			num = ((layerIndex != layerCount - 1 && nodes[levelGridNode.NodeInGridIndex + width * depth * (layerIndex + 1)] != null) ? ((float)Math.Abs(levelGridNode.position.y - nodes[levelGridNode.NodeInGridIndex + width * depth * (layerIndex + 1)].position.y) * 0.001f) : float.PositiveInfinity);
			for (int i = 0; i < 4; i++)
			{
				int num2 = x + neighbourXOffsets[i];
				int num3 = z + neighbourZOffsets[i];
				if (num2 < 0 || num3 < 0 || num2 >= width || num3 >= depth)
				{
					continue;
				}
				int num4 = num3 * width + num2;
				int value = 255;
				for (int j = 0; j < layerCount; j++)
				{
					GraphNode graphNode = nodes[num4 + width * depth * j];
					if (graphNode != null && graphNode.Walkable)
					{
						float num5 = 0f;
						num5 = ((j != layerCount - 1 && nodes[num4 + width * depth * (j + 1)] != null) ? ((float)Math.Abs(graphNode.position.y - nodes[num4 + width * depth * (j + 1)].position.y) * 0.001f) : float.PositiveInfinity);
						float num6 = Mathf.Max((float)graphNode.position.y * 0.001f, (float)levelGridNode.position.y * 0.001f);
						float num7 = Mathf.Min((float)graphNode.position.y * 0.001f + num5, (float)levelGridNode.position.y * 0.001f + num);
						float num8 = num7 - num6;
						if (num8 >= characterHeight && (float)Mathf.Abs(graphNode.position.y - levelGridNode.position.y) * 0.001f <= maxClimb)
						{
							value = j;
						}
					}
				}
				levelGridNode.SetConnectionValue(i, value);
			}
		}

		public override NNInfo GetNearest(Vector3 position, NNConstraint constraint, GraphNode hint = null)
		{
			if (nodes == null || depth * width * layerCount != nodes.Length)
			{
				return default(NNInfo);
			}
			position = inverseMatrix.MultiplyPoint3x4(position);
			int num = Mathf.Clamp(Mathf.RoundToInt(position.x - 0.5f), 0, width - 1);
			int num2 = Mathf.Clamp(Mathf.RoundToInt(position.z - 0.5f), 0, depth - 1);
			int num3 = width * num2 + num;
			float num4 = float.PositiveInfinity;
			LevelGridNode node = null;
			for (int i = 0; i < layerCount; i++)
			{
				LevelGridNode levelGridNode = nodes[num3 + width * depth * i];
				if (levelGridNode != null)
				{
					float sqrMagnitude = ((Vector3)levelGridNode.position - position).sqrMagnitude;
					if (sqrMagnitude < num4)
					{
						num4 = sqrMagnitude;
						node = levelGridNode;
					}
				}
			}
			return new NNInfo(node);
		}

		private LevelGridNode GetNearestNode(Vector3 position, int x, int z, NNConstraint constraint)
		{
			int num = width * z + x;
			float num2 = float.PositiveInfinity;
			LevelGridNode result = null;
			for (int i = 0; i < layerCount; i++)
			{
				LevelGridNode levelGridNode = nodes[num + width * depth * i];
				if (levelGridNode != null)
				{
					float sqrMagnitude = ((Vector3)levelGridNode.position - position).sqrMagnitude;
					if (sqrMagnitude < num2 && constraint.Suitable(levelGridNode))
					{
						num2 = sqrMagnitude;
						result = levelGridNode;
					}
				}
			}
			return result;
		}

		public override NNInfo GetNearestForce(Vector3 position, NNConstraint constraint)
		{
			if (nodes == null || depth * width * layerCount != nodes.Length || layerCount == 0)
			{
				return default(NNInfo);
			}
			Vector3 vector = position;
			position = inverseMatrix.MultiplyPoint3x4(position);
			int num = Mathf.Clamp(Mathf.RoundToInt(position.x - 0.5f), 0, width - 1);
			int num2 = Mathf.Clamp(Mathf.RoundToInt(position.z - 0.5f), 0, depth - 1);
			LevelGridNode levelGridNode = null;
			float num3 = float.PositiveInfinity;
			int num4 = 2;
			levelGridNode = GetNearestNode(vector, num, num2, constraint);
			if (levelGridNode != null)
			{
				num3 = ((Vector3)levelGridNode.position - vector).sqrMagnitude;
			}
			if (levelGridNode != null)
			{
				if (num4 == 0)
				{
					return new NNInfo(levelGridNode);
				}
				num4--;
			}
			float num5 = (!constraint.constrainDistance) ? float.PositiveInfinity : AstarPath.active.maxNearestNodeDistance;
			float num6 = num5 * num5;
			int num7 = 1;
			while (true)
			{
				int num8 = num;
				int num9 = num2 + num7;
				if (nodeSize * (float)num7 > num5)
				{
					return new NNInfo(levelGridNode);
				}
				for (num8 = num - num7; num8 <= num + num7; num8++)
				{
					if (num8 < 0 || num9 < 0 || num8 >= width || num9 >= depth)
					{
						continue;
					}
					LevelGridNode nearestNode = GetNearestNode(vector, num8, num9, constraint);
					if (nearestNode != null)
					{
						float sqrMagnitude = ((Vector3)nearestNode.position - vector).sqrMagnitude;
						if (sqrMagnitude < num3 && sqrMagnitude < num6)
						{
							num3 = sqrMagnitude;
							levelGridNode = nearestNode;
						}
					}
				}
				num9 = num2 - num7;
				for (num8 = num - num7; num8 <= num + num7; num8++)
				{
					if (num8 < 0 || num9 < 0 || num8 >= width || num9 >= depth)
					{
						continue;
					}
					LevelGridNode nearestNode2 = GetNearestNode(vector, num8, num9, constraint);
					if (nearestNode2 != null)
					{
						float sqrMagnitude2 = ((Vector3)nearestNode2.position - vector).sqrMagnitude;
						if (sqrMagnitude2 < num3 && sqrMagnitude2 < num6)
						{
							num3 = sqrMagnitude2;
							levelGridNode = nearestNode2;
						}
					}
				}
				num8 = num - num7;
				num9 = num2 - num7 + 1;
				for (num9 = num2 - num7 + 1; num9 <= num2 + num7 - 1; num9++)
				{
					if (num8 < 0 || num9 < 0 || num8 >= width || num9 >= depth)
					{
						continue;
					}
					LevelGridNode nearestNode3 = GetNearestNode(vector, num8, num9, constraint);
					if (nearestNode3 != null)
					{
						float sqrMagnitude3 = ((Vector3)nearestNode3.position - vector).sqrMagnitude;
						if (sqrMagnitude3 < num3 && sqrMagnitude3 < num6)
						{
							num3 = sqrMagnitude3;
							levelGridNode = nearestNode3;
						}
					}
				}
				num8 = num + num7;
				for (num9 = num2 - num7 + 1; num9 <= num2 + num7 - 1; num9++)
				{
					if (num8 < 0 || num9 < 0 || num8 >= width || num9 >= depth)
					{
						continue;
					}
					LevelGridNode nearestNode4 = GetNearestNode(vector, num8, num9, constraint);
					if (nearestNode4 != null)
					{
						float sqrMagnitude4 = ((Vector3)nearestNode4.position - vector).sqrMagnitude;
						if (sqrMagnitude4 < num3 && sqrMagnitude4 < num6)
						{
							num3 = sqrMagnitude4;
							levelGridNode = nearestNode4;
						}
					}
				}
				if (levelGridNode != null)
				{
					if (num4 == 0)
					{
						break;
					}
					num4--;
				}
				num7++;
			}
			return new NNInfo(levelGridNode);
		}

		public new bool Linecast(Vector3 _a, Vector3 _b)
		{
			GraphHitInfo hit;
			return Linecast(_a, _b, null, out hit);
		}

		public new bool Linecast(Vector3 _a, Vector3 _b, GraphNode hint)
		{
			GraphHitInfo hit;
			return Linecast(_a, _b, hint, out hit);
		}

		public new bool Linecast(Vector3 _a, Vector3 _b, GraphNode hint, out GraphHitInfo hit)
		{
			return SnappedLinecast(_a, _b, hint, out hit);
		}

		public new bool SnappedLinecast(Vector3 _a, Vector3 _b, GraphNode hint, out GraphHitInfo hit)
		{
			hit = default(GraphHitInfo);
			NNInfo nearest = GetNearest(_a, NNConstraint.None);
			LevelGridNode levelGridNode = nearest.node as LevelGridNode;
			NNInfo nearest2 = GetNearest(_b, NNConstraint.None);
			LevelGridNode levelGridNode2 = nearest2.node as LevelGridNode;
			if (levelGridNode == null || levelGridNode2 == null)
			{
				hit.node = null;
				hit.point = _a;
				return true;
			}
			_a = inverseMatrix.MultiplyPoint3x4((Vector3)levelGridNode.position);
			_a.x -= 0.5f;
			_a.z -= 0.5f;
			_b = inverseMatrix.MultiplyPoint3x4((Vector3)levelGridNode2.position);
			_b.x -= 0.5f;
			_b.z -= 0.5f;
			Int3 ob = new Int3(Mathf.RoundToInt(_a.x), Mathf.RoundToInt(_a.y), Mathf.RoundToInt(_a.z));
			Int3 @int = new Int3(Mathf.RoundToInt(_b.x), Mathf.RoundToInt(_b.y), Mathf.RoundToInt(_b.z));
			hit.origin = (Vector3)ob;
			if (!levelGridNode.Walkable)
			{
				hit.node = levelGridNode;
				hit.point = matrix.MultiplyPoint3x4(new Vector3((float)ob.x + 0.5f, 0f, (float)ob.z + 0.5f));
				ref Vector3 point = ref hit.point;
				Vector3 vector = (Vector3)hit.node.position;
				point.y = vector.y;
				return true;
			}
			int num = Mathf.Abs(ob.x - @int.x);
			int num2 = Mathf.Abs(ob.z - @int.z);
			LevelGridNode levelGridNode3 = levelGridNode;
			while (true)
			{
				if (levelGridNode3 == levelGridNode2)
				{
					return false;
				}
				if (levelGridNode3.NodeInGridIndex == levelGridNode2.NodeInGridIndex)
				{
					hit.node = levelGridNode3;
					hit.point = (Vector3)levelGridNode3.position;
					return true;
				}
				num = Math.Abs(ob.x - @int.x);
				num2 = Math.Abs(ob.z - @int.z);
				int num3 = 0;
				if (num >= num2)
				{
					num3 = ((@int.x > ob.x) ? 1 : 3);
				}
				else if (num2 > num)
				{
					num3 = ((@int.z > ob.z) ? 2 : 0);
				}
				if (!CheckConnection(levelGridNode3, num3))
				{
					break;
				}
				LevelGridNode levelGridNode4 = nodes[levelGridNode3.NodeInGridIndex + neighbourOffsets[num3] + width * depth * levelGridNode3.GetConnectionValue(num3)];
				if (!levelGridNode4.Walkable)
				{
					hit.node = levelGridNode4;
					hit.point = (Vector3)levelGridNode4.position;
					return true;
				}
				ob = (Int3)inverseMatrix.MultiplyPoint3x4((Vector3)levelGridNode4.position);
				levelGridNode3 = levelGridNode4;
			}
			hit.node = levelGridNode3;
			hit.point = (Vector3)levelGridNode3.position;
			return true;
		}

		public bool CheckConnection(LevelGridNode node, int dir)
		{
			return node.GetConnection(dir);
		}

		public override void OnDrawGizmos(bool drawNodes)
		{
			if (!drawNodes)
			{
				return;
			}
			base.OnDrawGizmos(drawNodes: false);
			if (nodes == null)
			{
				return;
			}
			PathHandler debugPathData = AstarPath.active.debugPathData;
			for (int i = 0; i < nodes.Length; i++)
			{
				LevelGridNode levelGridNode = nodes[i];
				if (levelGridNode == null || !levelGridNode.Walkable)
				{
					continue;
				}
				Gizmos.color = NodeColor(levelGridNode, AstarPath.active.debugPathData);
				if (AstarPath.active.showSearchTree && AstarPath.active.debugPathData != null)
				{
					if (InSearchTree(levelGridNode, AstarPath.active.debugPath))
					{
						PathNode pathNode = debugPathData.GetPathNode(levelGridNode);
						if (pathNode != null && pathNode.parent != null)
						{
							Gizmos.DrawLine((Vector3)levelGridNode.position, (Vector3)pathNode.parent.node.position);
						}
					}
					continue;
				}
				for (int j = 0; j < 4; j++)
				{
					int connectionValue = levelGridNode.GetConnectionValue(j);
					if (connectionValue == 255)
					{
						continue;
					}
					int num = levelGridNode.NodeInGridIndex + neighbourOffsets[j] + width * depth * connectionValue;
					if (num >= 0 && num <= nodes.Length)
					{
						GraphNode graphNode = nodes[num];
						if (graphNode != null)
						{
							Gizmos.DrawLine((Vector3)levelGridNode.position, (Vector3)graphNode.position);
						}
					}
				}
			}
		}

		public override void SerializeExtraInfo(GraphSerializationContext ctx)
		{
			if (nodes == null)
			{
				ctx.writer.Write(-1);
				return;
			}
			ctx.writer.Write(nodes.Length);
			for (int i = 0; i < nodes.Length; i++)
			{
				if (nodes[i] == null)
				{
					ctx.writer.Write(-1);
					continue;
				}
				ctx.writer.Write(0);
				nodes[i].SerializeNode(ctx);
			}
		}

		public override void DeserializeExtraInfo(GraphSerializationContext ctx)
		{
			int num = ctx.reader.ReadInt32();
			if (num == -1)
			{
				nodes = null;
				return;
			}
			nodes = new LevelGridNode[num];
			for (int i = 0; i < nodes.Length; i++)
			{
				if (ctx.reader.ReadInt32() != -1)
				{
					nodes[i] = new LevelGridNode(active);
					nodes[i].DeserializeNode(ctx);
				}
				else
				{
					nodes[i] = null;
				}
			}
		}

		public override void PostDeserialization()
		{
			GenerateMatrix();
			SetUpOffsetsAndCosts();
			if (nodes == null || nodes.Length == 0)
			{
				return;
			}
			LevelGridNode.SetGridGraph(AstarPath.active.astarData.GetGraphIndex(this), this);
			for (int i = 0; i < depth; i++)
			{
				for (int j = 0; j < width; j++)
				{
					for (int k = 0; k < layerCount; k++)
					{
						LevelGridNode levelGridNode = nodes[i * width + j + width * depth * k];
						if (levelGridNode != null)
						{
							levelGridNode.NodeInGridIndex = i * width + j;
						}
					}
				}
			}
		}
	}
	public class LinkedLevelCell
	{
		public int count;

		public int index;

		public LinkedLevelNode first;
	}
	public class LinkedLevelNode
	{
		public Vector3 position;

		public bool walkable;

		public RaycastHit hit;

		public float height;

		public LinkedLevelNode next;
	}
	public class LevelGridNode : GraphNode
	{
		private const int GridFlagsWalkableErosionOffset = 8;

		private const int GridFlagsWalkableErosionMask = 256;

		private const int GridFlagsWalkableTmpOffset = 9;

		private const int GridFlagsWalkableTmpMask = 512;

		public const int NoConnection = 255;

		public const int ConnectionMask = 255;

		private const int ConnectionStride = 8;

		public const int MaxLayerCount = 255;

		private static LayerGridGraph[] _gridGraphs = new LayerGridGraph[0];

		protected ushort gridFlags;

		protected int nodeInGridIndex;

		protected uint gridConnections;

		protected static LayerGridGraph[] gridGraphs;

		public bool WalkableErosion
		{
			get
			{
				return (gridFlags & 0x100) != 0;
			}
			set
			{
				gridFlags = (ushort)((gridFlags & -257) | (value ? 256 : 0));
			}
		}

		public bool TmpWalkable
		{
			get
			{
				return (gridFlags & 0x200) != 0;
			}
			set
			{
				gridFlags = (ushort)((gridFlags & -513) | (value ? 512 : 0));
			}
		}

		public int NodeInGridIndex
		{
			get
			{
				return nodeInGridIndex;
			}
			set
			{
				nodeInGridIndex = value;
			}
		}

		public LevelGridNode(AstarPath astar)
			: base(astar)
		{
		}

		public static LayerGridGraph GetGridGraph(uint graphIndex)
		{
			return _gridGraphs[graphIndex];
		}

		public static void SetGridGraph(int graphIndex, LayerGridGraph graph)
		{
			if (_gridGraphs.Length <= graphIndex)
			{
				LayerGridGraph[] array = new LayerGridGraph[graphIndex + 1];
				for (int i = 0; i < _gridGraphs.Length; i++)
				{
					array[i] = _gridGraphs[i];
				}
				_gridGraphs = array;
			}
			_gridGraphs[graphIndex] = graph;
		}

		public void ResetAllGridConnections()
		{
			gridConnections = uint.MaxValue;
		}

		public bool HasAnyGridConnections()
		{
			return gridConnections != uint.MaxValue;
		}

		public void SetPosition(Int3 position)
		{
			base.position = position;
		}

		public override void ClearConnections(bool alsoReverse)
		{
			if (alsoReverse)
			{
				LayerGridGraph gridGraph = GetGridGraph(base.GraphIndex);
				int[] neighbourOffsets = gridGraph.neighbourOffsets;
				LevelGridNode[] nodes = gridGraph.nodes;
				for (int i = 0; i < 4; i++)
				{
					int connectionValue = GetConnectionValue(i);
					if (connectionValue != 255)
					{
						nodes[NodeInGridIndex + neighbourOffsets[i] + gridGraph.width * gridGraph.depth * connectionValue]?.SetConnectionValue((i >= 4) ? 7 : ((i + 2) % 4), 255);
					}
				}
			}
			ResetAllGridConnections();
		}

		public override void GetConnections(GraphNodeDelegate del)
		{
			int num = NodeInGridIndex;
			LayerGridGraph gridGraph = GetGridGraph(base.GraphIndex);
			int[] neighbourOffsets = gridGraph.neighbourOffsets;
			LevelGridNode[] nodes = gridGraph.nodes;
			for (int i = 0; i < 4; i++)
			{
				int connectionValue = GetConnectionValue(i);
				if (connectionValue != 255)
				{
					LevelGridNode levelGridNode = nodes[num + neighbourOffsets[i] + gridGraph.width * gridGraph.depth * connectionValue];
					if (levelGridNode != null)
					{
						del(levelGridNode);
					}
				}
			}
		}

		public override void FloodFill(Stack<GraphNode> stack, uint region)
		{
			int num = NodeInGridIndex;
			LayerGridGraph gridGraph = GetGridGraph(base.GraphIndex);
			int[] neighbourOffsets = gridGraph.neighbourOffsets;
			LevelGridNode[] nodes = gridGraph.nodes;
			for (int i = 0; i < 4; i++)
			{
				int connectionValue = GetConnectionValue(i);
				if (connectionValue != 255)
				{
					LevelGridNode levelGridNode = nodes[num + neighbourOffsets[i] + gridGraph.width * gridGraph.depth * connectionValue];
					if (levelGridNode != null && levelGridNode.Area != region)
					{
						levelGridNode.Area = region;
						stack.Push(levelGridNode);
					}
				}
			}
		}

		public override void AddConnection(GraphNode node, uint cost)
		{
			throw new NotImplementedException("Layered Grid Nodes do not have support for adding manual connections");
		}

		public override void RemoveConnection(GraphNode node)
		{
			throw new NotImplementedException("Layered Grid Nodes do not have support for adding manual connections");
		}

		public bool GetConnection(int i)
		{
			return ((gridConnections >> i * 8) & 0xFF) != 255;
		}

		public void SetConnectionValue(int dir, int value)
		{
			gridConnections = (uint)(((int)gridConnections & ~(255 << dir * 8)) | (value << dir * 8));
		}

		public int GetConnectionValue(int dir)
		{
			return (int)((gridConnections >> dir * 8) & 0xFF);
		}

		public override bool GetPortal(GraphNode other, List<Vector3> left, List<Vector3> right, bool backwards)
		{
			if (backwards)
			{
				return true;
			}
			LayerGridGraph gridGraph = GetGridGraph(base.GraphIndex);
			int[] neighbourOffsets = gridGraph.neighbourOffsets;
			LevelGridNode[] nodes = gridGraph.nodes;
			int num = NodeInGridIndex;
			for (int i = 0; i < 4; i++)
			{
				int connectionValue = GetConnectionValue(i);
				if (connectionValue != 255 && other == nodes[num + neighbourOffsets[i] + gridGraph.width * gridGraph.depth * connectionValue])
				{
					Vector3 a = (Vector3)(position + other.position) * 0.5f;
					Vector3 b = Vector3.Cross(gridGraph.collision.up, (Vector3)(other.position - position));
					b.Normalize();
					b *= gridGraph.nodeSize * 0.5f;
					left.Add(a - b);
					right.Add(a + b);
					return true;
				}
			}
			return false;
		}

		public override void UpdateRecursiveG(Path path, PathNode pathNode, PathHandler handler)
		{
			handler.PushNode(pathNode);
			UpdateG(path, pathNode);
			LayerGridGraph gridGraph = GetGridGraph(base.GraphIndex);
			int[] neighbourOffsets = gridGraph.neighbourOffsets;
			LevelGridNode[] nodes = gridGraph.nodes;
			int num = NodeInGridIndex;
			for (int i = 0; i < 4; i++)
			{
				int connectionValue = GetConnectionValue(i);
				if (connectionValue != 255)
				{
					LevelGridNode levelGridNode = nodes[num + neighbourOffsets[i] + gridGraph.width * gridGraph.depth * connectionValue];
					PathNode pathNode2 = handler.GetPathNode(levelGridNode);
					if (pathNode2 != null && pathNode2.parent == pathNode && pathNode2.pathID == handler.PathID)
					{
						levelGridNode.UpdateRecursiveG(path, pathNode2, handler);
					}
				}
			}
		}

		public override void Open(Path path, PathNode pathNode, PathHandler handler)
		{
			LayerGridGraph gridGraph = GetGridGraph(base.GraphIndex);
			int[] neighbourOffsets = gridGraph.neighbourOffsets;
			uint[] neighbourCosts = gridGraph.neighbourCosts;
			LevelGridNode[] nodes = gridGraph.nodes;
			int num = NodeInGridIndex;
			for (int i = 0; i < 4; i++)
			{
				int connectionValue = GetConnectionValue(i);
				if (connectionValue == 255)
				{
					continue;
				}
				GraphNode graphNode = nodes[num + neighbourOffsets[i] + gridGraph.width * gridGraph.depth * connectionValue];
				if (!path.CanTraverse(graphNode))
				{
					continue;
				}
				PathNode pathNode2 = handler.GetPathNode(graphNode);
				if (pathNode2.pathID != handler.PathID)
				{
					pathNode2.parent = pathNode;
					pathNode2.pathID = handler.PathID;
					pathNode2.cost = neighbourCosts[i];
					pathNode2.H = path.CalculateHScore(graphNode);
					graphNode.UpdateG(path, pathNode2);
					handler.PushNode(pathNode2);
					continue;
				}
				uint num2 = neighbourCosts[i];
				if (pathNode.G + num2 + path.GetTraversalCost(graphNode) < pathNode2.G)
				{
					pathNode2.cost = num2;
					pathNode2.parent = pathNode;
					graphNode.UpdateRecursiveG(path, pathNode2, handler);
				}
				else if (pathNode2.G + num2 + path.GetTraversalCost(this) < pathNode.G)
				{
					pathNode.parent = pathNode2;
					pathNode.cost = num2;
					UpdateRecursiveG(path, pathNode, handler);
				}
			}
		}

		public override void SerializeNode(GraphSerializationContext ctx)
		{
			base.SerializeNode(ctx);
			ctx.writer.Write(position.x);
			ctx.writer.Write(position.y);
			ctx.writer.Write(position.z);
			ctx.writer.Write(gridFlags);
			ctx.writer.Write(gridConnections);
		}

		public override void DeserializeNode(GraphSerializationContext ctx)
		{
			base.DeserializeNode(ctx);
			position = new Int3(ctx.reader.ReadInt32(), ctx.reader.ReadInt32(), ctx.reader.ReadInt32());
			gridFlags = ctx.reader.ReadUInt16();
			gridConnections = ctx.reader.ReadUInt32();
		}
	}
	public class LayerGridGraphUpdate : GraphUpdateObject
	{
		public bool recalculateNodes;

		public bool preserveExistingNodes = true;
	}
	public interface INavmesh
	{
		void GetNodes(GraphNodeDelegateCancelable del);
	}
	[Serializable]
	[JsonOptIn]
	public class NavMeshGraph : NavGraph, IUpdatableGraph, IRaycastableGraph, INavmesh, INavmeshHolder, IFunnelGraph
	{
		[JsonMember]
		public Mesh sourceMesh;

		[JsonMember]
		public Vector3 offset;

		[JsonMember]
		public Vector3 rotation;

		[JsonMember]
		public float scale = 1f;

		[JsonMember]
		public bool accurateNearestNode = true;

		public TriangleMeshNode[] nodes;

		private BBTree _bbTree;

		[NonSerialized]
		private Int3[] _vertices;

		[NonSerialized]
		private Vector3[] originalVertices;

		[NonSerialized]
		public int[] triangles;

		public TriangleMeshNode[] TriNodes => nodes;

		public BBTree bbTree
		{
			get
			{
				return _bbTree;
			}
			set
			{
				_bbTree = value;
			}
		}

		public Int3[] vertices
		{
			get
			{
				return _vertices;
			}
			set
			{
				_vertices = value;
			}
		}

		public override void CreateNodes(int number)
		{
			TriangleMeshNode[] array = new TriangleMeshNode[number];
			for (int i = 0; i < number; i++)
			{
				array[i] = new TriangleMeshNode(active);
				array[i].Penalty = initialPenalty;
			}
		}

		public override void GetNodes(GraphNodeDelegateCancelable del)
		{
			if (nodes != null)
			{
				for (int i = 0; i < nodes.Length && del(nodes[i]); i++)
				{
				}
			}
		}

		public override void OnDestroy()
		{
			base.OnDestroy();
			TriangleMeshNode.SetNavmeshHolder(active.astarData.GetGraphIndex(this), null);
		}

		public Int3 GetVertex(int index)
		{
			return vertices[index];
		}

		public int GetVertexArrayIndex(int index)
		{
			return index;
		}

		public void GetTileCoordinates(int tileIndex, out int x, out int z)
		{
			x = (z = 0);
		}

		public void GenerateMatrix()
		{
			SetMatrix(Matrix4x4.TRS(offset, Quaternion.Euler(rotation), new Vector3(scale, scale, scale)));
		}

		public override void RelocateNodes(Matrix4x4 oldMatrix, Matrix4x4 newMatrix)
		{
			if (vertices == null || vertices.Length == 0 || originalVertices == null || originalVertices.Length != vertices.Length)
			{
				return;
			}
			for (int i = 0; i < _vertices.Length; i++)
			{
				_vertices[i] = (Int3)newMatrix.MultiplyPoint3x4(originalVertices[i]);
			}
			for (int j = 0; j < nodes.Length; j++)
			{
				TriangleMeshNode triangleMeshNode = nodes[j];
				triangleMeshNode.UpdatePositionFromVertices();
				if (triangleMeshNode.connections != null)
				{
					for (int k = 0; k < triangleMeshNode.connections.Length; k++)
					{
						triangleMeshNode.connectionCosts[k] = (uint)(triangleMeshNode.position - triangleMeshNode.connections[k].position).costMagnitude;
					}
				}
			}
			SetMatrix(newMatrix);
			bbTree = new BBTree(this);
			for (int l = 0; l < nodes.Length; l++)
			{
				bbTree.Insert(nodes[l]);
			}
		}

		public static NNInfo GetNearest(NavMeshGraph graph, GraphNode[] nodes, Vector3 position, NNConstraint constraint, bool accurateNearestNode)
		{
			if (nodes == null || nodes.Length == 0)
			{
				UnityEngine.Debug.LogError("NavGraph hasn't been generated yet or does not contain any nodes");
				return default(NNInfo);
			}
			if (constraint == null)
			{
				constraint = NNConstraint.None;
			}
			Int3[] vertices = graph.vertices;
			if (graph.bbTree == null)
			{
				return GetNearestForce(graph, graph, position, constraint, accurateNearestNode);
			}
			float num = (graph.bbTree.Size.width + graph.bbTree.Size.height) * 0.5f * 0.02f;
			NNInfo result = graph.bbTree.QueryCircle(position, num, constraint);
			if (result.node == null)
			{
				for (int i = 1; i <= 8; i++)
				{
					result = graph.bbTree.QueryCircle(position, (float)(i * i) * num, constraint);
					if (result.node != null || (float)((i - 1) * (i - 1)) * num > AstarPath.active.maxNearestNodeDistance * 2f)
					{
						break;
					}
				}
			}
			if (result.node != null)
			{
				result.clampedPosition = ClosestPointOnNode(result.node as TriangleMeshNode, vertices, position);
			}
			if (result.constrainedNode != null)
			{
				if (constraint.constrainDistance && ((Vector3)result.constrainedNode.position - position).sqrMagnitude > AstarPath.active.maxNearestNodeDistanceSqr)
				{
					result.constrainedNode = null;
				}
				else
				{
					result.constClampedPosition = ClosestPointOnNode(result.constrainedNode as TriangleMeshNode, vertices, position);
				}
			}
			return result;
		}

		public override NNInfo GetNearest(Vector3 position, NNConstraint constraint, GraphNode hint)
		{
			return GetNearest(this, nodes, position, constraint, accurateNearestNode);
		}

		public override NNInfo GetNearestForce(Vector3 position, NNConstraint constraint)
		{
			return GetNearestForce(this, this, position, constraint, accurateNearestNode);
		}

		public static NNInfo GetNearestForce(NavGraph graph, INavmeshHolder navmesh, Vector3 position, NNConstraint constraint, bool accurateNearestNode)
		{
			NNInfo nearestForceBoth = GetNearestForceBoth(graph, navmesh, position, constraint, accurateNearestNode);
			nearestForceBoth.node = nearestForceBoth.constrainedNode;
			nearestForceBoth.clampedPosition = nearestForceBoth.constClampedPosition;
			return nearestForceBoth;
		}

		public static NNInfo GetNearestForceBoth(NavGraph graph, INavmeshHolder navmesh, Vector3 position, NNConstraint constraint, bool accurateNearestNode)
		{
			Int3 pos = (Int3)position;
			float minDist = -1f;
			GraphNode minNode = null;
			float minConstDist = -1f;
			GraphNode minConstNode = null;
			float maxDistSqr = (!constraint.constrainDistance) ? float.PositiveInfinity : AstarPath.active.maxNearestNodeDistanceSqr;
			GraphNodeDelegateCancelable del = delegate(GraphNode _node)
			{
				TriangleMeshNode triangleMeshNode3 = _node as TriangleMeshNode;
				if (accurateNearestNode)
				{
					Vector3 b = triangleMeshNode3.ClosestPointOnNode(position);
					float sqrMagnitude = ((Vector3)pos - b).sqrMagnitude;
					if (minNode == null || sqrMagnitude < minDist)
					{
						minDist = sqrMagnitude;
						minNode = triangleMeshNode3;
					}
					if (sqrMagnitude < maxDistSqr && constraint.Suitable(triangleMeshNode3) && (minConstNode == null || sqrMagnitude < minConstDist))
					{
						minConstDist = sqrMagnitude;
						minConstNode = triangleMeshNode3;
					}
				}
				else if (!triangleMeshNode3.ContainsPoint((Int3)position))
				{
					float sqrMagnitude2 = (triangleMeshNode3.position - pos).sqrMagnitude;
					if (minNode == null || sqrMagnitude2 < minDist)
					{
						minDist = sqrMagnitude2;
						minNode = triangleMeshNode3;
					}
					if (sqrMagnitude2 < maxDistSqr && constraint.Suitable(triangleMeshNode3) && (minConstNode == null || sqrMagnitude2 < minConstDist))
					{
						minConstDist = sqrMagnitude2;
						minConstNode = triangleMeshNode3;
					}
				}
				else
				{
					int num = AstarMath.Abs(triangleMeshNode3.position.y - pos.y);
					if (minNode == null || (float)num < minDist)
					{
						minDist = num;
						minNode = triangleMeshNode3;
					}
					if ((float)num < maxDistSqr && constraint.Suitable(triangleMeshNode3) && (minConstNode == null || (float)num < minConstDist))
					{
						minConstDist = num;
						minConstNode = triangleMeshNode3;
					}
				}
				return true;
			};
			graph.GetNodes(del);
			NNInfo result = new NNInfo(minNode);
			if (result.node != null)
			{
				TriangleMeshNode triangleMeshNode = result.node as TriangleMeshNode;
				Vector3 vector = result.clampedPosition = triangleMeshNode.ClosestPointOnNode(position);
			}
			result.constrainedNode = minConstNode;
			if (result.constrainedNode != null)
			{
				TriangleMeshNode triangleMeshNode2 = result.constrainedNode as TriangleMeshNode;
				Vector3 vector2 = result.constClampedPosition = triangleMeshNode2.ClosestPointOnNode(position);
			}
			return result;
		}

		public void BuildFunnelCorridor(List<GraphNode> path, int startIndex, int endIndex, List<Vector3> left, List<Vector3> right)
		{
			BuildFunnelCorridor(this, path, startIndex, endIndex, left, right);
		}

		public static void BuildFunnelCorridor(INavmesh graph, List<GraphNode> path, int startIndex, int endIndex, List<Vector3> left, List<Vector3> right)
		{
			if (graph == null)
			{
				UnityEngine.Debug.LogError("Couldn't cast graph to the appropriate type (graph isn't a Navmesh type graph, it doesn't implement the INavmesh interface)");
				return;
			}
			for (int i = startIndex; i < endIndex; i++)
			{
				TriangleMeshNode triangleMeshNode = path[i] as TriangleMeshNode;
				TriangleMeshNode triangleMeshNode2 = path[i + 1] as TriangleMeshNode;
				bool flag = true;
				int j;
				for (j = 0; j < 3; j++)
				{
					for (int k = 0; k < 3; k++)
					{
						if (triangleMeshNode.GetVertexIndex(j) == triangleMeshNode2.GetVertexIndex((k + 1) % 3) && triangleMeshNode.GetVertexIndex((j + 1) % 3) == triangleMeshNode2.GetVertexIndex(k))
						{
							flag = false;
							break;
						}
					}
					if (!flag)
					{
						break;
					}
				}
				if (j == 3)
				{
					left.Add((Vector3)triangleMeshNode.position);
					right.Add((Vector3)triangleMeshNode.position);
					left.Add((Vector3)triangleMeshNode2.position);
					right.Add((Vector3)triangleMeshNode2.position);
				}
				else
				{
					left.Add((Vector3)triangleMeshNode.GetVertex(j));
					right.Add((Vector3)triangleMeshNode.GetVertex((j + 1) % 3));
				}
			}
		}

		public void AddPortal(GraphNode n1, GraphNode n2, List<Vector3> left, List<Vector3> right)
		{
		}

		public bool Linecast(Vector3 origin, Vector3 end)
		{
			NNInfo nearest = GetNearest(origin, NNConstraint.None);
			return Linecast(origin, end, nearest.node);
		}

		public bool Linecast(Vector3 origin, Vector3 end, GraphNode hint, out GraphHitInfo hit)
		{
			return Linecast(this, origin, end, hint, out hit, null);
		}

		public bool Linecast(Vector3 origin, Vector3 end, GraphNode hint)
		{
			GraphHitInfo hit;
			return Linecast(this, origin, end, hint, out hit, null);
		}

		public bool Linecast(Vector3 origin, Vector3 end, GraphNode hint, out GraphHitInfo hit, List<GraphNode> trace)
		{
			return Linecast(this, origin, end, hint, out hit, trace);
		}

		public static bool Linecast(INavmesh graph, Vector3 tmp_origin, Vector3 tmp_end, GraphNode hint, out GraphHitInfo hit)
		{
			return Linecast(graph, tmp_origin, tmp_end, hint, out hit, null);
		}

		public static bool Linecast(INavmesh graph, Vector3 tmp_origin, Vector3 tmp_end, GraphNode hint, out GraphHitInfo hit, List<GraphNode> trace)
		{
			Int3 @int = (Int3)tmp_end;
			Int3 int2 = (Int3)tmp_origin;
			hit = default(GraphHitInfo);
			if (float.IsNaN(tmp_origin.x + tmp_origin.y + tmp_origin.z))
			{
				throw new ArgumentException("origin is NaN");
			}
			if (float.IsNaN(tmp_end.x + tmp_end.y + tmp_end.z))
			{
				throw new ArgumentException("end is NaN");
			}
			TriangleMeshNode triangleMeshNode = hint as TriangleMeshNode;
			if (triangleMeshNode == null)
			{
				NNInfo nearest = (graph as NavGraph).GetNearest(tmp_origin, NNConstraint.None);
				triangleMeshNode = (nearest.node as TriangleMeshNode);
				if (triangleMeshNode == null)
				{
					UnityEngine.Debug.LogError("Could not find a valid node to start from");
					hit.point = tmp_origin;
					return true;
				}
			}
			if (int2 == @int)
			{
				hit.node = triangleMeshNode;
				return false;
			}
			int2 = (Int3)triangleMeshNode.ClosestPointOnNode((Vector3)int2);
			hit.origin = (Vector3)int2;
			if (!triangleMeshNode.Walkable)
			{
				hit.point = (Vector3)int2;
				hit.tangentOrigin = (Vector3)int2;
				return true;
			}
			List<Vector3> list = ListPool<Vector3>.Claim();
			List<Vector3> list2 = ListPool<Vector3>.Claim();
			while (true)
			{
				TriangleMeshNode triangleMeshNode2 = null;
				trace?.Add(triangleMeshNode);
				if (triangleMeshNode.ContainsPoint(@int))
				{
					ListPool<Vector3>.Release(list);
					ListPool<Vector3>.Release(list2);
					return false;
				}
				for (int i = 0; i < triangleMeshNode.connections.Length; i++)
				{
					if (triangleMeshNode.connections[i].GraphIndex != triangleMeshNode.GraphIndex)
					{
						continue;
					}
					list.Clear();
					list2.Clear();
					if (triangleMeshNode.GetPortal(triangleMeshNode.connections[i], list, list2, backwards: false))
					{
						Vector3 vector = list[0];
						Vector3 vector2 = list2[0];
						if ((Polygon.LeftNotColinear(vector, vector2, hit.origin) || !Polygon.LeftNotColinear(vector, vector2, tmp_end)) && Polygon.IntersectionFactor(vector, vector2, hit.origin, tmp_end, out float factor, out float factor2) && !(factor2 < 0f) && factor >= 0f && factor <= 1f)
						{
							triangleMeshNode2 = (triangleMeshNode.connections[i] as TriangleMeshNode);
							break;
						}
					}
				}
				if (triangleMeshNode2 == null)
				{
					break;
				}
				triangleMeshNode = triangleMeshNode2;
			}
			int vertexCount = triangleMeshNode.GetVertexCount();
			for (int j = 0; j < vertexCount; j++)
			{
				Vector3 vector3 = (Vector3)triangleMeshNode.GetVertex(j);
				Vector3 vector4 = (Vector3)triangleMeshNode.GetVertex((j + 1) % vertexCount);
				if ((Polygon.LeftNotColinear(vector3, vector4, hit.origin) || !Polygon.LeftNotColinear(vector3, vector4, tmp_end)) && Polygon.IntersectionFactor(vector3, vector4, hit.origin, tmp_end, out float factor3, out float factor4) && !(factor4 < 0f) && factor3 >= 0f && factor3 <= 1f)
				{
					Vector3 vector5 = hit.point = vector3 + (vector4 - vector3) * factor3;
					hit.node = triangleMeshNode;
					hit.tangent = vector4 - vector3;
					hit.tangentOrigin = vector3;
					ListPool<Vector3>.Release(list);
					ListPool<Vector3>.Release(list2);
					return true;
				}
			}
			UnityEngine.Debug.LogWarning("Linecast failing because point not inside node, and line does not hit any edges of it");
			ListPool<Vector3>.Release(list);
			ListPool<Vector3>.Release(list2);
			return false;
		}

		public GraphUpdateThreading CanUpdateAsync(GraphUpdateObject o)
		{
			return GraphUpdateThreading.UnityThread;
		}

		public void UpdateAreaInit(GraphUpdateObject o)
		{
		}

		public void UpdateArea(GraphUpdateObject o)
		{
		}

		public static void UpdateArea(GraphUpdateObject o, INavmesh graph)
		{
			Bounds bounds = o.bounds;
			Vector3 min = bounds.min;
			float x = min.x;
			Vector3 min2 = bounds.min;
			float z = min2.z;
			Vector3 max = bounds.max;
			float x2 = max.x;
			Vector3 max2 = bounds.max;
			Rect r = Rect.MinMaxRect(x, z, x2, max2.z);
			Vector3 min3 = bounds.min;
			int xmin = Mathf.FloorToInt(min3.x * 1000f);
			Vector3 min4 = bounds.min;
			int ymin = Mathf.FloorToInt(min4.z * 1000f);
			Vector3 max3 = bounds.max;
			int xmax = Mathf.FloorToInt(max3.x * 1000f);
			Vector3 max4 = bounds.max;
			IntRect r2 = new IntRect(xmin, ymin, xmax, Mathf.FloorToInt(max4.z * 1000f));
			Int3 a = new Int3(r2.xmin, 0, r2.ymin);
			Int3 b = new Int3(r2.xmin, 0, r2.ymax);
			Int3 c = new Int3(r2.xmax, 0, r2.ymin);
			Int3 d = new Int3(r2.xmax, 0, r2.ymax);
			Int3 ia = a;
			Int3 ib = b;
			Int3 ic = c;
			Int3 id = d;
			graph.GetNodes(delegate(GraphNode _node)
			{
				TriangleMeshNode triangleMeshNode = _node as TriangleMeshNode;
				bool flag = false;
				int num = 0;
				int num2 = 0;
				int num3 = 0;
				int num4 = 0;
				for (int i = 0; i < 3; i++)
				{
					Int3 vertex = triangleMeshNode.GetVertex(i);
					Vector3 vector = (Vector3)vertex;
					if (r2.Contains(vertex.x, vertex.z))
					{
						flag = true;
						break;
					}
					if (vector.x < r.xMin)
					{
						num++;
					}
					if (vector.x > r.xMax)
					{
						num2++;
					}
					if (vector.z < r.yMin)
					{
						num3++;
					}
					if (vector.z > r.yMax)
					{
						num4++;
					}
				}
				if (!flag && (num == 3 || num2 == 3 || num3 == 3 || num4 == 3))
				{
					return true;
				}
				for (int j = 0; j < 3; j++)
				{
					int i2 = (j <= 1) ? (j + 1) : 0;
					Int3 vertex2 = triangleMeshNode.GetVertex(j);
					Int3 vertex3 = triangleMeshNode.GetVertex(i2);
					if (Polygon.Intersects(a, b, vertex2, vertex3))
					{
						flag = true;
						break;
					}
					if (Polygon.Intersects(a, c, vertex2, vertex3))
					{
						flag = true;
						break;
					}
					if (Polygon.Intersects(c, d, vertex2, vertex3))
					{
						flag = true;
						break;
					}
					if (Polygon.Intersects(d, b, vertex2, vertex3))
					{
						flag = true;
						break;
					}
				}
				if (triangleMeshNode.ContainsPoint(ia) || triangleMeshNode.ContainsPoint(ib) || triangleMeshNode.ContainsPoint(ic) || triangleMeshNode.ContainsPoint(id))
				{
					flag = true;
				}
				if (!flag)
				{
					return true;
				}
				o.WillUpdateNode(triangleMeshNode);
				o.Apply(triangleMeshNode);
				return true;
			});
		}

		public static Vector3 ClosestPointOnNode(TriangleMeshNode node, Int3[] vertices, Vector3 pos)
		{
			return Polygon.ClosestPointOnTriangle((Vector3)vertices[node.v0], (Vector3)vertices[node.v1], (Vector3)vertices[node.v2], pos);
		}

		public bool ContainsPoint(TriangleMeshNode node, Vector3 pos)
		{
			if (Polygon.IsClockwise((Vector3)vertices[node.v0], (Vector3)vertices[node.v1], pos) && Polygon.IsClockwise((Vector3)vertices[node.v1], (Vector3)vertices[node.v2], pos) && Polygon.IsClockwise((Vector3)vertices[node.v2], (Vector3)vertices[node.v0], pos))
			{
				return true;
			}
			return false;
		}

		public static bool ContainsPoint(TriangleMeshNode node, Vector3 pos, Int3[] vertices)
		{
			if (!Polygon.IsClockwiseMargin((Vector3)vertices[node.v0], (Vector3)vertices[node.v1], (Vector3)vertices[node.v2]))
			{
				UnityEngine.Debug.LogError("Noes!");
			}
			if (Polygon.IsClockwiseMargin((Vector3)vertices[node.v0], (Vector3)vertices[node.v1], pos) && Polygon.IsClockwiseMargin((Vector3)vertices[node.v1], (Vector3)vertices[node.v2], pos) && Polygon.IsClockwiseMargin((Vector3)vertices[node.v2], (Vector3)vertices[node.v0], pos))
			{
				return true;
			}
			return false;
		}

		public void ScanInternal(string objMeshPath)
		{
			Mesh x = ObjImporter.ImportFile(objMeshPath);
			if (x == null)
			{
				UnityEngine.Debug.LogError("Couldn't read .obj file at '" + objMeshPath + "'");
				return;
			}
			sourceMesh = x;
			ScanInternal();
		}

		public override void ScanInternal(OnScanStatus statusCallback)
		{
			if (!(sourceMesh == null))
			{
				GenerateMatrix();
				Vector3[] vertices = sourceMesh.vertices;
				triangles = sourceMesh.triangles;
				TriangleMeshNode.SetNavmeshHolder(active.astarData.GetGraphIndex(this), this);
				GenerateNodes(vertices, triangles, out originalVertices, out _vertices);
			}
		}

		public void GenerateNodes(Vector3[] vectorVertices, int[] triangles, out Vector3[] originalVertices, out Int3[] vertices)
		{
			if (vectorVertices.Length == 0 || triangles.Length == 0)
			{
				originalVertices = vectorVertices;
				vertices = new Int3[0];
				nodes = new TriangleMeshNode[0];
				return;
			}
			vertices = new Int3[vectorVertices.Length];
			int num = 0;
			for (int i = 0; i < vertices.Length; i++)
			{
				vertices[i] = (Int3)matrix.MultiplyPoint3x4(vectorVertices[i]);
			}
			Dictionary<Int3, int> dictionary = new Dictionary<Int3, int>();
			int[] array = new int[vertices.Length];
			for (int j = 0; j < vertices.Length; j++)
			{
				if (!dictionary.ContainsKey(vertices[j]))
				{
					array[num] = j;
					dictionary.Add(vertices[j], num);
					num++;
				}
			}
			for (int k = 0; k < triangles.Length; k++)
			{
				Int3 key = vertices[triangles[k]];
				triangles[k] = dictionary[key];
			}
			Int3[] array2 = vertices;
			vertices = new Int3[num];
			originalVertices = new Vector3[num];
			for (int l = 0; l < num; l++)
			{
				vertices[l] = array2[array[l]];
				originalVertices[l] = vectorVertices[array[l]];
			}
			nodes = new TriangleMeshNode[triangles.Length / 3];
			for (int m = 0; m < nodes.Length; m++)
			{
				nodes[m] = new TriangleMeshNode(active);
				TriangleMeshNode triangleMeshNode = nodes[m];
				triangleMeshNode.Penalty = initialPenalty;
				triangleMeshNode.Walkable = true;
				triangleMeshNode.v0 = triangles[m * 3];
				triangleMeshNode.v1 = triangles[m * 3 + 1];
				triangleMeshNode.v2 = triangles[m * 3 + 2];
				if (!Polygon.IsClockwise(vertices[triangleMeshNode.v0], vertices[triangleMeshNode.v1], vertices[triangleMeshNode.v2]))
				{
					int v = triangleMeshNode.v0;
					triangleMeshNode.v0 = triangleMeshNode.v2;
					triangleMeshNode.v2 = v;
				}
				if (Polygon.IsColinear(vertices[triangleMeshNode.v0], vertices[triangleMeshNode.v1], vertices[triangleMeshNode.v2]))
				{
					UnityEngine.Debug.DrawLine((Vector3)vertices[triangleMeshNode.v0], (Vector3)vertices[triangleMeshNode.v1], Color.red);
					UnityEngine.Debug.DrawLine((Vector3)vertices[triangleMeshNode.v1], (Vector3)vertices[triangleMeshNode.v2], Color.red);
					UnityEngine.Debug.DrawLine((Vector3)vertices[triangleMeshNode.v2], (Vector3)vertices[triangleMeshNode.v0], Color.red);
				}
				triangleMeshNode.UpdatePositionFromVertices();
			}
			Dictionary<Int2, TriangleMeshNode> dictionary2 = new Dictionary<Int2, TriangleMeshNode>();
			int n = 0;
			int num2 = 0;
			for (; n < triangles.Length; n += 3)
			{
				dictionary2[new Int2(triangles[n], triangles[n + 1])] = nodes[num2];
				dictionary2[new Int2(triangles[n + 1], triangles[n + 2])] = nodes[num2];
				dictionary2[new Int2(triangles[n + 2], triangles[n])] = nodes[num2];
				num2++;
			}
			List<MeshNode> list = new List<MeshNode>();
			List<uint> list2 = new List<uint>();
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			for (; num4 < triangles.Length; num4 += 3)
			{
				list.Clear();
				list2.Clear();
				TriangleMeshNode triangleMeshNode2 = nodes[num5];
				for (int num6 = 0; num6 < 3; num6++)
				{
					if (dictionary2.TryGetValue(new Int2(triangles[num4 + (num6 + 1) % 3], triangles[num4 + num6]), out TriangleMeshNode value))
					{
						list.Add(value);
						list2.Add((uint)(triangleMeshNode2.position - value.position).costMagnitude);
					}
				}
				triangleMeshNode2.connections = list.ToArray();
				triangleMeshNode2.connectionCosts = list2.ToArray();
				num5++;
			}
			if (num3 > 0)
			{
				UnityEngine.Debug.LogError("One or more triangles are identical to other triangles, this is not a good thing to have in a navmesh\nIncreasing the scale of the mesh might help\nNumber of triangles with error: " + num3 + "\n");
			}
			RebuildBBTree(this);
		}

		public static void RebuildBBTree(NavMeshGraph graph)
		{
			BBTree bBTree = graph.bbTree;
			if (bBTree == null)
			{
				bBTree = new BBTree(graph);
			}
			bBTree.Clear();
			TriangleMeshNode[] triNodes = graph.TriNodes;
			for (int num = triNodes.Length - 1; num >= 0; num--)
			{
				bBTree.Insert(triNodes[num]);
			}
			graph.bbTree = bBTree;
		}

		public void PostProcess()
		{
		}

		public void Sort(Vector3[] a)
		{
			bool flag = true;
			while (flag)
			{
				flag = false;
				for (int i = 0; i < a.Length - 1; i++)
				{
					if (a[i].x > a[i + 1].x || (a[i].x == a[i + 1].x && (a[i].y > a[i + 1].y || (a[i].y == a[i + 1].y && a[i].z > a[i + 1].z))))
					{
						Vector3 vector = a[i];
						a[i] = a[i + 1];
						a[i + 1] = vector;
						flag = true;
					}
				}
			}
		}

		public override void OnDrawGizmos(bool drawNodes)
		{
			if (!drawNodes)
			{
				return;
			}
			Matrix4x4 matrix = base.matrix;
			GenerateMatrix();
			if (nodes == null)
			{
			}
			if (nodes == null)
			{
				return;
			}
			if (bbTree != null)
			{
				bbTree.OnDrawGizmos();
			}
			if (matrix != base.matrix)
			{
				RelocateNodes(matrix, base.matrix);
			}
			PathHandler debugPathData = AstarPath.active.debugPathData;
			for (int i = 0; i < nodes.Length; i++)
			{
				TriangleMeshNode triangleMeshNode = nodes[i];
				Gizmos.color = NodeColor(triangleMeshNode, AstarPath.active.debugPathData);
				if (triangleMeshNode.Walkable)
				{
					if (AstarPath.active.showSearchTree && debugPathData != null && debugPathData.GetPathNode(triangleMeshNode).parent != null)
					{
						Gizmos.DrawLine((Vector3)triangleMeshNode.position, (Vector3)debugPathData.GetPathNode(triangleMeshNode).parent.node.position);
					}
					else
					{
						for (int j = 0; j < triangleMeshNode.connections.Length; j++)
						{
							Gizmos.DrawLine((Vector3)triangleMeshNode.position, Vector3.Lerp((Vector3)triangleMeshNode.position, (Vector3)triangleMeshNode.connections[j].position, 0.45f));
						}
					}
					Gizmos.color = AstarColor.MeshEdgeColor;
				}
				else
				{
					Gizmos.color = Color.red;
				}
				Gizmos.DrawLine((Vector3)vertices[triangleMeshNode.v0], (Vector3)vertices[triangleMeshNode.v1]);
				Gizmos.DrawLine((Vector3)vertices[triangleMeshNode.v1], (Vector3)vertices[triangleMeshNode.v2]);
				Gizmos.DrawLine((Vector3)vertices[triangleMeshNode.v2], (Vector3)vertices[triangleMeshNode.v0]);
			}
		}

		public override void DeserializeExtraInfo(GraphSerializationContext ctx)
		{
			uint graphIndex = (uint)active.astarData.GetGraphIndex(this);
			TriangleMeshNode.SetNavmeshHolder((int)graphIndex, this);
			int num = ctx.reader.ReadInt32();
			int num2 = ctx.reader.ReadInt32();
			if (num == -1)
			{
				nodes = new TriangleMeshNode[0];
				_vertices = new Int3[0];
				originalVertices = new Vector3[0];
			}
			nodes = new TriangleMeshNode[num];
			_vertices = new Int3[num2];
			originalVertices = new Vector3[num2];
			for (int i = 0; i < num2; i++)
			{
				_vertices[i] = new Int3(ctx.reader.ReadInt32(), ctx.reader.ReadInt32(), ctx.reader.ReadInt32());
				originalVertices[i] = new Vector3(ctx.reader.ReadSingle(), ctx.reader.ReadSingle(), ctx.reader.ReadSingle());
			}
			bbTree = new BBTree(this);
			for (int j = 0; j < num; j++)
			{
				nodes[j] = new TriangleMeshNode(active);
				TriangleMeshNode triangleMeshNode = nodes[j];
				triangleMeshNode.DeserializeNode(ctx);
				triangleMeshNode.GraphIndex = graphIndex;
				triangleMeshNode.UpdatePositionFromVertices();
				bbTree.Insert(triangleMeshNode);
			}
		}

		public override void SerializeExtraInfo(GraphSerializationContext ctx)
		{
			if (nodes == null || originalVertices == null || _vertices == null || originalVertices.Length != _vertices.Length)
			{
				ctx.writer.Write(-1);
				ctx.writer.Write(-1);
				return;
			}
			ctx.writer.Write(nodes.Length);
			ctx.writer.Write(_vertices.Length);
			for (int i = 0; i < _vertices.Length; i++)
			{
				ctx.writer.Write(_vertices[i].x);
				ctx.writer.Write(_vertices[i].y);
				ctx.writer.Write(_vertices[i].z);
				ctx.writer.Write(originalVertices[i].x);
				ctx.writer.Write(originalVertices[i].y);
				ctx.writer.Write(originalVertices[i].z);
			}
			for (int j = 0; j < nodes.Length; j++)
			{
				nodes[j].SerializeNode(ctx);
			}
		}

		public static void DeserializeMeshNodes(NavMeshGraph graph, GraphNode[] nodes, byte[] bytes)
		{
			MemoryStream input = new MemoryStream(bytes);
			System.IO.BinaryReader binaryReader = new System.IO.BinaryReader(input);
			for (int i = 0; i < nodes.Length; i++)
			{
				TriangleMeshNode triangleMeshNode = nodes[i] as TriangleMeshNode;
				if (triangleMeshNode == null)
				{
					UnityEngine.Debug.LogError("Serialization Error : Couldn't cast the node to the appropriate type - NavMeshGenerator");
					return;
				}
				triangleMeshNode.v0 = binaryReader.ReadInt32();
				triangleMeshNode.v1 = binaryReader.ReadInt32();
				triangleMeshNode.v2 = binaryReader.ReadInt32();
			}
			int num = binaryReader.ReadInt32();
			graph.vertices = new Int3[num];
			for (int j = 0; j < num; j++)
			{
				int x = binaryReader.ReadInt32();
				int y = binaryReader.ReadInt32();
				int z = binaryReader.ReadInt32();
				graph.vertices[j] = new Int3(x, y, z);
			}
			RebuildBBTree(graph);
		}
	}
	public class GridNode : GraphNode
	{
		private const int GridFlagsConnectionOffset = 0;

		private const int GridFlagsConnectionBit0 = 1;

		private const int GridFlagsConnectionMask = 255;

		private const int GridFlagsWalkableErosionOffset = 8;

		private const int GridFlagsWalkableErosionMask = 256;

		private const int GridFlagsWalkableTmpOffset = 9;

		private const int GridFlagsWalkableTmpMask = 512;

		private const int GridFlagsEdgeNodeOffset = 10;

		private const int GridFlagsEdgeNodeMask = 1024;

		private static GridGraph[] _gridGraphs = new GridGraph[0];

		public GraphNode[] connections;

		public uint[] connectionCosts;

		protected int nodeInGridIndex;

		protected ushort gridFlags;

		public bool EdgeNode
		{
			get
			{
				return (gridFlags & 0x400) != 0;
			}
			set
			{
				gridFlags = (ushort)((gridFlags & -1025) | (value ? 1024 : 0));
			}
		}

		public bool WalkableErosion
		{
			get
			{
				return (gridFlags & 0x100) != 0;
			}
			set
			{
				gridFlags = (ushort)((gridFlags & -257) | (value ? 256 : 0));
			}
		}

		public bool TmpWalkable
		{
			get
			{
				return (gridFlags & 0x200) != 0;
			}
			set
			{
				gridFlags = (ushort)((gridFlags & -513) | (value ? 512 : 0));
			}
		}

		public int NodeInGridIndex
		{
			get
			{
				return nodeInGridIndex;
			}
			set
			{
				nodeInGridIndex = value;
			}
		}

		public GridNode(AstarPath astar)
			: base(astar)
		{
		}

		public static GridGraph GetGridGraph(uint graphIndex)
		{
			return _gridGraphs[graphIndex];
		}

		public static void SetGridGraph(int graphIndex, GridGraph graph)
		{
			if (_gridGraphs.Length <= graphIndex)
			{
				GridGraph[] array = new GridGraph[graphIndex + 1];
				for (int i = 0; i < _gridGraphs.Length; i++)
				{
					array[i] = _gridGraphs[i];
				}
				_gridGraphs = array;
			}
			_gridGraphs[graphIndex] = graph;
		}

		[Obsolete("This method has been deprecated. Please use NodeInGridIndex instead.", true)]
		public int GetIndex()
		{
			return 0;
		}

		public bool GetConnectionInternal(int dir)
		{
			return ((gridFlags >> dir) & 1) != 0;
		}

		public void SetConnectionInternal(int dir, bool value)
		{
			gridFlags = (ushort)((gridFlags & ~(1 << dir)) | ((value ? 1 : 0) << dir));
		}

		public void ResetConnectionsInternal()
		{
			gridFlags = (ushort)(gridFlags & -256);
		}

		public override void ClearConnections(bool alsoReverse)
		{
			if (alsoReverse)
			{
				GridGraph gridGraph = GetGridGraph(base.GraphIndex);
				for (int i = 0; i < 8; i++)
				{
					gridGraph.GetNodeConnection(this, i)?.SetConnectionInternal((i >= 4) ? 7 : ((i + 2) % 4), value: false);
				}
			}
			ResetConnectionsInternal();
			if (alsoReverse && connections != null)
			{
				for (int j = 0; j < connections.Length; j++)
				{
					connections[j].RemoveConnection(this);
				}
			}
			connections = null;
			connectionCosts = null;
		}

		public override void GetConnections(GraphNodeDelegate del)
		{
			GridGraph gridGraph = GetGridGraph(base.GraphIndex);
			int[] neighbourOffsets = gridGraph.neighbourOffsets;
			GridNode[] nodes = gridGraph.nodes;
			for (int i = 0; i < 8; i++)
			{
				if (GetConnectionInternal(i))
				{
					GridNode gridNode = nodes[nodeInGridIndex + neighbourOffsets[i]];
					if (gridNode != null)
					{
						del(gridNode);
					}
				}
			}
			if (connections != null)
			{
				for (int j = 0; j < connections.Length; j++)
				{
					del(connections[j]);
				}
			}
		}

		public override bool GetPortal(GraphNode other, List<Vector3> left, List<Vector3> right, bool backwards)
		{
			if (backwards)
			{
				return true;
			}
			GridGraph gridGraph = GetGridGraph(base.GraphIndex);
			int[] neighbourOffsets = gridGraph.neighbourOffsets;
			GridNode[] nodes = gridGraph.nodes;
			for (int i = 0; i < 4; i++)
			{
				if (GetConnectionInternal(i) && other == nodes[nodeInGridIndex + neighbourOffsets[i]])
				{
					Vector3 a = (Vector3)(position + other.position) * 0.5f;
					Vector3 b = Vector3.Cross(gridGraph.collision.up, (Vector3)(other.position - position));
					b.Normalize();
					b *= gridGraph.nodeSize * 0.5f;
					left.Add(a - b);
					right.Add(a + b);
					return true;
				}
			}
			for (int j = 4; j < 8; j++)
			{
				if (!GetConnectionInternal(j) || other != nodes[nodeInGridIndex + neighbourOffsets[j]])
				{
					continue;
				}
				bool flag = false;
				bool flag2 = false;
				if (GetConnectionInternal(j - 4))
				{
					GridNode gridNode = nodes[nodeInGridIndex + neighbourOffsets[j - 4]];
					if (gridNode.Walkable && gridNode.GetConnectionInternal((j - 4 + 1) % 4))
					{
						flag = true;
					}
				}
				if (GetConnectionInternal((j - 4 + 1) % 4))
				{
					GridNode gridNode2 = nodes[nodeInGridIndex + neighbourOffsets[(j - 4 + 1) % 4]];
					if (gridNode2.Walkable && gridNode2.GetConnectionInternal(j - 4))
					{
						flag2 = true;
					}
				}
				Vector3 a2 = (Vector3)(position + other.position) * 0.5f;
				Vector3 vector = Vector3.Cross(gridGraph.collision.up, (Vector3)(other.position - position));
				vector.Normalize();
				vector *= gridGraph.nodeSize * 1.4142f;
				left.Add(a2 - ((!flag2) ? Vector3.zero : vector));
				right.Add(a2 + ((!flag) ? Vector3.zero : vector));
				return true;
			}
			return false;
		}

		public override void FloodFill(Stack<GraphNode> stack, uint region)
		{
			GridGraph gridGraph = GetGridGraph(base.GraphIndex);
			int[] neighbourOffsets = gridGraph.neighbourOffsets;
			GridNode[] nodes = gridGraph.nodes;
			for (int i = 0; i < 8; i++)
			{
				if (GetConnectionInternal(i))
				{
					GridNode gridNode = nodes[nodeInGridIndex + neighbourOffsets[i]];
					if (gridNode != null && gridNode.Area != region)
					{
						gridNode.Area = region;
						stack.Push(gridNode);
					}
				}
			}
			if (connections == null)
			{
				return;
			}
			for (int j = 0; j < connections.Length; j++)
			{
				GraphNode graphNode = connections[j];
				if (graphNode.Area != region)
				{
					graphNode.Area = region;
					stack.Push(graphNode);
				}
			}
		}

		public override void AddConnection(GraphNode node, uint cost)
		{
			if (connections != null)
			{
				for (int i = 0; i < connections.Length; i++)
				{
					if (connections[i] == node)
					{
						connectionCosts[i] = cost;
						return;
					}
				}
			}
			int num = (connections != null) ? connections.Length : 0;
			GraphNode[] array = new GraphNode[num + 1];
			uint[] array2 = new uint[num + 1];
			for (int j = 0; j < num; j++)
			{
				array[j] = connections[j];
				array2[j] = connectionCosts[j];
			}
			array[num] = node;
			array2[num] = cost;
			connections = array;
			connectionCosts = array2;
		}

		public override void RemoveConnection(GraphNode node)
		{
			if (connections == null)
			{
				return;
			}
			int num = 0;
			while (true)
			{
				if (num < connections.Length)
				{
					if (connections[num] == node)
					{
						break;
					}
					num++;
					continue;
				}
				return;
			}
			int num2 = connections.Length;
			GraphNode[] array = new GraphNode[num2 - 1];
			uint[] array2 = new uint[num2 - 1];
			for (int i = 0; i < num; i++)
			{
				array[i] = connections[i];
				array2[i] = connectionCosts[i];
			}
			for (int j = num + 1; j < num2; j++)
			{
				array[j - 1] = connections[j];
				array2[j - 1] = connectionCosts[j];
			}
			connections = array;
			connectionCosts = array2;
		}

		public override void UpdateRecursiveG(Path path, PathNode pathNode, PathHandler handler)
		{
			GridGraph gridGraph = GetGridGraph(base.GraphIndex);
			int[] neighbourOffsets = gridGraph.neighbourOffsets;
			GridNode[] nodes = gridGraph.nodes;
			UpdateG(path, pathNode);
			handler.PushNode(pathNode);
			ushort pathID = handler.PathID;
			for (int i = 0; i < 8; i++)
			{
				if (GetConnectionInternal(i))
				{
					GridNode gridNode = nodes[nodeInGridIndex + neighbourOffsets[i]];
					PathNode pathNode2 = handler.GetPathNode(gridNode);
					if (pathNode2.parent == pathNode && pathNode2.pathID == pathID)
					{
						gridNode.UpdateRecursiveG(path, pathNode2, handler);
					}
				}
			}
			if (connections == null)
			{
				return;
			}
			for (int j = 0; j < connections.Length; j++)
			{
				GraphNode graphNode = connections[j];
				PathNode pathNode3 = handler.GetPathNode(graphNode);
				if (pathNode3.parent == pathNode && pathNode3.pathID == pathID)
				{
					graphNode.UpdateRecursiveG(path, pathNode3, handler);
				}
			}
		}

		public override void Open(Path path, PathNode pathNode, PathHandler handler)
		{
			GridGraph gridGraph = GetGridGraph(base.GraphIndex);
			int[] neighbourOffsets = gridGraph.neighbourOffsets;
			uint[] neighbourCosts = gridGraph.neighbourCosts;
			GridNode[] nodes = gridGraph.nodes;
			ushort pathID = handler.PathID;
			for (int i = 0; i < 8; i++)
			{
				if (!GetConnectionInternal(i))
				{
					continue;
				}
				GridNode gridNode = nodes[nodeInGridIndex + neighbourOffsets[i]];
				if (!path.CanTraverse(gridNode))
				{
					continue;
				}
				PathNode pathNode2 = handler.GetPathNode(gridNode);
				if (pathNode2.pathID != pathID)
				{
					pathNode2.parent = pathNode;
					pathNode2.pathID = pathID;
					pathNode2.cost = neighbourCosts[i];
					pathNode2.H = path.CalculateHScore(gridNode);
					gridNode.UpdateG(path, pathNode2);
					handler.PushNode(pathNode2);
					continue;
				}
				uint num = neighbourCosts[i];
				if (pathNode.G + num + path.GetTraversalCost(gridNode) < pathNode2.G)
				{
					pathNode2.cost = num;
					pathNode2.parent = pathNode;
					gridNode.UpdateRecursiveG(path, pathNode2, handler);
				}
				else if (pathNode2.G + num + path.GetTraversalCost(this) < pathNode.G)
				{
					pathNode.parent = pathNode2;
					pathNode.cost = num;
					UpdateRecursiveG(path, pathNode, handler);
				}
			}
			if (connections == null)
			{
				return;
			}
			for (int j = 0; j < connections.Length; j++)
			{
				GraphNode graphNode = connections[j];
				if (!path.CanTraverse(graphNode))
				{
					continue;
				}
				PathNode pathNode3 = handler.GetPathNode(graphNode);
				if (pathNode3.pathID != pathID)
				{
					pathNode3.parent = pathNode;
					pathNode3.pathID = pathID;
					pathNode3.cost = connectionCosts[j];
					pathNode3.H = path.CalculateHScore(graphNode);
					graphNode.UpdateG(path, pathNode3);
					handler.PushNode(pathNode3);
					continue;
				}
				uint num2 = connectionCosts[j];
				if (pathNode.G + num2 + path.GetTraversalCost(graphNode) < pathNode3.G)
				{
					pathNode3.cost = num2;
					pathNode3.parent = pathNode;
					graphNode.UpdateRecursiveG(path, pathNode3, handler);
				}
				else if (pathNode3.G + num2 + path.GetTraversalCost(this) < pathNode.G && graphNode.ContainsConnection(this))
				{
					pathNode.parent = pathNode3;
					pathNode.cost = num2;
					UpdateRecursiveG(path, pathNode, handler);
				}
			}
		}

		public override void SerializeNode(GraphSerializationContext ctx)
		{
			base.SerializeNode(ctx);
			ctx.writer.Write(position.x);
			ctx.writer.Write(position.y);
			ctx.writer.Write(position.z);
			ctx.writer.Write(gridFlags);
		}

		public override void DeserializeNode(GraphSerializationContext ctx)
		{
			base.DeserializeNode(ctx);
			position = new Int3(ctx.reader.ReadInt32(), ctx.reader.ReadInt32(), ctx.reader.ReadInt32());
			gridFlags = ctx.reader.ReadUInt16();
		}
	}
	public class PointNode : GraphNode
	{
		public GraphNode[] connections;

		public uint[] connectionCosts;

		public PointNode next;

		public PointNode(AstarPath astar)
			: base(astar)
		{
		}

		public void SetPosition(Int3 value)
		{
			position = value;
		}

		public override void GetConnections(GraphNodeDelegate del)
		{
			if (connections != null)
			{
				for (int i = 0; i < connections.Length; i++)
				{
					del(connections[i]);
				}
			}
		}

		public override void ClearConnections(bool alsoReverse)
		{
			if (alsoReverse && connections != null)
			{
				for (int i = 0; i < connections.Length; i++)
				{
					connections[i].RemoveConnection(this);
				}
			}
			connections = null;
			connectionCosts = null;
		}

		public override void UpdateRecursiveG(Path path, PathNode pathNode, PathHandler handler)
		{
			UpdateG(path, pathNode);
			handler.PushNode(pathNode);
			for (int i = 0; i < connections.Length; i++)
			{
				GraphNode graphNode = connections[i];
				PathNode pathNode2 = handler.GetPathNode(graphNode);
				if (pathNode2.parent == pathNode && pathNode2.pathID == handler.PathID)
				{
					graphNode.UpdateRecursiveG(path, pathNode2, handler);
				}
			}
		}

		public override bool ContainsConnection(GraphNode node)
		{
			for (int i = 0; i < connections.Length; i++)
			{
				if (connections[i] == node)
				{
					return true;
				}
			}
			return false;
		}

		public override void AddConnection(GraphNode node, uint cost)
		{
			if (connections != null)
			{
				for (int i = 0; i < connections.Length; i++)
				{
					if (connections[i] == node)
					{
						connectionCosts[i] = cost;
						return;
					}
				}
			}
			int num = (connections != null) ? connections.Length : 0;
			GraphNode[] array = new GraphNode[num + 1];
			uint[] array2 = new uint[num + 1];
			for (int j = 0; j < num; j++)
			{
				array[j] = connections[j];
				array2[j] = connectionCosts[j];
			}
			array[num] = node;
			array2[num] = cost;
			connections = array;
			connectionCosts = array2;
		}

		public override void RemoveConnection(GraphNode node)
		{
			if (connections == null)
			{
				return;
			}
			int num = 0;
			while (true)
			{
				if (num < connections.Length)
				{
					if (connections[num] == node)
					{
						break;
					}
					num++;
					continue;
				}
				return;
			}
			int num2 = connections.Length;
			GraphNode[] array = new GraphNode[num2 - 1];
			uint[] array2 = new uint[num2 - 1];
			for (int i = 0; i < num; i++)
			{
				array[i] = connections[i];
				array2[i] = connectionCosts[i];
			}
			for (int j = num + 1; j < num2; j++)
			{
				array[j - 1] = connections[j];
				array2[j - 1] = connectionCosts[j];
			}
			connections = array;
			connectionCosts = array2;
		}

		public override void Open(Path path, PathNode pathNode, PathHandler handler)
		{
			if (connections == null)
			{
				return;
			}
			for (int i = 0; i < connections.Length; i++)
			{
				GraphNode graphNode = connections[i];
				if (!path.CanTraverse(graphNode))
				{
					continue;
				}
				PathNode pathNode2 = handler.GetPathNode(graphNode);
				if (pathNode2.pathID != handler.PathID)
				{
					pathNode2.parent = pathNode;
					pathNode2.pathID = handler.PathID;
					pathNode2.cost = connectionCosts[i];
					pathNode2.H = path.CalculateHScore(graphNode);
					graphNode.UpdateG(path, pathNode2);
					handler.PushNode(pathNode2);
					continue;
				}
				uint num = connectionCosts[i];
				if (pathNode.G + num + path.GetTraversalCost(graphNode) < pathNode2.G)
				{
					pathNode2.cost = num;
					pathNode2.parent = pathNode;
					graphNode.UpdateRecursiveG(path, pathNode2, handler);
				}
				else if (pathNode2.G + num + path.GetTraversalCost(this) < pathNode.G && graphNode.ContainsConnection(this))
				{
					pathNode.parent = pathNode2;
					pathNode.cost = num;
					UpdateRecursiveG(path, pathNode, handler);
				}
			}
		}

		public override void SerializeNode(GraphSerializationContext ctx)
		{
			base.SerializeNode(ctx);
			ctx.writer.Write(position.x);
			ctx.writer.Write(position.y);
			ctx.writer.Write(position.z);
		}

		public override void DeserializeNode(GraphSerializationContext ctx)
		{
			base.DeserializeNode(ctx);
			position = new Int3(ctx.reader.ReadInt32(), ctx.reader.ReadInt32(), ctx.reader.ReadInt32());
		}

		public override void SerializeReferences(GraphSerializationContext ctx)
		{
			if (connections == null)
			{
				ctx.writer.Write(-1);
				return;
			}
			ctx.writer.Write(connections.Length);
			for (int i = 0; i < connections.Length; i++)
			{
				ctx.writer.Write(ctx.GetNodeIdentifier(connections[i]));
				ctx.writer.Write(connectionCosts[i]);
			}
		}

		public override void DeserializeReferences(GraphSerializationContext ctx)
		{
			int num = ctx.reader.ReadInt32();
			if (num == -1)
			{
				connections = null;
				connectionCosts = null;
				return;
			}
			connections = new GraphNode[num];
			connectionCosts = new uint[num];
			for (int i = 0; i < num; i++)
			{
				connections[i] = ctx.GetNodeFromIdentifier(ctx.reader.ReadInt32());
				connectionCosts[i] = ctx.reader.ReadUInt32();
			}
		}
	}
	public interface INavmeshHolder
	{
		Int3 GetVertex(int i);

		int GetVertexArrayIndex(int index);

		void GetTileCoordinates(int tileIndex, out int x, out int z);
	}
	public class TriangleMeshNode : MeshNode
	{
		public int v0;

		public int v1;

		public int v2;

		protected static INavmeshHolder[] _navmeshHolders = new INavmeshHolder[0];

		public TriangleMeshNode(AstarPath astar)
			: base(astar)
		{
		}

		public static INavmeshHolder GetNavmeshHolder(uint graphIndex)
		{
			return _navmeshHolders[graphIndex];
		}

		public static void SetNavmeshHolder(int graphIndex, INavmeshHolder graph)
		{
			if (_navmeshHolders.Length <= graphIndex)
			{
				INavmeshHolder[] array = new INavmeshHolder[graphIndex + 1];
				for (int i = 0; i < _navmeshHolders.Length; i++)
				{
					array[i] = _navmeshHolders[i];
				}
				_navmeshHolders = array;
			}
			_navmeshHolders[graphIndex] = graph;
		}

		public void UpdatePositionFromVertices()
		{
			INavmeshHolder navmeshHolder = GetNavmeshHolder(base.GraphIndex);
			position = (navmeshHolder.GetVertex(v0) + navmeshHolder.GetVertex(v1) + navmeshHolder.GetVertex(v2)) * 0.333333f;
		}

		public int GetVertexIndex(int i)
		{
			int result;
			switch (i)
			{
			case 0:
				result = v0;
				break;
			case 1:
				result = v1;
				break;
			default:
				result = v2;
				break;
			}
			return result;
		}

		public int GetVertexArrayIndex(int i)
		{
			INavmeshHolder navmeshHolder = GetNavmeshHolder(base.GraphIndex);
			int index;
			switch (i)
			{
			case 0:
				index = v0;
				break;
			case 1:
				index = v1;
				break;
			default:
				index = v2;
				break;
			}
			return navmeshHolder.GetVertexArrayIndex(index);
		}

		public override Int3 GetVertex(int i)
		{
			return GetNavmeshHolder(base.GraphIndex).GetVertex(GetVertexIndex(i));
		}

		public override int GetVertexCount()
		{
			return 3;
		}

		public override Vector3 ClosestPointOnNode(Vector3 p)
		{
			INavmeshHolder navmeshHolder = GetNavmeshHolder(base.GraphIndex);
			return Polygon.ClosestPointOnTriangle((Vector3)navmeshHolder.GetVertex(v0), (Vector3)navmeshHolder.GetVertex(v1), (Vector3)navmeshHolder.GetVertex(v2), p);
		}

		public override Vector3 ClosestPointOnNodeXZ(Vector3 _p)
		{
			INavmeshHolder navmeshHolder = GetNavmeshHolder(base.GraphIndex);
			Int3 vertex = navmeshHolder.GetVertex(v0);
			Int3 vertex2 = navmeshHolder.GetVertex(v1);
			Int3 vertex3 = navmeshHolder.GetVertex(v2);
			Int3 point = (Int3)_p;
			int y = point.y;
			vertex.y = 0;
			vertex2.y = 0;
			vertex3.y = 0;
			point.y = 0;
			if ((long)(vertex2.x - vertex.x) * (long)(point.z - vertex.z) - (long)(point.x - vertex.x) * (long)(vertex2.z - vertex.z) > 0)
			{
				float num = Mathf.Clamp01(AstarMath.NearestPointFactor(vertex, vertex2, point));
				return new Vector3((float)vertex.x + (float)(vertex2.x - vertex.x) * num, y, (float)vertex.z + (float)(vertex2.z - vertex.z) * num) * 0.001f;
			}
			if ((long)(vertex3.x - vertex2.x) * (long)(point.z - vertex2.z) - (long)(point.x - vertex2.x) * (long)(vertex3.z - vertex2.z) > 0)
			{
				float num2 = Mathf.Clamp01(AstarMath.NearestPointFactor(vertex2, vertex3, point));
				return new Vector3((float)vertex2.x + (float)(vertex3.x - vertex2.x) * num2, y, (float)vertex2.z + (float)(vertex3.z - vertex2.z) * num2) * 0.001f;
			}
			if ((long)(vertex.x - vertex3.x) * (long)(point.z - vertex3.z) - (long)(point.x - vertex3.x) * (long)(vertex.z - vertex3.z) > 0)
			{
				float num3 = Mathf.Clamp01(AstarMath.NearestPointFactor(vertex3, vertex, point));
				return new Vector3((float)vertex3.x + (float)(vertex.x - vertex3.x) * num3, y, (float)vertex3.z + (float)(vertex.z - vertex3.z) * num3) * 0.001f;
			}
			return _p;
		}

		public override bool ContainsPoint(Int3 p)
		{
			INavmeshHolder navmeshHolder = GetNavmeshHolder(base.GraphIndex);
			Int3 vertex = navmeshHolder.GetVertex(v0);
			Int3 vertex2 = navmeshHolder.GetVertex(v1);
			Int3 vertex3 = navmeshHolder.GetVertex(v2);
			if ((long)(vertex2.x - vertex.x) * (long)(p.z - vertex.z) - (long)(p.x - vertex.x) * (long)(vertex2.z - vertex.z) > 0)
			{
				return false;
			}
			if ((long)(vertex3.x - vertex2.x) * (long)(p.z - vertex2.z) - (long)(p.x - vertex2.x) * (long)(vertex3.z - vertex2.z) > 0)
			{
				return false;
			}
			if ((long)(vertex.x - vertex3.x) * (long)(p.z - vertex3.z) - (long)(p.x - vertex3.x) * (long)(vertex.z - vertex3.z) > 0)
			{
				return false;
			}
			return true;
		}

		public override void UpdateRecursiveG(Path path, PathNode pathNode, PathHandler handler)
		{
			UpdateG(path, pathNode);
			handler.PushNode(pathNode);
			if (connections == null)
			{
				return;
			}
			for (int i = 0; i < connections.Length; i++)
			{
				GraphNode graphNode = connections[i];
				PathNode pathNode2 = handler.GetPathNode(graphNode);
				if (pathNode2.parent == pathNode && pathNode2.pathID == handler.PathID)
				{
					graphNode.UpdateRecursiveG(path, pathNode2, handler);
				}
			}
		}

		public override void Open(Path path, PathNode pathNode, PathHandler handler)
		{
			if (connections == null)
			{
				return;
			}
			bool flag = pathNode.flag2;
			for (int num = connections.Length - 1; num >= 0; num--)
			{
				GraphNode graphNode = connections[num];
				if (path.CanTraverse(graphNode))
				{
					PathNode pathNode2 = handler.GetPathNode(graphNode);
					if (pathNode2 != pathNode.parent)
					{
						uint num2 = connectionCosts[num];
						if (flag || pathNode2.flag2)
						{
							num2 = path.GetConnectionSpecialCost(this, graphNode, num2);
						}
						if (pathNode2.pathID != handler.PathID)
						{
							pathNode2.node = graphNode;
							pathNode2.parent = pathNode;
							pathNode2.pathID = handler.PathID;
							pathNode2.cost = num2;
							pathNode2.H = path.CalculateHScore(graphNode);
							graphNode.UpdateG(path, pathNode2);
							handler.PushNode(pathNode2);
						}
						else if (pathNode.G + num2 + path.GetTraversalCost(graphNode) < pathNode2.G)
						{
							pathNode2.cost = num2;
							pathNode2.parent = pathNode;
							graphNode.UpdateRecursiveG(path, pathNode2, handler);
						}
						else if (pathNode2.G + num2 + path.GetTraversalCost(this) < pathNode.G && graphNode.ContainsConnection(this))
						{
							pathNode.parent = pathNode2;
							pathNode.cost = num2;
							UpdateRecursiveG(path, pathNode, handler);
						}
					}
				}
			}
		}

		public int SharedEdge(GraphNode other)
		{
			GetPortal(other, null, null, backwards: false, out int aIndex, out int _);
			return aIndex;
		}

		public override bool GetPortal(GraphNode _other, List<Vector3> left, List<Vector3> right, bool backwards)
		{
			int aIndex;
			int bIndex;
			return GetPortal(_other, left, right, backwards, out aIndex, out bIndex);
		}

		public bool GetPortal(GraphNode _other, List<Vector3> left, List<Vector3> right, bool backwards, out int aIndex, out int bIndex)
		{
			aIndex = -1;
			bIndex = -1;
			if (_other.GraphIndex != base.GraphIndex)
			{
				return false;
			}
			TriangleMeshNode triangleMeshNode = _other as TriangleMeshNode;
			int num = (GetVertexIndex(0) >> 12) & 0x7FFFF;
			int num2 = (triangleMeshNode.GetVertexIndex(0) >> 12) & 0x7FFFF;
			if (num != num2 && GetNavmeshHolder(base.GraphIndex) is RecastGraph)
			{
				for (int i = 0; i < connections.Length; i++)
				{
					if (connections[i].GraphIndex != base.GraphIndex)
					{
						NodeLink3Node nodeLink3Node = connections[i] as NodeLink3Node;
						if (nodeLink3Node != null && nodeLink3Node.GetOther(this) == triangleMeshNode && left != null)
						{
							nodeLink3Node.GetPortal(triangleMeshNode, left, right, backwards: false);
							return true;
						}
					}
				}
				INavmeshHolder navmeshHolder = GetNavmeshHolder(base.GraphIndex);
				navmeshHolder.GetTileCoordinates(num, out int x, out int z);
				navmeshHolder.GetTileCoordinates(num2, out int x2, out int z2);
				int num3;
				if (Math.Abs(x - x2) == 1)
				{
					num3 = 0;
				}
				else
				{
					if (Math.Abs(z - z2) != 1)
					{
						throw new Exception("Tiles not adjacent (" + x + ", " + z + ") (" + x2 + ", " + z2 + ")");
					}
					num3 = 2;
				}
				int vertexCount = GetVertexCount();
				int vertexCount2 = triangleMeshNode.GetVertexCount();
				int num4 = -1;
				int num5 = -1;
				for (int j = 0; j < vertexCount; j++)
				{
					int num6 = GetVertex(j)[num3];
					for (int k = 0; k < vertexCount2; k++)
					{
						if (num6 == triangleMeshNode.GetVertex((k + 1) % vertexCount2)[num3] && GetVertex((j + 1) % vertexCount)[num3] == triangleMeshNode.GetVertex(k)[num3])
						{
							num4 = j;
							num5 = k;
							j = vertexCount;
							break;
						}
					}
				}
				aIndex = num4;
				bIndex = num5;
				if (num4 != -1)
				{
					Int3 vertex = GetVertex(num4);
					Int3 vertex2 = GetVertex((num4 + 1) % vertexCount);
					int i2 = (num3 != 2) ? 2 : 0;
					int val = Math.Min(vertex[i2], vertex2[i2]);
					int val2 = Math.Max(vertex[i2], vertex2[i2]);
					val = Math.Max(val, Math.Min(triangleMeshNode.GetVertex(num5)[i2], triangleMeshNode.GetVertex((num5 + 1) % vertexCount2)[i2]));
					val2 = Math.Min(val2, Math.Max(triangleMeshNode.GetVertex(num5)[i2], triangleMeshNode.GetVertex((num5 + 1) % vertexCount2)[i2]));
					if (vertex[i2] < vertex2[i2])
					{
						vertex[i2] = val;
						vertex2[i2] = val2;
					}
					else
					{
						vertex[i2] = val2;
						vertex2[i2] = val;
					}
					if (left != null)
					{
						left.Add((Vector3)vertex);
						right.Add((Vector3)vertex2);
					}
					return true;
				}
			}
			else if (!backwards)
			{
				int num7 = -1;
				int num8 = -1;
				int vertexCount3 = GetVertexCount();
				int vertexCount4 = triangleMeshNode.GetVertexCount();
				for (int l = 0; l < vertexCount3; l++)
				{
					int vertexIndex = GetVertexIndex(l);
					for (int m = 0; m < vertexCount4; m++)
					{
						if (vertexIndex == triangleMeshNode.GetVertexIndex((m + 1) % vertexCount4) && GetVertexIndex((l + 1) % vertexCount3) == triangleMeshNode.GetVertexIndex(m))
						{
							num7 = l;
							num8 = m;
							l = vertexCount3;
							break;
						}
					}
				}
				aIndex = num7;
				bIndex = num8;
				if (num7 == -1)
				{
					for (int n = 0; n < connections.Length; n++)
					{
						if (connections[n].GraphIndex != base.GraphIndex)
						{
							NodeLink3Node nodeLink3Node2 = connections[n] as NodeLink3Node;
							if (nodeLink3Node2 != null && nodeLink3Node2.GetOther(this) == triangleMeshNode && left != null)
							{
								nodeLink3Node2.GetPortal(triangleMeshNode, left, right, backwards: false);
								return true;
							}
						}
					}
					return false;
				}
				if (left != null)
				{
					left.Add((Vector3)GetVertex(num7));
					right.Add((Vector3)GetVertex((num7 + 1) % vertexCount3));
				}
			}
			return true;
		}

		public override void SerializeNode(GraphSerializationContext ctx)
		{
			base.SerializeNode(ctx);
			ctx.writer.Write(v0);
			ctx.writer.Write(v1);
			ctx.writer.Write(v2);
		}

		public override void DeserializeNode(GraphSerializationContext ctx)
		{
			base.DeserializeNode(ctx);
			v0 = ctx.reader.ReadInt32();
			v1 = ctx.reader.ReadInt32();
			v2 = ctx.reader.ReadInt32();
		}
	}
	public class ConvexMeshNode : MeshNode
	{
		private int[] indices;

		protected static INavmeshHolder[] navmeshHolders;

		public ConvexMeshNode(AstarPath astar)
			: base(astar)
		{
			indices = new int[0];
		}

		static ConvexMeshNode()
		{
			navmeshHolders = new INavmeshHolder[0];
		}

		protected static INavmeshHolder GetNavmeshHolder(uint graphIndex)
		{
			return navmeshHolders[graphIndex];
		}

		public void SetPosition(Int3 p)
		{
			position = p;
		}

		public int GetVertexIndex(int i)
		{
			return indices[i];
		}

		public override Int3 GetVertex(int i)
		{
			return GetNavmeshHolder(base.GraphIndex).GetVertex(GetVertexIndex(i));
		}

		public override int GetVertexCount()
		{
			return indices.Length;
		}

		public override Vector3 ClosestPointOnNode(Vector3 p)
		{
			throw new NotImplementedException();
		}

		public override Vector3 ClosestPointOnNodeXZ(Vector3 p)
		{
			throw new NotImplementedException();
		}

		public override void GetConnections(GraphNodeDelegate del)
		{
			if (connections != null)
			{
				for (int i = 0; i < connections.Length; i++)
				{
					del(connections[i]);
				}
			}
		}

		public override void Open(Path path, PathNode pathNode, PathHandler handler)
		{
			if (connections == null)
			{
				return;
			}
			for (int i = 0; i < connections.Length; i++)
			{
				GraphNode graphNode = connections[i];
				if (!path.CanTraverse(graphNode))
				{
					continue;
				}
				PathNode pathNode2 = handler.GetPathNode(graphNode);
				if (pathNode2.pathID != handler.PathID)
				{
					pathNode2.parent = pathNode;
					pathNode2.pathID = handler.PathID;
					pathNode2.cost = connectionCosts[i];
					pathNode2.H = path.CalculateHScore(graphNode);
					graphNode.UpdateG(path, pathNode2);
					handler.PushNode(pathNode2);
					continue;
				}
				uint num = connectionCosts[i];
				if (pathNode.G + num + path.GetTraversalCost(graphNode) < pathNode2.G)
				{
					pathNode2.cost = num;
					pathNode2.parent = pathNode;
					graphNode.UpdateRecursiveG(path, pathNode2, handler);
				}
				else if (pathNode2.G + num + path.GetTraversalCost(this) < pathNode.G && graphNode.ContainsConnection(this))
				{
					pathNode.parent = pathNode2;
					pathNode.cost = num;
					UpdateRecursiveG(path, pathNode, handler);
				}
			}
		}
	}
	[JsonOptIn]
	public class PointGraph : NavGraph, IUpdatableGraph
	{
		[JsonMember]
		public Transform root;

		[JsonMember]
		public string searchTag;

		[JsonMember]
		public float maxDistance;

		[JsonMember]
		public Vector3 limits;

		[JsonMember]
		public bool raycast = true;

		[JsonMember]
		public bool thickRaycast;

		[JsonMember]
		public float thickRaycastRadius = 1f;

		[JsonMember]
		public bool recursive = true;

		[JsonMember]
		public bool autoLinkNodes = true;

		[JsonMember]
		public LayerMask mask;

		[JsonMember]
		public bool optimizeForSparseGraph;

		[JsonMember]
		public bool optimizeFor2D;

		private static readonly Int3[] ThreeDNeighbours = new Int3[27]
		{
			new Int3(-1, 0, -1),
			new Int3(0, 0, -1),
			new Int3(1, 0, -1),
			new Int3(-1, 0, 0),
			new Int3(0, 0, 0),
			new Int3(1, 0, 0),
			new Int3(-1, 0, 1),
			new Int3(0, 0, 1),
			new Int3(1, 0, 1),
			new Int3(-1, -1, -1),
			new Int3(0, -1, -1),
			new Int3(1, -1, -1),
			new Int3(-1, -1, 0),
			new Int3(0, -1, 0),
			new Int3(1, -1, 0),
			new Int3(-1, -1, 1),
			new Int3(0, -1, 1),
			new Int3(1, -1, 1),
			new Int3(-1, 1, -1),
			new Int3(0, 1, -1),
			new Int3(1, 1, -1),
			new Int3(-1, 1, 0),
			new Int3(0, 1, 0),
			new Int3(1, 1, 0),
			new Int3(-1, 1, 1),
			new Int3(0, 1, 1),
			new Int3(1, 1, 1)
		};

		private Dictionary<Int3, PointNode> nodeLookup;

		private Int3 minLookup;

		private Int3 maxLookup;

		private Int3 lookupCellSize;

		private GameObject[] nodeGameObjects;

		public PointNode[] nodes;

		public int nodeCount;

		private Int3 WorldToLookupSpace(Int3 p)
		{
			Int3 zero = Int3.zero;
			zero.x = ((lookupCellSize.x != 0) ? (p.x / lookupCellSize.x) : 0);
			zero.y = ((lookupCellSize.y != 0) ? (p.y / lookupCellSize.y) : 0);
			zero.z = ((lookupCellSize.z != 0) ? (p.z / lookupCellSize.z) : 0);
			return zero;
		}

		public override void GetNodes(GraphNodeDelegateCancelable del)
		{
			if (nodes != null)
			{
				for (int i = 0; i < nodeCount && del(nodes[i]); i++)
				{
				}
			}
		}

		public override NNInfo GetNearest(Vector3 position, NNConstraint constraint, GraphNode hint)
		{
			return GetNearestForce(position, constraint);
		}

		public override NNInfo GetNearestForce(Vector3 position, NNConstraint constraint)
		{
			if (nodes == null)
			{
				return default(NNInfo);
			}
			float num = (!constraint.constrainDistance) ? float.PositiveInfinity : AstarPath.active.maxNearestNodeDistanceSqr;
			float num2 = float.PositiveInfinity;
			GraphNode graphNode = null;
			float num3 = float.PositiveInfinity;
			GraphNode graphNode2 = null;
			if (optimizeForSparseGraph)
			{
				Int3 @int = WorldToLookupSpace((Int3)position);
				Int3 int2 = @int - minLookup;
				int val = 0;
				val = Math.Max(val, Math.Abs(int2.x));
				val = Math.Max(val, Math.Abs(int2.y));
				val = Math.Max(val, Math.Abs(int2.z));
				int2 = @int - maxLookup;
				val = Math.Max(val, Math.Abs(int2.x));
				val = Math.Max(val, Math.Abs(int2.y));
				val = Math.Max(val, Math.Abs(int2.z));
				PointNode value = null;
				if (nodeLookup.TryGetValue(@int, out value))
				{
					while (value != null)
					{
						float sqrMagnitude = (position - (Vector3)value.position).sqrMagnitude;
						if (sqrMagnitude < num2)
						{
							num2 = sqrMagnitude;
							graphNode = value;
						}
						if (constraint == null || (sqrMagnitude < num3 && sqrMagnitude < num && constraint.Suitable(value)))
						{
							num3 = sqrMagnitude;
							graphNode2 = value;
						}
						value = value.next;
					}
				}
				for (int i = 1; i <= val; i++)
				{
					if (i >= 20)
					{
						UnityEngine.Debug.LogWarning("Aborting GetNearest call at maximum distance because it has iterated too many times.\nIf you get this regularly, check your settings for PointGraph -> <b>Optimize For Sparse Graph</b> and PointGraph -> <b>Optimize For 2D</b>.\nThis happens when the closest node was very far away (20*link distance between nodes). When optimizing for sparse graphs, getting the nearest node from far away positions is <b>very slow</b>.\n");
						break;
					}
					if (lookupCellSize.y == 0)
					{
						Int3 lhs = @int + new Int3(-i, 0, -i);
						for (int j = 0; j <= 2 * i; j++)
						{
							if (nodeLookup.TryGetValue(lhs + new Int3(j, 0, 0), out value))
							{
								while (value != null)
								{
									float sqrMagnitude2 = (position - (Vector3)value.position).sqrMagnitude;
									if (sqrMagnitude2 < num2)
									{
										num2 = sqrMagnitude2;
										graphNode = value;
									}
									if (constraint == null || (sqrMagnitude2 < num3 && sqrMagnitude2 < num && constraint.Suitable(value)))
									{
										num3 = sqrMagnitude2;
										graphNode2 = value;
									}
									value = value.next;
								}
							}
							if (!nodeLookup.TryGetValue(lhs + new Int3(j, 0, 2 * i), out value))
							{
								continue;
							}
							while (value != null)
							{
								float sqrMagnitude3 = (position - (Vector3)value.position).sqrMagnitude;
								if (sqrMagnitude3 < num2)
								{
									num2 = sqrMagnitude3;
									graphNode = value;
								}
								if (constraint == null || (sqrMagnitude3 < num3 && sqrMagnitude3 < num && constraint.Suitable(value)))
								{
									num3 = sqrMagnitude3;
									graphNode2 = value;
								}
								value = value.next;
							}
						}
						for (int k = 1; k < 2 * i; k++)
						{
							if (nodeLookup.TryGetValue(lhs + new Int3(0, 0, k), out value))
							{
								while (value != null)
								{
									float sqrMagnitude4 = (position - (Vector3)value.position).sqrMagnitude;
									if (sqrMagnitude4 < num2)
									{
										num2 = sqrMagnitude4;
										graphNode = value;
									}
									if (constraint == null || (sqrMagnitude4 < num3 && sqrMagnitude4 < num && constraint.Suitable(value)))
									{
										num3 = sqrMagnitude4;
										graphNode2 = value;
									}
									value = value.next;
								}
							}
							if (!nodeLookup.TryGetValue(lhs + new Int3(2 * i, 0, k), out value))
							{
								continue;
							}
							while (value != null)
							{
								float sqrMagnitude5 = (position - (Vector3)value.position).sqrMagnitude;
								if (sqrMagnitude5 < num2)
								{
									num2 = sqrMagnitude5;
									graphNode = value;
								}
								if (constraint == null || (sqrMagnitude5 < num3 && sqrMagnitude5 < num && constraint.Suitable(value)))
								{
									num3 = sqrMagnitude5;
									graphNode2 = value;
								}
								value = value.next;
							}
						}
					}
					else
					{
						Int3 lhs2 = @int + new Int3(-i, -i, -i);
						for (int l = 0; l <= 2 * i; l++)
						{
							for (int m = 0; m <= 2 * i; m++)
							{
								if (nodeLookup.TryGetValue(lhs2 + new Int3(l, m, 0), out value))
								{
									while (value != null)
									{
										float sqrMagnitude6 = (position - (Vector3)value.position).sqrMagnitude;
										if (sqrMagnitude6 < num2)
										{
											num2 = sqrMagnitude6;
											graphNode = value;
										}
										if (constraint == null || (sqrMagnitude6 < num3 && sqrMagnitude6 < num && constraint.Suitable(value)))
										{
											num3 = sqrMagnitude6;
											graphNode2 = value;
										}
										value = value.next;
									}
								}
								if (!nodeLookup.TryGetValue(lhs2 + new Int3(l, m, 2 * i), out value))
								{
									continue;
								}
								while (value != null)
								{
									float sqrMagnitude7 = (position - (Vector3)value.position).sqrMagnitude;
									if (sqrMagnitude7 < num2)
									{
										num2 = sqrMagnitude7;
										graphNode = value;
									}
									if (constraint == null || (sqrMagnitude7 < num3 && sqrMagnitude7 < num && constraint.Suitable(value)))
									{
										num3 = sqrMagnitude7;
										graphNode2 = value;
									}
									value = value.next;
								}
							}
						}
						for (int n = 1; n < 2 * i; n++)
						{
							for (int num4 = 0; num4 <= 2 * i; num4++)
							{
								if (nodeLookup.TryGetValue(lhs2 + new Int3(0, num4, n), out value))
								{
									while (value != null)
									{
										float sqrMagnitude8 = (position - (Vector3)value.position).sqrMagnitude;
										if (sqrMagnitude8 < num2)
										{
											num2 = sqrMagnitude8;
											graphNode = value;
										}
										if (constraint == null || (sqrMagnitude8 < num3 && sqrMagnitude8 < num && constraint.Suitable(value)))
										{
											num3 = sqrMagnitude8;
											graphNode2 = value;
										}
										value = value.next;
									}
								}
								if (!nodeLookup.TryGetValue(lhs2 + new Int3(2 * i, num4, n), out value))
								{
									continue;
								}
								while (value != null)
								{
									float sqrMagnitude9 = (position - (Vector3)value.position).sqrMagnitude;
									if (sqrMagnitude9 < num2)
									{
										num2 = sqrMagnitude9;
										graphNode = value;
									}
									if (constraint == null || (sqrMagnitude9 < num3 && sqrMagnitude9 < num && constraint.Suitable(value)))
									{
										num3 = sqrMagnitude9;
										graphNode2 = value;
									}
									value = value.next;
								}
							}
						}
						for (int num5 = 1; num5 < 2 * i; num5++)
						{
							for (int num6 = 1; num6 < 2 * i; num6++)
							{
								if (nodeLookup.TryGetValue(lhs2 + new Int3(num5, 0, num6), out value))
								{
									while (value != null)
									{
										float sqrMagnitude10 = (position - (Vector3)value.position).sqrMagnitude;
										if (sqrMagnitude10 < num2)
										{
											num2 = sqrMagnitude10;
											graphNode = value;
										}
										if (constraint == null || (sqrMagnitude10 < num3 && sqrMagnitude10 < num && constraint.Suitable(value)))
										{
											num3 = sqrMagnitude10;
											graphNode2 = value;
										}
										value = value.next;
									}
								}
								if (!nodeLookup.TryGetValue(lhs2 + new Int3(num5, 2 * i, num6), out value))
								{
									continue;
								}
								while (value != null)
								{
									float sqrMagnitude11 = (position - (Vector3)value.position).sqrMagnitude;
									if (sqrMagnitude11 < num2)
									{
										num2 = sqrMagnitude11;
										graphNode = value;
									}
									if (constraint == null || (sqrMagnitude11 < num3 && sqrMagnitude11 < num && constraint.Suitable(value)))
									{
										num3 = sqrMagnitude11;
										graphNode2 = value;
									}
									value = value.next;
								}
							}
						}
					}
					if (graphNode2 != null)
					{
						val = Math.Min(val, i + 1);
					}
				}
			}
			else
			{
				for (int num7 = 0; num7 < nodeCount; num7++)
				{
					PointNode pointNode = nodes[num7];
					float sqrMagnitude12 = (position - (Vector3)pointNode.position).sqrMagnitude;
					if (sqrMagnitude12 < num2)
					{
						num2 = sqrMagnitude12;
						graphNode = pointNode;
					}
					if (constraint == null || (sqrMagnitude12 < num3 && sqrMagnitude12 < num && constraint.Suitable(pointNode)))
					{
						num3 = sqrMagnitude12;
						graphNode2 = pointNode;
					}
				}
			}
			NNInfo result = new NNInfo(graphNode);
			result.constrainedNode = graphNode2;
			if (graphNode2 != null)
			{
				result.constClampedPosition = (Vector3)graphNode2.position;
			}
			else if (graphNode != null)
			{
				result.constrainedNode = graphNode;
				result.constClampedPosition = (Vector3)graphNode.position;
			}
			return result;
		}

		public PointNode AddNode(Int3 position)
		{
			return AddNode(new PointNode(active), position);
		}

		public T AddNode<T>(T nd, Int3 position) where T : PointNode
		{
			if (nodes == null || nodeCount == nodes.Length)
			{
				PointNode[] array = new PointNode[(nodes == null) ? 4 : Math.Max(nodes.Length + 4, nodes.Length * 2)];
				for (int i = 0; i < nodeCount; i++)
				{
					array[i] = nodes[i];
				}
				nodes = array;
			}
			nd.SetPosition(position);
			nd.GraphIndex = graphIndex;
			nd.Walkable = true;
			nodes[nodeCount] = nd;
			nodeCount++;
			AddToLookup(nd);
			return nd;
		}

		public static int CountChildren(Transform tr)
		{
			int num = 0;
			foreach (Transform item in tr)
			{
				num++;
				num += CountChildren(item);
			}
			return num;
		}

		public void AddChildren(ref int c, Transform tr)
		{
			foreach (Transform item in tr)
			{
				nodes[c].SetPosition((Int3)item.position);
				nodes[c].Walkable = true;
				nodeGameObjects[c] = item.gameObject;
				c++;
				AddChildren(ref c, item);
			}
		}

		public void RebuildNodeLookup()
		{
			if (optimizeForSparseGraph)
			{
				if (maxDistance == 0f)
				{
					lookupCellSize = (Int3)limits;
				}
				else
				{
					lookupCellSize.x = Mathf.CeilToInt(1000f * ((limits.x == 0f) ? maxDistance : Mathf.Min(maxDistance, limits.x)));
					lookupCellSize.y = Mathf.CeilToInt(1000f * ((limits.y == 0f) ? maxDistance : Mathf.Min(maxDistance, limits.y)));
					lookupCellSize.z = Mathf.CeilToInt(1000f * ((limits.z == 0f) ? maxDistance : Mathf.Min(maxDistance, limits.z)));
				}
				if (optimizeFor2D)
				{
					lookupCellSize.y = 0;
				}
				if (nodeLookup == null)
				{
					nodeLookup = new Dictionary<Int3, PointNode>();
				}
				nodeLookup.Clear();
				for (int i = 0; i < nodeCount; i++)
				{
					PointNode node = nodes[i];
					AddToLookup(node);
				}
			}
		}

		public void AddToLookup(PointNode node)
		{
			if (nodeLookup != null)
			{
				Int3 key = WorldToLookupSpace(node.position);
				if (nodeLookup.Count == 0)
				{
					minLookup = key;
					maxLookup = key;
				}
				else
				{
					minLookup = new Int3(Math.Min(minLookup.x, key.x), Math.Min(minLookup.y, key.y), Math.Min(minLookup.z, key.z));
					maxLookup = new Int3(Math.Max(minLookup.x, key.x), Math.Max(minLookup.y, key.y), Math.Max(minLookup.z, key.z));
				}
				if (node.next != null)
				{
					throw new Exception("This node has already been added to the lookup structure");
				}
				if (nodeLookup.TryGetValue(key, out PointNode value))
				{
					node.next = value.next;
					value.next = node;
				}
				else
				{
					nodeLookup[key] = node;
				}
			}
		}

		public override void ScanInternal(OnScanStatus statusCallback)
		{
			if (root == null)
			{
				GameObject[] array = nodeGameObjects = GameObject.FindGameObjectsWithTag(searchTag);
				if (array == null)
				{
					nodes = new PointNode[0];
					nodeCount = 0;
					return;
				}
				nodes = new PointNode[array.Length];
				nodeCount = nodes.Length;
				for (int i = 0; i < nodes.Length; i++)
				{
					nodes[i] = new PointNode(active);
				}
				for (int j = 0; j < array.Length; j++)
				{
					nodes[j].SetPosition((Int3)array[j].transform.position);
					nodes[j].Walkable = true;
				}
			}
			else if (!recursive)
			{
				nodes = new PointNode[root.childCount];
				nodeCount = nodes.Length;
				for (int k = 0; k < nodes.Length; k++)
				{
					nodes[k] = new PointNode(active);
				}
				nodeGameObjects = new GameObject[nodes.Length];
				int num = 0;
				foreach (Transform item in root)
				{
					nodes[num].SetPosition((Int3)item.position);
					nodes[num].Walkable = true;
					nodeGameObjects[num] = item.gameObject;
					num++;
				}
			}
			else
			{
				nodes = new PointNode[CountChildren(root)];
				nodeCount = nodes.Length;
				for (int l = 0; l < nodes.Length; l++)
				{
					nodes[l] = new PointNode(active);
				}
				nodeGameObjects = new GameObject[nodes.Length];
				int c = 0;
				AddChildren(ref c, root);
			}
			if (optimizeForSparseGraph)
			{
				RebuildNodeLookup();
			}
			if (maxDistance >= 0f)
			{
				List<PointNode> list = new List<PointNode>(3);
				List<uint> list2 = new List<uint>(3);
				for (int m = 0; m < nodes.Length; m++)
				{
					list.Clear();
					list2.Clear();
					PointNode pointNode = nodes[m];
					if (optimizeForSparseGraph)
					{
						Int3 lhs = WorldToLookupSpace(pointNode.position);
						int num2 = (lookupCellSize.y != 0) ? ThreeDNeighbours.Length : 9;
						for (int n = 0; n < num2; n++)
						{
							Int3 key = lhs + ThreeDNeighbours[n];
							if (!nodeLookup.TryGetValue(key, out PointNode value))
							{
								continue;
							}
							while (value != null)
							{
								float dist = 0f;
								if (IsValidConnection(pointNode, value, out dist))
								{
									list.Add(value);
									list2.Add((uint)Mathf.RoundToInt(dist * 1000f));
								}
								value = value.next;
							}
						}
					}
					else
					{
						for (int num3 = 0; num3 < nodes.Length; num3++)
						{
							if (m != num3)
							{
								PointNode pointNode2 = nodes[num3];
								float dist2 = 0f;
								if (IsValidConnection(pointNode, pointNode2, out dist2))
								{
									list.Add(pointNode2);
									list2.Add((uint)Mathf.RoundToInt(dist2 * 1000f));
								}
							}
						}
					}
					pointNode.connections = list.ToArray();
					pointNode.connectionCosts = list2.ToArray();
				}
			}
			nodeGameObjects = null;
		}

		public virtual bool IsValidConnection(GraphNode a, GraphNode b, out float dist)
		{
			dist = 0f;
			if (!a.Walkable || !b.Walkable)
			{
				return false;
			}
			Vector3 vector = (Vector3)(a.position - b.position);
			if ((!Mathf.Approximately(limits.x, 0f) && Mathf.Abs(vector.x) > limits.x) || (!Mathf.Approximately(limits.y, 0f) && Mathf.Abs(vector.y) > limits.y) || (!Mathf.Approximately(limits.z, 0f) && Mathf.Abs(vector.z) > limits.z))
			{
				return false;
			}
			dist = vector.magnitude;
			if (maxDistance == 0f || dist < maxDistance)
			{
				if (!raycast)
				{
					return true;
				}
				Ray ray = new Ray((Vector3)a.position, (Vector3)(b.position - a.position));
				Ray ray2 = new Ray((Vector3)b.position, (Vector3)(a.position - b.position));
				if (thickRaycast)
				{
					if (!Physics.SphereCast(ray, thickRaycastRadius, dist, mask) && !Physics.SphereCast(ray2, thickRaycastRadius, dist, mask))
					{
						return true;
					}
				}
				else if (!Physics.Raycast(ray, dist, mask) && !Physics.Raycast(ray2, dist, mask))
				{
					return true;
				}
			}
			return false;
		}

		public GraphUpdateThreading CanUpdateAsync(GraphUpdateObject o)
		{
			return GraphUpdateThreading.UnityThread;
		}

		public void UpdateAreaInit(GraphUpdateObject o)
		{
		}

		public void UpdateArea(GraphUpdateObject guo)
		{
			if (nodes == null)
			{
				return;
			}
			for (int i = 0; i < nodeCount; i++)
			{
				if (guo.bounds.Contains((Vector3)nodes[i].position))
				{
					guo.WillUpdateNode(nodes[i]);
					guo.Apply(nodes[i]);
				}
			}
			if (!guo.updatePhysics)
			{
				return;
			}
			Bounds bounds = guo.bounds;
			if (thickRaycast)
			{
				bounds.Expand(thickRaycastRadius * 2f);
			}
			List<GraphNode> list = ListPool<GraphNode>.Claim();
			List<uint> list2 = ListPool<uint>.Claim();
			for (int j = 0; j < nodeCount; j++)
			{
				PointNode pointNode = nodes[j];
				Vector3 a = (Vector3)pointNode.position;
				List<GraphNode> list3 = null;
				List<uint> list4 = null;
				for (int k = 0; k < nodeCount; k++)
				{
					if (k == j)
					{
						continue;
					}
					Vector3 b = (Vector3)nodes[k].position;
					if (!Polygon.LineIntersectsBounds(bounds, a, b))
					{
						continue;
					}
					PointNode pointNode2 = nodes[k];
					bool flag = pointNode.ContainsConnection(pointNode2);
					if (!flag && IsValidConnection(pointNode, pointNode2, out float dist))
					{
						if (list3 == null)
						{
							list.Clear();
							list2.Clear();
							list3 = list;
							list4 = list2;
							list3.AddRange(pointNode.connections);
							list4.AddRange(pointNode.connectionCosts);
						}
						uint item = (uint)Mathf.RoundToInt(dist * 1000f);
						list3.Add(pointNode2);
						list4.Add(item);
					}
					else if (flag && !IsValidConnection(pointNode, pointNode2, out dist))
					{
						if (list3 == null)
						{
							list.Clear();
							list2.Clear();
							list3 = list;
							list4 = list2;
							list3.AddRange(pointNode.connections);
							list4.AddRange(pointNode.connectionCosts);
						}
						int num = list3.IndexOf(pointNode2);
						if (num != -1)
						{
							list3.RemoveAt(num);
							list4.RemoveAt(num);
						}
					}
				}
				if (list3 != null)
				{
					pointNode.connections = list3.ToArray();
					pointNode.connectionCosts = list4.ToArray();
				}
			}
			ListPool<GraphNode>.Release(list);
			ListPool<uint>.Release(list2);
		}

		public override void PostDeserialization()
		{
			RebuildNodeLookup();
		}

		public override void RelocateNodes(Matrix4x4 oldMatrix, Matrix4x4 newMatrix)
		{
			base.RelocateNodes(oldMatrix, newMatrix);
			RebuildNodeLookup();
		}

		public override void SerializeExtraInfo(GraphSerializationContext ctx)
		{
			if (nodes == null)
			{
				ctx.writer.Write(-1);
			}
			ctx.writer.Write(nodeCount);
			for (int i = 0; i < nodeCount; i++)
			{
				if (nodes[i] == null)
				{
					ctx.writer.Write(-1);
					continue;
				}
				ctx.writer.Write(0);
				nodes[i].SerializeNode(ctx);
			}
		}

		public override void DeserializeExtraInfo(GraphSerializationContext ctx)
		{
			int num = ctx.reader.ReadInt32();
			if (num == -1)
			{
				nodes = null;
				return;
			}
			nodes = new PointNode[num];
			nodeCount = num;
			for (int i = 0; i < nodes.Length; i++)
			{
				if (ctx.reader.ReadInt32() != -1)
				{
					nodes[i] = new PointNode(active);
					nodes[i].DeserializeNode(ctx);
				}
			}
		}
	}
	public class QuadtreeGraph : NavGraph
	{
		public int editorWidthLog2 = 6;

		public int editorHeightLog2 = 6;

		public LayerMask layerMask = -1;

		public float nodeSize = 1f;

		public int minDepth = 3;

		private QuadtreeNodeHolder root;

		public Vector3 center;

		private BitArray map;

		public int Width
		{
			get;
			protected set;
		}

		public int Height
		{
			get;
			protected set;
		}

		public override void GetNodes(GraphNodeDelegateCancelable del)
		{
			if (root != null)
			{
				root.GetNodes(del);
			}
		}

		public bool CheckCollision(int x, int y)
		{
			Vector3 position = LocalToWorldPosition(x, y, 1);
			return !Physics.CheckSphere(position, nodeSize * 1.4142f, layerMask);
		}

		public int CheckNode(int xs, int ys, int width)
		{
			UnityEngine.Debug.Log("Checking Node " + xs + " " + ys + " width: " + width);
			bool flag = map[xs + ys * Width];
			for (int i = xs; i < xs + width; i++)
			{
				for (int j = ys; j < ys + width; j++)
				{
					if (map[i + j * Width] != flag)
					{
						return -1;
					}
				}
			}
			return flag ? 1 : 0;
		}

		public override void ScanInternal(OnScanStatus statusCallback)
		{
			Width = 1 << editorWidthLog2;
			Height = 1 << editorHeightLog2;
			map = new BitArray(Width * Height);
			for (int i = 0; i < Width; i++)
			{
				for (int j = 0; j < Height; j++)
				{
					map.Set(i + j * Width, CheckCollision(i, j));
				}
			}
			QuadtreeNodeHolder holder = new QuadtreeNodeHolder();
			CreateNodeRec(holder, 0, 0, 0);
			root = holder;
			RecalculateConnectionsRec(root, 0, 0, 0);
		}

		public void RecalculateConnectionsRec(QuadtreeNodeHolder holder, int depth, int x, int y)
		{
			if (holder.node != null)
			{
				RecalculateConnections(holder, depth, x, y);
				return;
			}
			int num = 1 << Math.Min(editorHeightLog2, editorWidthLog2) - depth;
			RecalculateConnectionsRec(holder.c0, depth + 1, x, y);
			RecalculateConnectionsRec(holder.c1, depth + 1, x + num / 2, y);
			RecalculateConnectionsRec(holder.c2, depth + 1, x + num / 2, y + num / 2);
			RecalculateConnectionsRec(holder.c3, depth + 1, x, y + num / 2);
		}

		public Vector3 LocalToWorldPosition(int x, int y, int width)
		{
			return new Vector3(((float)x + (float)width * 0.5f) * nodeSize, 0f, ((float)y + (float)width * 0.5f) * nodeSize);
		}

		public void CreateNodeRec(QuadtreeNodeHolder holder, int depth, int x, int y)
		{
			int num = 1 << Math.Min(editorHeightLog2, editorWidthLog2) - depth;
			int num2 = (depth >= minDepth) ? CheckNode(x, y, num) : (-1);
			if (num2 == 1 || num2 == 0 || num == 1)
			{
				QuadtreeNode quadtreeNode = new QuadtreeNode(active);
				quadtreeNode.SetPosition((Int3)LocalToWorldPosition(x, y, num));
				quadtreeNode.Walkable = (num2 == 1);
				holder.node = quadtreeNode;
				return;
			}
			holder.c0 = new QuadtreeNodeHolder();
			holder.c1 = new QuadtreeNodeHolder();
			holder.c2 = new QuadtreeNodeHolder();
			holder.c3 = new QuadtreeNodeHolder();
			CreateNodeRec(holder.c0, depth + 1, x, y);
			CreateNodeRec(holder.c1, depth + 1, x + num / 2, y);
			CreateNodeRec(holder.c2, depth + 1, x + num / 2, y + num / 2);
			CreateNodeRec(holder.c3, depth + 1, x, y + num / 2);
		}

		public void RecalculateConnections(QuadtreeNodeHolder holder, int depth, int x, int y)
		{
			if (root == null)
			{
				throw new InvalidOperationException("Graph contains no nodes");
			}
			if (holder.node == null)
			{
				throw new ArgumentException("No leaf node specified. Holder has no node.");
			}
			int num = 1 << Math.Min(editorHeightLog2, editorWidthLog2) - depth;
			List<QuadtreeNode> list = new List<QuadtreeNode>();
			AddNeighboursRec(list, root, 0, 0, 0, new IntRect(x, y, x + num, y + num).Expand(0), holder.node);
			holder.node.connections = list.ToArray();
			holder.node.connectionCosts = new uint[list.Count];
			for (int i = 0; i < list.Count; i++)
			{
				uint costMagnitude = (uint)(list[i].position - holder.node.position).costMagnitude;
				holder.node.connectionCosts[i] = costMagnitude;
			}
		}

		public void AddNeighboursRec(List<QuadtreeNode> arr, QuadtreeNodeHolder holder, int depth, int x, int y, IntRect bounds, QuadtreeNode dontInclude)
		{
			int num = 1 << Math.Min(editorHeightLog2, editorWidthLog2) - depth;
			IntRect a = new IntRect(x, y, x + num, y + num);
			if (!IntRect.Intersects(a, bounds))
			{
				return;
			}
			if (holder.node != null)
			{
				if (holder.node != dontInclude)
				{
					arr.Add(holder.node);
				}
			}
			else
			{
				AddNeighboursRec(arr, holder.c0, depth + 1, x, y, bounds, dontInclude);
				AddNeighboursRec(arr, holder.c1, depth + 1, x + num / 2, y, bounds, dontInclude);
				AddNeighboursRec(arr, holder.c2, depth + 1, x + num / 2, y + num / 2, bounds, dontInclude);
				AddNeighboursRec(arr, holder.c3, depth + 1, x, y + num / 2, bounds, dontInclude);
			}
		}

		public QuadtreeNode QueryPoint(int qx, int qy)
		{
			if (root == null)
			{
				return null;
			}
			QuadtreeNodeHolder quadtreeNodeHolder = root;
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			while (quadtreeNodeHolder.node == null)
			{
				int num4 = 1 << Math.Min(editorHeightLog2, editorWidthLog2) - num;
				if (qx >= num2 + num4 / 2)
				{
					num2 += num4 / 2;
					if (qy >= num3 + num4 / 2)
					{
						num3 += num4 / 2;
						quadtreeNodeHolder = quadtreeNodeHolder.c2;
					}
					else
					{
						quadtreeNodeHolder = quadtreeNodeHolder.c1;
					}
				}
				else if (qy >= num3 + num4 / 2)
				{
					num3 += num4 / 2;
					quadtreeNodeHolder = quadtreeNodeHolder.c3;
				}
				else
				{
					quadtreeNodeHolder = quadtreeNodeHolder.c0;
				}
				num++;
			}
			return quadtreeNodeHolder.node;
		}

		public override void OnDrawGizmos(bool drawNodes)
		{
			base.OnDrawGizmos(drawNodes);
			if (drawNodes && root != null)
			{
				DrawRec(root, 0, 0, 0, Vector3.zero);
			}
		}

		public void DrawRec(QuadtreeNodeHolder h, int depth, int x, int y, Vector3 parentPos)
		{
			int num = 1 << Math.Min(editorHeightLog2, editorWidthLog2) - depth;
			Vector3 vector = LocalToWorldPosition(x, y, num);
			UnityEngine.Debug.DrawLine(vector, parentPos, Color.red);
			if (h.node != null)
			{
				UnityEngine.Debug.DrawRay(vector, Vector3.down, (!h.node.Walkable) ? Color.yellow : Color.green);
				return;
			}
			DrawRec(h.c0, depth + 1, x, y, vector);
			DrawRec(h.c1, depth + 1, x + num / 2, y, vector);
			DrawRec(h.c2, depth + 1, x + num / 2, y + num / 2, vector);
			DrawRec(h.c3, depth + 1, x, y + num / 2, vector);
		}
	}
	public class QuadtreeNode : GraphNode
	{
		public GraphNode[] connections;

		public uint[] connectionCosts;

		public QuadtreeNode(AstarPath astar)
			: base(astar)
		{
		}

		public void SetPosition(Int3 value)
		{
			position = value;
		}

		public override void GetConnections(GraphNodeDelegate del)
		{
			if (connections != null)
			{
				for (int i = 0; i < connections.Length; i++)
				{
					del(connections[i]);
				}
			}
		}

		public override void AddConnection(GraphNode node, uint cost)
		{
			throw new NotImplementedException("QuadTree Nodes do not have support for adding manual connections");
		}

		public override void RemoveConnection(GraphNode node)
		{
			throw new NotImplementedException("QuadTree Nodes do not have support for adding manual connections");
		}

		public override void ClearConnections(bool alsoReverse)
		{
			if (alsoReverse)
			{
				for (int i = 0; i < connections.Length; i++)
				{
					connections[i].RemoveConnection(this);
				}
			}
			connections = null;
			connectionCosts = null;
		}

		public override void Open(Path path, PathNode pathNode, PathHandler handler)
		{
			if (connections == null)
			{
				return;
			}
			for (int i = 0; i < connections.Length; i++)
			{
				GraphNode graphNode = connections[i];
				if (!path.CanTraverse(graphNode))
				{
					continue;
				}
				PathNode pathNode2 = handler.GetPathNode(graphNode);
				if (pathNode2.pathID != handler.PathID)
				{
					pathNode2.node = graphNode;
					pathNode2.parent = pathNode;
					pathNode2.pathID = handler.PathID;
					pathNode2.cost = connectionCosts[i];
					pathNode2.H = path.CalculateHScore(graphNode);
					graphNode.UpdateG(path, pathNode2);
					handler.PushNode(pathNode2);
					continue;
				}
				uint num = connectionCosts[i];
				if (pathNode.G + num + path.GetTraversalCost(graphNode) < pathNode2.G)
				{
					pathNode2.cost = num;
					pathNode2.parent = pathNode;
					graphNode.UpdateRecursiveG(path, pathNode2, handler);
				}
				else if (pathNode2.G + num + path.GetTraversalCost(this) < pathNode.G && graphNode.ContainsConnection(this))
				{
					pathNode.parent = pathNode2;
					pathNode.cost = num;
					UpdateRecursiveG(path, pathNode, handler);
				}
			}
		}
	}
	public class QuadtreeNodeHolder
	{
		public QuadtreeNode node;

		public QuadtreeNodeHolder c0;

		public QuadtreeNodeHolder c1;

		public QuadtreeNodeHolder c2;

		public QuadtreeNodeHolder c3;

		public void GetNodes(GraphNodeDelegateCancelable del)
		{
			if (node != null)
			{
				del(node);
				return;
			}
			c0.GetNodes(del);
			c1.GetNodes(del);
			c2.GetNodes(del);
			c3.GetNodes(del);
		}
	}
	[Serializable]
	[JsonOptIn]
	public class RecastGraph : NavGraph, IUpdatableGraph, IRaycastableGraph, INavmesh, INavmeshHolder, IFunnelGraph
	{
		public enum RelevantGraphSurfaceMode
		{
			DoNotRequire,
			OnlyForCompletelyInsideTile,
			RequireForAll
		}

		public class NavmeshTile : INavmesh, INavmeshHolder
		{
			public int[] tris;

			public Int3[] verts;

			public int x;

			public int z;

			public int w;

			public int d;

			public TriangleMeshNode[] nodes;

			public BBTree bbTree;

			public bool flag;

			public void GetTileCoordinates(int tileIndex, out int x, out int z)
			{
				x = this.x;
				z = this.z;
			}

			public int GetVertexArrayIndex(int index)
			{
				return index & 0xFFF;
			}

			public Int3 GetVertex(int index)
			{
				int num = index & 0xFFF;
				return verts[num];
			}

			public void GetNodes(GraphNodeDelegateCancelable del)
			{
				if (nodes != null)
				{
					for (int i = 0; i < nodes.Length && del(nodes[i]); i++)
					{
					}
				}
			}
		}

		public struct SceneMesh
		{
			public Mesh mesh;

			public Matrix4x4 matrix;

			public Bounds bounds;
		}

		private class CapsuleCache
		{
			public int rows;

			public float height;

			public Vector3[] verts;

			public int[] tris;
		}

		public const int VertexIndexMask = 4095;

		public const int TileIndexMask = 524287;

		public const int TileIndexOffset = 12;

		public const int BorderVertexMask = 1;

		public const int BorderVertexOffset = 31;

		public bool dynamic = true;

		[JsonMember]
		public float characterRadius = 0.5f;

		[JsonMember]
		public float contourMaxError = 2f;

		[JsonMember]
		public float cellSize = 0.5f;

		[JsonMember]
		public float cellHeight = 0.4f;

		[JsonMember]
		public float walkableHeight = 2f;

		[JsonMember]
		public float walkableClimb = 0.5f;

		[JsonMember]
		public float maxSlope = 30f;

		[JsonMember]
		public float maxEdgeLength = 20f;

		[JsonMember]
		public float minRegionSize = 3f;

		[JsonMember]
		public int editorTileSize = 128;

		[JsonMember]
		public int tileSizeX = 128;

		[JsonMember]
		public int tileSizeZ = 128;

		[JsonMember]
		public bool nearestSearchOnlyXZ;

		[JsonMember]
		public bool useTiles;

		public bool scanEmptyGraph;

		[JsonMember]
		public RelevantGraphSurfaceMode relevantGraphSurfaceMode;

		[JsonMember]
		public bool rasterizeColliders;

		[JsonMember]
		public bool rasterizeMeshes = true;

		[JsonMember]
		public bool rasterizeTerrain = true;

		[JsonMember]
		public bool rasterizeTrees = true;

		[JsonMember]
		public float colliderRasterizeDetail = 10f;

		[JsonMember]
		public Vector3 forcedBoundsCenter;

		[JsonMember]
		public Vector3 forcedBoundsSize = new Vector3(100f, 40f, 100f);

		[JsonMember]
		public LayerMask mask = -1;

		[JsonMember]
		public List<string> tagMask = new List<string>();

		[JsonMember]
		public bool showMeshOutline = true;

		[JsonMember]
		public bool showNodeConnections;

		[JsonMember]
		public int terrainSampleSize = 3;

		private Voxelize globalVox;

		private BBTree _bbTree;

		private Int3[] _vertices;

		private Vector3[] _vectorVertices;

		public TriangleMeshNode[] nodes;

		public int tileXCount;

		public int tileZCount;

		private NavmeshTile[] tiles;

		private bool batchTileUpdate;

		private List<int> batchUpdatedTiles = new List<int>();

		private Dictionary<Int2, int> cachedInt2_int_dict = new Dictionary<Int2, int>();

		private Dictionary<Int3, int> cachedInt3_int_dict = new Dictionary<Int3, int>();

		private readonly int[] BoxColliderTris = new int[36]
		{
			0,
			1,
			2,
			0,
			2,
			3,
			6,
			5,
			4,
			7,
			6,
			4,
			0,
			5,
			1,
			0,
			4,
			5,
			1,
			6,
			2,
			1,
			5,
			6,
			2,
			7,
			3,
			2,
			6,
			7,
			3,
			4,
			0,
			3,
			7,
			4
		};

		private readonly Vector3[] BoxColliderVerts = new Vector3[8]
		{
			new Vector3(-1f, -1f, -1f),
			new Vector3(1f, -1f, -1f),
			new Vector3(1f, -1f, 1f),
			new Vector3(-1f, -1f, 1f),
			new Vector3(-1f, 1f, -1f),
			new Vector3(1f, 1f, -1f),
			new Vector3(1f, 1f, 1f),
			new Vector3(-1f, 1f, 1f)
		};

		private List<CapsuleCache> capsuleCache = new List<CapsuleCache>();

		public Bounds forcedBounds => new Bounds(forcedBoundsCenter, forcedBoundsSize);

		public BBTree bbTree
		{
			get
			{
				return _bbTree;
			}
			set
			{
				_bbTree = value;
			}
		}

		public Int3[] vertices
		{
			get
			{
				return _vertices;
			}
			set
			{
				_vertices = value;
			}
		}

		public Vector3[] vectorVertices
		{
			get
			{
				if (_vectorVertices != null && _vectorVertices.Length == vertices.Length)
				{
					return _vectorVertices;
				}
				if (vertices == null)
				{
					return null;
				}
				_vectorVertices = new Vector3[vertices.Length];
				for (int i = 0; i < _vectorVertices.Length; i++)
				{
					_vectorVertices[i] = (Vector3)vertices[i];
				}
				return _vectorVertices;
			}
		}

		public TriangleMeshNode[] TriNodes => nodes;

		public override void CreateNodes(int number)
		{
			throw new NotSupportedException();
		}

		public Int3 GetVertex(int index)
		{
			int num = (index >> 12) & 0x7FFFF;
			return tiles[num].GetVertex(index);
		}

		public int GetTileIndex(int index)
		{
			return (index >> 12) & 0x7FFFF;
		}

		public int GetVertexArrayIndex(int index)
		{
			return index & 0xFFF;
		}

		public void GetTileCoordinates(int tileIndex, out int x, out int z)
		{
			z = tileIndex / tileXCount;
			x = tileIndex - z * tileXCount;
		}

		public NavmeshTile[] GetTiles()
		{
			return tiles;
		}

		public Bounds GetTileBounds(int x, int z)
		{
			Bounds result = default(Bounds);
			Vector3 min = new Vector3((float)(x * tileSizeX) * cellSize, 0f, (float)(z * tileSizeZ) * cellSize) + forcedBounds.min;
			float x2 = (float)((x + 1) * tileSizeX) * cellSize;
			Vector3 size = forcedBounds.size;
			result.SetMinMax(min, new Vector3(x2, size.y, (float)((z + 1) * tileSizeZ) * cellSize) + forcedBounds.min);
			return result;
		}

		public Bounds GetTileBounds(int x, int z, int width, int depth)
		{
			Bounds result = default(Bounds);
			Vector3 min = new Vector3((float)(x * tileSizeX) * cellSize, 0f, (float)(z * tileSizeZ) * cellSize) + forcedBounds.min;
			float x2 = (float)((x + width) * tileSizeX) * cellSize;
			Vector3 size = forcedBounds.size;
			result.SetMinMax(min, new Vector3(x2, size.y, (float)((z + depth) * tileSizeZ) * cellSize) + forcedBounds.min);
			return result;
		}

		public Int2 GetTileCoordinates(Vector3 p)
		{
			p -= forcedBounds.min;
			p.x /= cellSize * (float)tileSizeX;
			p.z /= cellSize * (float)tileSizeZ;
			return new Int2((int)p.x, (int)p.z);
		}

		public override void OnDestroy()
		{
			base.OnDestroy();
			TriangleMeshNode.SetNavmeshHolder(active.astarData.GetGraphIndex(this), null);
		}

		private static NavmeshTile NewEmptyTile(int x, int z)
		{
			NavmeshTile navmeshTile = new NavmeshTile();
			navmeshTile.x = x;
			navmeshTile.z = z;
			navmeshTile.w = 1;
			navmeshTile.d = 1;
			navmeshTile.verts = new Int3[0];
			navmeshTile.tris = new int[0];
			navmeshTile.nodes = new TriangleMeshNode[0];
			navmeshTile.bbTree = new BBTree(navmeshTile);
			return navmeshTile;
		}

		public override void GetNodes(GraphNodeDelegateCancelable del)
		{
			if (tiles == null)
			{
				return;
			}
			for (int i = 0; i < tiles.Length; i++)
			{
				if (tiles[i] == null || tiles[i].x + tiles[i].z * tileXCount != i)
				{
					continue;
				}
				TriangleMeshNode[] array = tiles[i].nodes;
				if (array != null)
				{
					for (int j = 0; j < array.Length && del(array[j]); j++)
					{
					}
				}
			}
		}

		public Vector3 ClosestPointOnNode(TriangleMeshNode node, Vector3 pos)
		{
			return Polygon.ClosestPointOnTriangle((Vector3)GetVertex(node.v0), (Vector3)GetVertex(node.v1), (Vector3)GetVertex(node.v2), pos);
		}

		public bool ContainsPoint(TriangleMeshNode node, Vector3 pos)
		{
			if (Polygon.IsClockwise((Vector3)GetVertex(node.v0), (Vector3)GetVertex(node.v1), pos) && Polygon.IsClockwise((Vector3)GetVertex(node.v1), (Vector3)GetVertex(node.v2), pos) && Polygon.IsClockwise((Vector3)GetVertex(node.v2), (Vector3)GetVertex(node.v0), pos))
			{
				return true;
			}
			return false;
		}

		public void SnapForceBoundsToScene()
		{
			List<ExtraMesh> sceneMeshes = GetSceneMeshes(forcedBounds);
			if (sceneMeshes.Count != 0)
			{
				Bounds bounds = default(Bounds);
				ExtraMesh extraMesh = sceneMeshes[0];
				bounds = extraMesh.bounds;
				for (int i = 1; i < sceneMeshes.Count; i++)
				{
					ExtraMesh extraMesh2 = sceneMeshes[i];
					bounds.Encapsulate(extraMesh2.bounds);
				}
				forcedBoundsCenter = bounds.center;
				forcedBoundsSize = bounds.size;
			}
		}

		public void GetRecastMeshObjs(Bounds bounds, List<ExtraMesh> buffer)
		{
			List<RecastMeshObj> list = ListPool<RecastMeshObj>.Claim();
			RecastMeshObj.GetAllInBounds(list, bounds);
			Dictionary<Mesh, Vector3[]> dictionary = new Dictionary<Mesh, Vector3[]>();
			Dictionary<Mesh, int[]> dictionary2 = new Dictionary<Mesh, int[]>();
			for (int i = 0; i < list.Count; i++)
			{
				MeshFilter meshFilter = list[i].GetMeshFilter();
				if (meshFilter != null)
				{
					Mesh sharedMesh = meshFilter.sharedMesh;
					ExtraMesh item = default(ExtraMesh);
					item.matrix = meshFilter.GetComponent<Renderer>().localToWorldMatrix;
					item.original = meshFilter;
					item.area = list[i].area;
					if (dictionary.ContainsKey(sharedMesh))
					{
						item.vertices = dictionary[sharedMesh];
						item.triangles = dictionary2[sharedMesh];
					}
					else
					{
						item.vertices = sharedMesh.vertices;
						item.triangles = sharedMesh.triangles;
						dictionary[sharedMesh] = item.vertices;
						dictionary2[sharedMesh] = item.triangles;
					}
					item.bounds = meshFilter.GetComponent<Renderer>().bounds;
					buffer.Add(item);
					continue;
				}
				Collider collider = list[i].GetCollider();
				if (collider == null)
				{
					UnityEngine.Debug.LogError("RecastMeshObject (" + list[i].gameObject.name + ") didn't have a collider or MeshFilter attached");
					continue;
				}
				ExtraMesh item2 = RasterizeCollider(collider);
				item2.area = list[i].area;
				if (item2.vertices != null)
				{
					buffer.Add(item2);
				}
			}
			capsuleCache.Clear();
			ListPool<RecastMeshObj>.Release(list);
		}

		public List<ExtraMesh> GetSceneMeshes(Bounds bounds)
		{
			if ((tagMask != null && tagMask.Count > 0) || (int)mask != 0)
			{
				MeshFilter[] array = UnityEngine.Object.FindObjectsOfType(typeof(MeshFilter)) as MeshFilter[];
				List<MeshFilter> list = new List<MeshFilter>(array.Length / 3);
				foreach (MeshFilter meshFilter in array)
				{
					if (meshFilter.GetComponent<Renderer>() != null && meshFilter.sharedMesh != null && meshFilter.GetComponent<Renderer>().enabled && (((1 << meshFilter.gameObject.layer) & (int)mask) == 1 << meshFilter.gameObject.layer || tagMask.Contains(meshFilter.tag)) && meshFilter.GetComponent<RecastMeshObj>() == null)
					{
						list.Add(meshFilter);
					}
				}
				List<ExtraMesh> list2 = new List<ExtraMesh>();
				Dictionary<Mesh, Vector3[]> dictionary = new Dictionary<Mesh, Vector3[]>();
				Dictionary<Mesh, int[]> dictionary2 = new Dictionary<Mesh, int[]>();
				HashSet<Mesh> hashSet = new HashSet<Mesh>();
				{
					foreach (MeshFilter item3 in list)
					{
						if (item3.GetComponent<Renderer>().isPartOfStaticBatch)
						{
							Mesh sharedMesh = item3.sharedMesh;
							if (!hashSet.Contains(sharedMesh))
							{
								hashSet.Add(sharedMesh);
								ExtraMesh item = default(ExtraMesh);
								item.original = item3;
								if (dictionary.ContainsKey(sharedMesh))
								{
									item.vertices = dictionary[sharedMesh];
									item.triangles = dictionary2[sharedMesh];
								}
								else
								{
									item.vertices = sharedMesh.vertices;
									item.triangles = sharedMesh.triangles;
									dictionary[sharedMesh] = item.vertices;
									dictionary2[sharedMesh] = item.triangles;
								}
								item.bounds = item3.GetComponent<Renderer>().bounds;
								item.matrix = Matrix4x4.identity;
								list2.Add(item);
							}
							else
							{
								ExtraMesh extraMesh2 = default(ExtraMesh);
								for (int j = 0; j < list2.Count; j++)
								{
									ExtraMesh extraMesh = list2[j];
									if (extraMesh.original == sharedMesh)
									{
										extraMesh2 = list2[j];
										break;
									}
								}
								extraMesh2.bounds.Encapsulate(item3.GetComponent<Renderer>().bounds);
							}
						}
						else if (item3.GetComponent<Renderer>().bounds.Intersects(bounds))
						{
							Mesh sharedMesh2 = item3.sharedMesh;
							ExtraMesh item2 = default(ExtraMesh);
							item2.matrix = item3.GetComponent<Renderer>().localToWorldMatrix;
							item2.original = item3;
							if (dictionary.ContainsKey(sharedMesh2))
							{
								item2.vertices = dictionary[sharedMesh2];
								item2.triangles = dictionary2[sharedMesh2];
							}
							else
							{
								item2.vertices = sharedMesh2.vertices;
								item2.triangles = sharedMesh2.triangles;
								dictionary[sharedMesh2] = item2.vertices;
								dictionary2[sharedMesh2] = item2.triangles;
							}
							item2.bounds = item3.GetComponent<Renderer>().bounds;
							list2.Add(item2);
						}
					}
					return list2;
				}
			}
			return new List<ExtraMesh>();
		}

		public IntRect GetTouchingTiles(Bounds b)
		{
			b.center -= forcedBounds.min;
			Vector3 min = b.min;
			int xmin = Mathf.FloorToInt(min.x / ((float)tileSizeX * cellSize));
			Vector3 min2 = b.min;
			int ymin = Mathf.FloorToInt(min2.z / ((float)tileSizeZ * cellSize));
			Vector3 max = b.max;
			int xmax = Mathf.FloorToInt(max.x / ((float)tileSizeX * cellSize));
			Vector3 max2 = b.max;
			IntRect a = new IntRect(xmin, ymin, xmax, Mathf.FloorToInt(max2.z / ((float)tileSizeZ * cellSize)));
			return IntRect.Intersection(a, new IntRect(0, 0, tileXCount - 1, tileZCount - 1));
		}

		public IntRect GetTouchingTilesRound(Bounds b)
		{
			b.center -= forcedBounds.min;
			Vector3 min = b.min;
			int xmin = Mathf.RoundToInt(min.x / ((float)tileSizeX * cellSize));
			Vector3 min2 = b.min;
			int ymin = Mathf.RoundToInt(min2.z / ((float)tileSizeZ * cellSize));
			Vector3 max = b.max;
			int xmax = Mathf.RoundToInt(max.x / ((float)tileSizeX * cellSize)) - 1;
			Vector3 max2 = b.max;
			IntRect a = new IntRect(xmin, ymin, xmax, Mathf.RoundToInt(max2.z / ((float)tileSizeZ * cellSize)) - 1);
			return IntRect.Intersection(a, new IntRect(0, 0, tileXCount - 1, tileZCount - 1));
		}

		public GraphUpdateThreading CanUpdateAsync(GraphUpdateObject o)
		{
			if (o.updatePhysics)
			{
				return GraphUpdateThreading.SeparateAndUnityInit;
			}
			return GraphUpdateThreading.SeparateThread;
		}

		public void UpdateAreaInit(GraphUpdateObject o)
		{
			if (!o.updatePhysics)
			{
				return;
			}
			if (!dynamic)
			{
				throw new Exception("Recast graph must be marked as dynamic to enable graph updates");
			}
			RelevantGraphSurface.UpdateAllPositions();
			IntRect touchingTiles = GetTouchingTiles(o.bounds);
			Bounds bounds = default(Bounds);
			Vector3 min = forcedBounds.min;
			Vector3 max = forcedBounds.max;
			float num = (float)tileSizeX * cellSize;
			float num2 = (float)tileSizeZ * cellSize;
			bounds.SetMinMax(new Vector3((float)touchingTiles.xmin * num, 0f, (float)touchingTiles.ymin * num2) + min, new Vector3((float)(touchingTiles.xmax + 1) * num + min.x, max.y, (float)(touchingTiles.ymax + 1) * num2 + min.z));
			int num3 = Mathf.CeilToInt(characterRadius / cellSize);
			int num4 = num3 + 3;
			bounds.Expand(new Vector3(num4, 0f, num4) * cellSize * 2f);
			UnityEngine.Debug.DrawLine(bounds.min, bounds.max);
			if (!CollectMeshes(out List<ExtraMesh> extraMeshes, bounds))
			{
			}
			Voxelize voxelize = globalVox;
			if (voxelize == null)
			{
				voxelize = new Voxelize(cellHeight, cellSize, walkableClimb, walkableHeight, maxSlope);
				voxelize.maxEdgeLength = maxEdgeLength;
				if (dynamic)
				{
					globalVox = voxelize;
				}
			}
			voxelize.inputExtraMeshes = extraMeshes;
		}

		public void UpdateArea(GraphUpdateObject guo)
		{
			Bounds bounds = guo.bounds;
			bounds.center -= forcedBounds.min;
			Vector3 min = bounds.min;
			int xmin = Mathf.FloorToInt(min.x / ((float)tileSizeX * cellSize));
			Vector3 min2 = bounds.min;
			int ymin = Mathf.FloorToInt(min2.z / ((float)tileSizeZ * cellSize));
			Vector3 max = bounds.max;
			int xmax = Mathf.FloorToInt(max.x / ((float)tileSizeX * cellSize));
			Vector3 max2 = bounds.max;
			IntRect a = new IntRect(xmin, ymin, xmax, Mathf.FloorToInt(max2.z / ((float)tileSizeZ * cellSize)));
			a = IntRect.Intersection(a, new IntRect(0, 0, tileXCount - 1, tileZCount - 1));
			if (!guo.updatePhysics)
			{
				for (int i = a.ymin; i <= a.ymax; i++)
				{
					for (int j = a.xmin; j <= a.xmax; j++)
					{
						NavmeshTile navmeshTile = tiles[i * tileXCount + j];
						navmeshTile.flag = true;
					}
				}
				for (int k = a.ymin; k <= a.ymax; k++)
				{
					for (int l = a.xmin; l <= a.xmax; l++)
					{
						NavmeshTile navmeshTile2 = tiles[k * tileXCount + l];
						if (navmeshTile2.flag)
						{
							navmeshTile2.flag = false;
							NavMeshGraph.UpdateArea(guo, navmeshTile2);
						}
					}
				}
				return;
			}
			if (!dynamic)
			{
				throw new Exception("Recast graph must be marked as dynamic to enable graph updates with updatePhysics = true");
			}
			Voxelize voxelize = globalVox;
			if (voxelize == null)
			{
				throw new InvalidOperationException("No Voxelizer object. UpdateAreaInit should have been called before this function.");
			}
			for (int m = a.xmin; m <= a.xmax; m++)
			{
				for (int n = a.ymin; n <= a.ymax; n++)
				{
					RemoveConnectionsFromTile(tiles[m + n * tileXCount]);
				}
			}
			for (int num = a.xmin; num <= a.xmax; num++)
			{
				for (int num2 = a.ymin; num2 <= a.ymax; num2++)
				{
					BuildTileMesh(voxelize, num, num2);
				}
			}
			uint graphIndex = (uint)AstarPath.active.astarData.GetGraphIndex(this);
			for (int num3 = a.xmin; num3 <= a.xmax; num3++)
			{
				for (int num4 = a.ymin; num4 <= a.ymax; num4++)
				{
					NavmeshTile navmeshTile3 = tiles[num3 + num4 * tileXCount];
					GraphNode[] array = navmeshTile3.nodes;
					for (int num5 = 0; num5 < array.Length; num5++)
					{
						array[num5].GraphIndex = graphIndex;
					}
				}
			}
			a = a.Expand(1);
			a = IntRect.Intersection(a, new IntRect(0, 0, tileXCount - 1, tileZCount - 1));
			for (int num6 = a.xmin; num6 <= a.xmax; num6++)
			{
				for (int num7 = a.ymin; num7 <= a.ymax; num7++)
				{
					if (num6 < tileXCount - 1 && a.Contains(num6 + 1, num7))
					{
						ConnectTiles(tiles[num6 + num7 * tileXCount], tiles[num6 + 1 + num7 * tileXCount]);
					}
					if (num7 < tileZCount - 1 && a.Contains(num6, num7 + 1))
					{
						ConnectTiles(tiles[num6 + num7 * tileXCount], tiles[num6 + (num7 + 1) * tileXCount]);
					}
				}
			}
		}

		public void ConnectTileWithNeighbours(NavmeshTile tile)
		{
			if (tile.x > 0)
			{
				int num = tile.x - 1;
				for (int i = tile.z; i < tile.z + tile.d; i++)
				{
					ConnectTiles(tiles[num + i * tileXCount], tile);
				}
			}
			if (tile.x + tile.w < tileXCount)
			{
				int num2 = tile.x + tile.w;
				for (int j = tile.z; j < tile.z + tile.d; j++)
				{
					ConnectTiles(tiles[num2 + j * tileXCount], tile);
				}
			}
			if (tile.z > 0)
			{
				int num3 = tile.z - 1;
				for (int k = tile.x; k < tile.x + tile.w; k++)
				{
					ConnectTiles(tiles[k + num3 * tileXCount], tile);
				}
			}
			if (tile.z + tile.d < tileZCount)
			{
				int num4 = tile.z + tile.d;
				for (int l = tile.x; l < tile.x + tile.w; l++)
				{
					ConnectTiles(tiles[l + num4 * tileXCount], tile);
				}
			}
		}

		public void RemoveConnectionsFromTile(NavmeshTile tile)
		{
			if (tile.x > 0)
			{
				int num = tile.x - 1;
				for (int i = tile.z; i < tile.z + tile.d; i++)
				{
					RemoveConnectionsFromTo(tiles[num + i * tileXCount], tile);
				}
			}
			if (tile.x + tile.w < tileXCount)
			{
				int num2 = tile.x + tile.w;
				for (int j = tile.z; j < tile.z + tile.d; j++)
				{
					RemoveConnectionsFromTo(tiles[num2 + j * tileXCount], tile);
				}
			}
			if (tile.z > 0)
			{
				int num3 = tile.z - 1;
				for (int k = tile.x; k < tile.x + tile.w; k++)
				{
					RemoveConnectionsFromTo(tiles[k + num3 * tileXCount], tile);
				}
			}
			if (tile.z + tile.d < tileZCount)
			{
				int num4 = tile.z + tile.d;
				for (int l = tile.x; l < tile.x + tile.w; l++)
				{
					RemoveConnectionsFromTo(tiles[l + num4 * tileXCount], tile);
				}
			}
		}

		public void RemoveConnectionsFromTo(NavmeshTile a, NavmeshTile b)
		{
			if (a == null || b == null || a == b)
			{
				return;
			}
			int num = b.x + b.z * tileXCount;
			for (int i = 0; i < a.nodes.Length; i++)
			{
				TriangleMeshNode triangleMeshNode = a.nodes[i];
				if (triangleMeshNode.connections == null)
				{
					continue;
				}
				for (int j = 0; j < triangleMeshNode.connections.Length; j++)
				{
					TriangleMeshNode triangleMeshNode2 = triangleMeshNode.connections[j] as TriangleMeshNode;
					if (triangleMeshNode2 != null)
					{
						int vertexIndex = triangleMeshNode2.GetVertexIndex(0);
						vertexIndex = ((vertexIndex >> 12) & 0x7FFFF);
						if (vertexIndex == num)
						{
							triangleMeshNode.RemoveConnection(triangleMeshNode.connections[j]);
							j--;
						}
					}
				}
			}
		}

		public override NNInfo GetNearest(Vector3 position, NNConstraint constraint, GraphNode hint)
		{
			return GetNearestForce(position, null);
		}

		public override NNInfo GetNearestForce(Vector3 position, NNConstraint constraint)
		{
			if (tiles == null)
			{
				return default(NNInfo);
			}
			Vector3 vector = position - forcedBounds.min;
			int value = Mathf.FloorToInt(vector.x / (cellSize * (float)tileSizeX));
			int value2 = Mathf.FloorToInt(vector.z / (cellSize * (float)tileSizeZ));
			value = Mathf.Clamp(value, 0, tileXCount - 1);
			value2 = Mathf.Clamp(value2, 0, tileZCount - 1);
			int num = Math.Max(tileXCount, tileZCount);
			NNInfo nNInfo = default(NNInfo);
			float distance = float.PositiveInfinity;
			bool flag = nearestSearchOnlyXZ || (constraint?.distanceXZ ?? false);
			for (int i = 0; i < num && (flag || !(distance < (float)(i - 1) * cellSize * (float)Math.Max(tileSizeX, tileSizeZ))); i++)
			{
				int num2 = Math.Min(i + value2 + 1, tileZCount);
				for (int j = Math.Max(-i + value2, 0); j < num2; j++)
				{
					int num3 = Math.Abs(i - Math.Abs(j - value2));
					if (-num3 + value >= 0)
					{
						int num4 = -num3 + value;
						NavmeshTile navmeshTile = tiles[num4 + j * tileXCount];
						if (navmeshTile != null)
						{
							if (flag)
							{
								nNInfo = navmeshTile.bbTree.QueryClosestXZ(position, constraint, ref distance, nNInfo);
								if (distance < float.PositiveInfinity)
								{
									break;
								}
							}
							else
							{
								nNInfo = navmeshTile.bbTree.QueryClosest(position, constraint, ref distance, nNInfo);
							}
						}
					}
					if (num3 == 0 || num3 + value >= tileXCount)
					{
						continue;
					}
					int num5 = num3 + value;
					NavmeshTile navmeshTile2 = tiles[num5 + j * tileXCount];
					if (navmeshTile2 == null)
					{
						continue;
					}
					if (flag)
					{
						nNInfo = navmeshTile2.bbTree.QueryClosestXZ(position, constraint, ref distance, nNInfo);
						if (distance < float.PositiveInfinity)
						{
							break;
						}
					}
					else
					{
						nNInfo = navmeshTile2.bbTree.QueryClosest(position, constraint, ref distance, nNInfo);
					}
				}
			}
			nNInfo.node = nNInfo.constrainedNode;
			nNInfo.constrainedNode = null;
			nNInfo.clampedPosition = nNInfo.constClampedPosition;
			return nNInfo;
		}

		public GraphNode PointOnNavmesh(Vector3 position, NNConstraint constraint)
		{
			if (tiles == null)
			{
				return null;
			}
			Vector3 vector = position - forcedBounds.min;
			int num = Mathf.FloorToInt(vector.x / (cellSize * (float)tileSizeX));
			int num2 = Mathf.FloorToInt(vector.z / (cellSize * (float)tileSizeZ));
			if (num < 0 || num2 < 0 || num >= tileXCount || num2 >= tileZCount)
			{
				return null;
			}
			return tiles[num + num2 * tileXCount]?.bbTree.QueryInside(position, constraint);
		}

		public void BuildFunnelCorridor(List<GraphNode> path, int startIndex, int endIndex, List<Vector3> left, List<Vector3> right)
		{
			NavMeshGraph.BuildFunnelCorridor(this, path, startIndex, endIndex, left, right);
		}

		public void AddPortal(GraphNode n1, GraphNode n2, List<Vector3> left, List<Vector3> right)
		{
		}

		public static string GetRecastPath()
		{
			return UnityEngine.Application.dataPath + "/Recast/recast";
		}

		public override void ScanInternal(OnScanStatus statusCallback)
		{
			TriangleMeshNode.SetNavmeshHolder(AstarPath.active.astarData.GetGraphIndex(this), this);
			ScanTiledNavmesh(statusCallback);
		}

		protected void ScanTiledNavmesh(OnScanStatus statusCallback)
		{
			ScanAllTiles(statusCallback);
		}

		protected void ScanAllTiles(OnScanStatus statusCallback)
		{
			Vector3 size = forcedBounds.size;
			int num = (int)(size.x / cellSize + 0.5f);
			Vector3 size2 = forcedBounds.size;
			int num2 = (int)(size2.z / cellSize + 0.5f);
			if (!useTiles)
			{
				tileSizeX = num;
				tileSizeZ = num2;
			}
			else
			{
				tileSizeX = editorTileSize;
				tileSizeZ = editorTileSize;
			}
			int num3 = (num + tileSizeX - 1) / tileSizeX;
			int num4 = (num2 + tileSizeZ - 1) / tileSizeZ;
			tileXCount = num3;
			tileZCount = num4;
			if (tileXCount * tileZCount > 524288)
			{
				throw new Exception("Too many tiles (" + tileXCount * tileZCount + ") maximum is " + 524288 + "\nTry disabling ASTAR_RECAST_LARGER_TILES under the 'Optimizations' tab in the A* inspector.");
			}
			tiles = new NavmeshTile[tileXCount * tileZCount];
			if (scanEmptyGraph)
			{
				for (int i = 0; i < num4; i++)
				{
					for (int j = 0; j < num3; j++)
					{
						tiles[i * tileXCount + j] = NewEmptyTile(j, i);
					}
				}
				return;
			}
			Console.WriteLine("Collecting Meshes");
			CollectMeshes(out List<ExtraMesh> extraMeshes, forcedBounds);
			Voxelize voxelize = new Voxelize(cellHeight, cellSize, walkableClimb, walkableHeight, maxSlope);
			voxelize.inputExtraMeshes = extraMeshes;
			voxelize.maxEdgeLength = maxEdgeLength;
			int num5 = -1;
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			for (int k = 0; k < num4; k++)
			{
				for (int l = 0; l < num3; l++)
				{
					int num6 = k * tileXCount + l;
					Console.WriteLine("Generating Tile #" + num6 + " of " + num4 * num3);
					if ((num6 * 10 / tiles.Length > num5 || stopwatch.ElapsedMilliseconds > 2000) && statusCallback != null)
					{
						num5 = num6 * 10 / tiles.Length;
						stopwatch.Reset();
						stopwatch.Start();
						statusCallback(new Progress(AstarMath.MapToRange(0.1f, 0.9f, (float)num6 / (float)tiles.Length), "Building Tile " + num6 + "/" + tiles.Length));
					}
					BuildTileMesh(voxelize, l, k);
				}
			}
			Console.WriteLine("Assigning Graph Indices");
			statusCallback?.Invoke(new Progress(0.9f, "Connecting tiles"));
			uint graphIndex = (uint)AstarPath.active.astarData.GetGraphIndex(this);
			GraphNodeDelegateCancelable del = delegate(GraphNode n)
			{
				n.GraphIndex = graphIndex;
				return true;
			};
			GetNodes(del);
			for (int m = 0; m < num4; m++)
			{
				for (int num7 = 0; num7 < num3; num7++)
				{
					Console.WriteLine("Connecing Tile #" + (m * tileXCount + num7) + " of " + num4 * num3);
					if (num7 < num3 - 1)
					{
						ConnectTiles(tiles[num7 + m * tileXCount], tiles[num7 + 1 + m * tileXCount]);
					}
					if (m < num4 - 1)
					{
						ConnectTiles(tiles[num7 + m * tileXCount], tiles[num7 + (m + 1) * tileXCount]);
					}
				}
			}
		}

		protected void BuildTileMesh(Voxelize vox, int x, int z)
		{
			float num = (float)tileSizeX * cellSize;
			float num2 = (float)tileSizeZ * cellSize;
			int num3 = Mathf.CeilToInt(characterRadius / cellSize);
			Vector3 min = this.forcedBounds.min;
			Vector3 max = this.forcedBounds.max;
			Bounds forcedBounds = default(Bounds);
			forcedBounds.SetMinMax(new Vector3((float)x * num, 0f, (float)z * num2) + min, new Vector3((float)(x + 1) * num + min.x, max.y, (float)(z + 1) * num2 + min.z));
			vox.borderSize = num3 + 3;
			forcedBounds.Expand(new Vector3(vox.borderSize, 0f, vox.borderSize) * cellSize * 2f);
			vox.forcedBounds = forcedBounds;
			vox.width = tileSizeX + vox.borderSize * 2;
			vox.depth = tileSizeZ + vox.borderSize * 2;
			if (!useTiles && relevantGraphSurfaceMode == RelevantGraphSurfaceMode.OnlyForCompletelyInsideTile)
			{
				vox.relevantGraphSurfaceMode = RelevantGraphSurfaceMode.RequireForAll;
			}
			else
			{
				vox.relevantGraphSurfaceMode = relevantGraphSurfaceMode;
			}
			vox.minRegionSize = Mathf.RoundToInt(minRegionSize / (cellSize * cellSize));
			vox.Init();
			vox.CollectMeshes();
			vox.VoxelizeInput();
			vox.FilterLedges(vox.voxelWalkableHeight, vox.voxelWalkableClimb, vox.cellSize, vox.cellHeight, vox.forcedBounds.min);
			vox.FilterLowHeightSpans(vox.voxelWalkableHeight, vox.cellSize, vox.cellHeight, vox.forcedBounds.min);
			vox.BuildCompactField();
			vox.BuildVoxelConnections();
			vox.ErodeWalkableArea(num3);
			vox.BuildDistanceField();
			vox.BuildRegions();
			VoxelContourSet cset = new VoxelContourSet();
			vox.BuildContours(contourMaxError, 1, cset, 1);
			vox.BuildPolyMesh(cset, 3, out VoxelMesh mesh);
			for (int i = 0; i < mesh.verts.Length; i++)
			{
				mesh.verts[i] = mesh.verts[i] * 1000 * vox.cellScale + (Int3)vox.voxelOffset;
			}
			NavmeshTile navmeshTile = CreateTile(vox, mesh, x, z);
			tiles[navmeshTile.x + navmeshTile.z * tileXCount] = navmeshTile;
		}

		private NavmeshTile CreateTile(Voxelize vox, VoxelMesh mesh, int x, int z)
		{
			if (mesh.tris == null)
			{
				throw new ArgumentNullException("The mesh must be valid. tris is null.");
			}
			if (mesh.verts == null)
			{
				throw new ArgumentNullException("The mesh must be valid. verts is null.");
			}
			NavmeshTile navmeshTile = new NavmeshTile();
			navmeshTile.x = x;
			navmeshTile.z = z;
			navmeshTile.w = 1;
			navmeshTile.d = 1;
			navmeshTile.tris = mesh.tris;
			navmeshTile.verts = mesh.verts;
			navmeshTile.bbTree = new BBTree(navmeshTile);
			if (navmeshTile.tris.Length % 3 != 0)
			{
				throw new ArgumentException("Indices array's length must be a multiple of 3 (mesh.tris)");
			}
			if (navmeshTile.verts.Length >= 4095)
			{
				throw new ArgumentException("Too many vertices per tile (more than " + 4095 + ").\nTry enabling ASTAR_RECAST_LARGER_TILES under the 'Optimizations' tab in the A* Inspector");
			}
			Dictionary<Int3, int> dictionary = cachedInt3_int_dict;
			dictionary.Clear();
			int[] array = new int[navmeshTile.verts.Length];
			int num = 0;
			for (int i = 0; i < navmeshTile.verts.Length; i++)
			{
				try
				{
					dictionary.Add(navmeshTile.verts[i], num);
					array[i] = num;
					navmeshTile.verts[num] = navmeshTile.verts[i];
					num++;
				}
				catch
				{
					array[i] = dictionary[navmeshTile.verts[i]];
				}
			}
			for (int j = 0; j < navmeshTile.tris.Length; j++)
			{
				navmeshTile.tris[j] = array[navmeshTile.tris[j]];
			}
			Int3[] array2 = new Int3[num];
			for (int k = 0; k < num; k++)
			{
				array2[k] = navmeshTile.verts[k];
			}
			navmeshTile.verts = array2;
			TriangleMeshNode[] array3 = navmeshTile.nodes = new TriangleMeshNode[navmeshTile.tris.Length / 3];
			int graphIndex = AstarPath.active.astarData.graphs.Length;
			TriangleMeshNode.SetNavmeshHolder(graphIndex, navmeshTile);
			int num2 = x + z * tileXCount;
			num2 <<= 12;
			for (int l = 0; l < array3.Length; l++)
			{
				TriangleMeshNode triangleMeshNode = array3[l] = new TriangleMeshNode(active);
				triangleMeshNode.GraphIndex = (uint)graphIndex;
				triangleMeshNode.v0 = (navmeshTile.tris[l * 3] | num2);
				triangleMeshNode.v1 = (navmeshTile.tris[l * 3 + 1] | num2);
				triangleMeshNode.v2 = (navmeshTile.tris[l * 3 + 2] | num2);
				if (!Polygon.IsClockwise(triangleMeshNode.GetVertex(0), triangleMeshNode.GetVertex(1), triangleMeshNode.GetVertex(2)))
				{
					int v = triangleMeshNode.v0;
					triangleMeshNode.v0 = triangleMeshNode.v2;
					triangleMeshNode.v2 = v;
				}
				triangleMeshNode.Walkable = true;
				triangleMeshNode.Penalty = initialPenalty;
				triangleMeshNode.UpdatePositionFromVertices();
				navmeshTile.bbTree.Insert(triangleMeshNode);
			}
			CreateNodeConnections(navmeshTile.nodes);
			TriangleMeshNode.SetNavmeshHolder(graphIndex, null);
			return navmeshTile;
		}

		private void CreateNodeConnections(TriangleMeshNode[] nodes)
		{
			List<MeshNode> list = ListPool<MeshNode>.Claim();
			List<uint> list2 = ListPool<uint>.Claim();
			Dictionary<Int2, int> dictionary = cachedInt2_int_dict;
			dictionary.Clear();
			for (int i = 0; i < nodes.Length; i++)
			{
				TriangleMeshNode triangleMeshNode = nodes[i];
				int vertexCount = triangleMeshNode.GetVertexCount();
				for (int j = 0; j < vertexCount; j++)
				{
					try
					{
						dictionary.Add(new Int2(triangleMeshNode.GetVertexIndex(j), triangleMeshNode.GetVertexIndex((j + 1) % vertexCount)), i);
					}
					catch (Exception)
					{
					}
				}
			}
			foreach (TriangleMeshNode triangleMeshNode2 in nodes)
			{
				list.Clear();
				list2.Clear();
				int vertexCount2 = triangleMeshNode2.GetVertexCount();
				for (int l = 0; l < vertexCount2; l++)
				{
					int vertexIndex = triangleMeshNode2.GetVertexIndex(l);
					int vertexIndex2 = triangleMeshNode2.GetVertexIndex((l + 1) % vertexCount2);
					if (!dictionary.TryGetValue(new Int2(vertexIndex2, vertexIndex), out int value))
					{
						continue;
					}
					TriangleMeshNode triangleMeshNode3 = nodes[value];
					int vertexCount3 = triangleMeshNode3.GetVertexCount();
					for (int m = 0; m < vertexCount3; m++)
					{
						if (triangleMeshNode3.GetVertexIndex(m) == vertexIndex2 && triangleMeshNode3.GetVertexIndex((m + 1) % vertexCount3) == vertexIndex)
						{
							uint costMagnitude = (uint)(triangleMeshNode2.position - triangleMeshNode3.position).costMagnitude;
							list.Add(triangleMeshNode3);
							list2.Add(costMagnitude);
							break;
						}
					}
				}
				triangleMeshNode2.connections = list.ToArray();
				triangleMeshNode2.connectionCosts = list2.ToArray();
			}
			ListPool<MeshNode>.Release(list);
			ListPool<uint>.Release(list2);
		}

		private void ConnectTiles(NavmeshTile tile1, NavmeshTile tile2)
		{
			if (tile1 == null || tile2 == null)
			{
				return;
			}
			if (tile1.nodes == null)
			{
				throw new ArgumentException("tile1 does not contain any nodes");
			}
			if (tile2.nodes == null)
			{
				throw new ArgumentException("tile2 does not contain any nodes");
			}
			int num = Mathf.Clamp(tile2.x, tile1.x, tile1.x + tile1.w - 1);
			int num2 = Mathf.Clamp(tile1.x, tile2.x, tile2.x + tile2.w - 1);
			int num3 = Mathf.Clamp(tile2.z, tile1.z, tile1.z + tile1.d - 1);
			int num4 = Mathf.Clamp(tile1.z, tile2.z, tile2.z + tile2.d - 1);
			int num5;
			int i;
			int num6;
			int num7;
			float num8;
			if (num == num2)
			{
				num5 = 2;
				i = 0;
				num6 = num3;
				num7 = num4;
				num8 = (float)tileSizeZ * cellSize;
			}
			else
			{
				if (num3 != num4)
				{
					throw new ArgumentException("Tiles are not adjacent (neither x or z coordinates match)");
				}
				num5 = 0;
				i = 2;
				num6 = num;
				num7 = num2;
				num8 = (float)tileSizeX * cellSize;
			}
			if (Math.Abs(num6 - num7) != 1)
			{
				UnityEngine.Debug.Log(tile1.x + " " + tile1.z + " " + tile1.w + " " + tile1.d + "\n" + tile2.x + " " + tile2.z + " " + tile2.w + " " + tile2.d + "\n" + num + " " + num3 + " " + num2 + " " + num4);
				throw new ArgumentException("Tiles are not adjacent (tile coordinates must differ by exactly 1. Got '" + num6 + "' and '" + num7 + "')");
			}
			int num9 = (int)Math.Round(((float)Math.Max(num6, num7) * num8 + forcedBounds.min[num5]) * 1000f);
			TriangleMeshNode[] array = tile1.nodes;
			TriangleMeshNode[] array2 = tile2.nodes;
			foreach (TriangleMeshNode triangleMeshNode in array)
			{
				int vertexCount = triangleMeshNode.GetVertexCount();
				for (int k = 0; k < vertexCount; k++)
				{
					Int3 vertex = triangleMeshNode.GetVertex(k);
					Int3 vertex2 = triangleMeshNode.GetVertex((k + 1) % vertexCount);
					if (Math.Abs(vertex[num5] - num9) >= 2 || Math.Abs(vertex2[num5] - num9) >= 2)
					{
						continue;
					}
					int num10 = Math.Min(vertex[i], vertex2[i]);
					int num11 = Math.Max(vertex[i], vertex2[i]);
					if (num10 == num11)
					{
						continue;
					}
					foreach (TriangleMeshNode triangleMeshNode2 in array2)
					{
						int vertexCount2 = triangleMeshNode2.GetVertexCount();
						for (int m = 0; m < vertexCount2; m++)
						{
							Int3 vertex3 = triangleMeshNode2.GetVertex(m);
							Int3 vertex4 = triangleMeshNode2.GetVertex((m + 1) % vertexCount);
							if (Math.Abs(vertex3[num5] - num9) < 2 && Math.Abs(vertex4[num5] - num9) < 2)
							{
								int num12 = Math.Min(vertex3[i], vertex4[i]);
								int num13 = Math.Max(vertex3[i], vertex4[i]);
								if (num12 != num13 && num11 > num12 && num10 < num13 && ((vertex == vertex3 && vertex2 == vertex4) || (vertex == vertex4 && vertex2 == vertex3) || Polygon.DistanceSegmentSegment3D((Vector3)vertex, (Vector3)vertex2, (Vector3)vertex3, (Vector3)vertex4) < walkableClimb * walkableClimb))
								{
									uint costMagnitude = (uint)(triangleMeshNode.position - triangleMeshNode2.position).costMagnitude;
									triangleMeshNode.AddConnection(triangleMeshNode2, costMagnitude);
									triangleMeshNode2.AddConnection(triangleMeshNode, costMagnitude);
								}
							}
						}
					}
				}
			}
		}

		public void StartBatchTileUpdate()
		{
			if (batchTileUpdate)
			{
				throw new InvalidOperationException("Calling StartBatchLoad when batching is already enabled");
			}
			batchTileUpdate = true;
		}

		public void EndBatchTileUpdate()
		{
			if (!batchTileUpdate)
			{
				throw new InvalidOperationException("Calling EndBatchLoad when batching not enabled");
			}
			batchTileUpdate = false;
			int num = tileXCount;
			int num2 = tileZCount;
			for (int i = 0; i < num2; i++)
			{
				for (int j = 0; j < num; j++)
				{
					tiles[j + i * tileXCount].flag = false;
				}
			}
			for (int k = 0; k < batchUpdatedTiles.Count; k++)
			{
				tiles[batchUpdatedTiles[k]].flag = true;
			}
			for (int l = 0; l < num2; l++)
			{
				for (int m = 0; m < num; m++)
				{
					if (m < num - 1 && (tiles[m + l * tileXCount].flag || tiles[m + 1 + l * tileXCount].flag) && tiles[m + l * tileXCount] != tiles[m + 1 + l * tileXCount])
					{
						ConnectTiles(tiles[m + l * tileXCount], tiles[m + 1 + l * tileXCount]);
					}
					if (l < num2 - 1 && (tiles[m + l * tileXCount].flag || tiles[m + (l + 1) * tileXCount].flag) && tiles[m + l * tileXCount] != tiles[m + (l + 1) * tileXCount])
					{
						ConnectTiles(tiles[m + l * tileXCount], tiles[m + (l + 1) * tileXCount]);
					}
				}
			}
			batchUpdatedTiles.Clear();
		}

		public void ReplaceTile(int x, int z, Int3[] verts, int[] tris, bool worldSpace)
		{
			ReplaceTile(x, z, 1, 1, verts, tris, worldSpace);
		}

		public void ReplaceTile(int x, int z, int w, int d, Int3[] verts, int[] tris, bool worldSpace)
		{
			if (x + w > tileXCount || z + d > tileZCount || x < 0 || z < 0)
			{
				throw new ArgumentException("Tile is placed at an out of bounds position or extends out of the graph bounds (" + x + ", " + z + " [" + w + ", " + d + "] " + tileXCount + " " + tileZCount + ")");
			}
			if (w < 1 || d < 1)
			{
				throw new ArgumentException("width and depth must be greater or equal to 1. Was " + w + ", " + d);
			}
			for (int i = z; i < z + d; i++)
			{
				for (int j = x; j < x + w; j++)
				{
					NavmeshTile navmeshTile = tiles[j + i * tileXCount];
					if (navmeshTile == null)
					{
						continue;
					}
					RemoveConnectionsFromTile(navmeshTile);
					for (int k = 0; k < navmeshTile.nodes.Length; k++)
					{
						navmeshTile.nodes[k].Destroy();
					}
					for (int l = navmeshTile.z; l < navmeshTile.z + navmeshTile.d; l++)
					{
						for (int m = navmeshTile.x; m < navmeshTile.x + navmeshTile.w; m++)
						{
							NavmeshTile navmeshTile2 = tiles[m + l * tileXCount];
							if (navmeshTile2 == null || navmeshTile2 != navmeshTile)
							{
								throw new Exception("This should not happen");
							}
							if (l < z || l >= z + d || m < x || m >= x + w)
							{
								tiles[m + l * tileXCount] = NewEmptyTile(m, l);
								if (batchTileUpdate)
								{
									batchUpdatedTiles.Add(m + l * tileXCount);
								}
							}
							else
							{
								tiles[m + l * tileXCount] = null;
							}
						}
					}
				}
			}
			NavmeshTile navmeshTile3 = new NavmeshTile();
			navmeshTile3.x = x;
			navmeshTile3.z = z;
			navmeshTile3.w = w;
			navmeshTile3.d = d;
			navmeshTile3.tris = tris;
			navmeshTile3.verts = verts;
			navmeshTile3.bbTree = new BBTree(navmeshTile3);
			if (navmeshTile3.tris.Length % 3 != 0)
			{
				throw new ArgumentException("Triangle array's length must be a multiple of 3 (tris)");
			}
			if (navmeshTile3.verts.Length > 65535)
			{
				throw new ArgumentException("Too many vertices per tile (more than 65535)");
			}
			if (!worldSpace)
			{
				if (!Mathf.Approximately((float)(x * tileSizeX) * cellSize * 1000f, (float)Math.Round((float)(x * tileSizeX) * cellSize * 1000f)))
				{
					UnityEngine.Debug.LogWarning("Possible numerical imprecision. Consider adjusting tileSize and/or cellSize");
				}
				if (!Mathf.Approximately((float)(z * tileSizeZ) * cellSize * 1000f, (float)Math.Round((float)(z * tileSizeZ) * cellSize * 1000f)))
				{
					UnityEngine.Debug.LogWarning("Possible numerical imprecision. Consider adjusting tileSize and/or cellSize");
				}
				Int3 @int = (Int3)(new Vector3((float)(x * tileSizeX) * cellSize, 0f, (float)(z * tileSizeZ) * cellSize) + forcedBounds.min);
				for (int n = 0; n < verts.Length; n++)
				{
					verts[n] += @int;
				}
			}
			TriangleMeshNode[] array = navmeshTile3.nodes = new TriangleMeshNode[navmeshTile3.tris.Length / 3];
			int graphIndex = AstarPath.active.astarData.graphs.Length;
			TriangleMeshNode.SetNavmeshHolder(graphIndex, navmeshTile3);
			int num = x + z * tileXCount;
			num <<= 12;
			for (int num2 = 0; num2 < array.Length; num2++)
			{
				TriangleMeshNode triangleMeshNode = array[num2] = new TriangleMeshNode(active);
				triangleMeshNode.GraphIndex = (uint)graphIndex;
				triangleMeshNode.v0 = (navmeshTile3.tris[num2 * 3] | num);
				triangleMeshNode.v1 = (navmeshTile3.tris[num2 * 3 + 1] | num);
				triangleMeshNode.v2 = (navmeshTile3.tris[num2 * 3 + 2] | num);
				if (!Polygon.IsClockwise(triangleMeshNode.GetVertex(0), triangleMeshNode.GetVertex(1), triangleMeshNode.GetVertex(2)))
				{
					int v = triangleMeshNode.v0;
					triangleMeshNode.v0 = triangleMeshNode.v2;
					triangleMeshNode.v2 = v;
				}
				triangleMeshNode.Walkable = true;
				triangleMeshNode.Penalty = initialPenalty;
				triangleMeshNode.UpdatePositionFromVertices();
				navmeshTile3.bbTree.Insert(triangleMeshNode);
			}
			CreateNodeConnections(navmeshTile3.nodes);
			for (int num3 = z; num3 < z + d; num3++)
			{
				for (int num4 = x; num4 < x + w; num4++)
				{
					tiles[num4 + num3 * tileXCount] = navmeshTile3;
				}
			}
			if (batchTileUpdate)
			{
				batchUpdatedTiles.Add(x + z * tileXCount);
			}
			else
			{
				ConnectTileWithNeighbours(navmeshTile3);
			}
			TriangleMeshNode.SetNavmeshHolder(graphIndex, null);
			graphIndex = AstarPath.active.astarData.GetGraphIndex(this);
			for (int num5 = 0; num5 < array.Length; num5++)
			{
				array[num5].GraphIndex = (uint)graphIndex;
			}
		}

		protected void ScanCRecast()
		{
			UnityEngine.Debug.LogError("The C++ version of recast can only be used in osx editor or osx standalone mode, I'm sure it cannot be used in the webplayer, but other platforms are not tested yet\nIf you are in the Unity Editor, try switching Platform to OSX Standalone just when scanning, scanned graphs can be cached to enable them to be used in a webplayer.");
		}

		private void CollectTreeMeshes(List<ExtraMesh> extraMeshes, Terrain terrain)
		{
			TerrainData terrainData = terrain.terrainData;
			for (int i = 0; i < terrainData.treeInstances.Length; i++)
			{
				TreeInstance treeInstance = terrainData.treeInstances[i];
				TreePrototype treePrototype = terrainData.treePrototypes[treeInstance.prototypeIndex];
				if (treePrototype.prefab.GetComponent<Collider>() == null)
				{
					Bounds b = new Bounds(terrain.transform.position + Vector3.Scale(treeInstance.position, terrainData.size), new Vector3(treeInstance.widthScale, treeInstance.heightScale, treeInstance.widthScale));
					Matrix4x4 matrix = Matrix4x4.TRS(terrain.transform.position + Vector3.Scale(treeInstance.position, terrainData.size), Quaternion.identity, new Vector3(treeInstance.widthScale, treeInstance.heightScale, treeInstance.widthScale) * 0.5f);
					ExtraMesh item = new ExtraMesh(BoxColliderVerts, BoxColliderTris, b, matrix);
					extraMeshes.Add(item);
					continue;
				}
				Vector3 pos = terrain.transform.position + Vector3.Scale(treeInstance.position, terrainData.size);
				Vector3 s = new Vector3(treeInstance.widthScale, treeInstance.heightScale, treeInstance.widthScale);
				ExtraMesh item2 = RasterizeCollider(treePrototype.prefab.GetComponent<Collider>(), Matrix4x4.TRS(pos, Quaternion.identity, s));
				if (item2.vertices != null)
				{
					item2.RecalculateBounds();
					extraMeshes.Add(item2);
				}
			}
		}

		private bool CollectMeshes(out List<ExtraMesh> extraMeshes, Bounds bounds)
		{
			List<ExtraMesh> list = new List<ExtraMesh>();
			if (rasterizeMeshes)
			{
				list = GetSceneMeshes(bounds);
			}
			GetRecastMeshObjs(bounds, list);
			Terrain[] array = UnityEngine.Object.FindObjectsOfType(typeof(Terrain)) as Terrain[];
			if (rasterizeTerrain && array.Length > 0)
			{
				for (int i = 0; i < array.Length; i++)
				{
					TerrainData terrainData = array[i].terrainData;
					if (terrainData == null)
					{
						continue;
					}
					Vector3 position = array[i].GetPosition();
					Vector3 center = position + terrainData.size * 0.5f;
					Bounds b = new Bounds(center, terrainData.size);
					if (!b.Intersects(bounds))
					{
						continue;
					}
					float[,] heights = terrainData.GetHeights(0, 0, terrainData.heightmapWidth, terrainData.heightmapHeight);
					terrainSampleSize = ((terrainSampleSize < 1) ? 1 : terrainSampleSize);
					int heightmapWidth = terrainData.heightmapWidth;
					int heightmapHeight = terrainData.heightmapHeight;
					int num = (terrainData.heightmapWidth + terrainSampleSize - 1) / terrainSampleSize + 1;
					int num2 = (terrainData.heightmapHeight + terrainSampleSize - 1) / terrainSampleSize + 1;
					Vector3[] array2 = new Vector3[num * num2];
					Vector3 heightmapScale = terrainData.heightmapScale;
					Vector3 size = terrainData.size;
					float y = size.y;
					int num3 = 0;
					for (int j = 0; j < num2; j++)
					{
						int num4 = 0;
						for (int k = 0; k < num; k++)
						{
							int num5 = Math.Min(num4, heightmapWidth - 1);
							int num6 = Math.Min(num3, heightmapHeight - 1);
							array2[j * num + k] = new Vector3((float)num6 * heightmapScale.z, heights[num5, num6] * y, (float)num5 * heightmapScale.x) + position;
							num4 += terrainSampleSize;
						}
						num3 += terrainSampleSize;
					}
					int[] array3 = new int[(num - 1) * (num2 - 1) * 2 * 3];
					int num7 = 0;
					for (int l = 0; l < num2 - 1; l++)
					{
						for (int m = 0; m < num - 1; m++)
						{
							array3[num7] = l * num + m;
							array3[num7 + 1] = l * num + m + 1;
							array3[num7 + 2] = (l + 1) * num + m + 1;
							num7 += 3;
							array3[num7] = l * num + m;
							array3[num7 + 1] = (l + 1) * num + m + 1;
							array3[num7 + 2] = (l + 1) * num + m;
							num7 += 3;
						}
					}
					list.Add(new ExtraMesh(array2, array3, b));
					if (rasterizeTrees)
					{
						CollectTreeMeshes(list, array[i]);
					}
				}
			}
			if (rasterizeColliders)
			{
				Collider[] array4 = UnityEngine.Object.FindObjectsOfType(typeof(Collider)) as Collider[];
				Collider[] array5 = array4;
				foreach (Collider collider in array5)
				{
					if (((1 << collider.gameObject.layer) & (int)mask) == 1 << collider.gameObject.layer && collider.enabled && !collider.isTrigger && collider.bounds.Intersects(bounds))
					{
						ExtraMesh item = RasterizeCollider(collider);
						if (item.vertices != null)
						{
							list.Add(item);
						}
					}
				}
				capsuleCache.Clear();
			}
			extraMeshes = list;
			if (list.Count == 0)
			{
				UnityEngine.Debug.LogWarning("No MeshFilters where found contained in the layers specified by the 'mask' variable");
				return false;
			}
			return true;
		}

		private ExtraMesh RasterizeCollider(Collider col)
		{
			return RasterizeCollider(col, col.transform.localToWorldMatrix);
		}

		private ExtraMesh RasterizeCollider(Collider col, Matrix4x4 localToWorldMatrix)
		{
			if (col is BoxCollider)
			{
				BoxCollider boxCollider = col as BoxCollider;
				Matrix4x4 rhs = Matrix4x4.TRS(boxCollider.center, Quaternion.identity, boxCollider.size * 0.5f);
				rhs = localToWorldMatrix * rhs;
				Bounds bounds = boxCollider.bounds;
				return new ExtraMesh(BoxColliderVerts, BoxColliderTris, bounds, rhs);
			}
			if (col is SphereCollider || col is CapsuleCollider)
			{
				SphereCollider sphereCollider = col as SphereCollider;
				CapsuleCollider capsuleCollider = col as CapsuleCollider;
				float num = (!(sphereCollider != null)) ? capsuleCollider.radius : sphereCollider.radius;
				float num2 = (!(sphereCollider != null)) ? (capsuleCollider.height * 0.5f / num - 1f) : 0f;
				Matrix4x4 rhs2 = Matrix4x4.TRS((!(sphereCollider != null)) ? capsuleCollider.center : sphereCollider.center, Quaternion.identity, Vector3.one * num);
				rhs2 = localToWorldMatrix * rhs2;
				int num3 = Mathf.Max(4, Mathf.RoundToInt(colliderRasterizeDetail * Mathf.Sqrt(rhs2.MultiplyVector(Vector3.one).magnitude)));
				if (num3 > 100)
				{
					UnityEngine.Debug.LogWarning("Very large detail for some collider meshes. Consider decreasing Collider Rasterize Detail (RecastGraph)");
				}
				int num4 = num3;
				CapsuleCache capsuleCache = null;
				for (int i = 0; i < this.capsuleCache.Count; i++)
				{
					CapsuleCache capsuleCache2 = this.capsuleCache[i];
					if (capsuleCache2.rows == num3 && Mathf.Approximately(capsuleCache2.height, num2))
					{
						capsuleCache = capsuleCache2;
					}
				}
				Vector3[] array;
				if (capsuleCache == null)
				{
					array = new Vector3[num3 * num4 + 2];
					List<int> list = new List<int>();
					array[array.Length - 1] = Vector3.up;
					for (int j = 0; j < num3; j++)
					{
						for (int k = 0; k < num4; k++)
						{
							array[k + j * num4] = new Vector3(Mathf.Cos((float)k * (float)Math.PI * 2f / (float)num4) * Mathf.Sin((float)j * (float)Math.PI / (float)(num3 - 1)), Mathf.Cos((float)j * (float)Math.PI / (float)(num3 - 1)) + ((j >= num3 / 2) ? (0f - num2) : num2), Mathf.Sin((float)k * (float)Math.PI * 2f / (float)num4) * Mathf.Sin((float)j * (float)Math.PI / (float)(num3 - 1)));
						}
					}
					array[array.Length - 2] = Vector3.down;
					int num5 = 0;
					int num6 = num4 - 1;
					while (num5 < num4)
					{
						list.Add(array.Length - 1);
						list.Add(0 * num4 + num6);
						list.Add(0 * num4 + num5);
						num6 = num5++;
					}
					for (int l = 1; l < num3; l++)
					{
						int num7 = 0;
						int num8 = num4 - 1;
						while (num7 < num4)
						{
							list.Add(l * num4 + num7);
							list.Add(l * num4 + num8);
							list.Add((l - 1) * num4 + num7);
							list.Add((l - 1) * num4 + num8);
							list.Add((l - 1) * num4 + num7);
							list.Add(l * num4 + num8);
							num8 = num7++;
						}
					}
					int num9 = 0;
					int num10 = num4 - 1;
					while (num9 < num4)
					{
						list.Add(array.Length - 2);
						list.Add((num3 - 1) * num4 + num10);
						list.Add((num3 - 1) * num4 + num9);
						num10 = num9++;
					}
					capsuleCache = new CapsuleCache();
					capsuleCache.rows = num3;
					capsuleCache.height = num2;
					capsuleCache.verts = array;
					capsuleCache.tris = list.ToArray();
					this.capsuleCache.Add(capsuleCache);
				}
				array = capsuleCache.verts;
				int[] tris = capsuleCache.tris;
				Bounds bounds2 = col.bounds;
				return new ExtraMesh(array, tris, bounds2, rhs2);
			}
			if (col is MeshCollider)
			{
				MeshCollider meshCollider = col as MeshCollider;
				if (meshCollider.sharedMesh != null)
				{
					return new ExtraMesh(meshCollider.sharedMesh.vertices, meshCollider.sharedMesh.triangles, meshCollider.bounds, localToWorldMatrix);
				}
			}
			return default(ExtraMesh);
		}

		public bool Linecast(Vector3 origin, Vector3 end)
		{
			NNInfo nearest = GetNearest(origin, NNConstraint.None);
			return Linecast(origin, end, nearest.node);
		}

		public bool Linecast(Vector3 origin, Vector3 end, GraphNode hint, out GraphHitInfo hit)
		{
			return NavMeshGraph.Linecast(this, origin, end, hint, out hit, null);
		}

		public bool Linecast(Vector3 origin, Vector3 end, GraphNode hint)
		{
			GraphHitInfo hit;
			return NavMeshGraph.Linecast(this, origin, end, hint, out hit, null);
		}

		public bool Linecast(Vector3 tmp_origin, Vector3 tmp_end, GraphNode hint, out GraphHitInfo hit, List<GraphNode> trace)
		{
			return NavMeshGraph.Linecast(this, tmp_origin, tmp_end, hint, out hit, trace);
		}

		public override void OnDrawGizmos(bool drawNodes)
		{
			if (drawNodes)
			{
				if (bbTree != null)
				{
					bbTree.OnDrawGizmos();
				}
				Gizmos.DrawWireCube(forcedBounds.center, forcedBounds.size);
				if (nodes == null)
				{
				}
				PathHandler debugData = AstarPath.active.debugPathData;
				GraphNodeDelegateCancelable del = delegate(GraphNode _node)
				{
					TriangleMeshNode triangleMeshNode = _node as TriangleMeshNode;
					if (AstarPath.active.showSearchTree && debugData != null && debugData.GetPathNode(triangleMeshNode).parent != null && debugData.GetPathNode(triangleMeshNode).parent.node != null)
					{
						Gizmos.color = NodeColor(triangleMeshNode, debugData);
						Gizmos.DrawLine((Vector3)triangleMeshNode.position, (Vector3)debugData.GetPathNode(triangleMeshNode).parent.node.position);
					}
					else if (showNodeConnections)
					{
						Gizmos.color = NodeColor(triangleMeshNode, null);
						for (int i = 0; i < triangleMeshNode.connections.Length; i++)
						{
							Gizmos.DrawLine((Vector3)triangleMeshNode.position, Vector3.Lerp((Vector3)triangleMeshNode.connections[i].position, (Vector3)triangleMeshNode.position, 0.4f));
						}
					}
					if (showMeshOutline)
					{
						Gizmos.color = NodeColor(triangleMeshNode, debugData);
						Gizmos.DrawLine((Vector3)triangleMeshNode.GetVertex(0), (Vector3)triangleMeshNode.GetVertex(1));
						Gizmos.DrawLine((Vector3)triangleMeshNode.GetVertex(1), (Vector3)triangleMeshNode.GetVertex(2));
						Gizmos.DrawLine((Vector3)triangleMeshNode.GetVertex(2), (Vector3)triangleMeshNode.GetVertex(0));
					}
					return true;
				};
				GetNodes(del);
			}
		}

		public override void SerializeExtraInfo(GraphSerializationContext ctx)
		{
			System.IO.BinaryWriter writer = ctx.writer;
			if (tiles == null)
			{
				writer.Write(-1);
				return;
			}
			writer.Write(tileXCount);
			writer.Write(tileZCount);
			for (int i = 0; i < tileZCount; i++)
			{
				for (int j = 0; j < tileXCount; j++)
				{
					NavmeshTile navmeshTile = tiles[j + i * tileXCount];
					if (navmeshTile == null)
					{
						throw new Exception("NULL Tile");
					}
					writer.Write(navmeshTile.x);
					writer.Write(navmeshTile.z);
					UnityEngine.Debug.Log(navmeshTile.x + " " + navmeshTile.z + " " + j + " " + i);
					if (navmeshTile.x == j && navmeshTile.z == i)
					{
						writer.Write(navmeshTile.w);
						writer.Write(navmeshTile.d);
						writer.Write(navmeshTile.tris.Length);
						UnityEngine.Debug.Log("Tris saved " + navmeshTile.tris.Length);
						for (int k = 0; k < navmeshTile.tris.Length; k++)
						{
							writer.Write(navmeshTile.tris[k]);
						}
						writer.Write(navmeshTile.verts.Length);
						for (int l = 0; l < navmeshTile.verts.Length; l++)
						{
							writer.Write(navmeshTile.verts[l].x);
							writer.Write(navmeshTile.verts[l].y);
							writer.Write(navmeshTile.verts[l].z);
						}
						writer.Write(navmeshTile.nodes.Length);
						for (int m = 0; m < navmeshTile.nodes.Length; m++)
						{
							navmeshTile.nodes[m].SerializeNode(ctx);
						}
					}
				}
			}
		}

		public override void DeserializeExtraInfo(GraphSerializationContext ctx)
		{
			System.IO.BinaryReader reader = ctx.reader;
			tileXCount = reader.ReadInt32();
			if (tileXCount < 0)
			{
				return;
			}
			tileZCount = reader.ReadInt32();
			tiles = new NavmeshTile[tileXCount * tileZCount];
			TriangleMeshNode.SetNavmeshHolder(ctx.graphIndex, this);
			for (int i = 0; i < tileZCount; i++)
			{
				for (int j = 0; j < tileXCount; j++)
				{
					int num = j + i * tileXCount;
					int num2 = reader.ReadInt32();
					if (num2 < 0)
					{
						throw new Exception("Invalid tile coordinates (x < 0)");
					}
					int num3 = reader.ReadInt32();
					if (num3 < 0)
					{
						throw new Exception("Invalid tile coordinates (z < 0)");
					}
					if (num2 != j || num3 != i)
					{
						tiles[num] = tiles[num3 * tileXCount + num2];
						continue;
					}
					NavmeshTile navmeshTile = new NavmeshTile();
					navmeshTile.x = num2;
					navmeshTile.z = num3;
					navmeshTile.w = reader.ReadInt32();
					navmeshTile.d = reader.ReadInt32();
					navmeshTile.bbTree = new BBTree(navmeshTile);
					tiles[num] = navmeshTile;
					int num4 = reader.ReadInt32();
					if (num4 % 3 != 0)
					{
						throw new Exception("Corrupt data. Triangle indices count must be divisable by 3. Got " + num4);
					}
					navmeshTile.tris = new int[num4];
					for (int k = 0; k < navmeshTile.tris.Length; k++)
					{
						navmeshTile.tris[k] = reader.ReadInt32();
					}
					navmeshTile.verts = new Int3[reader.ReadInt32()];
					for (int l = 0; l < navmeshTile.verts.Length; l++)
					{
						navmeshTile.verts[l] = new Int3(reader.ReadInt32(), reader.ReadInt32(), reader.ReadInt32());
					}
					int num5 = reader.ReadInt32();
					navmeshTile.nodes = new TriangleMeshNode[num5];
					num <<= 12;
					for (int m = 0; m < navmeshTile.nodes.Length; m++)
					{
						TriangleMeshNode triangleMeshNode = new TriangleMeshNode(active);
						navmeshTile.nodes[m] = triangleMeshNode;
						triangleMeshNode.GraphIndex = (uint)ctx.graphIndex;
						triangleMeshNode.DeserializeNode(ctx);
						triangleMeshNode.v0 = (navmeshTile.tris[m * 3] | num);
						triangleMeshNode.v1 = (navmeshTile.tris[m * 3 + 1] | num);
						triangleMeshNode.v2 = (navmeshTile.tris[m * 3 + 2] | num);
						triangleMeshNode.UpdatePositionFromVertices();
						navmeshTile.bbTree.Insert(triangleMeshNode);
					}
				}
			}
		}
	}
	public class BBTree
	{
		private struct BBTreeBox
		{
			public Rect rect;

			public MeshNode node;

			public int left;

			public int right;

			public bool IsLeaf => node != null;

			public BBTreeBox(BBTree tree, MeshNode node)
			{
				this.node = node;
				Vector3 vector = (Vector3)node.GetVertex(0);
				Vector2 vector2 = new Vector2(vector.x, vector.z);
				Vector2 vector3 = vector2;
				for (int i = 1; i < node.GetVertexCount(); i++)
				{
					Vector3 vector4 = (Vector3)node.GetVertex(i);
					vector2.x = Math.Min(vector2.x, vector4.x);
					vector2.y = Math.Min(vector2.y, vector4.z);
					vector3.x = Math.Max(vector3.x, vector4.x);
					vector3.y = Math.Max(vector3.y, vector4.z);
				}
				rect = Rect.MinMaxRect(vector2.x, vector2.y, vector3.x, vector3.y);
				left = (right = -1);
			}

			public bool Contains(Vector3 p)
			{
				return rect.Contains(new Vector2(p.x, p.z));
			}
		}

		private BBTreeBox[] arr = new BBTreeBox[6];

		private int count;

		public INavmeshHolder graph;

		public Rect Size => (count == 0) ? new Rect(0f, 0f, 0f, 0f) : arr[0].rect;

		public BBTree(INavmeshHolder graph)
		{
			this.graph = graph;
		}

		public void Clear()
		{
			count = 0;
		}

		private void EnsureCapacity(int c)
		{
			if (arr.Length < c)
			{
				BBTreeBox[] array = new BBTreeBox[Math.Max(c, (int)((float)arr.Length * 1.5f))];
				for (int i = 0; i < count; i++)
				{
					array[i] = arr[i];
				}
				arr = array;
			}
		}

		private int GetBox(MeshNode node)
		{
			if (count >= arr.Length)
			{
				EnsureCapacity(count + 1);
			}
			arr[count] = new BBTreeBox(this, node);
			count++;
			return count - 1;
		}

		public void Insert(MeshNode node)
		{
			int box = GetBox(node);
			if (box == 0)
			{
				return;
			}
			BBTreeBox bBTreeBox = arr[box];
			int num = 0;
			BBTreeBox bBTreeBox2;
			while (true)
			{
				bBTreeBox2 = arr[num];
				bBTreeBox2.rect = ExpandToContain(bBTreeBox2.rect, bBTreeBox.rect);
				if (bBTreeBox2.node != null)
				{
					break;
				}
				arr[num] = bBTreeBox2;
				float num2 = ExpansionRequired(arr[bBTreeBox2.left].rect, bBTreeBox.rect);
				float num3 = ExpansionRequired(arr[bBTreeBox2.right].rect, bBTreeBox.rect);
				num = ((!(num2 < num3)) ? ((!(num3 < num2)) ? ((!(RectArea(arr[bBTreeBox2.left].rect) < RectArea(arr[bBTreeBox2.right].rect))) ? bBTreeBox2.right : bBTreeBox2.left) : bBTreeBox2.right) : bBTreeBox2.left);
			}
			bBTreeBox2.left = box;
			int num4 = bBTreeBox2.right = GetBox(bBTreeBox2.node);
			bBTreeBox2.node = null;
			arr[num] = bBTreeBox2;
		}

		public NNInfo Query(Vector3 p, NNConstraint constraint)
		{
			if (count == 0)
			{
				return new NNInfo(null);
			}
			NNInfo nnInfo = default(NNInfo);
			SearchBox(0, p, constraint, ref nnInfo);
			nnInfo.UpdateInfo();
			return nnInfo;
		}

		public NNInfo QueryCircle(Vector3 p, float radius, NNConstraint constraint)
		{
			if (count == 0)
			{
				return new NNInfo(null);
			}
			NNInfo nnInfo = new NNInfo(null);
			SearchBoxCircle(0, p, radius, constraint, ref nnInfo);
			nnInfo.UpdateInfo();
			return nnInfo;
		}

		public NNInfo QueryClosest(Vector3 p, NNConstraint constraint, out float distance)
		{
			distance = float.PositiveInfinity;
			return QueryClosest(p, constraint, ref distance, new NNInfo(null));
		}

		public NNInfo QueryClosestXZ(Vector3 p, NNConstraint constraint, ref float distance, NNInfo previous)
		{
			if (count == 0)
			{
				return previous;
			}
			SearchBoxClosestXZ(0, p, ref distance, constraint, ref previous);
			return previous;
		}

		private void SearchBoxClosestXZ(int boxi, Vector3 p, ref float closestDist, NNConstraint constraint, ref NNInfo nnInfo)
		{
			BBTreeBox bBTreeBox = arr[boxi];
			if (bBTreeBox.node != null)
			{
				Vector3 constClampedPosition = bBTreeBox.node.ClosestPointOnNodeXZ(p);
				float num = (constClampedPosition.x - p.x) * (constClampedPosition.x - p.x) + (constClampedPosition.z - p.z) * (constClampedPosition.z - p.z);
				if (constraint == null || constraint.Suitable(bBTreeBox.node))
				{
					if (nnInfo.constrainedNode == null)
					{
						nnInfo.constrainedNode = bBTreeBox.node;
						nnInfo.constClampedPosition = constClampedPosition;
						closestDist = (float)Math.Sqrt(num);
					}
					else if (num < closestDist * closestDist)
					{
						nnInfo.constrainedNode = bBTreeBox.node;
						nnInfo.constClampedPosition = constClampedPosition;
						closestDist = (float)Math.Sqrt(num);
					}
				}
			}
			else
			{
				if (RectIntersectsCircle(arr[bBTreeBox.left].rect, p, closestDist))
				{
					SearchBoxClosestXZ(bBTreeBox.left, p, ref closestDist, constraint, ref nnInfo);
				}
				if (RectIntersectsCircle(arr[bBTreeBox.right].rect, p, closestDist))
				{
					SearchBoxClosestXZ(bBTreeBox.right, p, ref closestDist, constraint, ref nnInfo);
				}
			}
		}

		public NNInfo QueryClosest(Vector3 p, NNConstraint constraint, ref float distance, NNInfo previous)
		{
			if (count == 0)
			{
				return previous;
			}
			SearchBoxClosest(0, p, ref distance, constraint, ref previous);
			return previous;
		}

		private void SearchBoxClosest(int boxi, Vector3 p, ref float closestDist, NNConstraint constraint, ref NNInfo nnInfo)
		{
			BBTreeBox bBTreeBox = arr[boxi];
			if (bBTreeBox.node != null)
			{
				if (!NodeIntersectsCircle(bBTreeBox.node, p, closestDist))
				{
					return;
				}
				Vector3 vector = bBTreeBox.node.ClosestPointOnNode(p);
				float sqrMagnitude = (vector - p).sqrMagnitude;
				if (constraint == null || constraint.Suitable(bBTreeBox.node))
				{
					if (nnInfo.constrainedNode == null)
					{
						nnInfo.constrainedNode = bBTreeBox.node;
						nnInfo.constClampedPosition = vector;
						closestDist = (float)Math.Sqrt(sqrMagnitude);
					}
					else if (sqrMagnitude < closestDist * closestDist)
					{
						nnInfo.constrainedNode = bBTreeBox.node;
						nnInfo.constClampedPosition = vector;
						closestDist = (float)Math.Sqrt(sqrMagnitude);
					}
				}
			}
			else
			{
				if (RectIntersectsCircle(arr[bBTreeBox.left].rect, p, closestDist))
				{
					SearchBoxClosest(bBTreeBox.left, p, ref closestDist, constraint, ref nnInfo);
				}
				if (RectIntersectsCircle(arr[bBTreeBox.right].rect, p, closestDist))
				{
					SearchBoxClosest(bBTreeBox.right, p, ref closestDist, constraint, ref nnInfo);
				}
			}
		}

		public MeshNode QueryInside(Vector3 p, NNConstraint constraint)
		{
			if (count == 0)
			{
				return null;
			}
			return SearchBoxInside(0, p, constraint);
		}

		private MeshNode SearchBoxInside(int boxi, Vector3 p, NNConstraint constraint)
		{
			BBTreeBox bBTreeBox = arr[boxi];
			if (bBTreeBox.node != null)
			{
				if (bBTreeBox.node.ContainsPoint((Int3)p) && (constraint == null || constraint.Suitable(bBTreeBox.node)))
				{
					return bBTreeBox.node;
				}
			}
			else
			{
				if (arr[bBTreeBox.left].rect.Contains(new Vector2(p.x, p.z)))
				{
					MeshNode meshNode = SearchBoxInside(bBTreeBox.left, p, constraint);
					if (meshNode != null)
					{
						return meshNode;
					}
				}
				if (arr[bBTreeBox.right].rect.Contains(new Vector2(p.x, p.z)))
				{
					MeshNode meshNode = SearchBoxInside(bBTreeBox.right, p, constraint);
					if (meshNode != null)
					{
						return meshNode;
					}
				}
			}
			return null;
		}

		private void SearchBoxCircle(int boxi, Vector3 p, float radius, NNConstraint constraint, ref NNInfo nnInfo)
		{
			BBTreeBox bBTreeBox = arr[boxi];
			if (bBTreeBox.node != null)
			{
				if (!NodeIntersectsCircle(bBTreeBox.node, p, radius))
				{
					return;
				}
				Vector3 vector = bBTreeBox.node.ClosestPointOnNode(p);
				float sqrMagnitude = (vector - p).sqrMagnitude;
				if (nnInfo.node == null)
				{
					nnInfo.node = bBTreeBox.node;
					nnInfo.clampedPosition = vector;
				}
				else if (sqrMagnitude < (nnInfo.clampedPosition - p).sqrMagnitude)
				{
					nnInfo.node = bBTreeBox.node;
					nnInfo.clampedPosition = vector;
				}
				if (constraint == null || constraint.Suitable(bBTreeBox.node))
				{
					if (nnInfo.constrainedNode == null)
					{
						nnInfo.constrainedNode = bBTreeBox.node;
						nnInfo.constClampedPosition = vector;
					}
					else if (sqrMagnitude < (nnInfo.constClampedPosition - p).sqrMagnitude)
					{
						nnInfo.constrainedNode = bBTreeBox.node;
						nnInfo.constClampedPosition = vector;
					}
				}
			}
			else
			{
				if (RectIntersectsCircle(arr[bBTreeBox.left].rect, p, radius))
				{
					SearchBoxCircle(bBTreeBox.left, p, radius, constraint, ref nnInfo);
				}
				if (RectIntersectsCircle(arr[bBTreeBox.right].rect, p, radius))
				{
					SearchBoxCircle(bBTreeBox.right, p, radius, constraint, ref nnInfo);
				}
			}
		}

		private void SearchBox(int boxi, Vector3 p, NNConstraint constraint, ref NNInfo nnInfo)
		{
			BBTreeBox bBTreeBox = arr[boxi];
			if (bBTreeBox.node != null)
			{
				if (!bBTreeBox.node.ContainsPoint((Int3)p))
				{
					return;
				}
				if (nnInfo.node == null)
				{
					nnInfo.node = bBTreeBox.node;
				}
				else
				{
					Vector3 vector = (Vector3)bBTreeBox.node.position;
					float num = Mathf.Abs(vector.y - p.y);
					Vector3 vector2 = (Vector3)nnInfo.node.position;
					if (num < Mathf.Abs(vector2.y - p.y))
					{
						nnInfo.node = bBTreeBox.node;
					}
				}
				if (constraint.Suitable(bBTreeBox.node))
				{
					if (nnInfo.constrainedNode == null)
					{
						nnInfo.constrainedNode = bBTreeBox.node;
					}
					else if (Mathf.Abs((float)bBTreeBox.node.position.y - p.y) < Mathf.Abs((float)nnInfo.constrainedNode.position.y - p.y))
					{
						nnInfo.constrainedNode = bBTreeBox.node;
					}
				}
			}
			else
			{
				if (RectContains(arr[bBTreeBox.left].rect, p))
				{
					SearchBox(bBTreeBox.left, p, constraint, ref nnInfo);
				}
				if (RectContains(arr[bBTreeBox.right].rect, p))
				{
					SearchBox(bBTreeBox.right, p, constraint, ref nnInfo);
				}
			}
		}

		public void OnDrawGizmos()
		{
			Gizmos.color = new Color(1f, 1f, 1f, 0.5f);
			if (count != 0)
			{
			}
		}

		private void OnDrawGizmos(int boxi, int depth)
		{
			BBTreeBox bBTreeBox = arr[boxi];
			Vector3 a = new Vector3(bBTreeBox.rect.xMin, 0f, bBTreeBox.rect.yMin);
			Vector3 vector = new Vector3(bBTreeBox.rect.xMax, 0f, bBTreeBox.rect.yMax);
			Vector3 vector2 = (a + vector) * 0.5f;
			Vector3 size = (vector - vector2) * 2f;
			vector2.y += (float)depth * 0.2f;
			Gizmos.color = AstarMath.IntToColor(depth, 0.05f);
			Gizmos.DrawCube(vector2, size);
			if (bBTreeBox.node == null)
			{
				OnDrawGizmos(bBTreeBox.left, depth + 1);
				OnDrawGizmos(bBTreeBox.right, depth + 1);
			}
		}

		private static bool NodeIntersectsCircle(MeshNode node, Vector3 p, float radius)
		{
			if (float.IsPositiveInfinity(radius))
			{
				return true;
			}
			return (p - node.ClosestPointOnNode(p)).sqrMagnitude < radius * radius;
		}

		private static bool RectIntersectsCircle(Rect r, Vector3 p, float radius)
		{
			if (float.IsPositiveInfinity(radius))
			{
				return true;
			}
			Vector3 vector = p;
			p.x = Math.Max(p.x, r.xMin);
			p.x = Math.Min(p.x, r.xMax);
			p.z = Math.Max(p.z, r.yMin);
			p.z = Math.Min(p.z, r.yMax);
			return (p.x - vector.x) * (p.x - vector.x) + (p.z - vector.z) * (p.z - vector.z) < radius * radius;
		}

		private static bool RectContains(Rect r, Vector3 p)
		{
			return p.x >= r.xMin && p.x <= r.xMax && p.z >= r.yMin && p.z <= r.yMax;
		}

		private static float ExpansionRequired(Rect r, Rect r2)
		{
			float num = Math.Min(r.xMin, r2.xMin);
			float num2 = Math.Max(r.xMax, r2.xMax);
			float num3 = Math.Min(r.yMin, r2.yMin);
			float num4 = Math.Max(r.yMax, r2.yMax);
			return (num2 - num) * (num4 - num3) - RectArea(r);
		}

		private static Rect ExpandToContain(Rect r, Rect r2)
		{
			float left = Math.Min(r.xMin, r2.xMin);
			float right = Math.Max(r.xMax, r2.xMax);
			float top = Math.Min(r.yMin, r2.yMin);
			float bottom = Math.Max(r.yMax, r2.yMax);
			return Rect.MinMaxRect(left, top, right, bottom);
		}

		private static float RectArea(Rect r)
		{
			return r.width * r.height;
		}
	}
}
[ExecuteInEditMode]
public class NavMeshRenderer : MonoBehaviour
{
	private string lastLevel = string.Empty;

	public string SomeFunction()
	{
		return lastLevel;
	}

	private void Update()
	{
	}
}
namespace Pathfinding
{
	public class ObjImporter
	{
		private struct meshStruct
		{
			public Vector3[] vertices;

			public Vector3[] normals;

			public Vector2[] uv;

			public Vector2[] uv1;

			public Vector2[] uv2;

			public int[] triangles;

			public int[] faceVerts;

			public int[] faceUVs;

			public Vector3[] faceData;

			public string name;

			public string fileName;
		}

		public static Mesh ImportFile(string filePath)
		{
			if (!File.Exists(filePath))
			{
				UnityEngine.Debug.LogError("No file was found at '" + filePath + "'");
				return null;
			}
			meshStruct mesh = createMeshStruct(filePath);
			populateMeshStruct(ref mesh);
			Vector3[] array = new Vector3[mesh.faceData.Length];
			Vector2[] array2 = new Vector2[mesh.faceData.Length];
			Vector3[] array3 = new Vector3[mesh.faceData.Length];
			int num = 0;
			Vector3[] faceData = mesh.faceData;
			for (int i = 0; i < faceData.Length; i++)
			{
				Vector3 vector = faceData[i];
				array[num] = mesh.vertices[(int)vector.x - 1];
				if (vector.y >= 1f)
				{
					array2[num] = mesh.uv[(int)vector.y - 1];
				}
				if (vector.z >= 1f)
				{
					array3[num] = mesh.normals[(int)vector.z - 1];
				}
				num++;
			}
			Mesh mesh2 = new Mesh();
			mesh2.vertices = array;
			mesh2.uv = array2;
			mesh2.normals = array3;
			mesh2.triangles = mesh.triangles;
			mesh2.RecalculateBounds();
			return mesh2;
		}

		private static meshStruct createMeshStruct(string filename)
		{
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			meshStruct result = default(meshStruct);
			result.fileName = filename;
			StreamReader streamReader = File.OpenText(filename);
			string s = streamReader.ReadToEnd();
			streamReader.Dispose();
			using (StringReader stringReader = new StringReader(s))
			{
				string text = stringReader.ReadLine();
				char[] separator = new char[1]
				{
					' '
				};
				while (text != null)
				{
					if (!text.StartsWith("f ") && !text.StartsWith("v ") && !text.StartsWith("vt ") && !text.StartsWith("vn "))
					{
						text = stringReader.ReadLine();
						if (text != null)
						{
							text = text.Replace("  ", " ");
						}
					}
					else
					{
						text = text.Trim();
						string[] array = text.Split(separator, 50);
						switch (array[0])
						{
						case "v":
							num2++;
							break;
						case "vt":
							num3++;
							break;
						case "vn":
							num4++;
							break;
						case "f":
							num5 = num5 + array.Length - 1;
							num += 3 * (array.Length - 2);
							break;
						}
						text = stringReader.ReadLine();
						if (text != null)
						{
							text = text.Replace("  ", " ");
						}
					}
				}
			}
			result.triangles = new int[num];
			result.vertices = new Vector3[num2];
			result.uv = new Vector2[num3];
			result.normals = new Vector3[num4];
			result.faceData = new Vector3[num5];
			return result;
		}

		private static void populateMeshStruct(ref meshStruct mesh)
		{
			StreamReader streamReader = File.OpenText(mesh.fileName);
			string s = streamReader.ReadToEnd();
			streamReader.Close();
			using (StringReader stringReader = new StringReader(s))
			{
				string text = stringReader.ReadLine();
				char[] separator = new char[1]
				{
					' '
				};
				char[] separator2 = new char[1]
				{
					'/'
				};
				int num = 0;
				int num2 = 0;
				int num3 = 0;
				int num4 = 0;
				int num5 = 0;
				int num6 = 0;
				int num7 = 0;
				while (text != null)
				{
					if (!text.StartsWith("f ") && !text.StartsWith("v ") && !text.StartsWith("vt ") && !text.StartsWith("vn ") && !text.StartsWith("g ") && !text.StartsWith("usemtl ") && !text.StartsWith("mtllib ") && !text.StartsWith("vt1 ") && !text.StartsWith("vt2 ") && !text.StartsWith("vc ") && !text.StartsWith("usemap "))
					{
						text = stringReader.ReadLine();
						if (text != null)
						{
							text = text.Replace("  ", " ");
						}
					}
					else
					{
						text = text.Trim();
						string[] array = text.Split(separator, 50);
						switch (array[0])
						{
						case "v":
							mesh.vertices[num3] = new Vector3(Convert.ToSingle(array[1]), Convert.ToSingle(array[2]), Convert.ToSingle(array[3]));
							num3++;
							break;
						case "vt":
							mesh.uv[num5] = new Vector2(Convert.ToSingle(array[1]), Convert.ToSingle(array[2]));
							num5++;
							break;
						case "vt1":
							mesh.uv[num6] = new Vector2(Convert.ToSingle(array[1]), Convert.ToSingle(array[2]));
							num6++;
							break;
						case "vt2":
							mesh.uv[num7] = new Vector2(Convert.ToSingle(array[1]), Convert.ToSingle(array[2]));
							num7++;
							break;
						case "vn":
							mesh.normals[num4] = new Vector3(Convert.ToSingle(array[1]), Convert.ToSingle(array[2]), Convert.ToSingle(array[3]));
							num4++;
							break;
						case "f":
						{
							int num8 = 1;
							List<int> list = new List<int>();
							while (num8 < array.Length && (string.Empty + array[num8]).Length > 0)
							{
								Vector3 vector = default(Vector3);
								string[] array2 = array[num8].Split(separator2, 3);
								vector.x = Convert.ToInt32(array2[0]);
								if (array2.Length > 1)
								{
									if (array2[1] != string.Empty)
									{
										vector.y = Convert.ToInt32(array2[1]);
									}
									vector.z = Convert.ToInt32(array2[2]);
								}
								num8++;
								mesh.faceData[num2] = vector;
								list.Add(num2);
								num2++;
							}
							for (num8 = 1; num8 + 2 < array.Length; num8++)
							{
								mesh.triangles[num] = list[0];
								num++;
								mesh.triangles[num] = list[num8];
								num++;
								mesh.triangles[num] = list[num8 + 1];
								num++;
							}
							break;
						}
						}
						text = stringReader.ReadLine();
						if (text != null)
						{
							text = text.Replace("  ", " ");
						}
					}
				}
			}
		}
	}
	public class RecastBBTree
	{
		public RecastBBTreeBox root;

		public void QueryInBounds(Rect bounds, List<RecastMeshObj> buffer)
		{
			RecastBBTreeBox recastBBTreeBox = root;
			if (recastBBTreeBox != null)
			{
				QueryBoxInBounds(recastBBTreeBox, bounds, buffer);
			}
		}

		public void QueryBoxInBounds(RecastBBTreeBox box, Rect bounds, List<RecastMeshObj> boxes)
		{
			if (box.mesh != null)
			{
				if (RectIntersectsRect(box.rect, bounds))
				{
					boxes.Add(box.mesh);
				}
				return;
			}
			if (RectIntersectsRect(box.c1.rect, bounds))
			{
				QueryBoxInBounds(box.c1, bounds, boxes);
			}
			if (RectIntersectsRect(box.c2.rect, bounds))
			{
				QueryBoxInBounds(box.c2, bounds, boxes);
			}
		}

		public bool Remove(RecastMeshObj mesh)
		{
			if (mesh == null)
			{
				throw new ArgumentNullException("mesh");
			}
			if (root == null)
			{
				return false;
			}
			bool found = false;
			Bounds bounds = mesh.GetBounds();
			Vector3 min = bounds.min;
			float x = min.x;
			Vector3 min2 = bounds.min;
			float z = min2.z;
			Vector3 max = bounds.max;
			float x2 = max.x;
			Vector3 max2 = bounds.max;
			Rect bounds2 = Rect.MinMaxRect(x, z, x2, max2.z);
			root = RemoveBox(root, mesh, bounds2, ref found);
			return found;
		}

		private RecastBBTreeBox RemoveBox(RecastBBTreeBox c, RecastMeshObj mesh, Rect bounds, ref bool found)
		{
			if (!RectIntersectsRect(c.rect, bounds))
			{
				return c;
			}
			if (c.mesh == mesh)
			{
				found = true;
				return null;
			}
			if (c.mesh == null && !found)
			{
				c.c1 = RemoveBox(c.c1, mesh, bounds, ref found);
				if (c.c1 == null)
				{
					return c.c2;
				}
				if (!found)
				{
					c.c2 = RemoveBox(c.c2, mesh, bounds, ref found);
					if (c.c2 == null)
					{
						return c.c1;
					}
				}
				if (found)
				{
					c.rect = ExpandToContain(c.c1.rect, c.c2.rect);
				}
			}
			return c;
		}

		public void Insert(RecastMeshObj mesh)
		{
			RecastBBTreeBox recastBBTreeBox = new RecastBBTreeBox(this, mesh);
			if (root == null)
			{
				root = recastBBTreeBox;
				return;
			}
			RecastBBTreeBox recastBBTreeBox2 = root;
			while (true)
			{
				recastBBTreeBox2.rect = ExpandToContain(recastBBTreeBox2.rect, recastBBTreeBox.rect);
				if (recastBBTreeBox2.mesh != null)
				{
					break;
				}
				float num = ExpansionRequired(recastBBTreeBox2.c1.rect, recastBBTreeBox.rect);
				float num2 = ExpansionRequired(recastBBTreeBox2.c2.rect, recastBBTreeBox.rect);
				recastBBTreeBox2 = ((!(num < num2)) ? ((!(num2 < num)) ? ((!(RectArea(recastBBTreeBox2.c1.rect) < RectArea(recastBBTreeBox2.c2.rect))) ? recastBBTreeBox2.c2 : recastBBTreeBox2.c1) : recastBBTreeBox2.c2) : recastBBTreeBox2.c1);
			}
			recastBBTreeBox2.c1 = recastBBTreeBox;
			RecastBBTreeBox recastBBTreeBox3 = recastBBTreeBox2.c2 = new RecastBBTreeBox(this, recastBBTreeBox2.mesh);
			recastBBTreeBox2.mesh = null;
		}

		public void OnDrawGizmos()
		{
		}

		public void OnDrawGizmos(RecastBBTreeBox box)
		{
			if (box != null)
			{
				Vector3 a = new Vector3(box.rect.xMin, 0f, box.rect.yMin);
				Vector3 vector = new Vector3(box.rect.xMax, 0f, box.rect.yMax);
				Vector3 vector2 = (a + vector) * 0.5f;
				Vector3 size = (vector - vector2) * 2f;
				Gizmos.DrawCube(vector2, size);
				OnDrawGizmos(box.c1);
				OnDrawGizmos(box.c2);
			}
		}

		public void TestIntersections(Vector3 p, float radius)
		{
			RecastBBTreeBox box = root;
			TestIntersections(box, p, radius);
		}

		public void TestIntersections(RecastBBTreeBox box, Vector3 p, float radius)
		{
			if (box != null)
			{
				RectIntersectsCircle(box.rect, p, radius);
				TestIntersections(box.c1, p, radius);
				TestIntersections(box.c2, p, radius);
			}
		}

		public bool RectIntersectsRect(Rect r, Rect r2)
		{
			return r.xMax > r2.xMin && r.yMax > r2.yMin && r2.xMax > r.xMin && r2.yMax > r.yMin;
		}

		public bool RectIntersectsCircle(Rect r, Vector3 p, float radius)
		{
			if (float.IsPositiveInfinity(radius))
			{
				return true;
			}
			if (RectContains(r, p))
			{
				return true;
			}
			return XIntersectsCircle(r.xMin, r.xMax, r.yMin, p, radius) || XIntersectsCircle(r.xMin, r.xMax, r.yMax, p, radius) || ZIntersectsCircle(r.yMin, r.yMax, r.xMin, p, radius) || ZIntersectsCircle(r.yMin, r.yMax, r.xMax, p, radius);
		}

		public bool RectContains(Rect r, Vector3 p)
		{
			return p.x >= r.xMin && p.x <= r.xMax && p.z >= r.yMin && p.z <= r.yMax;
		}

		public bool ZIntersectsCircle(float z1, float z2, float xpos, Vector3 circle, float radius)
		{
			double num = Math.Abs(xpos - circle.x) / radius;
			if (num > 1.0 || num < -1.0)
			{
				return false;
			}
			float num2 = (float)Math.Sqrt(1.0 - num * num) * radius;
			float val = circle.z - num2;
			num2 += circle.z;
			float b = Math.Min(num2, val);
			float b2 = Math.Max(num2, val);
			b = Mathf.Max(z1, b);
			b2 = Mathf.Min(z2, b2);
			return b2 > b;
		}

		public bool XIntersectsCircle(float x1, float x2, float zpos, Vector3 circle, float radius)
		{
			double num = Math.Abs(zpos - circle.z) / radius;
			if (num > 1.0 || num < -1.0)
			{
				return false;
			}
			float num2 = (float)Math.Sqrt(1.0 - num * num) * radius;
			float val = circle.x - num2;
			num2 += circle.x;
			float b = Math.Min(num2, val);
			float b2 = Math.Max(num2, val);
			b = Mathf.Max(x1, b);
			b2 = Mathf.Min(x2, b2);
			return b2 > b;
		}

		public float ExpansionRequired(Rect r, Rect r2)
		{
			float num = Mathf.Min(r.xMin, r2.xMin);
			float num2 = Mathf.Max(r.xMax, r2.xMax);
			float num3 = Mathf.Min(r.yMin, r2.yMin);
			float num4 = Mathf.Max(r.yMax, r2.yMax);
			return (num2 - num) * (num4 - num3) - RectArea(r);
		}

		public Rect ExpandToContain(Rect r, Rect r2)
		{
			float left = Mathf.Min(r.xMin, r2.xMin);
			float right = Mathf.Max(r.xMax, r2.xMax);
			float top = Mathf.Min(r.yMin, r2.yMin);
			float bottom = Mathf.Max(r.yMax, r2.yMax);
			return Rect.MinMaxRect(left, top, right, bottom);
		}

		public float RectArea(Rect r)
		{
			return r.width * r.height;
		}

		public new void ToString()
		{
			RecastBBTreeBox recastBBTreeBox = root;
			Stack<RecastBBTreeBox> stack = new Stack<RecastBBTreeBox>();
			stack.Push(recastBBTreeBox);
			recastBBTreeBox.WriteChildren(0);
		}
	}
	public class RecastBBTreeBox
	{
		public Rect rect;

		public RecastMeshObj mesh;

		public RecastBBTreeBox c1;

		public RecastBBTreeBox c2;

		public RecastBBTreeBox(RecastBBTree tree, RecastMeshObj mesh)
		{
			this.mesh = mesh;
			Vector3 min = mesh.bounds.min;
			Vector3 max = mesh.bounds.max;
			rect = Rect.MinMaxRect(min.x, min.z, max.x, max.z);
		}

		public bool Contains(Vector3 p)
		{
			return rect.Contains(p);
		}

		public void WriteChildren(int level)
		{
			for (int i = 0; i < level; i++)
			{
				Console.Write("  ");
			}
			if (mesh != null)
			{
				Console.WriteLine("Leaf ");
				return;
			}
			Console.WriteLine("Box ");
			c1.WriteChildren(level + 1);
			c2.WriteChildren(level + 1);
		}
	}
	[AddComponentMenu("Pathfinding/Navmesh/RecastMeshObj")]
	public class RecastMeshObj : MonoBehaviour
	{
		protected static RecastBBTree tree = new RecastBBTree();

		protected static List<RecastMeshObj> dynamicMeshObjs = new List<RecastMeshObj>();

		[HideInInspector]
		public Bounds bounds;

		public bool dynamic;

		public int area;

		private bool _dynamic;

		private bool registered;

		public static void GetAllInBounds(List<RecastMeshObj> buffer, Bounds bounds)
		{
			if (!UnityEngine.Application.isPlaying)
			{
				RecastMeshObj[] array = UnityEngine.Object.FindObjectsOfType(typeof(RecastMeshObj)) as RecastMeshObj[];
				for (int i = 0; i < array.Length; i++)
				{
					array[i].RecalculateBounds();
					if (array[i].GetBounds().Intersects(bounds))
					{
						buffer.Add(array[i]);
					}
				}
				return;
			}
			if (Time.timeSinceLevelLoad == 0f)
			{
				RecastMeshObj[] array2 = UnityEngine.Object.FindObjectsOfType(typeof(RecastMeshObj)) as RecastMeshObj[];
				for (int j = 0; j < array2.Length; j++)
				{
					array2[j].Register();
				}
			}
			for (int k = 0; k < dynamicMeshObjs.Count; k++)
			{
				if (dynamicMeshObjs[k].GetBounds().Intersects(bounds))
				{
					buffer.Add(dynamicMeshObjs[k]);
				}
			}
			Vector3 min = bounds.min;
			float x = min.x;
			Vector3 min2 = bounds.min;
			float z = min2.z;
			Vector3 max = bounds.max;
			float x2 = max.x;
			Vector3 max2 = bounds.max;
			Rect rect = Rect.MinMaxRect(x, z, x2, max2.z);
			tree.QueryInBounds(rect, buffer);
		}

		private void OnEnable()
		{
			Register();
		}

		private void Register()
		{
			if (!registered)
			{
				registered = true;
				area = Mathf.Clamp(area, -1, 33554432);
				Renderer component = GetComponent<Renderer>();
				Collider component2 = GetComponent<Collider>();
				if (component == null && component2 == null)
				{
					throw new Exception("A renderer or a collider should be attached to the GameObject");
				}
				MeshFilter component3 = GetComponent<MeshFilter>();
				if (component != null && component3 == null)
				{
					throw new Exception("A renderer was attached but no mesh filter");
				}
				if (component != null)
				{
					bounds = component.bounds;
				}
				else
				{
					bounds = component2.bounds;
				}
				_dynamic = dynamic;
				if (_dynamic)
				{
					dynamicMeshObjs.Add(this);
				}
				else
				{
					tree.Insert(this);
				}
			}
		}

		private void RecalculateBounds()
		{
			Renderer component = GetComponent<Renderer>();
			Collider collider = GetCollider();
			if (component == null && collider == null)
			{
				throw new Exception("A renderer or a collider should be attached to the GameObject");
			}
			MeshFilter component2 = GetComponent<MeshFilter>();
			if (component != null && component2 == null)
			{
				throw new Exception("A renderer was attached but no mesh filter");
			}
			if (component != null)
			{
				bounds = component.bounds;
			}
			else
			{
				bounds = collider.bounds;
			}
		}

		public Bounds GetBounds()
		{
			if (_dynamic)
			{
				RecalculateBounds();
			}
			return bounds;
		}

		public MeshFilter GetMeshFilter()
		{
			return GetComponent<MeshFilter>();
		}

		public Collider GetCollider()
		{
			return GetComponent<Collider>();
		}

		private void OnDisable()
		{
			registered = false;
			if (_dynamic)
			{
				dynamicMeshObjs.Remove(this);
			}
			else if (!tree.Remove(this))
			{
				throw new Exception("Could not remove RecastMeshObj from tree even though it should exist in it. Has the object moved without being marked as dynamic?");
			}
			_dynamic = dynamic;
		}
	}
}
namespace Pathfinding.Util
{
	public class TileHandler
	{
		public class TileType
		{
			private Int3[] verts;

			private int[] tris;

			private Int3 offset;

			private int lastYOffset;

			private int lastRotation;

			private int width;

			private int depth;

			private static readonly int[] Rotations = new int[16]
			{
				1,
				0,
				0,
				1,
				0,
				1,
				-1,
				0,
				-1,
				0,
				0,
				-1,
				0,
				-1,
				1,
				0
			};

			public int Width => width;

			public int Depth => depth;

			public TileType(Int3[] sourceVerts, int[] sourceTris, Int3 tileSize, Int3 centerOffset, int width = 1, int depth = 1)
			{
				if (sourceVerts == null)
				{
					throw new ArgumentNullException("sourceVerts");
				}
				if (sourceTris == null)
				{
					throw new ArgumentNullException("sourceTris");
				}
				tris = new int[sourceTris.Length];
				for (int i = 0; i < tris.Length; i++)
				{
					tris[i] = sourceTris[i];
				}
				verts = new Int3[sourceVerts.Length];
				for (int j = 0; j < sourceVerts.Length; j++)
				{
					verts[j] = sourceVerts[j] + centerOffset;
				}
				offset = tileSize / 2f;
				offset.x *= width;
				offset.z *= depth;
				offset.y = 0;
				for (int k = 0; k < sourceVerts.Length; k++)
				{
					verts[k] += offset;
				}
				lastRotation = 0;
				lastYOffset = 0;
				this.width = width;
				this.depth = depth;
			}

			public TileType(Mesh source, Int3 tileSize, Int3 centerOffset, int width = 1, int depth = 1)
			{
				if (source == null)
				{
					throw new ArgumentNullException("source");
				}
				Vector3[] vertices = source.vertices;
				tris = source.triangles;
				verts = new Int3[vertices.Length];
				for (int i = 0; i < vertices.Length; i++)
				{
					verts[i] = (Int3)vertices[i] + centerOffset;
				}
				offset = tileSize / 2f;
				offset.x *= width;
				offset.z *= depth;
				offset.y = 0;
				for (int j = 0; j < vertices.Length; j++)
				{
					verts[j] += offset;
				}
				lastRotation = 0;
				lastYOffset = 0;
				this.width = width;
				this.depth = depth;
			}

			public void Load(out Int3[] verts, out int[] tris, int rotation, int yoffset)
			{
				rotation = (rotation % 4 + 4) % 4;
				int num = rotation;
				rotation = (rotation - lastRotation % 4 + 4) % 4;
				lastRotation = num;
				verts = this.verts;
				int num2 = yoffset - lastYOffset;
				lastYOffset = yoffset;
				if (rotation != 0 || num2 != 0)
				{
					for (int i = 0; i < verts.Length; i++)
					{
						Int3 @int = verts[i] - offset;
						Int3 lhs = @int;
						lhs.y += num2;
						lhs.x = @int.x * Rotations[rotation * 4] + @int.z * Rotations[rotation * 4 + 1];
						lhs.z = @int.x * Rotations[rotation * 4 + 2] + @int.z * Rotations[rotation * 4 + 3];
						verts[i] = lhs + offset;
					}
				}
				tris = this.tris;
			}
		}

		public enum CutMode
		{
			CutAll = 1,
			CutDual = 2,
			CutExtra = 4
		}

		private const int CUT_ALL = 0;

		private const int CUT_DUAL = 1;

		private const int CUT_BREAK = 2;

		private RecastGraph _graph;

		private List<TileType> tileTypes = new List<TileType>();

		private Clipper clipper;

		private int[] cached_int_array = new int[32];

		private Dictionary<Int3, int> cached_Int3_int_dict = new Dictionary<Int3, int>();

		private Dictionary<Int2, int> cached_Int2_int_dict = new Dictionary<Int2, int>();

		private TileType[] activeTileTypes;

		private int[] activeTileRotations;

		private int[] activeTileOffsets;

		private bool[] reloadedInBatch;

		private bool isBatching;

		public RecastGraph graph => _graph;

		public TileHandler(RecastGraph graph)
		{
			if (graph == null)
			{
				throw new ArgumentNullException("'graph' cannot be null");
			}
			if (graph.GetTiles() == null)
			{
				throw new ArgumentException("graph has no tiles. Please scan the graph before creating a TileHandler");
			}
			activeTileTypes = new TileType[graph.tileXCount * graph.tileZCount];
			activeTileRotations = new int[activeTileTypes.Length];
			activeTileOffsets = new int[activeTileTypes.Length];
			reloadedInBatch = new bool[activeTileTypes.Length];
			_graph = graph;
		}

		public int GetActiveRotation(Int2 p)
		{
			return activeTileRotations[p.x + p.y * _graph.tileXCount];
		}

		public TileType GetTileType(int index)
		{
			return tileTypes[index];
		}

		public int GetTileTypeCount()
		{
			return tileTypes.Count;
		}

		public TileType RegisterTileType(Mesh source, Int3 centerOffset, int width = 1, int depth = 1)
		{
			TileType tileType = new TileType(source, new Int3(graph.tileSizeX, 1, graph.tileSizeZ) * (1000f * graph.cellSize), centerOffset, width, depth);
			tileTypes.Add(tileType);
			return tileType;
		}

		public void CreateTileTypesFromGraph()
		{
			RecastGraph.NavmeshTile[] tiles = graph.GetTiles();
			if (tiles == null || tiles.Length != graph.tileXCount * graph.tileZCount)
			{
				throw new InvalidOperationException("Graph tiles are invalid (either null or number of tiles is not equal to width*depth of the graph");
			}
			for (int i = 0; i < graph.tileZCount; i++)
			{
				for (int j = 0; j < graph.tileXCount; j++)
				{
					RecastGraph.NavmeshTile navmeshTile = tiles[j + i * graph.tileXCount];
					Int3 lhs = (Int3)graph.GetTileBounds(j, i).min;
					Int3 tileSize = new Int3(graph.tileSizeX, 1, graph.tileSizeZ) * (1000f * graph.cellSize);
					lhs += new Int3(tileSize.x * navmeshTile.w / 2, 0, tileSize.z * navmeshTile.d / 2);
					lhs = -lhs;
					TileType tileType = new TileType(navmeshTile.verts, navmeshTile.tris, tileSize, lhs, navmeshTile.w, navmeshTile.d);
					tileTypes.Add(tileType);
					int num = j + i * graph.tileXCount;
					activeTileTypes[num] = tileType;
					activeTileRotations[num] = 0;
					activeTileOffsets[num] = 0;
				}
			}
		}

		public bool StartBatchLoad()
		{
			if (isBatching)
			{
				return false;
			}
			isBatching = true;
			AstarPath.active.AddWorkItem(new AstarPath.AstarWorkItem(delegate
			{
				graph.StartBatchTileUpdate();
				return true;
			}));
			return true;
		}

		public void EndBatchLoad()
		{
			if (!isBatching)
			{
				throw new Exception("Ending batching when batching has not been started");
			}
			for (int i = 0; i < reloadedInBatch.Length; i++)
			{
				reloadedInBatch[i] = false;
			}
			isBatching = false;
			AstarPath.active.AddWorkItem(new AstarPath.AstarWorkItem(delegate
			{
				graph.EndBatchTileUpdate();
				return true;
			}));
		}

		private void CutPoly(Int3[] verts, int[] tris, ref Int3[] outVertsArr, ref int[] outTrisArr, out int outVCount, out int outTCount, Int3[] extraShape, Int3 cuttingOffset, Bounds realBounds, CutMode mode = (CutMode)3, int perturbate = 0)
		{
			//Discarded unreachable code: IL_1000
			if (verts.Length == 0 || tris.Length == 0)
			{
				outVCount = 0;
				outTCount = 0;
				outTrisArr = new int[0];
				outVertsArr = new Int3[0];
				return;
			}
			List<IntPoint> list = null;
			if (extraShape == null && (mode & CutMode.CutExtra) != 0)
			{
				throw new Exception("extraShape is null and the CutMode specifies that it should be used. Cannot use null shape.");
			}
			if ((mode & CutMode.CutExtra) != 0)
			{
				list = new List<IntPoint>(extraShape.Length);
				for (int i = 0; i < extraShape.Length; i++)
				{
					list.Add(new IntPoint(extraShape[i].x + cuttingOffset.x, extraShape[i].z + cuttingOffset.z));
				}
			}
			List<IntPoint> list2 = new List<IntPoint>(5);
			Dictionary<TriangulationPoint, int> dictionary = new Dictionary<TriangulationPoint, int>();
			List<PolygonPoint> list3 = new List<PolygonPoint>();
			IntRect b = new IntRect(verts[0].x, verts[0].z, verts[0].x, verts[0].z);
			for (int j = 0; j < verts.Length; j++)
			{
				b = b.ExpandToContain(verts[j].x, verts[j].z);
			}
			List<Int3> list4 = ListPool<Int3>.Claim(verts.Length * 2);
			List<int> list5 = ListPool<int>.Claim(tris.Length);
			PolyTree polyTree = new PolyTree();
			List<List<IntPoint>> list6 = new List<List<IntPoint>>();
			Stack<Pathfinding.Poly2Tri.Polygon> stack = new Stack<Pathfinding.Poly2Tri.Polygon>();
			if (clipper == null)
			{
				clipper = new Clipper();
			}
			clipper.ReverseSolution = true;
			List<NavmeshCut> list7 = (mode != CutMode.CutExtra) ? NavmeshCut.GetAllInRange(realBounds) : ListPool<NavmeshCut>.Claim();
			List<int> list8 = ListPool<int>.Claim();
			List<IntRect> list9 = ListPool<IntRect>.Claim();
			List<Int2> list10 = ListPool<Int2>.Claim();
			List<List<IntPoint>> list11 = new List<List<IntPoint>>();
			List<bool> list12 = ListPool<bool>.Claim();
			List<bool> list13 = ListPool<bool>.Claim();
			if (perturbate > 10)
			{
				UnityEngine.Debug.LogError("Too many perturbations aborting : " + mode);
				UnityEngine.Debug.Break();
				outVCount = verts.Length;
				outTCount = tris.Length;
				outTrisArr = tris;
				outVertsArr = verts;
				return;
			}
			System.Random random = null;
			if (perturbate > 0)
			{
				random = new System.Random();
			}
			IntRect item = default(IntRect);
			for (int k = 0; k < list7.Count; k++)
			{
				Bounds bounds = list7[k].GetBounds();
				Int3 @int = (Int3)bounds.min + cuttingOffset;
				Int3 int2 = (Int3)bounds.max + cuttingOffset;
				IntRect a = new IntRect(@int.x, @int.z, int2.x, int2.z);
				if (!IntRect.Intersects(a, b))
				{
					continue;
				}
				Int2 int3 = new Int2(0, 0);
				if (perturbate > 0)
				{
					int3.x = random.Next() % 6 * perturbate - 3 * perturbate;
					if (int3.x >= 0)
					{
						int3.x++;
					}
					int3.y = random.Next() % 6 * perturbate - 3 * perturbate;
					if (int3.y >= 0)
					{
						int3.y++;
					}
				}
				int count = list11.Count;
				list7[k].GetContour(list11);
				for (int l = count; l < list11.Count; l++)
				{
					List<IntPoint> list14 = list11[l];
					if (list14.Count == 0)
					{
						UnityEngine.Debug.LogError("Zero Length Contour");
						list9.Add(default(IntRect));
						list10.Add(new Int2(0, 0));
						continue;
					}
					IntPoint intPoint = list14[0];
					int xmin = (int)intPoint.X + cuttingOffset.x;
					IntPoint intPoint2 = list14[0];
					int ymin = (int)intPoint2.Y + cuttingOffset.y;
					IntPoint intPoint3 = list14[0];
					int xmax = (int)intPoint3.X + cuttingOffset.x;
					IntPoint intPoint4 = list14[0];
					item = new IntRect(xmin, ymin, xmax, (int)intPoint4.Y + cuttingOffset.y);
					for (int m = 0; m < list14.Count; m++)
					{
						IntPoint value = list14[m];
						value.X += cuttingOffset.x;
						value.Y += cuttingOffset.z;
						if (perturbate > 0)
						{
							value.X += int3.x;
							value.Y += int3.y;
						}
						list14[m] = value;
						item = item.ExpandToContain((int)value.X, (int)value.Y);
					}
					list10.Add(new Int2(@int.y, int2.y));
					list9.Add(item);
					list12.Add(list7[k].isDual);
					list13.Add(list7[k].cutsAddedGeom);
				}
			}
			List<NavmeshAdd> allInRange = NavmeshAdd.GetAllInRange(realBounds);
			Int3[] vbuffer = verts;
			int[] tbuffer = tris;
			int num = -1;
			int num2 = -3;
			Int3[] array = null;
			Int3[] array2 = null;
			Int3 int4 = Int3.zero;
			if (allInRange.Count > 0)
			{
				array = new Int3[7];
				array2 = new Int3[7];
				int4 = (Int3)realBounds.extents;
			}
			Int3 item2 = default(Int3);
			Int3 item3 = default(Int3);
			while (true)
			{
				num2 += 3;
				while (num2 >= tbuffer.Length)
				{
					num++;
					num2 = 0;
					if (num >= allInRange.Count)
					{
						vbuffer = null;
						break;
					}
					if (vbuffer == verts)
					{
						vbuffer = null;
					}
					allInRange[num].GetMesh(cuttingOffset, ref vbuffer, out tbuffer);
				}
				if (vbuffer == null)
				{
					break;
				}
				Int3 int5 = vbuffer[tbuffer[num2]];
				Int3 int6 = vbuffer[tbuffer[num2 + 1]];
				Int3 int7 = vbuffer[tbuffer[num2 + 2]];
				IntRect a2 = new IntRect(int5.x, int5.z, int5.x, int5.z).ExpandToContain(int6.x, int6.z).ExpandToContain(int7.x, int7.z);
				int num3 = Math.Min(int5.y, Math.Min(int6.y, int7.y));
				int num4 = Math.Max(int5.y, Math.Max(int6.y, int7.y));
				list8.Clear();
				bool flag = false;
				for (int n = 0; n < list11.Count; n++)
				{
					Int2 int8 = list10[n];
					int x = int8.x;
					Int2 int9 = list10[n];
					int y = int9.y;
					if (IntRect.Intersects(a2, list9[n]) && y >= num3 && x <= num4 && (list13[n] || num == -1))
					{
						Int3 int10 = int5;
						int10.y = x;
						Int3 int11 = int5;
						int11.y = y;
						list8.Add(n);
						flag |= list12[n];
					}
				}
				if (list8.Count == 0 && (mode & CutMode.CutExtra) == 0 && (mode & CutMode.CutAll) != 0 && num == -1)
				{
					list5.Add(list4.Count);
					list5.Add(list4.Count + 1);
					list5.Add(list4.Count + 2);
					list4.Add(int5);
					list4.Add(int6);
					list4.Add(int7);
					continue;
				}
				list2.Clear();
				if (num == -1)
				{
					list2.Add(new IntPoint(int5.x, int5.z));
					list2.Add(new IntPoint(int6.x, int6.z));
					list2.Add(new IntPoint(int7.x, int7.z));
				}
				else
				{
					array[0] = int5;
					array[1] = int6;
					array[2] = int7;
					int num5 = Utility.ClipPolygon(array, 3, array2, 1, 0, 0);
					if (num5 == 0)
					{
						continue;
					}
					num5 = Utility.ClipPolygon(array2, num5, array, -1, 2 * int4.x, 0);
					if (num5 == 0)
					{
						continue;
					}
					num5 = Utility.ClipPolygon(array, num5, array2, 1, 0, 2);
					if (num5 == 0)
					{
						continue;
					}
					num5 = Utility.ClipPolygon(array2, num5, array, -1, 2 * int4.z, 2);
					if (num5 == 0)
					{
						continue;
					}
					for (int num6 = 0; num6 < num5; num6++)
					{
						list2.Add(new IntPoint(array[num6].x, array[num6].z));
					}
				}
				dictionary.Clear();
				Int3 int12 = int6 - int5;
				Int3 int13 = int7 - int5;
				Int3 int14 = int12;
				Int3 int15 = int13;
				int14.y = 0;
				int15.y = 0;
				for (int num7 = 0; num7 < 16; num7++)
				{
					if ((((int)mode >> num7) & 1) == 0)
					{
						continue;
					}
					if (1 << num7 == 1)
					{
						clipper.Clear();
						clipper.AddPolygon(list2, PolyType.ptSubject);
						for (int num8 = 0; num8 < list8.Count; num8++)
						{
							clipper.AddPolygon(list11[list8[num8]], PolyType.ptClip);
						}
						polyTree.Clear();
						clipper.Execute(ClipType.ctDifference, polyTree, PolyFillType.pftEvenOdd, PolyFillType.pftNonZero);
					}
					else if (1 << num7 == 2)
					{
						if (!flag)
						{
							continue;
						}
						clipper.Clear();
						clipper.AddPolygon(list2, PolyType.ptSubject);
						for (int num9 = 0; num9 < list8.Count; num9++)
						{
							if (list12[list8[num9]])
							{
								clipper.AddPolygon(list11[list8[num9]], PolyType.ptClip);
							}
						}
						list6.Clear();
						clipper.Execute(ClipType.ctIntersection, list6, PolyFillType.pftEvenOdd, PolyFillType.pftNonZero);
						clipper.Clear();
						for (int num10 = 0; num10 < list6.Count; num10++)
						{
							clipper.AddPolygon(list6[num10], Clipper.Orientation(list6[num10]) ? PolyType.ptClip : PolyType.ptSubject);
						}
						for (int num11 = 0; num11 < list8.Count; num11++)
						{
							if (!list12[list8[num11]])
							{
								clipper.AddPolygon(list11[list8[num11]], PolyType.ptClip);
							}
						}
						polyTree.Clear();
						clipper.Execute(ClipType.ctDifference, polyTree, PolyFillType.pftEvenOdd, PolyFillType.pftNonZero);
					}
					else if (1 << num7 == 4)
					{
						clipper.Clear();
						clipper.AddPolygon(list2, PolyType.ptSubject);
						clipper.AddPolygon(list, PolyType.ptClip);
						polyTree.Clear();
						clipper.Execute(ClipType.ctIntersection, polyTree, PolyFillType.pftEvenOdd, PolyFillType.pftNonZero);
					}
					for (int num12 = 0; num12 < polyTree.ChildCount; num12++)
					{
						PolyNode polyNode = polyTree.Childs[num12];
						List<IntPoint> contour = polyNode.Contour;
						List<PolyNode> childs = polyNode.Childs;
						if (childs.Count == 0 && contour.Count == 3 && num == -1)
						{
							for (int num13 = 0; num13 < contour.Count; num13++)
							{
								IntPoint intPoint5 = contour[num13];
								int x2 = (int)intPoint5.X;
								IntPoint intPoint6 = contour[num13];
								item2 = new Int3(x2, 0, (int)intPoint6.Y);
								double num14 = (double)(int6.z - int7.z) * (double)(int5.x - int7.x) + (double)(int7.x - int6.x) * (double)(int5.z - int7.z);
								if (num14 == 0.0)
								{
									UnityEngine.Debug.LogWarning("Degenerate triangle");
									continue;
								}
								double num15 = ((double)(int6.z - int7.z) * (double)(item2.x - int7.x) + (double)(int7.x - int6.x) * (double)(item2.z - int7.z)) / num14;
								double num16 = ((double)(int7.z - int5.z) * (double)(item2.x - int7.x) + (double)(int5.x - int7.x) * (double)(item2.z - int7.z)) / num14;
								item2.y = (int)Math.Round(num15 * (double)int5.y + num16 * (double)int6.y + (1.0 - num15 - num16) * (double)int7.y);
								list5.Add(list4.Count);
								list4.Add(item2);
							}
							continue;
						}
						Pathfinding.Poly2Tri.Polygon polygon = null;
						int num17 = -1;
						for (List<IntPoint> list15 = contour; list15 != null; list15 = ((num17 >= childs.Count) ? null : childs[num17].Contour))
						{
							list3.Clear();
							for (int num18 = 0; num18 < list15.Count; num18++)
							{
								IntPoint intPoint7 = list15[num18];
								double x3 = intPoint7.X;
								IntPoint intPoint8 = list15[num18];
								PolygonPoint polygonPoint = new PolygonPoint(x3, intPoint8.Y);
								list3.Add(polygonPoint);
								IntPoint intPoint9 = list15[num18];
								int x4 = (int)intPoint9.X;
								IntPoint intPoint10 = list15[num18];
								item3 = new Int3(x4, 0, (int)intPoint10.Y);
								double num19 = (double)(int6.z - int7.z) * (double)(int5.x - int7.x) + (double)(int7.x - int6.x) * (double)(int5.z - int7.z);
								if (num19 == 0.0)
								{
									UnityEngine.Debug.LogWarning("Degenerate triangle");
									continue;
								}
								double num20 = ((double)(int6.z - int7.z) * (double)(item3.x - int7.x) + (double)(int7.x - int6.x) * (double)(item3.z - int7.z)) / num19;
								double num21 = ((double)(int7.z - int5.z) * (double)(item3.x - int7.x) + (double)(int5.x - int7.x) * (double)(item3.z - int7.z)) / num19;
								item3.y = (int)Math.Round(num20 * (double)int5.y + num21 * (double)int6.y + (1.0 - num20 - num21) * (double)int7.y);
								dictionary[polygonPoint] = list4.Count;
								list4.Add(item3);
							}
							Pathfinding.Poly2Tri.Polygon polygon2 = null;
							if (stack.Count > 0)
							{
								polygon2 = stack.Pop();
								polygon2.AddPoints(list3);
							}
							else
							{
								polygon2 = new Pathfinding.Poly2Tri.Polygon(list3);
							}
							if (polygon == null)
							{
								polygon = polygon2;
							}
							else
							{
								polygon.AddHole(polygon2);
							}
							num17++;
						}
						try
						{
							P2T.Triangulate(polygon);
						}
						catch (PointOnEdgeException)
						{
							UnityEngine.Debug.LogWarning("PointOnEdgeException, perturbating vertices slightly ( at " + num7 + " in " + mode + ")");
							CutPoly(verts, tris, ref outVertsArr, ref outTrisArr, out outVCount, out outTCount, extraShape, cuttingOffset, realBounds, mode, perturbate + 1);
							return;
						}
						for (int num22 = 0; num22 < polygon.Triangles.Count; num22++)
						{
							DelaunayTriangle delaunayTriangle = polygon.Triangles[num22];
							list5.Add(dictionary[delaunayTriangle.Points._0]);
							list5.Add(dictionary[delaunayTriangle.Points._1]);
							list5.Add(dictionary[delaunayTriangle.Points._2]);
						}
						if (polygon.Holes != null)
						{
							for (int num23 = 0; num23 < polygon.Holes.Count; num23++)
							{
								polygon.Holes[num23].Points.Clear();
								polygon.Holes[num23].ClearTriangles();
								if (polygon.Holes[num23].Holes != null)
								{
									polygon.Holes[num23].Holes.Clear();
								}
								stack.Push(polygon.Holes[num23]);
							}
						}
						polygon.ClearTriangles();
						if (polygon.Holes != null)
						{
							polygon.Holes.Clear();
						}
						polygon.Points.Clear();
						stack.Push(polygon);
					}
				}
			}
			Dictionary<Int3, int> dictionary2 = cached_Int3_int_dict;
			dictionary2.Clear();
			if (cached_int_array.Length < list4.Count)
			{
				cached_int_array = new int[Math.Max(cached_int_array.Length * 2, list4.Count)];
			}
			int[] array3 = cached_int_array;
			int num24 = 0;
			for (int num25 = 0; num25 < list4.Count; num25++)
			{
				if (!dictionary2.TryGetValue(list4[num25], out int value2))
				{
					dictionary2.Add(list4[num25], num24);
					array3[num25] = num24;
					list4[num24] = list4[num25];
					num24++;
				}
				else
				{
					array3[num25] = value2;
				}
			}
			outTCount = list5.Count;
			if (outTrisArr == null || outTrisArr.Length < outTCount)
			{
				outTrisArr = new int[outTCount];
			}
			for (int num26 = 0; num26 < outTCount; num26++)
			{
				outTrisArr[num26] = array3[list5[num26]];
			}
			outVCount = num24;
			if (outVertsArr == null || outVertsArr.Length < outVCount)
			{
				outVertsArr = new Int3[outVCount];
			}
			for (int num27 = 0; num27 < outVCount; num27++)
			{
				outVertsArr[num27] = list4[num27];
			}
			for (int num28 = 0; num28 < list7.Count; num28++)
			{
				list7[num28].UsedForCut();
			}
			ListPool<Int3>.Release(list4);
			ListPool<int>.Release(list5);
			ListPool<int>.Release(list8);
			ListPool<Int2>.Release(list10);
			ListPool<bool>.Release(list12);
			ListPool<bool>.Release(list13);
			ListPool<IntRect>.Release(list9);
			ListPool<NavmeshCut>.Release(list7);
		}

		private void DelaunayRefinement(Int3[] verts, int[] tris, ref int vCount, ref int tCount, bool delaunay, bool colinear, Int3 worldOffset)
		{
			if (tCount % 3 != 0)
			{
				throw new Exception("Triangle array length must be a multiple of 3");
			}
			Dictionary<Int2, int> dictionary = cached_Int2_int_dict;
			dictionary.Clear();
			for (int i = 0; i < tCount; i += 3)
			{
				if (!Polygon.IsClockwise(verts[tris[i]], verts[tris[i + 1]], verts[tris[i + 2]]))
				{
					int num = tris[i];
					tris[i] = tris[i + 2];
					tris[i + 2] = num;
				}
				dictionary[new Int2(tris[i], tris[i + 1])] = i + 2;
				dictionary[new Int2(tris[i + 1], tris[i + 2])] = i;
				dictionary[new Int2(tris[i + 2], tris[i])] = i + 1;
			}
			int num2 = 9;
			for (int j = 0; j < tCount; j += 3)
			{
				for (int k = 0; k < 3; k++)
				{
					if (!dictionary.TryGetValue(new Int2(tris[j + (k + 1) % 3], tris[j + k % 3]), out int value))
					{
						continue;
					}
					Int3 @int = verts[tris[j + (k + 2) % 3]];
					Int3 int2 = verts[tris[j + (k + 1) % 3]];
					Int3 int3 = verts[tris[j + (k + 3) % 3]];
					Int3 int4 = verts[tris[value]];
					@int.y = 0;
					int2.y = 0;
					int3.y = 0;
					int4.y = 0;
					bool flag = false;
					if (!Polygon.Left(@int, int3, int4) || Polygon.LeftNotColinear(@int, int2, int4))
					{
						if (!colinear)
						{
							continue;
						}
						flag = true;
					}
					if (colinear && AstarMath.DistancePointSegment(@int, int4, int2) < (float)num2 && !dictionary.ContainsKey(new Int2(tris[j + (k + 2) % 3], tris[j + (k + 1) % 3])) && !dictionary.ContainsKey(new Int2(tris[j + (k + 1) % 3], tris[value])))
					{
						tCount -= 3;
						int num3 = value / 3 * 3;
						tris[j + (k + 1) % 3] = tris[value];
						if (num3 != tCount)
						{
							tris[num3] = tris[tCount];
							tris[num3 + 1] = tris[tCount + 1];
							tris[num3 + 2] = tris[tCount + 2];
							dictionary[new Int2(tris[num3], tris[num3 + 1])] = num3 + 2;
							dictionary[new Int2(tris[num3 + 1], tris[num3 + 2])] = num3;
							dictionary[new Int2(tris[num3 + 2], tris[num3])] = num3 + 1;
							tris[tCount] = 0;
							tris[tCount + 1] = 0;
							tris[tCount + 2] = 0;
						}
						else
						{
							tCount += 3;
						}
						dictionary[new Int2(tris[j], tris[j + 1])] = j + 2;
						dictionary[new Int2(tris[j + 1], tris[j + 2])] = j;
						dictionary[new Int2(tris[j + 2], tris[j])] = j + 1;
					}
					else if (delaunay && !flag)
					{
						float num4 = Int3.Angle(int2 - @int, int3 - @int);
						float num5 = Int3.Angle(int2 - int4, int3 - int4);
						if (num5 > (float)Math.PI * 2f - 2f * num4)
						{
							tris[j + (k + 1) % 3] = tris[value];
							int num6 = value / 3 * 3;
							int num7 = value - num6;
							tris[num6 + (num7 - 1 + 3) % 3] = tris[j + (k + 2) % 3];
							dictionary[new Int2(tris[j], tris[j + 1])] = j + 2;
							dictionary[new Int2(tris[j + 1], tris[j + 2])] = j;
							dictionary[new Int2(tris[j + 2], tris[j])] = j + 1;
							dictionary[new Int2(tris[num6], tris[num6 + 1])] = num6 + 2;
							dictionary[new Int2(tris[num6 + 1], tris[num6 + 2])] = num6;
							dictionary[new Int2(tris[num6 + 2], tris[num6])] = num6 + 1;
						}
					}
				}
			}
		}

		private Vector3 Point2D2V3(TriangulationPoint p)
		{
			return new Vector3((float)p.X, 0f, (float)p.Y) * 0.001f;
		}

		private Int3 IntPoint2Int3(IntPoint p)
		{
			return new Int3((int)p.X, 0, (int)p.Y);
		}

		public void ClearTile(int x, int z)
		{
			if (!(AstarPath.active == null) && x >= 0 && z >= 0 && x < graph.tileXCount && z < graph.tileZCount)
			{
				AstarPath.active.AddWorkItem(new AstarPath.AstarWorkItem(delegate
				{
					graph.ReplaceTile(x, z, new Int3[0], new int[0], worldSpace: false);
					activeTileTypes[x + z * graph.tileXCount] = null;
					GraphModifier.TriggerEvent(GraphModifier.EventType.PostUpdate);
					AstarPath.active.QueueWorkItemFloodFill();
					return true;
				}));
			}
		}

		public void ReloadInBounds(Bounds b)
		{
			Int2 tileCoordinates = graph.GetTileCoordinates(b.min);
			Int2 tileCoordinates2 = graph.GetTileCoordinates(b.max);
			IntRect a = new IntRect(tileCoordinates.x, tileCoordinates.y, tileCoordinates2.x, tileCoordinates2.y);
			a = IntRect.Intersection(a, new IntRect(0, 0, graph.tileXCount - 1, graph.tileZCount - 1));
			if (!a.IsValid())
			{
				return;
			}
			for (int i = a.ymin; i <= a.ymax; i++)
			{
				for (int j = a.xmin; j <= a.xmax; j++)
				{
					ReloadTile(j, i);
				}
			}
		}

		public void ReloadTile(int x, int z)
		{
			if (x >= 0 && z >= 0 && x < graph.tileXCount && z < graph.tileZCount)
			{
				int num = x + z * graph.tileXCount;
				if (activeTileTypes[num] != null)
				{
					LoadTile(activeTileTypes[num], x, z, activeTileRotations[num], activeTileOffsets[num]);
				}
			}
		}

		public void CutShapeWithTile(int x, int z, Int3[] shape, ref Int3[] verts, ref int[] tris, out int vCount, out int tCount)
		{
			if (isBatching)
			{
				throw new Exception("Cannot cut with shape when batching. Please stop batching first.");
			}
			int num = x + z * graph.tileXCount;
			if (x < 0 || z < 0 || x >= graph.tileXCount || z >= graph.tileZCount || activeTileTypes[num] == null)
			{
				verts = new Int3[0];
				tris = new int[0];
				vCount = 0;
				tCount = 0;
				return;
			}
			activeTileTypes[num].Load(out Int3[] verts2, out int[] tris2, activeTileRotations[num], activeTileOffsets[num]);
			Bounds tileBounds = graph.GetTileBounds(x, z);
			Int3 lhs = (Int3)tileBounds.min;
			lhs = -lhs;
			CutPoly(verts2, tris2, ref verts, ref tris, out vCount, out tCount, shape, lhs, tileBounds, CutMode.CutExtra);
			for (int i = 0; i < verts.Length; i++)
			{
				verts[i] -= lhs;
			}
		}

		protected static T[] ShrinkArray<T>(T[] arr, int newLength)
		{
			newLength = Math.Min(newLength, arr.Length);
			T[] array = new T[newLength];
			if (newLength % 4 == 0)
			{
				for (int i = 0; i < newLength; i += 4)
				{
					array[i] = arr[i];
					array[i + 1] = arr[i + 1];
					array[i + 2] = arr[i + 2];
					array[i + 3] = arr[i + 3];
				}
			}
			else if (newLength % 3 == 0)
			{
				for (int j = 0; j < newLength; j += 3)
				{
					array[j] = arr[j];
					array[j + 1] = arr[j + 1];
					array[j + 2] = arr[j + 2];
				}
			}
			else if (newLength % 2 == 0)
			{
				for (int k = 0; k < newLength; k += 2)
				{
					array[k] = arr[k];
					array[k + 1] = arr[k + 1];
				}
			}
			else
			{
				for (int l = 0; l < newLength; l++)
				{
					array[l] = arr[l];
				}
			}
			return array;
		}

		public void LoadTile(TileType tile, int x, int z, int rotation, int yoffset)
		{
			if (tile == null)
			{
				throw new ArgumentNullException("tile");
			}
			if (AstarPath.active == null)
			{
				return;
			}
			int index = x + z * graph.tileXCount;
			rotation %= 4;
			if (!isBatching || !reloadedInBatch[index] || activeTileOffsets[index] != yoffset || activeTileRotations[index] != rotation || activeTileTypes[index] != tile)
			{
				if (isBatching)
				{
					reloadedInBatch[index] = true;
				}
				activeTileOffsets[index] = yoffset;
				activeTileRotations[index] = rotation;
				activeTileTypes[index] = tile;
				AstarPath.active.AddWorkItem(new AstarPath.AstarWorkItem(delegate
				{
					if (activeTileOffsets[index] != yoffset || activeTileRotations[index] != rotation || activeTileTypes[index] != tile)
					{
						return true;
					}
					GraphModifier.TriggerEvent(GraphModifier.EventType.PreUpdate);
					tile.Load(out Int3[] verts, out int[] tris, rotation, yoffset);
					Bounds tileBounds = graph.GetTileBounds(x, z, tile.Width, tile.Depth);
					Int3 lhs = (Int3)tileBounds.min;
					lhs = -lhs;
					Int3[] outVertsArr = null;
					int[] outTrisArr = null;
					CutPoly(verts, tris, ref outVertsArr, ref outTrisArr, out int outVCount, out int outTCount, null, lhs, tileBounds);
					DelaunayRefinement(outVertsArr, outTrisArr, ref outVCount, ref outTCount, delaunay: true, colinear: false, -lhs);
					if (outTCount != outTrisArr.Length)
					{
						outTrisArr = ShrinkArray(outTrisArr, outTCount);
					}
					if (outVCount != outVertsArr.Length)
					{
						outVertsArr = ShrinkArray(outVertsArr, outVCount);
					}
					int w = (rotation % 2 != 0) ? tile.Depth : tile.Width;
					int d = (rotation % 2 != 0) ? tile.Width : tile.Depth;
					graph.ReplaceTile(x, z, w, d, outVertsArr, outTrisArr, worldSpace: false);
					GraphModifier.TriggerEvent(GraphModifier.EventType.PostUpdate);
					AstarPath.active.QueueWorkItemFloodFill();
					return true;
				}));
			}
		}
	}
}
namespace Pathfinding
{
	public class DebugUtility : MonoBehaviour
	{
		public Material defaultMaterial;

		public static DebugUtility active;

		public float offset = 0.2f;

		public bool optimizeMeshes;

		public void Awake()
		{
			active = this;
		}

		public static void DrawCubes(Vector3[] topVerts, Vector3[] bottomVerts, Color[] vertexColors, float width)
		{
			if (active == null)
			{
				active = (UnityEngine.Object.FindObjectOfType(typeof(DebugUtility)) as DebugUtility);
			}
			if (active == null)
			{
				throw new NullReferenceException();
			}
			if (topVerts.Length != bottomVerts.Length || topVerts.Length != vertexColors.Length)
			{
				UnityEngine.Debug.LogError("Array Lengths are not the same");
				return;
			}
			if (topVerts.Length > 2708)
			{
				Vector3[] array = new Vector3[topVerts.Length - 2708];
				Vector3[] array2 = new Vector3[topVerts.Length - 2708];
				Color[] array3 = new Color[topVerts.Length - 2708];
				for (int i = 2708; i < topVerts.Length; i++)
				{
					array[i - 2708] = topVerts[i];
					array2[i - 2708] = bottomVerts[i];
					array3[i - 2708] = vertexColors[i];
				}
				Vector3[] array4 = new Vector3[2708];
				Vector3[] array5 = new Vector3[2708];
				Color[] array6 = new Color[2708];
				for (int j = 0; j < 2708; j++)
				{
					array4[j] = topVerts[j];
					array5[j] = bottomVerts[j];
					array6[j] = vertexColors[j];
				}
				DrawCubes(array, array2, array3, width);
				topVerts = array4;
				bottomVerts = array5;
				vertexColors = array6;
			}
			width /= 2f;
			Vector3[] array7 = new Vector3[topVerts.Length * 4 * 6];
			int[] array8 = new int[topVerts.Length * 6 * 6];
			Color[] array9 = new Color[topVerts.Length * 4 * 6];
			for (int k = 0; k < topVerts.Length; k++)
			{
				Vector3 a = topVerts[k] + new Vector3(0f, active.offset, 0f);
				Vector3 a2 = bottomVerts[k] - new Vector3(0f, active.offset, 0f);
				Vector3 vector = a + new Vector3(0f - width, 0f, 0f - width);
				Vector3 vector2 = a + new Vector3(width, 0f, 0f - width);
				Vector3 vector3 = a + new Vector3(width, 0f, width);
				Vector3 vector4 = a + new Vector3(0f - width, 0f, width);
				Vector3 vector5 = a2 + new Vector3(0f - width, 0f, 0f - width);
				Vector3 vector6 = a2 + new Vector3(width, 0f, 0f - width);
				Vector3 vector7 = a2 + new Vector3(width, 0f, width);
				Vector3 vector8 = a2 + new Vector3(0f - width, 0f, width);
				int num = k * 4 * 6;
				Color color = vertexColors[k];
				for (int l = num; l < num + 24; l++)
				{
					array9[l] = color;
				}
				array7[num] = vector;
				array7[num + 1] = vector4;
				array7[num + 2] = vector3;
				array7[num + 3] = vector2;
				int num2 = k * 6 * 6;
				array8[num2] = num;
				array8[num2 + 1] = num + 1;
				array8[num2 + 2] = num + 2;
				array8[num2 + 3] = num;
				array8[num2 + 4] = num + 2;
				array8[num2 + 5] = num + 3;
				num += 4;
				array7[num + 3] = vector5;
				array7[num + 2] = vector8;
				array7[num + 1] = vector7;
				array7[num] = vector6;
				num2 += 6;
				array8[num2] = num;
				array8[num2 + 1] = num + 1;
				array8[num2 + 2] = num + 2;
				array8[num2 + 3] = num;
				array8[num2 + 4] = num + 2;
				array8[num2 + 5] = num + 3;
				num += 4;
				array7[num] = vector6;
				array7[num + 1] = vector2;
				array7[num + 2] = vector3;
				array7[num + 3] = vector7;
				num2 += 6;
				array8[num2] = num;
				array8[num2 + 1] = num + 1;
				array8[num2 + 2] = num + 2;
				array8[num2 + 3] = num;
				array8[num2 + 4] = num + 2;
				array8[num2 + 5] = num + 3;
				num += 4;
				array7[num + 3] = vector5;
				array7[num + 2] = vector;
				array7[num + 1] = vector4;
				array7[num] = vector8;
				num2 += 6;
				array8[num2] = num;
				array8[num2 + 1] = num + 1;
				array8[num2 + 2] = num + 2;
				array8[num2 + 3] = num;
				array8[num2 + 4] = num + 2;
				array8[num2 + 5] = num + 3;
				num += 4;
				array7[num + 3] = vector7;
				array7[num + 2] = vector8;
				array7[num + 1] = vector4;
				array7[num] = vector3;
				num2 += 6;
				array8[num2] = num;
				array8[num2 + 1] = num + 1;
				array8[num2 + 2] = num + 2;
				array8[num2 + 3] = num;
				array8[num2 + 4] = num + 2;
				array8[num2 + 5] = num + 3;
				num += 4;
				array7[num] = vector6;
				array7[num + 1] = vector5;
				array7[num + 2] = vector;
				array7[num + 3] = vector2;
				num2 += 6;
				array8[num2] = num;
				array8[num2 + 1] = num + 1;
				array8[num2 + 2] = num + 2;
				array8[num2 + 3] = num;
				array8[num2 + 4] = num + 2;
				array8[num2 + 5] = num + 3;
			}
			Mesh mesh = new Mesh();
			mesh.vertices = array7;
			mesh.triangles = array8;
			mesh.colors = array9;
			mesh.name = "VoxelMesh";
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			if (active.optimizeMeshes)
			{
				mesh.Optimize();
			}
			GameObject gameObject = new GameObject("DebugMesh");
			MeshRenderer meshRenderer = gameObject.AddComponent(typeof(MeshRenderer)) as MeshRenderer;
			meshRenderer.material = active.defaultMaterial;
			(gameObject.AddComponent(typeof(MeshFilter)) as MeshFilter).mesh = mesh;
		}

		public static void DrawQuads(Vector3[] verts, float width)
		{
			if (verts.Length >= 16250)
			{
				Vector3[] array = new Vector3[verts.Length - 16250];
				for (int i = 16250; i < verts.Length; i++)
				{
					array[i - 16250] = verts[i];
				}
				Vector3[] array2 = new Vector3[16250];
				for (int j = 0; j < 16250; j++)
				{
					array2[j] = verts[j];
				}
				DrawQuads(array, width);
				verts = array2;
			}
			width /= 2f;
			Vector3[] array3 = new Vector3[verts.Length * 4];
			int[] array4 = new int[verts.Length * 6];
			for (int k = 0; k < verts.Length; k++)
			{
				Vector3 a = verts[k];
				int num = k * 4;
				array3[num] = a + new Vector3(0f - width, 0f, 0f - width);
				array3[num + 1] = a + new Vector3(0f - width, 0f, width);
				array3[num + 2] = a + new Vector3(width, 0f, width);
				array3[num + 3] = a + new Vector3(width, 0f, 0f - width);
				int num2 = k * 6;
				array4[num2] = num;
				array4[num2 + 1] = num + 1;
				array4[num2 + 2] = num + 2;
				array4[num2 + 3] = num;
				array4[num2 + 4] = num + 2;
				array4[num2 + 5] = num + 3;
			}
			Mesh mesh = new Mesh();
			mesh.vertices = array3;
			mesh.triangles = array4;
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			GameObject gameObject = new GameObject("DebugMesh");
			MeshRenderer meshRenderer = gameObject.AddComponent(typeof(MeshRenderer)) as MeshRenderer;
			meshRenderer.material = active.defaultMaterial;
			(gameObject.AddComponent(typeof(MeshFilter)) as MeshFilter).mesh = mesh;
		}

		public static void TestMeshLimit()
		{
			Vector3[] array = new Vector3[64000];
			int[] array2 = new int[96000];
			for (int i = 0; i < 16000; i++)
			{
				Vector3 a = UnityEngine.Random.onUnitSphere * 10f;
				int num = i * 4;
				array[num] = a + new Vector3(-0.1f, 0f, -0.1f);
				array[num + 1] = a + new Vector3(-0.1f, 0f, 0.1f);
				array[num + 2] = a + new Vector3(0.1f, 0f, 0.1f);
				array[num + 3] = a + new Vector3(0.1f, 0f, -0.1f);
				int num2 = i * 6;
				array2[num2] = num;
				array2[num2 + 1] = num + 1;
				array2[num2 + 2] = num + 2;
				array2[num2 + 3] = num;
				array2[num2 + 4] = num + 2;
				array2[num2 + 5] = num + 3;
			}
			Mesh mesh = new Mesh();
			mesh.vertices = array;
			mesh.triangles = array2;
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			GameObject gameObject = new GameObject("DebugMesh");
			gameObject.AddComponent(typeof(MeshRenderer));
			(gameObject.AddComponent(typeof(MeshFilter)) as MeshFilter).mesh = mesh;
		}
	}
}
namespace Pathfinding.Voxels
{
	public class VoxelArea
	{
		public const uint MaxHeight = 65536u;

		public const int MaxHeightInt = 65536;

		public const uint InvalidSpanValue = uint.MaxValue;

		public const float AvgSpanLayerCountEstimate = 8f;

		public readonly int width;

		public readonly int depth;

		public CompactVoxelSpan[] compactSpans;

		public CompactVoxelCell[] compactCells;

		public int compactSpanCount;

		public ushort[] tmpUShortArr;

		public int[] areaTypes;

		public ushort[] dist;

		public ushort maxDistance;

		public int maxRegions;

		public int[] DirectionX;

		public int[] DirectionZ;

		public Vector3[] VectorDirection;

		private int linkedSpanCount;

		public LinkedVoxelSpan[] linkedSpans;

		private int[] removedStack = new int[128];

		private int removedStackCount;

		public VoxelArea(int width, int depth)
		{
			this.width = width;
			this.depth = depth;
			int num = width * depth;
			compactCells = new CompactVoxelCell[num];
			linkedSpans = new LinkedVoxelSpan[((int)((float)num * 8f) + 15) & -16];
			ResetLinkedVoxelSpans();
			DirectionX = new int[4]
			{
				-1,
				0,
				1,
				0
			};
			DirectionZ = new int[4]
			{
				0,
				width,
				0,
				-width
			};
			VectorDirection = new Vector3[4]
			{
				Vector3.left,
				Vector3.forward,
				Vector3.right,
				Vector3.back
			};
		}

		public void Reset()
		{
			ResetLinkedVoxelSpans();
			for (int i = 0; i < compactCells.Length; i++)
			{
				compactCells[i].count = 0u;
				compactCells[i].index = 0u;
			}
		}

		private void ResetLinkedVoxelSpans()
		{
			int num = linkedSpans.Length;
			linkedSpanCount = width * depth;
			LinkedVoxelSpan linkedVoxelSpan = new LinkedVoxelSpan(uint.MaxValue, uint.MaxValue, -1, -1);
			int num2;
			for (num2 = 0; num2 < num; num2++)
			{
				linkedSpans[num2] = linkedVoxelSpan;
				num2++;
				linkedSpans[num2] = linkedVoxelSpan;
				num2++;
				linkedSpans[num2] = linkedVoxelSpan;
				num2++;
				linkedSpans[num2] = linkedVoxelSpan;
				num2++;
				linkedSpans[num2] = linkedVoxelSpan;
				num2++;
				linkedSpans[num2] = linkedVoxelSpan;
				num2++;
				linkedSpans[num2] = linkedVoxelSpan;
				num2++;
				linkedSpans[num2] = linkedVoxelSpan;
				num2++;
				linkedSpans[num2] = linkedVoxelSpan;
				num2++;
				linkedSpans[num2] = linkedVoxelSpan;
				num2++;
				linkedSpans[num2] = linkedVoxelSpan;
				num2++;
				linkedSpans[num2] = linkedVoxelSpan;
				num2++;
				linkedSpans[num2] = linkedVoxelSpan;
				num2++;
				linkedSpans[num2] = linkedVoxelSpan;
				num2++;
				linkedSpans[num2] = linkedVoxelSpan;
				num2++;
				linkedSpans[num2] = linkedVoxelSpan;
			}
			removedStackCount = 0;
		}

		public int GetSpanCountAll()
		{
			int num = 0;
			int num2 = width * depth;
			for (int i = 0; i < num2; i++)
			{
				int num3 = i;
				while (num3 != -1 && linkedSpans[num3].bottom != uint.MaxValue)
				{
					num++;
					num3 = linkedSpans[num3].next;
				}
			}
			return num;
		}

		public int GetSpanCount()
		{
			int num = 0;
			int num2 = width * depth;
			for (int i = 0; i < num2; i++)
			{
				int num3 = i;
				while (num3 != -1 && linkedSpans[num3].bottom != uint.MaxValue)
				{
					if (linkedSpans[num3].area != 0)
					{
						num++;
					}
					num3 = linkedSpans[num3].next;
				}
			}
			return num;
		}

		public void AddLinkedSpan(int index, uint bottom, uint top, int area, int voxelWalkableClimb)
		{
			if (linkedSpans[index].bottom == uint.MaxValue)
			{
				linkedSpans[index] = new LinkedVoxelSpan(bottom, top, area);
				return;
			}
			int num = -1;
			int num2 = index;
			while (index != -1 && linkedSpans[index].bottom <= top)
			{
				if (linkedSpans[index].top < bottom)
				{
					num = index;
					index = linkedSpans[index].next;
					continue;
				}
				if (linkedSpans[index].bottom < bottom)
				{
					bottom = linkedSpans[index].bottom;
				}
				if (linkedSpans[index].top > top)
				{
					top = linkedSpans[index].top;
				}
				if (AstarMath.Abs((int)(top - linkedSpans[index].top)) <= voxelWalkableClimb)
				{
					area = AstarMath.Max(area, linkedSpans[index].area);
				}
				int next = linkedSpans[index].next;
				if (num != -1)
				{
					linkedSpans[num].next = next;
					if (removedStackCount == removedStack.Length)
					{
						int[] dst = new int[removedStackCount * 4];
						Buffer.BlockCopy(removedStack, 0, dst, 0, removedStackCount * 4);
						removedStack = dst;
					}
					removedStack[removedStackCount] = index;
					removedStackCount++;
					index = next;
					continue;
				}
				if (next != -1)
				{
					linkedSpans[num2] = linkedSpans[next];
					if (removedStackCount == removedStack.Length)
					{
						int[] dst2 = new int[removedStackCount * 4];
						Buffer.BlockCopy(removedStack, 0, dst2, 0, removedStackCount * 4);
						removedStack = dst2;
					}
					removedStack[removedStackCount] = next;
					removedStackCount++;
					index = linkedSpans[num2].next;
					continue;
				}
				linkedSpans[num2] = new LinkedVoxelSpan(bottom, top, area);
				return;
			}
			if (linkedSpanCount >= linkedSpans.Length)
			{
				LinkedVoxelSpan[] array = linkedSpans;
				int num3 = linkedSpanCount;
				int num4 = removedStackCount;
				linkedSpans = new LinkedVoxelSpan[linkedSpans.Length * 2];
				ResetLinkedVoxelSpans();
				linkedSpanCount = num3;
				removedStackCount = num4;
				for (int i = 0; i < linkedSpanCount; i++)
				{
					linkedSpans[i] = array[i];
				}
				UnityEngine.Debug.Log("Layer estimate too low, doubling size of buffer.\nThis message is harmless.");
			}
			int num5;
			if (removedStackCount > 0)
			{
				removedStackCount--;
				num5 = removedStack[removedStackCount];
			}
			else
			{
				num5 = linkedSpanCount;
				linkedSpanCount++;
			}
			if (num != -1)
			{
				linkedSpans[num5] = new LinkedVoxelSpan(bottom, top, area, linkedSpans[num].next);
				linkedSpans[num].next = num5;
			}
			else
			{
				linkedSpans[num5] = linkedSpans[num2];
				linkedSpans[num2] = new LinkedVoxelSpan(bottom, top, area, num5);
			}
		}
	}
	public struct LinkedVoxelSpan
	{
		public uint bottom;

		public uint top;

		public int next;

		public int area;

		public LinkedVoxelSpan(uint bottom, uint top, int area)
		{
			this.bottom = bottom;
			this.top = top;
			this.area = area;
			next = -1;
		}

		public LinkedVoxelSpan(uint bottom, uint top, int area, int next)
		{
			this.bottom = bottom;
			this.top = top;
			this.area = area;
			this.next = next;
		}
	}
	public struct ExtraMesh
	{
		public MeshFilter original;

		public int area;

		public Vector3[] vertices;

		public int[] triangles;

		public Bounds bounds;

		public Matrix4x4 matrix;

		public ExtraMesh(Vector3[] v, int[] t, Bounds b)
		{
			matrix = Matrix4x4.identity;
			vertices = v;
			triangles = t;
			bounds = b;
			original = null;
			area = 0;
		}

		public ExtraMesh(Vector3[] v, int[] t, Bounds b, Matrix4x4 matrix)
		{
			this.matrix = matrix;
			vertices = v;
			triangles = t;
			bounds = b;
			original = null;
			area = 0;
		}

		public void RecalculateBounds()
		{
			Bounds bounds = new Bounds(matrix.MultiplyPoint3x4(vertices[0]), Vector3.zero);
			for (int i = 1; i < vertices.Length; i++)
			{
				bounds.Encapsulate(matrix.MultiplyPoint3x4(vertices[i]));
			}
			this.bounds = bounds;
		}
	}
	public class VoxelContourSet
	{
		public List<VoxelContour> conts;

		public Bounds bounds;
	}
	public struct VoxelContour
	{
		public int nverts;

		public int[] verts;

		public int[] rverts;

		public int reg;

		public int area;
	}
	public struct VoxelMesh
	{
		public Int3[] verts;

		public int[] tris;
	}
	public struct VoxelCell
	{
		public VoxelSpan firstSpan;

		public void AddSpan(uint bottom, uint top, int area, int voxelWalkableClimb)
		{
			VoxelSpan voxelSpan = new VoxelSpan(bottom, top, area);
			if (firstSpan == null)
			{
				firstSpan = voxelSpan;
				return;
			}
			VoxelSpan voxelSpan2 = null;
			VoxelSpan voxelSpan3 = firstSpan;
			while (voxelSpan3 != null && voxelSpan3.bottom <= voxelSpan.top)
			{
				if (voxelSpan3.top < voxelSpan.bottom)
				{
					voxelSpan2 = voxelSpan3;
					voxelSpan3 = voxelSpan3.next;
					continue;
				}
				if (voxelSpan3.bottom < bottom)
				{
					voxelSpan.bottom = voxelSpan3.bottom;
				}
				if (voxelSpan3.top > top)
				{
					voxelSpan.top = voxelSpan3.top;
				}
				if (AstarMath.Abs((int)(voxelSpan.top - voxelSpan3.top)) <= voxelWalkableClimb)
				{
					voxelSpan.area = AstarMath.Max(voxelSpan.area, voxelSpan3.area);
				}
				VoxelSpan next = voxelSpan3.next;
				if (voxelSpan2 != null)
				{
					voxelSpan2.next = next;
				}
				else
				{
					firstSpan = next;
				}
				voxelSpan3 = next;
			}
			if (voxelSpan2 != null)
			{
				voxelSpan.next = voxelSpan2.next;
				voxelSpan2.next = voxelSpan;
			}
			else
			{
				voxelSpan.next = firstSpan;
				firstSpan = voxelSpan;
			}
		}
	}
	public struct CompactVoxelCell
	{
		public uint index;

		public uint count;

		public CompactVoxelCell(uint i, uint c)
		{
			index = i;
			count = c;
		}
	}
	public struct CompactVoxelSpan
	{
		public ushort y;

		public uint con;

		public uint h;

		public int reg;

		public CompactVoxelSpan(ushort bottom, uint height)
		{
			con = 24u;
			y = bottom;
			h = height;
			reg = 0;
		}

		public void SetConnection(int dir, uint value)
		{
			int num = dir * 6;
			con = (uint)((con & ~(63 << num)) | ((value & 0x3F) << num));
		}

		public int GetConnection(int dir)
		{
			return ((int)con >> dir * 6) & 0x3F;
		}
	}
	public class VoxelSpan
	{
		public uint bottom;

		public uint top;

		public VoxelSpan next;

		public int area;

		public VoxelSpan(uint b, uint t, int area)
		{
			bottom = b;
			top = t;
			this.area = area;
		}
	}
	public class Voxelize
	{
		public const uint NotConnected = 63u;

		public const int MaxLayers = 65535;

		public const int MaxRegions = 500;

		public const int UnwalkableArea = 0;

		public const ushort BorderReg = 32768;

		public const int RC_BORDER_VERTEX = 65536;

		public const int RC_AREA_BORDER = 131072;

		public const int VERTEX_BUCKET_COUNT = 4096;

		public const int RC_CONTOUR_TESS_WALL_EDGES = 1;

		public const int RC_CONTOUR_TESS_AREA_EDGES = 2;

		public const int ContourRegMask = 65535;

		private static List<int[]> intArrCache = new List<int[]>();

		private static readonly int[] emptyArr = new int[0];

		public List<ExtraMesh> inputExtraMeshes;

		protected Vector3[] inputVertices;

		protected int[] inputTriangles;

		public readonly int voxelWalkableClimb;

		public readonly uint voxelWalkableHeight;

		public readonly float cellSize = 0.2f;

		public readonly float cellHeight = 0.1f;

		public int minRegionSize = 100;

		public int borderSize;

		public float maxEdgeLength = 20f;

		public float maxSlope = 30f;

		public RecastGraph.RelevantGraphSurfaceMode relevantGraphSurfaceMode;

		public Bounds forcedBounds;

		public VoxelArea voxelArea;

		public VoxelContourSet countourSet;

		public int width;

		public int depth;

		public Vector3 voxelOffset;

		public string debugString = string.Empty;

		public readonly Vector3 cellScale;

		public readonly Vector3 cellScaleDivision;

		public Voxelize(float ch, float cs, float wc, float wh, float ms)
		{
			cellSize = cs;
			cellHeight = ch;
			maxSlope = ms;
			cellScale = new Vector3(cellSize, cellHeight, cellSize);
			cellScaleDivision = new Vector3(1f / cellSize, 1f / cellHeight, 1f / cellSize);
			voxelWalkableHeight = (uint)(wh / cellHeight);
			voxelWalkableClimb = Mathf.RoundToInt(wc / cellHeight);
		}

		public void BuildContours(float maxError, int maxEdgeLength, VoxelContourSet cset, int buildFlags)
		{
			int num = voxelArea.width;
			int num2 = voxelArea.depth;
			int num3 = num * num2;
			int capacity = Mathf.Max(8, 8);
			List<VoxelContour> list = new List<VoxelContour>(capacity);
			ushort[] array = voxelArea.tmpUShortArr;
			if (array.Length < voxelArea.compactSpanCount)
			{
				array = (voxelArea.tmpUShortArr = new ushort[voxelArea.compactSpanCount]);
			}
			for (int i = 0; i < num3; i += voxelArea.width)
			{
				for (int j = 0; j < voxelArea.width; j++)
				{
					CompactVoxelCell compactVoxelCell = voxelArea.compactCells[j + i];
					int k = (int)compactVoxelCell.index;
					for (int num4 = (int)(compactVoxelCell.index + compactVoxelCell.count); k < num4; k++)
					{
						ushort num5 = 0;
						CompactVoxelSpan compactVoxelSpan = voxelArea.compactSpans[k];
						if (compactVoxelSpan.reg == 0 || (compactVoxelSpan.reg & 0x8000) == 32768)
						{
							array[k] = 0;
							continue;
						}
						for (int l = 0; l < 4; l++)
						{
							int num6 = 0;
							if ((long)compactVoxelSpan.GetConnection(l) != 63)
							{
								int num7 = j + voxelArea.DirectionX[l];
								int num8 = i + voxelArea.DirectionZ[l];
								int num9 = (int)voxelArea.compactCells[num7 + num8].index + compactVoxelSpan.GetConnection(l);
								num6 = voxelArea.compactSpans[num9].reg;
							}
							if (num6 == compactVoxelSpan.reg)
							{
								num5 = (ushort)(num5 | (ushort)(1 << l));
							}
						}
						array[k] = (ushort)(num5 ^ 0xF);
					}
				}
			}
			List<int> list2 = ListPool<int>.Claim(256);
			List<int> list3 = ListPool<int>.Claim(64);
			for (int m = 0; m < num3; m += voxelArea.width)
			{
				for (int n = 0; n < voxelArea.width; n++)
				{
					CompactVoxelCell compactVoxelCell2 = voxelArea.compactCells[n + m];
					int num10 = (int)compactVoxelCell2.index;
					for (int num11 = (int)(compactVoxelCell2.index + compactVoxelCell2.count); num10 < num11; num10++)
					{
						if (array[num10] == 0 || array[num10] == 15)
						{
							array[num10] = 0;
							continue;
						}
						int reg = voxelArea.compactSpans[num10].reg;
						if (reg != 0 && (reg & 0x8000) != 32768)
						{
							int area = voxelArea.areaTypes[num10];
							list2.Clear();
							list3.Clear();
							WalkContour(n, m, num10, array, list2);
							SimplifyContour(list2, list3, maxError, maxEdgeLength, buildFlags);
							RemoveDegenerateSegments(list3);
							VoxelContour item = default(VoxelContour);
							item.verts = ClaimIntArr(list3.Count, zero: false);
							for (int num12 = 0; num12 < list3.Count; num12++)
							{
								item.verts[num12] = list3[num12];
							}
							item.nverts = list3.Count / 4;
							item.reg = reg;
							item.area = area;
							list.Add(item);
						}
					}
				}
			}
			ListPool<int>.Release(list2);
			ListPool<int>.Release(list3);
			for (int num13 = 0; num13 < list.Count; num13++)
			{
				VoxelContour cb = list[num13];
				if (CalcAreaOfPolygon2D(cb.verts, cb.nverts) >= 0)
				{
					continue;
				}
				int num14 = -1;
				for (int num15 = 0; num15 < list.Count; num15++)
				{
					if (num13 == num15)
					{
						continue;
					}
					VoxelContour voxelContour = list[num15];
					if (voxelContour.nverts <= 0)
					{
						continue;
					}
					VoxelContour voxelContour2 = list[num15];
					if (voxelContour2.reg == cb.reg)
					{
						VoxelContour voxelContour3 = list[num15];
						int[] verts = voxelContour3.verts;
						VoxelContour voxelContour4 = list[num15];
						if (CalcAreaOfPolygon2D(verts, voxelContour4.nverts) > 0)
						{
							num14 = num15;
							break;
						}
					}
				}
				if (num14 == -1)
				{
					UnityEngine.Debug.LogError("rcBuildContours: Could not find merge target for bad contour " + num13 + ".");
					continue;
				}
				UnityEngine.Debug.LogWarning("Fixing contour");
				VoxelContour ca = list[num14];
				int ia = 0;
				int ib = 0;
				GetClosestIndices(ca.verts, ca.nverts, cb.verts, cb.nverts, ref ia, ref ib);
				if (ia == -1 || ib == -1)
				{
					UnityEngine.Debug.LogWarning("rcBuildContours: Failed to find merge points for " + num13 + " and " + num14 + ".");
					continue;
				}
				if (!MergeContours(ref ca, ref cb, ia, ib))
				{
					UnityEngine.Debug.LogWarning("rcBuildContours: Failed to merge contours " + num13 + " and " + num14 + ".");
					continue;
				}
				list[num14] = ca;
				list[num13] = cb;
			}
			cset.conts = list;
		}

		private void GetClosestIndices(int[] vertsa, int nvertsa, int[] vertsb, int nvertsb, ref int ia, ref int ib)
		{
			int num = 268435455;
			ia = -1;
			ib = -1;
			for (int i = 0; i < nvertsa; i++)
			{
				int num2 = (i + 1) % nvertsa;
				int num3 = (i + nvertsa - 1) % nvertsa;
				int num4 = i * 4;
				int b = num2 * 4;
				int a = num3 * 4;
				for (int j = 0; j < nvertsb; j++)
				{
					int num5 = j * 4;
					if (Ileft(a, num4, num5, vertsa, vertsa, vertsb) && Ileft(num4, b, num5, vertsa, vertsa, vertsb))
					{
						int num6 = vertsb[num5] - vertsa[num4];
						int num7 = vertsb[num5 + 2] / voxelArea.width - vertsa[num4 + 2] / voxelArea.width;
						int num8 = num6 * num6 + num7 * num7;
						if (num8 < num)
						{
							ia = i;
							ib = j;
							num = num8;
						}
					}
				}
			}
		}

		private static void ReleaseIntArr(int[] arr)
		{
			if (arr != null)
			{
				intArrCache.Add(arr);
			}
		}

		private static int[] ClaimIntArr(int minCapacity, bool zero)
		{
			for (int i = 0; i < intArrCache.Count; i++)
			{
				if (intArrCache[i].Length >= minCapacity)
				{
					int[] array = intArrCache[i];
					intArrCache.RemoveAt(i);
					if (zero)
					{
						Pathfinding.Util.Memory.MemSet(array, 0, 4);
					}
					return array;
				}
			}
			return new int[minCapacity];
		}

		private static void ReleaseContours(VoxelContourSet cset)
		{
			for (int i = 0; i < cset.conts.Count; i++)
			{
				VoxelContour voxelContour = cset.conts[i];
				ReleaseIntArr(voxelContour.verts);
				ReleaseIntArr(voxelContour.rverts);
			}
			cset.conts = null;
		}

		public static bool MergeContours(ref VoxelContour ca, ref VoxelContour cb, int ia, int ib)
		{
			int num = ca.nverts + cb.nverts + 2;
			int[] array = ClaimIntArr(num * 4, zero: false);
			int num2 = 0;
			for (int i = 0; i <= ca.nverts; i++)
			{
				int num3 = num2 * 4;
				int num4 = (ia + i) % ca.nverts * 4;
				array[num3] = ca.verts[num4];
				array[num3 + 1] = ca.verts[num4 + 1];
				array[num3 + 2] = ca.verts[num4 + 2];
				array[num3 + 3] = ca.verts[num4 + 3];
				num2++;
			}
			for (int j = 0; j <= cb.nverts; j++)
			{
				int num5 = num2 * 4;
				int num6 = (ib + j) % cb.nverts * 4;
				array[num5] = cb.verts[num6];
				array[num5 + 1] = cb.verts[num6 + 1];
				array[num5 + 2] = cb.verts[num6 + 2];
				array[num5 + 3] = cb.verts[num6 + 3];
				num2++;
			}
			ReleaseIntArr(ca.verts);
			ReleaseIntArr(cb.verts);
			ca.verts = array;
			ca.nverts = num2;
			cb.verts = emptyArr;
			cb.nverts = 0;
			return true;
		}

		public void SimplifyContour(List<int> verts, List<int> simplified, float maxError, int maxEdgeLenght, int buildFlags)
		{
			bool flag = false;
			for (int i = 0; i < verts.Count; i += 4)
			{
				if ((verts[i + 3] & 0xFFFF) != 0)
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				int j = 0;
				for (int num = verts.Count / 4; j < num; j++)
				{
					int num2 = (j + 1) % num;
					bool flag2 = (verts[j * 4 + 3] & 0xFFFF) != (verts[num2 * 4 + 3] & 0xFFFF);
					bool flag3 = (verts[j * 4 + 3] & 0x20000) != (verts[num2 * 4 + 3] & 0x20000);
					if (flag2 || flag3)
					{
						simplified.Add(verts[j * 4]);
						simplified.Add(verts[j * 4 + 1]);
						simplified.Add(verts[j * 4 + 2]);
						simplified.Add(j);
					}
				}
			}
			if (simplified.Count == 0)
			{
				int num3 = verts[0];
				int item = verts[1];
				int num4 = verts[2];
				int item2 = 0;
				int num5 = verts[0];
				int item3 = verts[1];
				int num6 = verts[2];
				int item4 = 0;
				for (int k = 0; k < verts.Count; k += 4)
				{
					int num7 = verts[k];
					int num8 = verts[k + 1];
					int num9 = verts[k + 2];
					if (num7 < num3 || (num7 == num3 && num9 < num4))
					{
						num3 = num7;
						item = num8;
						num4 = num9;
						item2 = k / 4;
					}
					if (num7 > num5 || (num7 == num5 && num9 > num6))
					{
						num5 = num7;
						item3 = num8;
						num6 = num9;
						item4 = k / 4;
					}
				}
				simplified.Add(num3);
				simplified.Add(item);
				simplified.Add(num4);
				simplified.Add(item2);
				simplified.Add(num5);
				simplified.Add(item3);
				simplified.Add(num6);
				simplified.Add(item4);
			}
			int num10 = verts.Count / 4;
			maxError *= maxError;
			int num11 = 0;
			while (num11 < simplified.Count / 4)
			{
				int num12 = (num11 + 1) % (simplified.Count / 4);
				int num13 = simplified[num11 * 4];
				int num14 = simplified[num11 * 4 + 2];
				int num15 = simplified[num11 * 4 + 3];
				int num16 = simplified[num12 * 4];
				int num17 = simplified[num12 * 4 + 2];
				int num18 = simplified[num12 * 4 + 3];
				float num19 = 0f;
				int num20 = -1;
				int num21;
				int num22;
				int num23;
				if (num16 > num13 || (num16 == num13 && num17 > num14))
				{
					num21 = 1;
					num22 = (num15 + num21) % num10;
					num23 = num18;
				}
				else
				{
					num21 = num10 - 1;
					num22 = (num18 + num21) % num10;
					num23 = num15;
				}
				if ((verts[num22 * 4 + 3] & 0xFFFF) == 0 || (verts[num22 * 4 + 3] & 0x20000) == 131072)
				{
					while (num22 != num23)
					{
						float num24 = AstarMath.DistancePointSegment(verts[num22 * 4], verts[num22 * 4 + 2] / voxelArea.width, num13, num14 / voxelArea.width, num16, num17 / voxelArea.width);
						if (num24 > num19)
						{
							num19 = num24;
							num20 = num22;
						}
						num22 = (num22 + num21) % num10;
					}
				}
				if (num20 != -1 && num19 > maxError)
				{
					simplified.Add(0);
					simplified.Add(0);
					simplified.Add(0);
					simplified.Add(0);
					int num25 = simplified.Count / 4;
					for (int num26 = num25 - 1; num26 > num11; num26--)
					{
						simplified[num26 * 4] = simplified[(num26 - 1) * 4];
						simplified[num26 * 4 + 1] = simplified[(num26 - 1) * 4 + 1];
						simplified[num26 * 4 + 2] = simplified[(num26 - 1) * 4 + 2];
						simplified[num26 * 4 + 3] = simplified[(num26 - 1) * 4 + 3];
					}
					simplified[(num11 + 1) * 4] = verts[num20 * 4];
					simplified[(num11 + 1) * 4 + 1] = verts[num20 * 4 + 1];
					simplified[(num11 + 1) * 4 + 2] = verts[num20 * 4 + 2];
					simplified[(num11 + 1) * 4 + 3] = num20;
				}
				else
				{
					num11++;
				}
			}
			float num27 = maxEdgeLength / cellSize;
			if (num27 > 0f && (buildFlags & 3) != 0)
			{
				int num28 = 0;
				while (num28 < simplified.Count / 4 && simplified.Count / 4 <= 200)
				{
					int num29 = (num28 + 1) % (simplified.Count / 4);
					int num30 = simplified[num28 * 4];
					int num31 = simplified[num28 * 4 + 2];
					int num32 = simplified[num28 * 4 + 3];
					int num33 = simplified[num29 * 4];
					int num34 = simplified[num29 * 4 + 2];
					int num35 = simplified[num29 * 4 + 3];
					int num36 = -1;
					int num37 = (num32 + 1) % num10;
					bool flag4 = false;
					if ((buildFlags & 1) == 1 && (verts[num37 * 4 + 3] & 0xFFFF) == 0)
					{
						flag4 = true;
					}
					if ((buildFlags & 2) == 1 && (verts[num37 * 4 + 3] & 0x20000) == 1)
					{
						flag4 = true;
					}
					if (flag4)
					{
						int num38 = num33 - num30;
						int num39 = num34 / voxelArea.width - num31 / voxelArea.width;
						if ((float)(num38 * num38 + num39 * num39) > num27 * num27)
						{
							if (num33 > num30 || (num33 == num30 && num34 > num31))
							{
								int num40 = (num35 >= num32) ? (num35 - num32) : (num35 + num10 - num32);
								num36 = (num32 + num40 / 2) % num10;
							}
							else
							{
								int num41 = (num35 >= num32) ? (num35 - num32) : (num35 + num10 - num32);
								num36 = (num32 + (num41 + 1) / 2) % num10;
							}
						}
					}
					if (num36 != -1)
					{
						simplified.AddRange(new int[4]);
						int num42 = simplified.Count / 4;
						for (int num43 = num42 - 1; num43 > num28; num43--)
						{
							simplified[num43 * 4] = simplified[(num43 - 1) * 4];
							simplified[num43 * 4 + 1] = simplified[(num43 - 1) * 4 + 1];
							simplified[num43 * 4 + 2] = simplified[(num43 - 1) * 4 + 2];
							simplified[num43 * 4 + 3] = simplified[(num43 - 1) * 4 + 3];
						}
						simplified[(num28 + 1) * 4] = verts[num36 * 4];
						simplified[(num28 + 1) * 4 + 1] = verts[num36 * 4 + 1];
						simplified[(num28 + 1) * 4 + 2] = verts[num36 * 4 + 2];
						simplified[(num28 + 1) * 4 + 3] = num36;
					}
					else
					{
						num28++;
					}
				}
			}
			for (int l = 0; l < simplified.Count / 4; l++)
			{
				int num44 = (simplified[l * 4 + 3] + 1) % num10;
				int num45 = simplified[l * 4 + 3];
				simplified[l * 4 + 3] = ((verts[num44 * 4 + 3] & 0xFFFF) | (verts[num45 * 4 + 3] & 0x10000));
			}
		}

		public void WalkContour(int x, int z, int i, ushort[] flags, List<int> verts)
		{
			int j;
			for (j = 0; (flags[i] & (ushort)(1 << j)) == 0; j++)
			{
			}
			int num = j;
			int num2 = i;
			int num3 = voxelArea.areaTypes[i];
			int num4 = 0;
			while (true)
			{
				if (num4++ >= 40000)
				{
					return;
				}
				if ((flags[i] & (ushort)(1 << j)) != 0)
				{
					bool isBorderVertex = false;
					bool flag = false;
					int num5 = x;
					int cornerHeight = GetCornerHeight(x, z, i, j, ref isBorderVertex);
					int num6 = z;
					switch (j)
					{
					case 0:
						num6 += voxelArea.width;
						break;
					case 1:
						num5++;
						num6 += voxelArea.width;
						break;
					case 2:
						num5++;
						break;
					}
					int num7 = 0;
					CompactVoxelSpan compactVoxelSpan = voxelArea.compactSpans[i];
					if ((long)compactVoxelSpan.GetConnection(j) != 63)
					{
						int num8 = x + voxelArea.DirectionX[j];
						int num9 = z + voxelArea.DirectionZ[j];
						int num10 = (int)voxelArea.compactCells[num8 + num9].index + compactVoxelSpan.GetConnection(j);
						num7 = voxelArea.compactSpans[num10].reg;
						if (num3 != voxelArea.areaTypes[num10])
						{
							flag = true;
						}
					}
					if (isBorderVertex)
					{
						num7 |= 0x10000;
					}
					if (flag)
					{
						num7 |= 0x20000;
					}
					verts.Add(num5);
					verts.Add(cornerHeight);
					verts.Add(num6);
					verts.Add(num7);
					flags[i] = (ushort)(flags[i] & ~(1 << j));
					j = ((j + 1) & 3);
				}
				else
				{
					int num11 = -1;
					int num12 = x + voxelArea.DirectionX[j];
					int num13 = z + voxelArea.DirectionZ[j];
					CompactVoxelSpan compactVoxelSpan2 = voxelArea.compactSpans[i];
					if ((long)compactVoxelSpan2.GetConnection(j) != 63)
					{
						CompactVoxelCell compactVoxelCell = voxelArea.compactCells[num12 + num13];
						num11 = (int)compactVoxelCell.index + compactVoxelSpan2.GetConnection(j);
					}
					if (num11 == -1)
					{
						break;
					}
					x = num12;
					z = num13;
					i = num11;
					j = ((j + 3) & 3);
				}
				if (num2 == i && num == j)
				{
					return;
				}
			}
			UnityEngine.Debug.LogError("This should not happen");
		}

		public int GetCornerHeight(int x, int z, int i, int dir, ref bool isBorderVertex)
		{
			CompactVoxelSpan compactVoxelSpan = voxelArea.compactSpans[i];
			int num = compactVoxelSpan.y;
			int num2 = (dir + 1) & 3;
			uint[] array = new uint[4]
			{
				(uint)(voxelArea.compactSpans[i].reg | (voxelArea.areaTypes[i] << 16)),
				0u,
				0u,
				0u
			};
			if ((long)compactVoxelSpan.GetConnection(dir) != 63)
			{
				int num3 = x + voxelArea.DirectionX[dir];
				int num4 = z + voxelArea.DirectionZ[dir];
				int num5 = (int)voxelArea.compactCells[num3 + num4].index + compactVoxelSpan.GetConnection(dir);
				CompactVoxelSpan compactVoxelSpan2 = voxelArea.compactSpans[num5];
				num = AstarMath.Max(num, compactVoxelSpan2.y);
				array[1] = (uint)(compactVoxelSpan2.reg | (voxelArea.areaTypes[num5] << 16));
				if ((long)compactVoxelSpan2.GetConnection(num2) != 63)
				{
					int num6 = num3 + voxelArea.DirectionX[num2];
					int num7 = num4 + voxelArea.DirectionZ[num2];
					int num8 = (int)voxelArea.compactCells[num6 + num7].index + compactVoxelSpan2.GetConnection(num2);
					CompactVoxelSpan compactVoxelSpan3 = voxelArea.compactSpans[num8];
					num = AstarMath.Max(num, compactVoxelSpan3.y);
					array[2] = (uint)(compactVoxelSpan3.reg | (voxelArea.areaTypes[num8] << 16));
				}
			}
			if ((long)compactVoxelSpan.GetConnection(num2) != 63)
			{
				int num9 = x + voxelArea.DirectionX[num2];
				int num10 = z + voxelArea.DirectionZ[num2];
				int num11 = (int)voxelArea.compactCells[num9 + num10].index + compactVoxelSpan.GetConnection(num2);
				CompactVoxelSpan compactVoxelSpan4 = voxelArea.compactSpans[num11];
				num = AstarMath.Max(num, compactVoxelSpan4.y);
				array[3] = (uint)(compactVoxelSpan4.reg | (voxelArea.areaTypes[num11] << 16));
				if ((long)compactVoxelSpan4.GetConnection(dir) != 63)
				{
					int num12 = num9 + voxelArea.DirectionX[dir];
					int num13 = num10 + voxelArea.DirectionZ[dir];
					int num14 = (int)voxelArea.compactCells[num12 + num13].index + compactVoxelSpan4.GetConnection(dir);
					CompactVoxelSpan compactVoxelSpan5 = voxelArea.compactSpans[num14];
					num = AstarMath.Max(num, compactVoxelSpan5.y);
					array[2] = (uint)(compactVoxelSpan5.reg | (voxelArea.areaTypes[num14] << 16));
				}
			}
			for (int j = 0; j < 4; j++)
			{
				int num15 = j;
				int num16 = (j + 1) & 3;
				int num17 = (j + 2) & 3;
				int num18 = (j + 3) & 3;
				bool flag = (array[num15] & array[num16] & 0x8000) != 0 && array[num15] == array[num16];
				bool flag2 = ((array[num17] | array[num18]) & 0x8000) == 0;
				bool flag3 = array[num17] >> 16 == array[num18] >> 16;
				bool flag4 = array[num15] != 0 && array[num16] != 0 && array[num17] != 0 && array[num18] != 0;
				if (flag && flag2 && flag3 && flag4)
				{
					isBorderVertex = true;
					break;
				}
			}
			return num;
		}

		public void RemoveDegenerateSegments(List<int> simplified)
		{
			for (int i = 0; i < simplified.Count / 4; i++)
			{
				int num = i + 1;
				if (num >= simplified.Count / 4)
				{
					num = 0;
				}
				if (simplified[i * 4] == simplified[num * 4] && simplified[i * 4 + 2] == simplified[num * 4 + 2])
				{
					simplified.RemoveRange(i, 4);
				}
			}
		}

		public int CalcAreaOfPolygon2D(int[] verts, int nverts)
		{
			int num = 0;
			int num2 = 0;
			int num3 = nverts - 1;
			while (num2 < nverts)
			{
				int num4 = num2 * 4;
				int num5 = num3 * 4;
				num += verts[num4] * (verts[num5 + 2] / voxelArea.width) - verts[num5] * (verts[num4 + 2] / voxelArea.width);
				num3 = num2++;
			}
			return (num + 1) / 2;
		}

		public static bool Ileft(int a, int b, int c, int[] va, int[] vb, int[] vc)
		{
			return (vb[b] - va[a]) * (vc[c + 2] - va[a + 2]) - (vc[c] - va[a]) * (vb[b + 2] - va[a + 2]) <= 0;
		}

		public static bool Diagonal(int i, int j, int n, int[] verts, int[] indices)
		{
			return InCone(i, j, n, verts, indices) && Diagonalie(i, j, n, verts, indices);
		}

		public static bool InCone(int i, int j, int n, int[] verts, int[] indices)
		{
			int num = (indices[i] & 0xFFFFFFF) * 4;
			int num2 = (indices[j] & 0xFFFFFFF) * 4;
			int c = (indices[Next(i, n)] & 0xFFFFFFF) * 4;
			int num3 = (indices[Prev(i, n)] & 0xFFFFFFF) * 4;
			if (LeftOn(num3, num, c, verts))
			{
				return Left(num, num2, num3, verts) && Left(num2, num, c, verts);
			}
			return !LeftOn(num, num2, c, verts) || !LeftOn(num2, num, num3, verts);
		}

		public static bool Left(int a, int b, int c, int[] verts)
		{
			return Area2(a, b, c, verts) < 0;
		}

		public static bool LeftOn(int a, int b, int c, int[] verts)
		{
			return Area2(a, b, c, verts) <= 0;
		}

		public static bool Collinear(int a, int b, int c, int[] verts)
		{
			return Area2(a, b, c, verts) == 0;
		}

		public static int Area2(int a, int b, int c, int[] verts)
		{
			return (verts[b] - verts[a]) * (verts[c + 2] - verts[a + 2]) - (verts[c] - verts[a]) * (verts[b + 2] - verts[a + 2]);
		}

		private static bool Diagonalie(int i, int j, int n, int[] verts, int[] indices)
		{
			int a = (indices[i] & 0xFFFFFFF) * 4;
			int num = (indices[j] & 0xFFFFFFF) * 4;
			for (int k = 0; k < n; k++)
			{
				int num2 = Next(k, n);
				if (k != i && num2 != i && k != j && num2 != j)
				{
					int num3 = (indices[k] & 0xFFFFFFF) * 4;
					int num4 = (indices[num2] & 0xFFFFFFF) * 4;
					if (!Vequal(a, num3, verts) && !Vequal(num, num3, verts) && !Vequal(a, num4, verts) && !Vequal(num, num4, verts) && Intersect(a, num, num3, num4, verts))
					{
						return false;
					}
				}
			}
			return true;
		}

		public static bool Xorb(bool x, bool y)
		{
			return !x ^ !y;
		}

		public static bool IntersectProp(int a, int b, int c, int d, int[] verts)
		{
			if (Collinear(a, b, c, verts) || Collinear(a, b, d, verts) || Collinear(c, d, a, verts) || Collinear(c, d, b, verts))
			{
				return false;
			}
			return Xorb(Left(a, b, c, verts), Left(a, b, d, verts)) && Xorb(Left(c, d, a, verts), Left(c, d, b, verts));
		}

		private static bool Between(int a, int b, int c, int[] verts)
		{
			if (!Collinear(a, b, c, verts))
			{
				return false;
			}
			if (verts[a] != verts[b])
			{
				return (verts[a] <= verts[c] && verts[c] <= verts[b]) || (verts[a] >= verts[c] && verts[c] >= verts[b]);
			}
			return (verts[a + 2] <= verts[c + 2] && verts[c + 2] <= verts[b + 2]) || (verts[a + 2] >= verts[c + 2] && verts[c + 2] >= verts[b + 2]);
		}

		private static bool Intersect(int a, int b, int c, int d, int[] verts)
		{
			if (IntersectProp(a, b, c, d, verts))
			{
				return true;
			}
			if (Between(a, b, c, verts) || Between(a, b, d, verts) || Between(c, d, a, verts) || Between(c, d, b, verts))
			{
				return true;
			}
			return false;
		}

		private static bool Vequal(int a, int b, int[] verts)
		{
			return verts[a] == verts[b] && verts[a + 2] == verts[b + 2];
		}

		public static int Prev(int i, int n)
		{
			return (i - 1 < 0) ? (n - 1) : (i - 1);
		}

		public static int Next(int i, int n)
		{
			return (i + 1 < n) ? (i + 1) : 0;
		}

		public void BuildPolyMesh(VoxelContourSet cset, int nvp, out VoxelMesh mesh)
		{
			nvp = 3;
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			for (int i = 0; i < cset.conts.Count; i++)
			{
				VoxelContour voxelContour = cset.conts[i];
				if (voxelContour.nverts >= 3)
				{
					int num4 = num;
					VoxelContour voxelContour2 = cset.conts[i];
					num = num4 + voxelContour2.nverts;
					int num5 = num2;
					VoxelContour voxelContour3 = cset.conts[i];
					num2 = num5 + (voxelContour3.nverts - 2);
					int a = num3;
					VoxelContour voxelContour4 = cset.conts[i];
					num3 = AstarMath.Max(a, voxelContour4.nverts);
				}
			}
			if (num >= 65534)
			{
				UnityEngine.Debug.LogWarning("To many vertices for unity to render - Unity might screw up rendering, but hopefully the navmesh will work ok");
			}
			Int3[] array = new Int3[num];
			int[] array2 = new int[num2 * nvp];
			Pathfinding.Util.Memory.MemSet(array2, 255, 4);
			int[] indices = new int[num3];
			int[] tris = new int[num3 * 3];
			int num6 = 0;
			int num7 = 0;
			for (int j = 0; j < cset.conts.Count; j++)
			{
				VoxelContour voxelContour5 = cset.conts[j];
				if (voxelContour5.nverts >= 3)
				{
					for (int k = 0; k < voxelContour5.nverts; k++)
					{
						indices[k] = k;
						voxelContour5.verts[k * 4 + 2] /= voxelArea.width;
					}
					int num8 = Triangulate(voxelContour5.nverts, voxelContour5.verts, ref indices, ref tris);
					int num9 = num6;
					for (int l = 0; l < num8 * 3; l++)
					{
						array2[num7] = tris[l] + num9;
						num7++;
					}
					for (int m = 0; m < voxelContour5.nverts; m++)
					{
						array[num6] = new Int3(voxelContour5.verts[m * 4], voxelContour5.verts[m * 4 + 1], voxelContour5.verts[m * 4 + 2]);
						num6++;
					}
				}
			}
			mesh = default(VoxelMesh);
			Int3[] array3 = new Int3[num6];
			for (int n = 0; n < num6; n++)
			{
				array3[n] = array[n];
			}
			int[] array4 = new int[num7];
			Buffer.BlockCopy(array2, 0, array4, 0, num7 * 4);
			mesh.verts = array3;
			mesh.tris = array4;
		}

		public int Triangulate(int n, int[] verts, ref int[] indices, ref int[] tris)
		{
			int num = 0;
			int[] array = tris;
			int num2 = 0;
			int num3 = n;
			for (int i = 0; i < n; i++)
			{
				int num4 = Next(i, n);
				int j = Next(num4, n);
				if (Diagonal(i, j, n, verts, indices))
				{
					indices[num4] |= 1073741824;
				}
			}
			while (n > 3)
			{
				int num5 = -1;
				int num6 = -1;
				for (int k = 0; k < n; k++)
				{
					int num7 = Next(k, n);
					if ((indices[num7] & 0x40000000) != 0)
					{
						int num8 = (indices[k] & 0xFFFFFFF) * 4;
						int num9 = (indices[Next(num7, n)] & 0xFFFFFFF) * 4;
						int num10 = verts[num9] - verts[num8];
						int num11 = verts[num9 + 2] - verts[num8 + 2];
						int num12 = num10 * num10 + num11 * num11;
						if (num5 < 0 || num12 < num5)
						{
							num5 = num12;
							num6 = k;
						}
					}
				}
				if (num6 == -1)
				{
					UnityEngine.Debug.LogError("This should not happen");
					for (int l = 0; l < num3; l++)
					{
						DrawLine(Prev(l, num3), l, indices, verts, Color.red);
					}
					return -num;
				}
				int num13 = num6;
				int num14 = Next(num13, n);
				int num15 = Next(num14, n);
				array[num2] = (indices[num13] & 0xFFFFFFF);
				num2++;
				array[num2] = (indices[num14] & 0xFFFFFFF);
				num2++;
				array[num2] = (indices[num15] & 0xFFFFFFF);
				num2++;
				num++;
				n--;
				for (int m = num14; m < n; m++)
				{
					indices[m] = indices[m + 1];
				}
				if (num14 >= n)
				{
					num14 = 0;
				}
				num13 = Prev(num14, n);
				if (Diagonal(Prev(num13, n), num14, n, verts, indices))
				{
					indices[num13] |= 1073741824;
				}
				else
				{
					indices[num13] &= 268435455;
				}
				if (Diagonal(num13, Next(num14, n), n, verts, indices))
				{
					indices[num14] |= 1073741824;
				}
				else
				{
					indices[num14] &= 268435455;
				}
			}
			array[num2] = (indices[0] & 0xFFFFFFF);
			num2++;
			array[num2] = (indices[1] & 0xFFFFFFF);
			num2++;
			array[num2] = (indices[2] & 0xFFFFFFF);
			num2++;
			return num + 1;
		}

		public Vector3 CompactSpanToVector(int x, int z, int i)
		{
			return voxelOffset + new Vector3((float)x * cellSize, (float)(int)voxelArea.compactSpans[i].y * cellHeight, (float)z * cellSize);
		}

		public void VectorToIndex(Vector3 p, out int x, out int z)
		{
			p -= voxelOffset;
			x = Mathf.RoundToInt(p.x / cellSize);
			z = Mathf.RoundToInt(p.z / cellSize);
		}

		public void OnGUI()
		{
			GUI.Label(new Rect(5f, 5f, 200f, Screen.height), debugString);
		}

		public void CollectMeshes()
		{
			CollectMeshes(inputExtraMeshes, forcedBounds, out inputVertices, out inputTriangles);
		}

		public static void CollectMeshes(List<ExtraMesh> extraMeshes, Bounds bounds, out Vector3[] verts, out int[] tris)
		{
			verts = null;
			tris = null;
		}

		public void Init()
		{
			if (voxelArea == null || voxelArea.width != width || voxelArea.depth != depth)
			{
				voxelArea = new VoxelArea(width, depth);
			}
			else
			{
				voxelArea.Reset();
			}
		}

		public void VoxelizeInput()
		{
			Vector3 a = voxelOffset = forcedBounds.min;
			float num = 1f / cellSize;
			float num2 = 1f / cellHeight;
			float num3 = Mathf.Cos(Mathf.Atan(Mathf.Tan(maxSlope * ((float)Math.PI / 180f)) * (num2 * cellSize)));
			float[] array = new float[9];
			float[] array2 = new float[21];
			float[] array3 = new float[21];
			float[] array4 = new float[21];
			float[] array5 = new float[21];
			if (inputExtraMeshes == null)
			{
				throw new NullReferenceException("inputExtraMeshes not set");
			}
			int num4 = 0;
			for (int i = 0; i < inputExtraMeshes.Count; i++)
			{
				if (inputExtraMeshes[i].bounds.Intersects(forcedBounds))
				{
					ExtraMesh extraMesh = inputExtraMeshes[i];
					num4 = Math.Max(extraMesh.vertices.Length, num4);
				}
			}
			Vector3[] array6 = new Vector3[num4];
			Matrix4x4 lhs = Matrix4x4.Scale(new Vector3(num, num2, num)) * Matrix4x4.TRS(-a, Quaternion.identity, Vector3.one);
			for (int j = 0; j < inputExtraMeshes.Count; j++)
			{
				ExtraMesh extraMesh2 = inputExtraMeshes[j];
				if (!extraMesh2.bounds.Intersects(forcedBounds))
				{
					continue;
				}
				Matrix4x4 matrix = extraMesh2.matrix;
				matrix = lhs * matrix;
				Vector3[] vertices = extraMesh2.vertices;
				int[] triangles = extraMesh2.triangles;
				int num5 = triangles.Length;
				for (int k = 0; k < vertices.Length; k++)
				{
					array6[k] = matrix.MultiplyPoint3x4(vertices[k]);
				}
				int area = extraMesh2.area;
				for (int l = 0; l < num5; l += 3)
				{
					Vector3 vector = array6[triangles[l]];
					Vector3 vector2 = array6[triangles[l + 1]];
					Vector3 vector3 = array6[triangles[l + 2]];
					int value = (int)Utility.Min(vector.x, vector2.x, vector3.x);
					int value2 = (int)Utility.Min(vector.z, vector2.z, vector3.z);
					int value3 = (int)Math.Ceiling(Utility.Max(vector.x, vector2.x, vector3.x));
					int value4 = (int)Math.Ceiling(Utility.Max(vector.z, vector2.z, vector3.z));
					value = Mathf.Clamp(value, 0, voxelArea.width - 1);
					value3 = Mathf.Clamp(value3, 0, voxelArea.width - 1);
					value2 = Mathf.Clamp(value2, 0, voxelArea.depth - 1);
					value4 = Mathf.Clamp(value4, 0, voxelArea.depth - 1);
					if (value >= voxelArea.width || value2 >= voxelArea.depth || value3 <= 0 || value4 <= 0)
					{
						continue;
					}
					float num6 = Vector3.Dot(Vector3.Cross(vector2 - vector, vector3 - vector).normalized, Vector3.up);
					int area2 = (!(num6 < num3)) ? (1 + area) : 0;
					Utility.CopyVector(array, 0, vector);
					Utility.CopyVector(array, 3, vector2);
					Utility.CopyVector(array, 6, vector3);
					for (int m = value; m <= value3; m++)
					{
						int num7 = Utility.ClipPolygon(array, 3, array2, 1f, (float)(-m) + 0.5f, 0);
						if (num7 < 3)
						{
							continue;
						}
						num7 = Utility.ClipPolygon(array2, num7, array3, -1f, (float)m + 0.5f, 0);
						if (num7 < 3)
						{
							continue;
						}
						float num8 = array3[2];
						float num9 = array3[2];
						for (int n = 1; n < num7; n++)
						{
							float val = array3[n * 3 + 2];
							num8 = Math.Min(num8, val);
							num9 = Math.Max(num9, val);
						}
						int num10 = AstarMath.Clamp((int)Math.Round(num8), 0, voxelArea.depth - 1);
						int num11 = AstarMath.Clamp((int)Math.Round(num9), 0, voxelArea.depth - 1);
						for (int num12 = num10; num12 <= num11; num12++)
						{
							int num13 = Utility.ClipPolygon(array3, num7, array4, 1f, (float)(-num12) + 0.5f, 2);
							if (num13 < 3)
							{
								continue;
							}
							num13 = Utility.ClipPolygonY(array4, num13, array5, -1f, (float)num12 + 0.5f, 2);
							if (num13 >= 3)
							{
								float num14 = array5[1];
								float num15 = array5[1];
								for (int num16 = 1; num16 < num13; num16++)
								{
									float val2 = array5[num16 * 3 + 1];
									num14 = Math.Min(num14, val2);
									num15 = Math.Max(num15, val2);
								}
								int num17 = (int)Math.Ceiling(num15);
								if (num17 >= 0)
								{
									int num18 = (int)(num14 + 1f);
									voxelArea.AddLinkedSpan(num12 * voxelArea.width + m, (uint)((num18 >= 0) ? num18 : 0), (uint)num17, area2, voxelWalkableClimb);
								}
							}
						}
					}
				}
			}
		}

		public void BuildCompactField()
		{
			int spanCount = voxelArea.GetSpanCount();
			voxelArea.compactSpanCount = spanCount;
			if (voxelArea.compactSpans == null || voxelArea.compactSpans.Length < spanCount)
			{
				voxelArea.compactSpans = new CompactVoxelSpan[spanCount];
				voxelArea.areaTypes = new int[spanCount];
			}
			uint num = 0u;
			int num2 = voxelArea.width;
			int num3 = voxelArea.depth;
			int num4 = num2 * num3;
			if (voxelWalkableHeight >= 65535)
			{
				UnityEngine.Debug.LogWarning("Too high walkable height to guarantee correctness. Increase voxel height or lower walkable height.");
			}
			LinkedVoxelSpan[] linkedSpans = voxelArea.linkedSpans;
			int num5 = 0;
			int num6 = 0;
			while (num5 < num4)
			{
				for (int i = 0; i < num2; i++)
				{
					int num7 = i + num5;
					if (linkedSpans[num7].bottom == uint.MaxValue)
					{
						voxelArea.compactCells[i + num5] = new CompactVoxelCell(0u, 0u);
						continue;
					}
					uint i2 = num;
					uint num8 = 0u;
					while (num7 != -1)
					{
						if (linkedSpans[num7].area != 0)
						{
							int top = (int)linkedSpans[num7].top;
							int next = linkedSpans[num7].next;
							int num9 = (int)((next == -1) ? 65536 : linkedSpans[next].bottom);
							voxelArea.compactSpans[num] = new CompactVoxelSpan((ushort)((top <= 65535) ? top : 65535), (uint)((num9 - top <= 65535) ? (num9 - top) : 65535));
							voxelArea.areaTypes[num] = linkedSpans[num7].area;
							num++;
							num8++;
						}
						num7 = linkedSpans[num7].next;
					}
					voxelArea.compactCells[i + num5] = new CompactVoxelCell(i2, num8);
				}
				num5 += num2;
				num6++;
			}
		}

		public void BuildVoxelConnections()
		{
			int num = voxelArea.width * voxelArea.depth;
			CompactVoxelSpan[] compactSpans = voxelArea.compactSpans;
			CompactVoxelCell[] compactCells = voxelArea.compactCells;
			int num2 = 0;
			int num3 = 0;
			while (num2 < num)
			{
				for (int i = 0; i < voxelArea.width; i++)
				{
					CompactVoxelCell compactVoxelCell = compactCells[i + num2];
					int j = (int)compactVoxelCell.index;
					for (int num4 = (int)(compactVoxelCell.index + compactVoxelCell.count); j < num4; j++)
					{
						CompactVoxelSpan compactVoxelSpan = compactSpans[j];
						compactSpans[j].con = uint.MaxValue;
						for (int k = 0; k < 4; k++)
						{
							int num5 = i + voxelArea.DirectionX[k];
							int num6 = num2 + voxelArea.DirectionZ[k];
							if (num5 < 0 || num6 < 0 || num6 >= num || num5 >= voxelArea.width)
							{
								continue;
							}
							CompactVoxelCell compactVoxelCell2 = compactCells[num5 + num6];
							int l = (int)compactVoxelCell2.index;
							for (int num7 = (int)(compactVoxelCell2.index + compactVoxelCell2.count); l < num7; l++)
							{
								CompactVoxelSpan compactVoxelSpan2 = compactSpans[l];
								int num8 = Math.Max(compactVoxelSpan.y, compactVoxelSpan2.y);
								int num9 = AstarMath.Min((int)(compactVoxelSpan.y + compactVoxelSpan.h), (int)(compactVoxelSpan2.y + compactVoxelSpan2.h));
								if (num9 - num8 >= voxelWalkableHeight && Math.Abs(compactVoxelSpan2.y - compactVoxelSpan.y) <= voxelWalkableClimb)
								{
									uint num10 = (uint)(l - (int)compactVoxelCell2.index);
									if (num10 <= 65535)
									{
										compactSpans[j].SetConnection(k, num10);
										break;
									}
									UnityEngine.Debug.LogError("Too many layers");
								}
							}
						}
					}
				}
				num2 += voxelArea.width;
				num3++;
			}
		}

		public void DrawLine(int a, int b, int[] indices, int[] verts, Color col)
		{
			int num = (indices[a] & 0xFFFFFFF) * 4;
			int num2 = (indices[b] & 0xFFFFFFF) * 4;
			UnityEngine.Debug.DrawLine(ConvertPosCorrZ(verts[num], verts[num + 1], verts[num + 2]), ConvertPosCorrZ(verts[num2], verts[num2 + 1], verts[num2 + 2]), col);
		}

		public Vector3 ConvertPos(int x, int y, int z)
		{
			return Vector3.Scale(new Vector3((float)x + 0.5f, y, (float)z / (float)voxelArea.width + 0.5f), cellScale) + voxelOffset;
		}

		public Vector3 ConvertPosCorrZ(int x, int y, int z)
		{
			return Vector3.Scale(new Vector3(x, y, z), cellScale) + voxelOffset;
		}

		public Vector3 ConvertPosWithoutOffset(int x, int y, int z)
		{
			return Vector3.Scale(new Vector3(x, y, (float)z / (float)voxelArea.width), cellScale) + voxelOffset;
		}

		public Vector3 ConvertPosition(int x, int z, int i)
		{
			CompactVoxelSpan compactVoxelSpan = voxelArea.compactSpans[i];
			return new Vector3((float)x * cellSize, (float)(int)compactVoxelSpan.y * cellHeight, (float)z / (float)voxelArea.width * cellSize) + voxelOffset;
		}

		public void ErodeWalkableArea(int radius)
		{
			ushort[] array = voxelArea.tmpUShortArr;
			if (array == null || array.Length < voxelArea.compactSpanCount)
			{
				array = (voxelArea.tmpUShortArr = new ushort[voxelArea.compactSpanCount]);
			}
			Pathfinding.Util.Memory.MemSet(array, ushort.MaxValue, 2);
			CalculateDistanceField(array);
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] < radius * 2)
				{
					voxelArea.areaTypes[i] = 0;
				}
			}
		}

		public void BuildDistanceField()
		{
			ushort[] array = voxelArea.tmpUShortArr;
			if (array == null || array.Length < voxelArea.compactSpanCount)
			{
				array = (voxelArea.tmpUShortArr = new ushort[voxelArea.compactSpanCount]);
			}
			Pathfinding.Util.Memory.MemSet(array, ushort.MaxValue, 2);
			voxelArea.maxDistance = CalculateDistanceField(array);
			ushort[] array2 = voxelArea.dist;
			if (array2 == null || array2.Length < voxelArea.compactSpanCount)
			{
				array2 = new ushort[voxelArea.compactSpanCount];
			}
			array2 = BoxBlur(array, array2);
			voxelArea.dist = array2;
		}

		[Obsolete("This function is not complete and should not be used")]
		public void ErodeVoxels(int radius)
		{
			if (radius > 255)
			{
				UnityEngine.Debug.LogError("Max Erode Radius is 255");
				radius = 255;
			}
			int num = voxelArea.width * voxelArea.depth;
			int[] array = new int[voxelArea.compactSpanCount];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = 255;
			}
			for (int j = 0; j < num; j += voxelArea.width)
			{
				for (int k = 0; k < voxelArea.width; k++)
				{
					CompactVoxelCell compactVoxelCell = voxelArea.compactCells[k + j];
					int l = (int)compactVoxelCell.index;
					for (int num2 = (int)(compactVoxelCell.index + compactVoxelCell.count); l < num2; l++)
					{
						if (voxelArea.areaTypes[l] == 0)
						{
							continue;
						}
						CompactVoxelSpan compactVoxelSpan = voxelArea.compactSpans[l];
						int num3 = 0;
						for (int m = 0; m < 4; m++)
						{
							if ((long)compactVoxelSpan.GetConnection(m) != 63)
							{
								num3++;
							}
						}
						if (num3 != 4)
						{
							array[l] = 0;
						}
					}
				}
			}
		}

		public void FilterLowHeightSpans(uint voxelWalkableHeight, float cs, float ch, Vector3 min)
		{
			int num = voxelArea.width * voxelArea.depth;
			LinkedVoxelSpan[] linkedSpans = voxelArea.linkedSpans;
			int num2 = 0;
			int num3 = 0;
			while (num2 < num)
			{
				for (int i = 0; i < voxelArea.width; i++)
				{
					int num4 = num2 + i;
					while (num4 != -1 && linkedSpans[num4].bottom != uint.MaxValue)
					{
						uint top = linkedSpans[num4].top;
						uint num5 = (linkedSpans[num4].next == -1) ? 65536u : linkedSpans[linkedSpans[num4].next].bottom;
						if (num5 - top < voxelWalkableHeight)
						{
							linkedSpans[num4].area = 0;
						}
						num4 = linkedSpans[num4].next;
					}
				}
				num2 += voxelArea.width;
				num3++;
			}
		}

		public void FilterLedges(uint voxelWalkableHeight, int voxelWalkableClimb, float cs, float ch, Vector3 min)
		{
			int num = voxelArea.width * voxelArea.depth;
			LinkedVoxelSpan[] linkedSpans = voxelArea.linkedSpans;
			int[] directionX = voxelArea.DirectionX;
			int[] directionZ = voxelArea.DirectionZ;
			int num2 = voxelArea.width;
			int num3 = 0;
			int num4 = 0;
			while (num3 < num)
			{
				for (int i = 0; i < num2; i++)
				{
					if (linkedSpans[i + num3].bottom == uint.MaxValue)
					{
						continue;
					}
					for (int num5 = i + num3; num5 != -1; num5 = linkedSpans[num5].next)
					{
						if (linkedSpans[num5].area != 0)
						{
							int top = (int)linkedSpans[num5].top;
							int val = (int)((linkedSpans[num5].next == -1) ? 65536 : linkedSpans[linkedSpans[num5].next].bottom);
							int num6 = 65536;
							int num7 = (int)linkedSpans[num5].top;
							int num8 = num7;
							for (int j = 0; j < 4; j++)
							{
								int num9 = i + directionX[j];
								int num10 = num3 + directionZ[j];
								if (num9 < 0 || num10 < 0 || num10 >= num || num9 >= num2)
								{
									linkedSpans[num5].area = 0;
									break;
								}
								int num11 = num9 + num10;
								int num12 = -voxelWalkableClimb;
								int val2 = (int)((linkedSpans[num11].bottom == uint.MaxValue) ? 65536 : linkedSpans[num11].bottom);
								if (Math.Min(val, val2) - Math.Max(top, num12) > voxelWalkableHeight)
								{
									num6 = Math.Min(num6, num12 - top);
								}
								if (linkedSpans[num11].bottom == uint.MaxValue)
								{
									continue;
								}
								for (int num13 = num11; num13 != -1; num13 = linkedSpans[num13].next)
								{
									num12 = (int)linkedSpans[num13].top;
									val2 = (int)((linkedSpans[num13].next == -1) ? 65536 : linkedSpans[linkedSpans[num13].next].bottom);
									if (Math.Min(val, val2) - Math.Max(top, num12) > voxelWalkableHeight)
									{
										num6 = AstarMath.Min(num6, num12 - top);
										if (Math.Abs(num12 - top) <= voxelWalkableClimb)
										{
											if (num12 < num7)
											{
												num7 = num12;
											}
											if (num12 > num8)
											{
												num8 = num12;
											}
										}
									}
								}
							}
							if (num6 < -voxelWalkableClimb || num8 - num7 > voxelWalkableClimb)
							{
								linkedSpans[num5].area = 0;
							}
						}
					}
				}
				num3 += num2;
				num4++;
			}
		}

		public ushort[] ExpandRegions(int maxIterations, uint level, ushort[] srcReg, ushort[] srcDist, ushort[] dstReg, ushort[] dstDist, List<int> stack)
		{
			int num = voxelArea.width;
			int num2 = voxelArea.depth;
			int num3 = num * num2;
			stack.Clear();
			int num4 = 0;
			int num5 = 0;
			while (num4 < num3)
			{
				for (int i = 0; i < voxelArea.width; i++)
				{
					CompactVoxelCell compactVoxelCell = voxelArea.compactCells[num4 + i];
					int j = (int)compactVoxelCell.index;
					for (int num6 = (int)(compactVoxelCell.index + compactVoxelCell.count); j < num6; j++)
					{
						if (voxelArea.dist[j] >= level && srcReg[j] == 0 && voxelArea.areaTypes[j] != 0)
						{
							stack.Add(i);
							stack.Add(num4);
							stack.Add(j);
						}
					}
				}
				num4 += num;
				num5++;
			}
			int num7 = 0;
			int count = stack.Count;
			if (count > 0)
			{
				while (true)
				{
					int num8 = 0;
					Buffer.BlockCopy(srcReg, 0, dstReg, 0, srcReg.Length * 2);
					Buffer.BlockCopy(srcDist, 0, dstDist, 0, dstDist.Length * 2);
					for (int k = 0; k < count && k < count; k += 3)
					{
						int num9 = stack[k];
						int num10 = stack[k + 1];
						int num11 = stack[k + 2];
						if (num11 < 0)
						{
							num8++;
							continue;
						}
						ushort num12 = srcReg[num11];
						ushort num13 = ushort.MaxValue;
						CompactVoxelSpan compactVoxelSpan = voxelArea.compactSpans[num11];
						int num14 = voxelArea.areaTypes[num11];
						for (int l = 0; l < 4; l++)
						{
							if ((long)compactVoxelSpan.GetConnection(l) != 63)
							{
								int num15 = num9 + voxelArea.DirectionX[l];
								int num16 = num10 + voxelArea.DirectionZ[l];
								int num17 = (int)voxelArea.compactCells[num15 + num16].index + compactVoxelSpan.GetConnection(l);
								if (num14 == voxelArea.areaTypes[num17] && srcReg[num17] > 0 && (srcReg[num17] & 0x8000) == 0 && srcDist[num17] + 2 < num13)
								{
									num12 = srcReg[num17];
									num13 = (ushort)(srcDist[num17] + 2);
								}
							}
						}
						if (num12 != 0)
						{
							stack[k + 2] = -1;
							dstReg[num11] = num12;
							dstDist[num11] = num13;
						}
						else
						{
							num8++;
						}
					}
					ushort[] array = srcReg;
					srcReg = dstReg;
					dstReg = array;
					array = srcDist;
					srcDist = dstDist;
					dstDist = array;
					if (num8 * 3 >= count)
					{
						break;
					}
					if (level != 0)
					{
						num7++;
						if (num7 >= maxIterations)
						{
							break;
						}
					}
				}
			}
			return srcReg;
		}

		public bool FloodRegion(int x, int z, int i, uint level, ushort r, ushort[] srcReg, ushort[] srcDist, List<int> stack)
		{
			int num = voxelArea.areaTypes[i];
			stack.Clear();
			stack.Add(x);
			stack.Add(z);
			stack.Add(i);
			srcReg[i] = r;
			srcDist[i] = 0;
			int num2 = (int)((level >= 2) ? (level - 2) : 0);
			int num3 = 0;
			while (stack.Count > 0)
			{
				int num4 = stack[stack.Count - 1];
				stack.RemoveAt(stack.Count - 1);
				int num5 = stack[stack.Count - 1];
				stack.RemoveAt(stack.Count - 1);
				int num6 = stack[stack.Count - 1];
				stack.RemoveAt(stack.Count - 1);
				CompactVoxelSpan compactVoxelSpan = voxelArea.compactSpans[num4];
				ushort num7 = 0;
				for (int j = 0; j < 4; j++)
				{
					if ((long)compactVoxelSpan.GetConnection(j) == 63)
					{
						continue;
					}
					int num8 = num6 + voxelArea.DirectionX[j];
					int num9 = num5 + voxelArea.DirectionZ[j];
					int num10 = (int)voxelArea.compactCells[num8 + num9].index + compactVoxelSpan.GetConnection(j);
					if (voxelArea.areaTypes[num10] != num)
					{
						continue;
					}
					ushort num11 = srcReg[num10];
					if ((num11 & 0x8000) == 32768)
					{
						continue;
					}
					if (num11 != 0 && num11 != r)
					{
						num7 = num11;
					}
					CompactVoxelSpan compactVoxelSpan2 = voxelArea.compactSpans[num10];
					int num12 = (j + 1) & 3;
					if ((long)compactVoxelSpan2.GetConnection(num12) == 63)
					{
						continue;
					}
					int num13 = num8 + voxelArea.DirectionX[num12];
					int num14 = num9 + voxelArea.DirectionZ[num12];
					int num15 = (int)voxelArea.compactCells[num13 + num14].index + compactVoxelSpan2.GetConnection(num12);
					if (voxelArea.areaTypes[num15] == num)
					{
						num11 = srcReg[num15];
						if (num11 != 0 && num11 != r)
						{
							num7 = num11;
						}
					}
				}
				if (num7 != 0)
				{
					srcReg[num4] = 0;
					continue;
				}
				num3++;
				for (int k = 0; k < 4; k++)
				{
					if ((long)compactVoxelSpan.GetConnection(k) != 63)
					{
						int num16 = num6 + voxelArea.DirectionX[k];
						int num17 = num5 + voxelArea.DirectionZ[k];
						int num18 = (int)voxelArea.compactCells[num16 + num17].index + compactVoxelSpan.GetConnection(k);
						if (voxelArea.areaTypes[num18] == num && voxelArea.dist[num18] >= num2 && srcReg[num18] == 0)
						{
							srcReg[num18] = r;
							srcDist[num18] = 0;
							stack.Add(num16);
							stack.Add(num17);
							stack.Add(num18);
						}
					}
				}
			}
			return num3 > 0;
		}

		public void MarkRectWithRegion(int minx, int maxx, int minz, int maxz, ushort region, ushort[] srcReg)
		{
			int num = maxz * voxelArea.width;
			for (int i = minz * voxelArea.width; i < num; i += voxelArea.width)
			{
				for (int j = minx; j < maxx; j++)
				{
					CompactVoxelCell compactVoxelCell = voxelArea.compactCells[i + j];
					int k = (int)compactVoxelCell.index;
					for (int num2 = (int)(compactVoxelCell.index + compactVoxelCell.count); k < num2; k++)
					{
						if (voxelArea.areaTypes[k] != 0)
						{
							srcReg[k] = region;
						}
					}
				}
			}
		}

		public ushort CalculateDistanceField(ushort[] src)
		{
			int num = voxelArea.width * voxelArea.depth;
			for (int i = 0; i < num; i += voxelArea.width)
			{
				for (int j = 0; j < voxelArea.width; j++)
				{
					CompactVoxelCell compactVoxelCell = voxelArea.compactCells[j + i];
					int k = (int)compactVoxelCell.index;
					for (int num2 = (int)(compactVoxelCell.index + compactVoxelCell.count); k < num2; k++)
					{
						CompactVoxelSpan compactVoxelSpan = voxelArea.compactSpans[k];
						int num3 = 0;
						for (int l = 0; l < 4 && (long)compactVoxelSpan.GetConnection(l) != 63; l++)
						{
							num3++;
						}
						if (num3 != 4)
						{
							src[k] = 0;
						}
					}
				}
			}
			for (int m = 0; m < num; m += voxelArea.width)
			{
				for (int n = 0; n < voxelArea.width; n++)
				{
					CompactVoxelCell compactVoxelCell2 = voxelArea.compactCells[n + m];
					int num4 = (int)compactVoxelCell2.index;
					for (int num5 = (int)(compactVoxelCell2.index + compactVoxelCell2.count); num4 < num5; num4++)
					{
						CompactVoxelSpan compactVoxelSpan2 = voxelArea.compactSpans[num4];
						if ((long)compactVoxelSpan2.GetConnection(0) != 63)
						{
							int num6 = n + voxelArea.DirectionX[0];
							int num7 = m + voxelArea.DirectionZ[0];
							int num8 = (int)(voxelArea.compactCells[num6 + num7].index + compactVoxelSpan2.GetConnection(0));
							if (src[num8] + 2 < src[num4])
							{
								src[num4] = (ushort)(src[num8] + 2);
							}
							CompactVoxelSpan compactVoxelSpan3 = voxelArea.compactSpans[num8];
							if ((long)compactVoxelSpan3.GetConnection(3) != 63)
							{
								int num9 = num6 + voxelArea.DirectionX[3];
								int num10 = num7 + voxelArea.DirectionZ[3];
								int num11 = (int)(voxelArea.compactCells[num9 + num10].index + compactVoxelSpan3.GetConnection(3));
								if (src[num11] + 3 < src[num4])
								{
									src[num4] = (ushort)(src[num11] + 3);
								}
							}
						}
						if ((long)compactVoxelSpan2.GetConnection(3) == 63)
						{
							continue;
						}
						int num12 = n + voxelArea.DirectionX[3];
						int num13 = m + voxelArea.DirectionZ[3];
						int num14 = (int)(voxelArea.compactCells[num12 + num13].index + compactVoxelSpan2.GetConnection(3));
						if (src[num14] + 2 < src[num4])
						{
							src[num4] = (ushort)(src[num14] + 2);
						}
						CompactVoxelSpan compactVoxelSpan4 = voxelArea.compactSpans[num14];
						if ((long)compactVoxelSpan4.GetConnection(2) != 63)
						{
							int num15 = num12 + voxelArea.DirectionX[2];
							int num16 = num13 + voxelArea.DirectionZ[2];
							int num17 = (int)(voxelArea.compactCells[num15 + num16].index + compactVoxelSpan4.GetConnection(2));
							if (src[num17] + 3 < src[num4])
							{
								src[num4] = (ushort)(src[num17] + 3);
							}
						}
					}
				}
			}
			for (int num18 = num - voxelArea.width; num18 >= 0; num18 -= voxelArea.width)
			{
				for (int num19 = voxelArea.width - 1; num19 >= 0; num19--)
				{
					CompactVoxelCell compactVoxelCell3 = voxelArea.compactCells[num19 + num18];
					int num20 = (int)compactVoxelCell3.index;
					for (int num21 = (int)(compactVoxelCell3.index + compactVoxelCell3.count); num20 < num21; num20++)
					{
						CompactVoxelSpan compactVoxelSpan5 = voxelArea.compactSpans[num20];
						if ((long)compactVoxelSpan5.GetConnection(2) != 63)
						{
							int num22 = num19 + voxelArea.DirectionX[2];
							int num23 = num18 + voxelArea.DirectionZ[2];
							int num24 = (int)(voxelArea.compactCells[num22 + num23].index + compactVoxelSpan5.GetConnection(2));
							if (src[num24] + 2 < src[num20])
							{
								src[num20] = (ushort)(src[num24] + 2);
							}
							CompactVoxelSpan compactVoxelSpan6 = voxelArea.compactSpans[num24];
							if ((long)compactVoxelSpan6.GetConnection(1) != 63)
							{
								int num25 = num22 + voxelArea.DirectionX[1];
								int num26 = num23 + voxelArea.DirectionZ[1];
								int num27 = (int)(voxelArea.compactCells[num25 + num26].index + compactVoxelSpan6.GetConnection(1));
								if (src[num27] + 3 < src[num20])
								{
									src[num20] = (ushort)(src[num27] + 3);
								}
							}
						}
						if ((long)compactVoxelSpan5.GetConnection(1) == 63)
						{
							continue;
						}
						int num28 = num19 + voxelArea.DirectionX[1];
						int num29 = num18 + voxelArea.DirectionZ[1];
						int num30 = (int)(voxelArea.compactCells[num28 + num29].index + compactVoxelSpan5.GetConnection(1));
						if (src[num30] + 2 < src[num20])
						{
							src[num20] = (ushort)(src[num30] + 2);
						}
						CompactVoxelSpan compactVoxelSpan7 = voxelArea.compactSpans[num30];
						if ((long)compactVoxelSpan7.GetConnection(0) != 63)
						{
							int num31 = num28 + voxelArea.DirectionX[0];
							int num32 = num29 + voxelArea.DirectionZ[0];
							int num33 = (int)(voxelArea.compactCells[num31 + num32].index + compactVoxelSpan7.GetConnection(0));
							if (src[num33] + 3 < src[num20])
							{
								src[num20] = (ushort)(src[num33] + 3);
							}
						}
					}
				}
			}
			ushort num34 = 0;
			for (int num35 = 0; num35 < voxelArea.compactSpanCount; num35++)
			{
				num34 = Math.Max(src[num35], num34);
			}
			return num34;
		}

		public ushort[] BoxBlur(ushort[] src, ushort[] dst)
		{
			ushort num = 20;
			int num2 = voxelArea.width * voxelArea.depth;
			for (int num3 = num2 - voxelArea.width; num3 >= 0; num3 -= voxelArea.width)
			{
				for (int num4 = voxelArea.width - 1; num4 >= 0; num4--)
				{
					CompactVoxelCell compactVoxelCell = voxelArea.compactCells[num4 + num3];
					int i = (int)compactVoxelCell.index;
					for (int num5 = (int)(compactVoxelCell.index + compactVoxelCell.count); i < num5; i++)
					{
						CompactVoxelSpan compactVoxelSpan = voxelArea.compactSpans[i];
						ushort num6 = src[i];
						if (num6 < num)
						{
							dst[i] = num6;
							continue;
						}
						int num7 = num6;
						for (int j = 0; j < 4; j++)
						{
							if ((long)compactVoxelSpan.GetConnection(j) != 63)
							{
								int num8 = num4 + voxelArea.DirectionX[j];
								int num9 = num3 + voxelArea.DirectionZ[j];
								int num10 = (int)(voxelArea.compactCells[num8 + num9].index + compactVoxelSpan.GetConnection(j));
								num7 += src[num10];
								CompactVoxelSpan compactVoxelSpan2 = voxelArea.compactSpans[num10];
								int num11 = (j + 1) & 3;
								if ((long)compactVoxelSpan2.GetConnection(num11) != 63)
								{
									int num12 = num8 + voxelArea.DirectionX[num11];
									int num13 = num9 + voxelArea.DirectionZ[num11];
									int num14 = (int)(voxelArea.compactCells[num12 + num13].index + compactVoxelSpan2.GetConnection(num11));
									num7 += src[num14];
								}
								else
								{
									num7 += num6;
								}
							}
							else
							{
								num7 += num6 * 2;
							}
						}
						dst[i] = (ushort)((float)(num7 + 5) / 9f);
					}
				}
			}
			return dst;
		}

		private void FloodOnes(List<Int3> st1, ushort[] regs, uint level, ushort reg)
		{
			for (int i = 0; i < st1.Count; i++)
			{
				Int3 @int = st1[i];
				int x = @int.x;
				Int3 int2 = st1[i];
				int y = int2.y;
				Int3 int3 = st1[i];
				int z = int3.z;
				regs[y] = reg;
				CompactVoxelSpan compactVoxelSpan = voxelArea.compactSpans[y];
				int num = voxelArea.areaTypes[y];
				for (int j = 0; j < 4; j++)
				{
					if ((long)compactVoxelSpan.GetConnection(j) != 63)
					{
						int num2 = x + voxelArea.DirectionX[j];
						int num3 = z + voxelArea.DirectionZ[j];
						int num4 = (int)voxelArea.compactCells[num2 + num3].index + compactVoxelSpan.GetConnection(j);
						if (num == voxelArea.areaTypes[num4] && regs[num4] == 1)
						{
							regs[num4] = reg;
							st1.Add(new Int3(num2, num4, num3));
						}
					}
				}
			}
		}

		public void BuildRegions()
		{
			int num = voxelArea.width;
			int num2 = voxelArea.depth;
			int num3 = num * num2;
			int num4 = 8;
			int compactSpanCount = voxelArea.compactSpanCount;
			List<int> list = ListPool<int>.Claim(1024);
			ushort[] array = new ushort[compactSpanCount];
			ushort[] array2 = new ushort[compactSpanCount];
			ushort[] array3 = new ushort[compactSpanCount];
			ushort[] array4 = new ushort[compactSpanCount];
			ushort num5 = 2;
			MarkRectWithRegion(0, borderSize, 0, num2, (ushort)(num5 | 0x8000), array);
			num5 = (ushort)(num5 + 1);
			MarkRectWithRegion(num - borderSize, num, 0, num2, (ushort)(num5 | 0x8000), array);
			num5 = (ushort)(num5 + 1);
			MarkRectWithRegion(0, num, 0, borderSize, (ushort)(num5 | 0x8000), array);
			num5 = (ushort)(num5 + 1);
			MarkRectWithRegion(0, num, num2 - borderSize, num2, (ushort)(num5 | 0x8000), array);
			num5 = (ushort)(num5 + 1);
			uint num6 = (uint)((voxelArea.maxDistance + 1) & -2);
			int num7 = 0;
			while (num6 != 0)
			{
				num6 = ((num6 >= 2) ? (num6 - 2) : 0u);
				if (ExpandRegions(num4, num6, array, array2, array3, array4, list) != array)
				{
					ushort[] array5 = array;
					array = array3;
					array3 = array5;
					array5 = array2;
					array2 = array4;
					array4 = array5;
				}
				int num8 = 0;
				int num9 = 0;
				while (num8 < num3)
				{
					for (int i = 0; i < voxelArea.width; i++)
					{
						CompactVoxelCell compactVoxelCell = voxelArea.compactCells[num8 + i];
						int j = (int)compactVoxelCell.index;
						for (int num10 = (int)(compactVoxelCell.index + compactVoxelCell.count); j < num10; j++)
						{
							if (voxelArea.dist[j] >= num6 && array[j] == 0 && voxelArea.areaTypes[j] != 0 && FloodRegion(i, num8, j, num6, num5, array, array2, list))
							{
								num5 = (ushort)(num5 + 1);
							}
						}
					}
					num8 += num;
					num9++;
				}
				num7++;
			}
			if (ExpandRegions(num4 * 8, 0u, array, array2, array3, array4, list) != array)
			{
				ushort[] array6 = array;
				array = array3;
				array3 = array6;
				array6 = array2;
				array2 = array4;
				array4 = array6;
			}
			voxelArea.maxRegions = num5;
			FilterSmallRegions(array, minRegionSize, voxelArea.maxRegions);
			for (int k = 0; k < voxelArea.compactSpanCount; k++)
			{
				voxelArea.compactSpans[k].reg = array[k];
			}
			ListPool<int>.Release(list);
		}

		private static int union_find_find(int[] arr, int x)
		{
			if (arr[x] < 0)
			{
				return x;
			}
			return arr[x] = union_find_find(arr, arr[x]);
		}

		private static void union_find_union(int[] arr, int a, int b)
		{
			a = union_find_find(arr, a);
			b = union_find_find(arr, b);
			if (a != b)
			{
				if (arr[a] > arr[b])
				{
					int num = a;
					a = b;
					b = num;
				}
				arr[a] += arr[b];
				arr[b] = a;
			}
		}

		public void FilterSmallRegions(ushort[] reg, int minRegionSize, int maxRegions)
		{
			RelevantGraphSurface relevantGraphSurface = RelevantGraphSurface.Root;
			bool flag = relevantGraphSurface != null && relevantGraphSurfaceMode != RecastGraph.RelevantGraphSurfaceMode.DoNotRequire;
			if (!flag && minRegionSize <= 0)
			{
				return;
			}
			int[] array = new int[maxRegions];
			ushort[] array2 = voxelArea.tmpUShortArr;
			if (array2 == null || array2.Length < maxRegions)
			{
				array2 = (voxelArea.tmpUShortArr = new ushort[maxRegions]);
			}
			Pathfinding.Util.Memory.MemSet(array, -1, 4);
			Pathfinding.Util.Memory.MemSet(array2, (ushort)0, maxRegions, 2);
			int num = array.Length;
			int num2 = voxelArea.width * voxelArea.depth;
			int num3 = 2 | ((relevantGraphSurfaceMode == RecastGraph.RelevantGraphSurfaceMode.OnlyForCompletelyInsideTile) ? 1 : 0);
			if (flag)
			{
				while (relevantGraphSurface != null)
				{
					VectorToIndex(relevantGraphSurface.Position, out int x, out int z);
					if (x < 0 || z < 0 || x >= voxelArea.width || z >= voxelArea.depth)
					{
						relevantGraphSurface = relevantGraphSurface.Next;
						continue;
					}
					Vector3 position = relevantGraphSurface.Position;
					int num4 = (int)((position.y - voxelOffset.y) / cellHeight);
					int num5 = (int)(relevantGraphSurface.maxRange / cellHeight);
					CompactVoxelCell compactVoxelCell = voxelArea.compactCells[x + z * voxelArea.width];
					for (int i = (int)compactVoxelCell.index; i < compactVoxelCell.index + compactVoxelCell.count; i++)
					{
						CompactVoxelSpan compactVoxelSpan = voxelArea.compactSpans[i];
						if (Math.Abs(compactVoxelSpan.y - num4) <= num5 && reg[i] != 0)
						{
							array2[union_find_find(array, reg[i] & -32769)] |= 2;
						}
					}
					relevantGraphSurface = relevantGraphSurface.Next;
				}
			}
			int num6 = 0;
			int num7 = 0;
			while (num6 < num2)
			{
				for (int j = 0; j < voxelArea.width; j++)
				{
					CompactVoxelCell compactVoxelCell2 = voxelArea.compactCells[j + num6];
					for (int k = (int)compactVoxelCell2.index; k < compactVoxelCell2.index + compactVoxelCell2.count; k++)
					{
						CompactVoxelSpan compactVoxelSpan2 = voxelArea.compactSpans[k];
						int num8 = reg[k];
						if ((num8 & -32769) == 0)
						{
							continue;
						}
						if (num8 >= num)
						{
							array2[union_find_find(array, num8 & -32769)] |= 1;
							continue;
						}
						int num9 = union_find_find(array, num8);
						array[num9]--;
						for (int l = 0; l < 4; l++)
						{
							if ((long)compactVoxelSpan2.GetConnection(l) == 63)
							{
								continue;
							}
							int num10 = j + voxelArea.DirectionX[l];
							int num11 = num6 + voxelArea.DirectionZ[l];
							int num12 = (int)voxelArea.compactCells[num10 + num11].index + compactVoxelSpan2.GetConnection(l);
							int num13 = reg[num12];
							if (num8 != num13 && (num13 & -32769) != 0)
							{
								if ((num13 & 0x8000) != 0)
								{
									array2[num9] |= 1;
								}
								else
								{
									union_find_union(array, num9, num13);
								}
							}
						}
					}
				}
				num6 += voxelArea.width;
				num7++;
			}
			for (int m = 0; m < array.Length; m++)
			{
				array2[union_find_find(array, m)] |= array2[m];
			}
			for (int n = 0; n < array.Length; n++)
			{
				int num14 = union_find_find(array, n);
				if ((array2[num14] & 1) != 0)
				{
					array[num14] = -minRegionSize - 2;
				}
				if (flag && (array2[num14] & num3) == 0)
				{
					array[num14] = -1;
				}
			}
			for (int num15 = 0; num15 < voxelArea.compactSpanCount; num15++)
			{
				int num16 = reg[num15];
				if (num16 < num && array[union_find_find(array, num16)] >= -minRegionSize - 1)
				{
					reg[num15] = 0;
				}
			}
		}
	}
	public class Utility
	{
		public static Color[] colors = new Color[7]
		{
			Color.green,
			Color.blue,
			Color.red,
			Color.yellow,
			Color.cyan,
			Color.white,
			Color.black
		};

		public static float lastStartTime;

		public static float lastAdditiveTimerStart;

		public static float additiveTimer;

		private static float[] clipPolygonCache = new float[21];

		private static int[] clipPolygonIntCache = new int[21];

		public static Color GetColor(int i)
		{
			while (i >= colors.Length)
			{
				i -= colors.Length;
			}
			while (i < 0)
			{
				i += colors.Length;
			}
			return colors[i];
		}

		public static int Bit(int a, int b)
		{
			return (a & (1 << b)) >> b;
		}

		public static Color IntToColor(int i, float a)
		{
			int num = Bit(i, 1) + Bit(i, 3) * 2 + 1;
			int num2 = Bit(i, 2) + Bit(i, 4) * 2 + 1;
			int num3 = Bit(i, 0) + Bit(i, 5) * 2 + 1;
			return new Color((float)num * 0.25f, (float)num2 * 0.25f, (float)num3 * 0.25f, a);
		}

		public static float TriangleArea2(Vector3 a, Vector3 b, Vector3 c)
		{
			return Mathf.Abs(a.x * b.z + b.x * c.z + c.x * a.z - a.x * c.z - c.x * b.z - b.x * a.z);
		}

		public static float TriangleArea(Vector3 a, Vector3 b, Vector3 c)
		{
			return (b.x - a.x) * (c.z - a.z) - (c.x - a.x) * (b.z - a.z);
		}

		public static float Min(float a, float b, float c)
		{
			a = ((!(a < b)) ? b : a);
			return (!(a < c)) ? c : a;
		}

		public static float Max(float a, float b, float c)
		{
			a = ((!(a > b)) ? b : a);
			return (!(a > c)) ? c : a;
		}

		public static int Max(int a, int b, int c, int d)
		{
			a = ((a <= b) ? b : a);
			a = ((a <= c) ? c : a);
			return (a <= d) ? d : a;
		}

		public static int Min(int a, int b, int c, int d)
		{
			a = ((a >= b) ? b : a);
			a = ((a >= c) ? c : a);
			return (a >= d) ? d : a;
		}

		public static float Max(float a, float b, float c, float d)
		{
			a = ((!(a > b)) ? b : a);
			a = ((!(a > c)) ? c : a);
			return (!(a > d)) ? d : a;
		}

		public static float Min(float a, float b, float c, float d)
		{
			a = ((!(a < b)) ? b : a);
			a = ((!(a < c)) ? c : a);
			return (!(a < d)) ? d : a;
		}

		public static string ToMillis(float v)
		{
			return (v * 1000f).ToString("0");
		}

		public static void StartTimer()
		{
			lastStartTime = Time.realtimeSinceStartup;
		}

		public static void EndTimer(string label)
		{
			UnityEngine.Debug.Log(label + ", process took " + ToMillis(Time.realtimeSinceStartup - lastStartTime) + "ms to complete");
		}

		public static void StartTimerAdditive(bool reset)
		{
			if (reset)
			{
				additiveTimer = 0f;
			}
			lastAdditiveTimerStart = Time.realtimeSinceStartup;
		}

		public static void EndTimerAdditive(string label, bool log)
		{
			additiveTimer += Time.realtimeSinceStartup - lastAdditiveTimerStart;
			if (log)
			{
				UnityEngine.Debug.Log(label + ", process took " + ToMillis(additiveTimer) + "ms to complete");
			}
			lastAdditiveTimerStart = Time.realtimeSinceStartup;
		}

		public static void CopyVector(float[] a, int i, Vector3 v)
		{
			a[i] = v.x;
			a[i + 1] = v.y;
			a[i + 2] = v.z;
		}

		public static int ClipPoly(float[] vIn, int n, float[] vOut, float pnx, float pnz, float pd)
		{
			float[] array = clipPolygonCache;
			for (int i = 0; i < n; i++)
			{
				array[i] = pnx * vIn[i * 3] + pnz * vIn[i * 3 + 2] + pd;
			}
			int num = 0;
			int j = 0;
			int num2 = n - 1;
			for (; j < n; j++)
			{
				bool flag = array[num2] >= 0f;
				bool flag2 = array[j] >= 0f;
				if (flag != flag2)
				{
					float num3 = array[num2] / (array[num2] - array[j]);
					vOut[num * 3] = vIn[num2 * 3] + (vIn[j * 3] - vIn[num2 * 3]) * num3;
					vOut[num * 3 + 1] = vIn[num2 * 3 + 1] + (vIn[j * 3 + 1] - vIn[num2 * 3 + 1]) * num3;
					vOut[num * 3 + 2] = vIn[num2 * 3 + 2] + (vIn[j * 3 + 2] - vIn[num2 * 3 + 2]) * num3;
					num++;
				}
				if (flag2)
				{
					vOut[num * 3] = vIn[j * 3];
					vOut[num * 3 + 1] = vIn[j * 3 + 1];
					vOut[num * 3 + 2] = vIn[j * 3 + 2];
					num++;
				}
				num2 = j;
			}
			return num;
		}

		public static int ClipPolygon(float[] vIn, int n, float[] vOut, float multi, float offset, int axis)
		{
			float[] array = clipPolygonCache;
			for (int i = 0; i < n; i++)
			{
				array[i] = multi * vIn[i * 3 + axis] + offset;
			}
			int num = 0;
			int j = 0;
			int num2 = n - 1;
			for (; j < n; j++)
			{
				bool flag = array[num2] >= 0f;
				bool flag2 = array[j] >= 0f;
				if (flag != flag2)
				{
					int num3 = num * 3;
					int num4 = j * 3;
					int num5 = num2 * 3;
					float num6 = array[num2] / (array[num2] - array[j]);
					vOut[num3] = vIn[num5] + (vIn[num4] - vIn[num5]) * num6;
					vOut[num3 + 1] = vIn[num5 + 1] + (vIn[num4 + 1] - vIn[num5 + 1]) * num6;
					vOut[num3 + 2] = vIn[num5 + 2] + (vIn[num4 + 2] - vIn[num5 + 2]) * num6;
					num++;
				}
				if (flag2)
				{
					int num7 = num * 3;
					int num8 = j * 3;
					vOut[num7] = vIn[num8];
					vOut[num7 + 1] = vIn[num8 + 1];
					vOut[num7 + 2] = vIn[num8 + 2];
					num++;
				}
				num2 = j;
			}
			return num;
		}

		public static int ClipPolygonY(float[] vIn, int n, float[] vOut, float multi, float offset, int axis)
		{
			float[] array = clipPolygonCache;
			for (int i = 0; i < n; i++)
			{
				array[i] = multi * vIn[i * 3 + axis] + offset;
			}
			int num = 0;
			int j = 0;
			int num2 = n - 1;
			for (; j < n; j++)
			{
				bool flag = array[num2] >= 0f;
				bool flag2 = array[j] >= 0f;
				if (flag != flag2)
				{
					vOut[num * 3 + 1] = vIn[num2 * 3 + 1] + (vIn[j * 3 + 1] - vIn[num2 * 3 + 1]) * (array[num2] / (array[num2] - array[j]));
					num++;
				}
				if (flag2)
				{
					vOut[num * 3 + 1] = vIn[j * 3 + 1];
					num++;
				}
				num2 = j;
			}
			return num;
		}

		public static int ClipPolygon(Vector3[] vIn, int n, Vector3[] vOut, float multi, float offset, int axis)
		{
			float[] array = clipPolygonCache;
			for (int i = 0; i < n; i++)
			{
				array[i] = multi * vIn[i][axis] + offset;
			}
			int num = 0;
			int j = 0;
			int num2 = n - 1;
			for (; j < n; j++)
			{
				bool flag = array[num2] >= 0f;
				bool flag2 = array[j] >= 0f;
				if (flag != flag2)
				{
					float d = array[num2] / (array[num2] - array[j]);
					vOut[num] = vIn[num2] + (vIn[j] - vIn[num2]) * d;
					num++;
				}
				if (flag2)
				{
					vOut[num] = vIn[j];
					num++;
				}
				num2 = j;
			}
			return num;
		}

		public static int ClipPolygon(Int3[] vIn, int n, Int3[] vOut, int multi, int offset, int axis)
		{
			int[] array = clipPolygonIntCache;
			for (int i = 0; i < n; i++)
			{
				array[i] = multi * vIn[i][axis] + offset;
			}
			int num = 0;
			int j = 0;
			int num2 = n - 1;
			for (; j < n; j++)
			{
				bool flag = array[num2] >= 0;
				bool flag2 = array[j] >= 0;
				if (flag != flag2)
				{
					double rhs = (double)array[num2] / (double)(array[num2] - array[j]);
					vOut[num] = vIn[num2] + (vIn[j] - vIn[num2]) * rhs;
					num++;
				}
				if (flag2)
				{
					vOut[num] = vIn[j];
					num++;
				}
				num2 = j;
			}
			return num;
		}

		public static bool IntersectXAxis(out Vector3 intersection, Vector3 start1, Vector3 dir1, float x)
		{
			float x2 = dir1.x;
			if (x2 == 0f)
			{
				intersection = Vector3.zero;
				return false;
			}
			float num = x - start1.x;
			float value = num / x2;
			value = Mathf.Clamp01(value);
			intersection = start1 + dir1 * value;
			return true;
		}

		public static bool IntersectZAxis(out Vector3 intersection, Vector3 start1, Vector3 dir1, float z)
		{
			float num = 0f - dir1.z;
			if (num == 0f)
			{
				intersection = Vector3.zero;
				return false;
			}
			float num2 = start1.z - z;
			float value = num2 / num;
			value = Mathf.Clamp01(value);
			intersection = start1 + dir1 * value;
			return true;
		}
	}
}
namespace Pathfinding
{
	[RequireComponent(typeof(CharacterController))]
	public class LocalAvoidance : MonoBehaviour
	{
		public enum ResolutionType
		{
			Sampled,
			Geometric
		}

		public struct VOLine
		{
			public VO vo;

			public Vector3 start;

			public Vector3 end;

			public bool inf;

			public int id;

			public bool wrongSide;

			public VOLine(VO vo, Vector3 start, Vector3 end, bool inf, int id, bool wrongSide)
			{
				this.vo = vo;
				this.start = start;
				this.end = end;
				this.inf = inf;
				this.id = id;
				this.wrongSide = wrongSide;
			}
		}

		public struct VOIntersection
		{
			public VO vo1;

			public VO vo2;

			public float factor1;

			public float factor2;

			public bool inside;

			public VOIntersection(VO vo1, VO vo2, float factor1, float factor2, bool inside = false)
			{
				this.vo1 = vo1;
				this.vo2 = vo2;
				this.factor1 = factor1;
				this.factor2 = factor2;
				this.inside = inside;
			}
		}

		public class HalfPlane
		{
			public Vector3 point;

			public Vector3 normal;

			public bool Contains(Vector3 p)
			{
				p -= point;
				return Vector3.Dot(normal, p) >= 0f;
			}

			public Vector3 ClosestPoint(Vector3 p)
			{
				p -= point;
				Vector3 vector = Vector3.Cross(normal, Vector3.up);
				float d = Vector3.Dot(vector, p);
				return point + vector * d;
			}

			public Vector3 ClosestPoint(Vector3 p, float minX, float maxX)
			{
				p -= point;
				Vector3 vector = Vector3.Cross(normal, Vector3.up);
				if (vector.x < 0f)
				{
					vector = -vector;
				}
				float value = Vector3.Dot(vector, p);
				float min = (minX - point.x) / vector.x;
				float max = (maxX - point.x) / vector.x;
				value = Mathf.Clamp(value, min, max);
				return point + vector * value;
			}

			public Vector3 Intersection(HalfPlane hp)
			{
				Vector3 dir = Vector3.Cross(normal, Vector3.up);
				Vector3 dir2 = Vector3.Cross(hp.normal, Vector3.up);
				return Polygon.IntersectionPointOptimized(point, dir, hp.point, dir2);
			}

			public void DrawBounds(float left, float right)
			{
				Vector3 a = Vector3.Cross(normal, Vector3.up);
				if (a.x < 0f)
				{
					a = -a;
				}
				float d = (left - point.x) / a.x;
				float d2 = (right - point.x) / a.x;
				UnityEngine.Debug.DrawLine(point + a * d + Vector3.up * 0.1f, point + a * d2 + Vector3.up * 0.1f, Color.yellow);
			}

			public void Draw()
			{
				Vector3 a = Vector3.Cross(normal, Vector3.up);
				UnityEngine.Debug.DrawLine(point - a * 10f, point + a * 10f, Color.blue);
				UnityEngine.Debug.DrawRay(point, normal, new Color(0.8f, 0.1f, 0.2f));
			}
		}

		public enum IntersectionState
		{
			Inside,
			Outside,
			Enter,
			Exit
		}

		public struct IntersectionPair : IComparable<IntersectionPair>
		{
			public float factor;

			public IntersectionState state;

			public IntersectionPair(float factor, bool inside)
			{
				this.factor = factor;
				state = ((!inside) ? IntersectionState.Outside : IntersectionState.Inside);
			}

			public void SetState(IntersectionState s)
			{
				state = s;
			}

			public int CompareTo(IntersectionPair o)
			{
				if (o.factor < factor)
				{
					return 1;
				}
				if (o.factor > factor)
				{
					return -1;
				}
				return 0;
			}
		}

		public class VO
		{
			public Vector3 origin;

			public Vector3 direction;

			public float angle;

			public float limit;

			public Vector3 pLeft;

			public Vector3 pRight;

			public Vector3 nLeft;

			public Vector3 nRight;

			public List<IntersectionPair> ints1 = new List<IntersectionPair>();

			public List<IntersectionPair> ints2 = new List<IntersectionPair>();

			public List<IntersectionPair> ints3 = new List<IntersectionPair>();

			public void AddInt(float factor, bool inside, int id)
			{
				switch (id)
				{
				case 1:
					ints1.Add(new IntersectionPair(factor, inside));
					break;
				case 2:
					ints2.Add(new IntersectionPair(factor, inside));
					break;
				case 3:
					ints3.Add(new IntersectionPair(factor, inside));
					break;
				}
			}

			public bool FinalInts(Vector3 target, Vector3 closeEdgeConstraint, bool drawGizmos, out Vector3 closest)
			{
				ints1.Sort();
				ints2.Sort();
				ints3.Sort();
				float num = (float)Math.Atan2(direction.z, direction.x);
				Vector3 vector = Vector3.Cross(direction, Vector3.up);
				Vector3 b = vector * (float)Math.Tan(angle) * limit;
				Vector3 vector2 = origin + direction * limit + b;
				Vector3 vector3 = origin + direction * limit - b;
				Vector3 vector4 = vector2 + new Vector3((float)Math.Cos(num + angle), 0f, (float)Math.Sin(num + angle)) * 100f;
				Vector3 vector5 = vector3 + new Vector3((float)Math.Cos(num - angle), 0f, (float)Math.Sin(num - angle)) * 100f;
				bool flag = false;
				closest = Vector3.zero;
				int num2 = (!(Vector3.Dot(closeEdgeConstraint - origin, vector) > 0f)) ? 1 : 2;
				for (int i = 1; i <= 3; i++)
				{
					if (i == num2)
					{
						continue;
					}
					List<IntersectionPair> list;
					switch (i)
					{
					case 1:
						list = ints1;
						break;
					case 2:
						list = ints2;
						break;
					default:
						list = ints3;
						break;
					}
					List<IntersectionPair> list2 = list;
					Vector3 vector6 = (i != 1 && i != 3) ? vector3 : vector2;
					Vector3 vector7;
					switch (i)
					{
					case 1:
						vector7 = vector4;
						break;
					case 2:
						vector7 = vector5;
						break;
					default:
						vector7 = vector3;
						break;
					}
					Vector3 vector8 = vector7;
					float num3 = AstarMath.NearestPointFactor(vector6, vector8, target);
					float num4 = float.PositiveInfinity;
					float num5 = float.NegativeInfinity;
					bool flag2 = false;
					for (int j = 0; j < list2.Count - ((i == 3) ? 1 : 0); j++)
					{
						if (drawGizmos)
						{
							Vector3 a = vector8 - vector6;
							IntersectionPair intersectionPair = list2[j];
							Vector3 start = vector6 + a * intersectionPair.factor;
							Vector3 down = Vector3.down;
							IntersectionPair intersectionPair2 = list2[j];
							UnityEngine.Debug.DrawRay(start, down, (intersectionPair2.state != IntersectionState.Outside) ? Color.red : Color.green);
						}
						IntersectionPair intersectionPair3 = list2[j];
						if (intersectionPair3.state != IntersectionState.Outside)
						{
							continue;
						}
						if (j != list2.Count - 1)
						{
							goto IL_02ac;
						}
						if (j != 0)
						{
							IntersectionPair intersectionPair4 = list2[j - 1];
							if (intersectionPair4.state == IntersectionState.Outside)
							{
								goto IL_02ac;
							}
						}
						goto IL_02d6;
						IL_02ac:
						if (j >= list2.Count - 1)
						{
							continue;
						}
						IntersectionPair intersectionPair5 = list2[j + 1];
						if (intersectionPair5.state != IntersectionState.Outside)
						{
							continue;
						}
						goto IL_02d6;
						IL_02d6:
						flag2 = true;
						IntersectionPair intersectionPair6 = list2[j];
						float factor = intersectionPair6.factor;
						float num6;
						if (j == list2.Count - 1)
						{
							num6 = ((i != 3) ? float.PositiveInfinity : 1f);
						}
						else
						{
							IntersectionPair intersectionPair7 = list2[j + 1];
							num6 = intersectionPair7.factor;
						}
						float num7 = num6;
						if (drawGizmos)
						{
							UnityEngine.Debug.DrawLine(vector6 + (vector8 - vector6) * factor + Vector3.up, vector6 + (vector8 - vector6) * Mathf.Clamp01(num7) + Vector3.up, Color.green);
						}
						if (factor <= num3 && num7 >= num3)
						{
							num4 = num3;
							num5 = num3;
							break;
						}
						if (num7 < num3 && num7 > num5)
						{
							num5 = num7;
						}
						else if (factor > num3 && factor < num4)
						{
							num4 = factor;
						}
					}
					if (flag2)
					{
						float d = (num4 == float.NegativeInfinity) ? num5 : ((num5 == float.PositiveInfinity) ? num4 : ((!(Mathf.Abs(num3 - num4) < Mathf.Abs(num3 - num5))) ? num5 : num4));
						Vector3 vector9 = vector6 + (vector8 - vector6) * d;
						if (!flag || (vector9 - target).sqrMagnitude < (closest - target).sqrMagnitude)
						{
							closest = vector9;
						}
						if (drawGizmos)
						{
							UnityEngine.Debug.DrawLine(target, closest, Color.yellow);
						}
						flag = true;
					}
				}
				return flag;
			}

			public bool Contains(Vector3 p)
			{
				return Vector3.Dot(nLeft, p - origin) > 0f && Vector3.Dot(nRight, p - origin) > 0f && Vector3.Dot(direction, p - origin) > limit;
			}

			public float ScoreContains(Vector3 p)
			{
				return 0f;
			}

			public void Draw(Color c)
			{
				float num = (float)Math.Atan2(direction.z, direction.x);
				Vector3 b = Vector3.Cross(direction, Vector3.up) * (float)Math.Tan(angle) * limit;
				UnityEngine.Debug.DrawLine(origin + direction * limit + b, origin + direction * limit - b, c);
				UnityEngine.Debug.DrawRay(origin + direction * limit + b, new Vector3((float)Math.Cos(num + angle), 0f, (float)Math.Sin(num + angle)) * 10f, c);
				UnityEngine.Debug.DrawRay(origin + direction * limit - b, new Vector3((float)Math.Cos(num - angle), 0f, (float)Math.Sin(num - angle)) * 10f, c);
			}

			public static explicit operator HalfPlane(VO vo)
			{
				HalfPlane halfPlane = new HalfPlane();
				halfPlane.point = vo.origin + vo.direction * vo.limit;
				halfPlane.normal = -vo.direction;
				return halfPlane;
			}
		}

		public const float Rad2Deg = 57.29578f;

		private const int maxVOCounter = 50;

		public float speed = 2f;

		public float delta = 1f;

		public float responability = 0.5f;

		public ResolutionType resType = ResolutionType.Geometric;

		private Vector3 velocity;

		public float radius = 0.5f;

		public float maxSpeedScale = 1.5f;

		public Vector3[] samples;

		public float sampleScale = 1f;

		public float circleScale = 0.5f;

		public float circlePoint = 0.5f;

		public bool drawGizmos;

		protected CharacterController controller;

		protected LocalAvoidance[] agents;

		private Vector3 preVelocity;

		private List<VO> vos = new List<VO>();

		private void Start()
		{
			controller = GetComponent<CharacterController>();
			agents = (UnityEngine.Object.FindObjectsOfType(typeof(LocalAvoidance)) as LocalAvoidance[]);
		}

		public void Update()
		{
			SimpleMove(base.transform.forward * speed);
		}

		public Vector3 GetVelocity()
		{
			return preVelocity;
		}

		public void LateUpdate()
		{
			preVelocity = velocity;
		}

		public void SimpleMove(Vector3 desiredMovement)
		{
			Vector3 b = UnityEngine.Random.insideUnitSphere * 0.1f;
			b.y = 0f;
			Vector3 vector = ClampMovement(desiredMovement + b);
			if (vector != Vector3.zero)
			{
				vector /= delta;
			}
			if (drawGizmos)
			{
				UnityEngine.Debug.DrawRay(base.transform.position, desiredMovement, Color.magenta);
				UnityEngine.Debug.DrawRay(base.transform.position, vector, Color.yellow);
				UnityEngine.Debug.DrawRay(base.transform.position + vector, Vector3.up, Color.yellow);
			}
			controller.SimpleMove(vector);
			velocity = controller.velocity;
			UnityEngine.Debug.DrawRay(base.transform.position, velocity, Color.blue);
		}

		public Vector3 ClampMovement(Vector3 direction)
		{
			Vector3 vector = direction * delta;
			Vector3 vector2 = base.transform.position + direction;
			Vector3 vector3 = vector2;
			float num = 0f;
			int num2 = 0;
			vos.Clear();
			float magnitude = velocity.magnitude;
			LocalAvoidance[] array = agents;
			foreach (LocalAvoidance localAvoidance in array)
			{
				if (localAvoidance == this || localAvoidance == null)
				{
					continue;
				}
				Vector3 vector4 = localAvoidance.transform.position - base.transform.position;
				float magnitude2 = vector4.magnitude;
				float num3 = radius + localAvoidance.radius;
				if (!(magnitude2 > vector.magnitude * delta + num3 + magnitude + localAvoidance.GetVelocity().magnitude) && num2 <= 50)
				{
					num2++;
					VO vO = new VO();
					vO.origin = base.transform.position + Vector3.Lerp(velocity * delta, localAvoidance.GetVelocity() * delta, responability);
					vO.direction = vector4.normalized;
					if (num3 > vector4.magnitude)
					{
						vO.angle = (float)Math.PI / 2f;
					}
					else
					{
						vO.angle = (float)Math.Asin(num3 / magnitude2);
					}
					vO.limit = magnitude2 - num3;
					if (vO.limit < 0f)
					{
						vO.origin += vO.direction * vO.limit;
						vO.limit = 0f;
					}
					float num4 = Mathf.Atan2(vO.direction.z, vO.direction.x);
					vO.pRight = new Vector3(Mathf.Cos(num4 + vO.angle), 0f, Mathf.Sin(num4 + vO.angle));
					vO.pLeft = new Vector3(Mathf.Cos(num4 - vO.angle), 0f, Mathf.Sin(num4 - vO.angle));
					vO.nLeft = new Vector3(Mathf.Cos(num4 + vO.angle - (float)Math.PI / 2f), 0f, Mathf.Sin(num4 + vO.angle - (float)Math.PI / 2f));
					vO.nRight = new Vector3(Mathf.Cos(num4 - vO.angle + (float)Math.PI / 2f), 0f, Mathf.Sin(num4 - vO.angle + (float)Math.PI / 2f));
					vos.Add(vO);
				}
			}
			if (resType == ResolutionType.Geometric)
			{
				for (int j = 0; j < vos.Count; j++)
				{
					if (vos[j].Contains(vector3))
					{
						num = float.PositiveInfinity;
						if (drawGizmos)
						{
							UnityEngine.Debug.DrawRay(vector3, Vector3.down, Color.red);
						}
						vector3 = base.transform.position;
						break;
					}
				}
				if (drawGizmos)
				{
					for (int k = 0; k < vos.Count; k++)
					{
						vos[k].Draw(Color.black);
					}
				}
				if (num == 0f)
				{
					return vector;
				}
				List<VOLine> list = new List<VOLine>();
				for (int l = 0; l < vos.Count; l++)
				{
					VO vO2 = vos[l];
					float num5 = (float)Math.Atan2(vO2.direction.z, vO2.direction.x);
					Vector3 vector5 = vO2.origin + new Vector3((float)Math.Cos(num5 + vO2.angle), 0f, (float)Math.Sin(num5 + vO2.angle)) * vO2.limit;
					Vector3 vector6 = vO2.origin + new Vector3((float)Math.Cos(num5 - vO2.angle), 0f, (float)Math.Sin(num5 - vO2.angle)) * vO2.limit;
					Vector3 end = vector5 + new Vector3((float)Math.Cos(num5 + vO2.angle), 0f, (float)Math.Sin(num5 + vO2.angle)) * 100f;
					Vector3 end2 = vector6 + new Vector3((float)Math.Cos(num5 - vO2.angle), 0f, (float)Math.Sin(num5 - vO2.angle)) * 100f;
					int num6 = Polygon.Left(vO2.origin, vO2.origin + vO2.direction, base.transform.position + velocity) ? 1 : 2;
					list.Add(new VOLine(vO2, vector5, end, inf: true, 1, num6 == 1));
					list.Add(new VOLine(vO2, vector6, end2, inf: true, 2, num6 == 2));
					list.Add(new VOLine(vO2, vector5, vector6, inf: false, 3, wrongSide: false));
					bool flag = false;
					bool flag2 = false;
					if (!flag)
					{
						for (int m = 0; m < vos.Count; m++)
						{
							if (m != l && vos[m].Contains(vector5))
							{
								flag = true;
								break;
							}
						}
					}
					if (!flag2)
					{
						for (int n = 0; n < vos.Count; n++)
						{
							if (n != l && vos[n].Contains(vector6))
							{
								flag2 = true;
								break;
							}
						}
					}
					vO2.AddInt(0f, flag, 1);
					vO2.AddInt(0f, flag2, 2);
					vO2.AddInt(0f, flag, 3);
					vO2.AddInt(1f, flag2, 3);
				}
				for (int num7 = 0; num7 < list.Count; num7++)
				{
					for (int num8 = num7 + 1; num8 < list.Count; num8++)
					{
						VOLine vOLine = list[num7];
						VOLine vOLine2 = list[num8];
						if (vOLine.vo == vOLine2.vo || !Polygon.IntersectionFactor(vOLine.start, vOLine.end, vOLine2.start, vOLine2.end, out float factor, out float factor2) || factor < 0f || factor2 < 0f || (!vOLine.inf && factor > 1f) || (!vOLine2.inf && factor2 > 1f))
						{
							continue;
						}
						Vector3 p = vOLine.start + (vOLine.end - vOLine.start) * factor;
						bool flag3 = vOLine.wrongSide || vOLine2.wrongSide;
						if (!flag3)
						{
							for (int num9 = 0; num9 < vos.Count; num9++)
							{
								if (vos[num9] != vOLine.vo && vos[num9] != vOLine2.vo && vos[num9].Contains(p))
								{
									flag3 = true;
									break;
								}
							}
						}
						vOLine.vo.AddInt(factor, flag3, vOLine.id);
						vOLine2.vo.AddInt(factor2, flag3, vOLine2.id);
						if (drawGizmos)
						{
							UnityEngine.Debug.DrawRay(vOLine.start + (vOLine.end - vOLine.start) * factor, Vector3.up, (!flag3) ? Color.green : Color.magenta);
						}
					}
				}
				for (int num10 = 0; num10 < vos.Count; num10++)
				{
					if (!vos[num10].FinalInts(vector2, base.transform.position + velocity, drawGizmos, out Vector3 closest))
					{
						continue;
					}
					float sqrMagnitude = (closest - vector2).sqrMagnitude;
					if (sqrMagnitude < num)
					{
						vector3 = closest;
						num = sqrMagnitude;
						if (drawGizmos)
						{
							UnityEngine.Debug.DrawLine(vector2 + Vector3.up, vector3 + Vector3.up, Color.red);
						}
					}
				}
				if (drawGizmos)
				{
					UnityEngine.Debug.DrawLine(vector2 + Vector3.up, vector3 + Vector3.up, Color.red);
				}
				return Vector3.ClampMagnitude(vector3 - base.transform.position, vector.magnitude * maxSpeedScale);
			}
			if (resType == ResolutionType.Sampled)
			{
				Vector3 a = vector;
				Vector3 normalized = a.normalized;
				Vector3 a2 = Vector3.Cross(normalized, Vector3.up);
				int num11 = 10;
				int num12 = 0;
				while (num12 < 10)
				{
					float num13 = (float)(Math.PI * (double)circlePoint / (double)num11);
					float num14 = (float)(Math.PI - (double)circlePoint * Math.PI) * 0.5f;
					for (int num15 = 0; num15 < num11; num15++)
					{
						float num16 = num13 * (float)num15;
						Vector3 vector7 = base.transform.position + vector - (a * (float)Math.Sin(num16 + num14) * num12 * circleScale + a2 * (float)Math.Cos(num16 + num14) * num12 * circleScale);
						if (CheckSample(vector7, vos))
						{
							return vector7 - base.transform.position;
						}
					}
					num12++;
					num11 += 2;
				}
				for (int num17 = 0; num17 < samples.Length; num17++)
				{
					Vector3 vector8 = base.transform.position + samples[num17].x * a2 + samples[num17].z * normalized + samples[num17].y * a;
					if (CheckSample(vector8, vos))
					{
						return vector8 - base.transform.position;
					}
				}
				return Vector3.zero;
			}
			return Vector3.zero;
		}

		public bool CheckSample(Vector3 sample, List<VO> vos)
		{
			bool flag = false;
			for (int i = 0; i < vos.Count; i++)
			{
				if (vos[i].Contains(sample))
				{
					if (drawGizmos)
					{
						UnityEngine.Debug.DrawRay(sample, Vector3.up, Color.red);
					}
					flag = true;
					break;
				}
			}
			if (drawGizmos && !flag)
			{
				UnityEngine.Debug.DrawRay(sample, Vector3.up, Color.yellow);
			}
			return !flag;
		}
	}
	[Serializable]
	[AddComponentMenu("Pathfinding/Modifiers/Advanced Smooth")]
	public class AdvancedSmooth : MonoModifier
	{
		[Serializable]
		public class MaxTurn : TurnConstructor
		{
			private Vector3 preRightCircleCenter = Vector3.zero;

			private Vector3 preLeftCircleCenter = Vector3.zero;

			private Vector3 rightCircleCenter;

			private Vector3 leftCircleCenter;

			private double vaRight;

			private double vaLeft;

			private double preVaLeft;

			private double preVaRight;

			private double gammaLeft;

			private double gammaRight;

			private double betaRightRight;

			private double betaRightLeft;

			private double betaLeftRight;

			private double betaLeftLeft;

			private double deltaRightLeft;

			private double deltaLeftRight;

			private double alfaRightRight;

			private double alfaLeftLeft;

			private double alfaRightLeft;

			private double alfaLeftRight;

			public override void OnTangentUpdate()
			{
				rightCircleCenter = TurnConstructor.current + TurnConstructor.normal * TurnConstructor.turningRadius;
				leftCircleCenter = TurnConstructor.current - TurnConstructor.normal * TurnConstructor.turningRadius;
				vaRight = Atan2(TurnConstructor.current - rightCircleCenter);
				vaLeft = vaRight + Math.PI;
			}

			public override void Prepare(int i, Vector3[] vectorPath)
			{
				preRightCircleCenter = rightCircleCenter;
				preLeftCircleCenter = leftCircleCenter;
				rightCircleCenter = TurnConstructor.current + TurnConstructor.normal * TurnConstructor.turningRadius;
				leftCircleCenter = TurnConstructor.current - TurnConstructor.normal * TurnConstructor.turningRadius;
				preVaRight = vaRight;
				preVaLeft = vaLeft;
				vaRight = Atan2(TurnConstructor.current - rightCircleCenter);
				vaLeft = vaRight + Math.PI;
			}

			public override void TangentToTangent(List<Turn> turnList)
			{
				alfaRightRight = Atan2(rightCircleCenter - preRightCircleCenter);
				alfaLeftLeft = Atan2(leftCircleCenter - preLeftCircleCenter);
				alfaRightLeft = Atan2(leftCircleCenter - preRightCircleCenter);
				alfaLeftRight = Atan2(rightCircleCenter - preLeftCircleCenter);
				double num = (leftCircleCenter - preRightCircleCenter).magnitude;
				double num2 = (rightCircleCenter - preLeftCircleCenter).magnitude;
				bool flag = false;
				bool flag2 = false;
				if (num < (double)(TurnConstructor.turningRadius * 2f))
				{
					num = TurnConstructor.turningRadius * 2f;
					flag = true;
				}
				if (num2 < (double)(TurnConstructor.turningRadius * 2f))
				{
					num2 = TurnConstructor.turningRadius * 2f;
					flag2 = true;
				}
				deltaRightLeft = ((!flag) ? (Math.PI / 2.0 - Math.Asin((double)(TurnConstructor.turningRadius * 2f) / num)) : 0.0);
				deltaLeftRight = ((!flag2) ? (Math.PI / 2.0 - Math.Asin((double)(TurnConstructor.turningRadius * 2f) / num2)) : 0.0);
				betaRightRight = ClockwiseAngle(preVaRight, alfaRightRight - Math.PI / 2.0);
				betaRightLeft = ClockwiseAngle(preVaRight, alfaRightLeft - deltaRightLeft);
				betaLeftRight = CounterClockwiseAngle(preVaLeft, alfaLeftRight + deltaLeftRight);
				betaLeftLeft = CounterClockwiseAngle(preVaLeft, alfaLeftLeft + Math.PI / 2.0);
				betaRightRight += ClockwiseAngle(alfaRightRight - Math.PI / 2.0, vaRight);
				betaRightLeft += CounterClockwiseAngle(alfaRightLeft + deltaRightLeft, vaLeft);
				betaLeftRight += ClockwiseAngle(alfaLeftRight - deltaLeftRight, vaRight);
				betaLeftLeft += CounterClockwiseAngle(alfaLeftLeft + Math.PI / 2.0, vaLeft);
				betaRightRight = GetLengthFromAngle(betaRightRight, TurnConstructor.turningRadius);
				betaRightLeft = GetLengthFromAngle(betaRightLeft, TurnConstructor.turningRadius);
				betaLeftRight = GetLengthFromAngle(betaLeftRight, TurnConstructor.turningRadius);
				betaLeftLeft = GetLengthFromAngle(betaLeftLeft, TurnConstructor.turningRadius);
				Vector3 a = AngleToVector(alfaRightRight - Math.PI / 2.0) * TurnConstructor.turningRadius + preRightCircleCenter;
				Vector3 a2 = AngleToVector(alfaRightLeft - deltaRightLeft) * TurnConstructor.turningRadius + preRightCircleCenter;
				Vector3 a3 = AngleToVector(alfaLeftRight + deltaLeftRight) * TurnConstructor.turningRadius + preLeftCircleCenter;
				Vector3 a4 = AngleToVector(alfaLeftLeft + Math.PI / 2.0) * TurnConstructor.turningRadius + preLeftCircleCenter;
				Vector3 b = AngleToVector(alfaRightRight - Math.PI / 2.0) * TurnConstructor.turningRadius + rightCircleCenter;
				Vector3 b2 = AngleToVector(alfaRightLeft - deltaRightLeft + Math.PI) * TurnConstructor.turningRadius + leftCircleCenter;
				Vector3 b3 = AngleToVector(alfaLeftRight + deltaLeftRight + Math.PI) * TurnConstructor.turningRadius + rightCircleCenter;
				Vector3 b4 = AngleToVector(alfaLeftLeft + Math.PI / 2.0) * TurnConstructor.turningRadius + leftCircleCenter;
				betaRightRight += (a - b).magnitude;
				betaRightLeft += (a2 - b2).magnitude;
				betaLeftRight += (a3 - b3).magnitude;
				betaLeftLeft += (a4 - b4).magnitude;
				if (flag)
				{
					betaRightLeft += 10000000.0;
				}
				if (flag2)
				{
					betaLeftRight += 10000000.0;
				}
				turnList.Add(new Turn((float)betaRightRight, this, 2));
				turnList.Add(new Turn((float)betaRightLeft, this, 3));
				turnList.Add(new Turn((float)betaLeftRight, this, 4));
				turnList.Add(new Turn((float)betaLeftLeft, this, 5));
			}

			public override void PointToTangent(List<Turn> turnList)
			{
				bool flag = false;
				bool flag2 = false;
				float magnitude = (TurnConstructor.prev - rightCircleCenter).magnitude;
				float magnitude2 = (TurnConstructor.prev - leftCircleCenter).magnitude;
				if (magnitude < TurnConstructor.turningRadius)
				{
					flag = true;
				}
				if (magnitude2 < TurnConstructor.turningRadius)
				{
					flag2 = true;
				}
				double num = (!flag) ? Atan2(TurnConstructor.prev - rightCircleCenter) : 0.0;
				double num2 = (!flag) ? (Math.PI / 2.0 - Math.Asin(TurnConstructor.turningRadius / (TurnConstructor.prev - rightCircleCenter).magnitude)) : 0.0;
				gammaRight = num + num2;
				double num3 = (!flag) ? ClockwiseAngle(gammaRight, vaRight) : 0.0;
				double num4 = (!flag2) ? Atan2(TurnConstructor.prev - leftCircleCenter) : 0.0;
				double num5 = (!flag2) ? (Math.PI / 2.0 - Math.Asin(TurnConstructor.turningRadius / (TurnConstructor.prev - leftCircleCenter).magnitude)) : 0.0;
				gammaLeft = num4 - num5;
				double num6 = (!flag2) ? CounterClockwiseAngle(gammaLeft, vaLeft) : 0.0;
				if (!flag)
				{
					turnList.Add(new Turn((float)num3, this));
				}
				if (!flag2)
				{
					turnList.Add(new Turn((float)num6, this, 1));
				}
			}

			public override void TangentToPoint(List<Turn> turnList)
			{
				bool flag = false;
				bool flag2 = false;
				float magnitude = (TurnConstructor.next - rightCircleCenter).magnitude;
				float magnitude2 = (TurnConstructor.next - leftCircleCenter).magnitude;
				if (magnitude < TurnConstructor.turningRadius)
				{
					flag = true;
				}
				if (magnitude2 < TurnConstructor.turningRadius)
				{
					flag2 = true;
				}
				if (!flag)
				{
					double num = Atan2(TurnConstructor.next - rightCircleCenter);
					double num2 = Math.PI / 2.0 - Math.Asin(TurnConstructor.turningRadius / magnitude);
					gammaRight = num - num2;
					double num3 = ClockwiseAngle(vaRight, gammaRight);
					turnList.Add(new Turn((float)num3, this, 6));
				}
				if (!flag2)
				{
					double num4 = Atan2(TurnConstructor.next - leftCircleCenter);
					double num5 = Math.PI / 2.0 - Math.Asin(TurnConstructor.turningRadius / magnitude2);
					gammaLeft = num4 + num5;
					double num6 = CounterClockwiseAngle(vaLeft, gammaLeft);
					turnList.Add(new Turn((float)num6, this, 7));
				}
			}

			public override void GetPath(Turn turn, List<Vector3> output)
			{
				switch (turn.id)
				{
				case 0:
					AddCircleSegment(gammaRight, vaRight, clockwise: true, rightCircleCenter, output, TurnConstructor.turningRadius);
					break;
				case 1:
					AddCircleSegment(gammaLeft, vaLeft, clockwise: false, leftCircleCenter, output, TurnConstructor.turningRadius);
					break;
				case 2:
					AddCircleSegment(preVaRight, alfaRightRight - Math.PI / 2.0, clockwise: true, preRightCircleCenter, output, TurnConstructor.turningRadius);
					AddCircleSegment(alfaRightRight - Math.PI / 2.0, vaRight, clockwise: true, rightCircleCenter, output, TurnConstructor.turningRadius);
					break;
				case 3:
					AddCircleSegment(preVaRight, alfaRightLeft - deltaRightLeft, clockwise: true, preRightCircleCenter, output, TurnConstructor.turningRadius);
					AddCircleSegment(alfaRightLeft - deltaRightLeft + Math.PI, vaLeft, clockwise: false, leftCircleCenter, output, TurnConstructor.turningRadius);
					break;
				case 4:
					AddCircleSegment(preVaLeft, alfaLeftRight + deltaLeftRight, clockwise: false, preLeftCircleCenter, output, TurnConstructor.turningRadius);
					AddCircleSegment(alfaLeftRight + deltaLeftRight + Math.PI, vaRight, clockwise: true, rightCircleCenter, output, TurnConstructor.turningRadius);
					break;
				case 5:
					AddCircleSegment(preVaLeft, alfaLeftLeft + Math.PI / 2.0, clockwise: false, preLeftCircleCenter, output, TurnConstructor.turningRadius);
					AddCircleSegment(alfaLeftLeft + Math.PI / 2.0, vaLeft, clockwise: false, leftCircleCenter, output, TurnConstructor.turningRadius);
					break;
				case 6:
					AddCircleSegment(vaRight, gammaRight, clockwise: true, rightCircleCenter, output, TurnConstructor.turningRadius);
					break;
				case 7:
					AddCircleSegment(vaLeft, gammaLeft, clockwise: false, leftCircleCenter, output, TurnConstructor.turningRadius);
					break;
				}
			}
		}

		[Serializable]
		public class ConstantTurn : TurnConstructor
		{
			private Vector3 circleCenter;

			private double gamma1;

			private double gamma2;

			private bool clockwise;

			public override void Prepare(int i, Vector3[] vectorPath)
			{
			}

			public override void TangentToTangent(List<Turn> turnList)
			{
				Vector3 dir = Vector3.Cross(TurnConstructor.t1, Vector3.up);
				Vector3 vector = TurnConstructor.current - TurnConstructor.prev;
				Vector3 start = vector * 0.5f + TurnConstructor.prev;
				vector = Vector3.Cross(vector, Vector3.up);
				circleCenter = Polygon.IntersectionPointOptimized(TurnConstructor.prev, dir, start, vector, out bool intersects);
				if (intersects)
				{
					gamma1 = Atan2(TurnConstructor.prev - circleCenter);
					gamma2 = Atan2(TurnConstructor.current - circleCenter);
					clockwise = !Polygon.Left(circleCenter, TurnConstructor.prev, TurnConstructor.prev + TurnConstructor.t1);
					double angle = (!clockwise) ? CounterClockwiseAngle(gamma1, gamma2) : ClockwiseAngle(gamma1, gamma2);
					angle = GetLengthFromAngle(angle, (circleCenter - TurnConstructor.current).magnitude);
					turnList.Add(new Turn((float)angle, this));
				}
			}

			public override void GetPath(Turn turn, List<Vector3> output)
			{
				AddCircleSegment(gamma1, gamma2, clockwise, circleCenter, output, (circleCenter - TurnConstructor.current).magnitude);
				TurnConstructor.normal = (TurnConstructor.current - circleCenter).normalized;
				TurnConstructor.t2 = Vector3.Cross(TurnConstructor.normal, Vector3.up).normalized;
				TurnConstructor.normal = -TurnConstructor.normal;
				if (!clockwise)
				{
					TurnConstructor.t2 = -TurnConstructor.t2;
					TurnConstructor.normal = -TurnConstructor.normal;
				}
				TurnConstructor.changedPreviousTangent = true;
			}
		}

		public abstract class TurnConstructor
		{
			public const double ThreeSixtyRadians = Math.PI * 2.0;

			public float constantBias;

			public float factorBias = 1f;

			public static float turningRadius = 1f;

			public static Vector3 prev;

			public static Vector3 current;

			public static Vector3 next;

			public static Vector3 t1;

			public static Vector3 t2;

			public static Vector3 normal;

			public static Vector3 prevNormal;

			public static bool changedPreviousTangent;

			public abstract void Prepare(int i, Vector3[] vectorPath);

			public virtual void OnTangentUpdate()
			{
			}

			public virtual void PointToTangent(List<Turn> turnList)
			{
			}

			public virtual void TangentToPoint(List<Turn> turnList)
			{
			}

			public virtual void TangentToTangent(List<Turn> turnList)
			{
			}

			public abstract void GetPath(Turn turn, List<Vector3> output);

			public static void Setup(int i, Vector3[] vectorPath)
			{
				current = vectorPath[i];
				prev = vectorPath[i - 1];
				next = vectorPath[i + 1];
				prev.y = current.y;
				next.y = current.y;
				t1 = t2;
				t2 = (next - current).normalized - (prev - current).normalized;
				t2 = t2.normalized;
				prevNormal = normal;
				normal = Vector3.Cross(t2, Vector3.up);
				normal = normal.normalized;
			}

			public static void PostPrepare()
			{
				changedPreviousTangent = false;
			}

			public void AddCircleSegment(double startAngle, double endAngle, bool clockwise, Vector3 center, List<Vector3> output, float radius)
			{
				double num = Math.PI / 50.0;
				if (clockwise)
				{
					while (endAngle > startAngle + Math.PI * 2.0)
					{
						endAngle -= Math.PI * 2.0;
					}
					while (endAngle < startAngle)
					{
						endAngle += Math.PI * 2.0;
					}
				}
				else
				{
					while (endAngle < startAngle - Math.PI * 2.0)
					{
						endAngle += Math.PI * 2.0;
					}
					while (endAngle > startAngle)
					{
						endAngle -= Math.PI * 2.0;
					}
				}
				if (clockwise)
				{
					for (double num2 = startAngle; num2 < endAngle; num2 += num)
					{
						output.Add(AngleToVector(num2) * radius + center);
					}
				}
				else
				{
					for (double num3 = startAngle; num3 > endAngle; num3 -= num)
					{
						output.Add(AngleToVector(num3) * radius + center);
					}
				}
				output.Add(AngleToVector(endAngle) * radius + center);
			}

			public void DebugCircleSegment(Vector3 center, double startAngle, double endAngle, double radius, Color color)
			{
				double num = Math.PI / 50.0;
				while (endAngle < startAngle)
				{
					endAngle += Math.PI * 2.0;
				}
				Vector3 start = AngleToVector(startAngle) * (float)radius + center;
				for (double num2 = startAngle + num; num2 < endAngle; num2 += num)
				{
					UnityEngine.Debug.DrawLine(start, AngleToVector(num2) * (float)radius + center);
				}
				UnityEngine.Debug.DrawLine(start, AngleToVector(endAngle) * (float)radius + center);
			}

			public void DebugCircle(Vector3 center, double radius, Color color)
			{
				double num = Math.PI / 50.0;
				Vector3 start = AngleToVector(0.0 - num) * (float)radius + center;
				for (double num2 = 0.0; num2 < Math.PI * 2.0; num2 += num)
				{
					Vector3 vector = AngleToVector(num2) * (float)radius + center;
					UnityEngine.Debug.DrawLine(start, vector, color);
					start = vector;
				}
			}

			public double GetLengthFromAngle(double angle, double radius)
			{
				return radius * angle;
			}

			public double ClockwiseAngle(double from, double to)
			{
				return ClampAngle(to - from);
			}

			public double CounterClockwiseAngle(double from, double to)
			{
				return ClampAngle(from - to);
			}

			public Vector3 AngleToVector(double a)
			{
				return new Vector3((float)Math.Cos(a), 0f, (float)Math.Sin(a));
			}

			public double ToDegrees(double rad)
			{
				return rad * 57.295780181884766;
			}

			public double ClampAngle(double a)
			{
				while (a < 0.0)
				{
					a += Math.PI * 2.0;
				}
				while (a > Math.PI * 2.0)
				{
					a -= Math.PI * 2.0;
				}
				return a;
			}

			public double Atan2(Vector3 v)
			{
				return Math.Atan2(v.z, v.x);
			}
		}

		public struct Turn : IComparable<Turn>
		{
			public float length;

			public int id;

			public TurnConstructor constructor;

			public float score => length * constructor.factorBias + constructor.constantBias;

			public Turn(float length, TurnConstructor constructor, int id = 0)
			{
				this.length = length;
				this.id = id;
				this.constructor = constructor;
			}

			public void GetPath(List<Vector3> output)
			{
				constructor.GetPath(this, output);
			}

			public int CompareTo(Turn t)
			{
				return (t.score > score) ? (-1) : ((t.score < score) ? 1 : 0);
			}

			public static bool operator <(Turn lhs, Turn rhs)
			{
				return lhs.score < rhs.score;
			}

			public static bool operator >(Turn lhs, Turn rhs)
			{
				return lhs.score > rhs.score;
			}
		}

		public float turningRadius = 1f;

		public MaxTurn turnConstruct1 = new MaxTurn();

		public ConstantTurn turnConstruct2 = new ConstantTurn();

		public override ModifierData input => ModifierData.VectorPath;

		public override ModifierData output => ModifierData.VectorPath;

		public override void Apply(Path p, ModifierData source)
		{
			Vector3[] array = p.vectorPath.ToArray();
			if (array == null || array.Length <= 2)
			{
				return;
			}
			List<Vector3> list = new List<Vector3>();
			list.Add(array[0]);
			TurnConstructor.turningRadius = turningRadius;
			for (int i = 1; i < array.Length - 1; i++)
			{
				List<Turn> turnList = new List<Turn>();
				TurnConstructor.Setup(i, array);
				turnConstruct1.Prepare(i, array);
				turnConstruct2.Prepare(i, array);
				TurnConstructor.PostPrepare();
				if (i == 1)
				{
					turnConstruct1.PointToTangent(turnList);
					turnConstruct2.PointToTangent(turnList);
				}
				else
				{
					turnConstruct1.TangentToTangent(turnList);
					turnConstruct2.TangentToTangent(turnList);
				}
				EvaluatePaths(turnList, list);
				if (i == array.Length - 2)
				{
					turnConstruct1.TangentToPoint(turnList);
					turnConstruct2.TangentToPoint(turnList);
				}
				EvaluatePaths(turnList, list);
			}
			list.Add(array[array.Length - 1]);
			p.vectorPath = list;
		}

		private void EvaluatePaths(List<Turn> turnList, List<Vector3> output)
		{
			turnList.Sort();
			for (int i = 0; i < turnList.Count; i++)
			{
				if (i == 0)
				{
					turnList[i].GetPath(output);
				}
			}
			turnList.Clear();
			if (TurnConstructor.changedPreviousTangent)
			{
				turnConstruct1.OnTangentUpdate();
				turnConstruct2.OnTangentUpdate();
			}
		}
	}
	[Serializable]
	[AddComponentMenu("Pathfinding/Modifiers/Alternative Path")]
	public class AlternativePath : MonoModifier
	{
		public int penalty = 1000;

		public int randomStep = 10;

		private GraphNode[] prevNodes;

		private int prevSeed;

		private int prevPenalty;

		private bool waitingForApply;

		private object lockObject = new object();

		private System.Random rnd = new System.Random();

		private System.Random seedGenerator = new System.Random();

		private bool destroyed;

		private GraphNode[] toBeApplied;

		public override ModifierData input => ModifierData.Original;

		public override ModifierData output => ModifierData.All;

		public override void Apply(Path p, ModifierData source)
		{
			if (!(this == null))
			{
				lock (lockObject)
				{
					toBeApplied = p.path.ToArray();
					if (!waitingForApply)
					{
						waitingForApply = true;
						AstarPath.OnPathPreSearch = (OnPathDelegate)Delegate.Combine(AstarPath.OnPathPreSearch, new OnPathDelegate(ApplyNow));
					}
				}
			}
		}

		public new void OnDestroy()
		{
			destroyed = true;
			lock (lockObject)
			{
				if (!waitingForApply)
				{
					waitingForApply = true;
					AstarPath.OnPathPreSearch = (OnPathDelegate)Delegate.Combine(AstarPath.OnPathPreSearch, new OnPathDelegate(ClearOnDestroy));
				}
			}
			((MonoModifier)this).OnDestroy();
		}

		private void ClearOnDestroy(Path p)
		{
			lock (lockObject)
			{
				AstarPath.OnPathPreSearch = (OnPathDelegate)Delegate.Remove(AstarPath.OnPathPreSearch, new OnPathDelegate(ClearOnDestroy));
				waitingForApply = false;
				InversePrevious();
			}
		}

		private void InversePrevious()
		{
			int seed = prevSeed;
			rnd = new System.Random(seed);
			if (prevNodes == null)
			{
				return;
			}
			bool flag = false;
			int num = rnd.Next(randomStep);
			for (int i = num; i < prevNodes.Length; i += rnd.Next(1, randomStep))
			{
				if (prevNodes[i].Penalty < prevPenalty)
				{
					flag = true;
				}
				prevNodes[i].Penalty = (uint)(prevNodes[i].Penalty - prevPenalty);
			}
			if (flag)
			{
				UnityEngine.Debug.LogWarning("Penalty for some nodes has been reset while this modifier was active. Penalties might not be correctly set.");
			}
		}

		private void ApplyNow(Path somePath)
		{
			lock (lockObject)
			{
				waitingForApply = false;
				AstarPath.OnPathPreSearch = (OnPathDelegate)Delegate.Remove(AstarPath.OnPathPreSearch, new OnPathDelegate(ApplyNow));
				InversePrevious();
				if (!destroyed)
				{
					int seed = seedGenerator.Next();
					rnd = new System.Random(seed);
					if (toBeApplied != null)
					{
						int num = rnd.Next(randomStep);
						for (int i = num; i < toBeApplied.Length; i += rnd.Next(1, randomStep))
						{
							toBeApplied[i].Penalty = (uint)(toBeApplied[i].Penalty + penalty);
						}
					}
					prevPenalty = penalty;
					prevSeed = seed;
					prevNodes = toBeApplied;
				}
			}
		}
	}
	[Serializable]
	[AddComponentMenu("Pathfinding/Modifiers/Funnel")]
	public class FunnelModifier : MonoModifier
	{
		public override ModifierData input => ModifierData.StrictVectorPath;

		public override ModifierData output => ModifierData.VectorPath;

		public override void Apply(Path p, ModifierData source)
		{
			List<GraphNode> path = p.path;
			List<Vector3> vectorPath = p.vectorPath;
			if (path == null || path.Count == 0 || vectorPath == null || vectorPath.Count != path.Count)
			{
				return;
			}
			List<Vector3> list = ListPool<Vector3>.Claim();
			List<Vector3> list2 = ListPool<Vector3>.Claim(path.Count + 1);
			List<Vector3> list3 = ListPool<Vector3>.Claim(path.Count + 1);
			list2.Add(vectorPath[0]);
			list3.Add(vectorPath[0]);
			for (int i = 0; i < path.Count - 1; i++)
			{
				bool portal = path[i].GetPortal(path[i + 1], list2, list3, backwards: false);
				bool flag = false;
				if (!portal && !flag)
				{
					list2.Add((Vector3)path[i].position);
					list3.Add((Vector3)path[i].position);
					list2.Add((Vector3)path[i + 1].position);
					list3.Add((Vector3)path[i + 1].position);
				}
			}
			list2.Add(vectorPath[vectorPath.Count - 1]);
			list3.Add(vectorPath[vectorPath.Count - 1]);
			if (!RunFunnel(list2, list3, list))
			{
				list.Add(vectorPath[0]);
				list.Add(vectorPath[vectorPath.Count - 1]);
			}
			ListPool<Vector3>.Release(p.vectorPath);
			p.vectorPath = list;
			ListPool<Vector3>.Release(list2);
			ListPool<Vector3>.Release(list3);
		}

		public bool RunFunnel(List<Vector3> left, List<Vector3> right, List<Vector3> funnelPath)
		{
			if (left == null)
			{
				throw new ArgumentNullException("left");
			}
			if (right == null)
			{
				throw new ArgumentNullException("right");
			}
			if (funnelPath == null)
			{
				throw new ArgumentNullException("funnelPath");
			}
			if (left.Count != right.Count)
			{
				throw new ArgumentException("left and right lists must have equal length");
			}
			if (left.Count <= 3)
			{
				return false;
			}
			while (left[1] == left[2] && right[1] == right[2])
			{
				left.RemoveAt(1);
				right.RemoveAt(1);
				if (left.Count <= 3)
				{
					return false;
				}
			}
			Vector3 vector = left[2];
			if (vector == left[1])
			{
				vector = right[2];
			}
			while (Polygon.IsColinear(left[0], left[1], right[1]) || Polygon.Left(left[1], right[1], vector) == Polygon.Left(left[1], right[1], left[0]))
			{
				left.RemoveAt(1);
				right.RemoveAt(1);
				if (left.Count <= 3)
				{
					return false;
				}
				vector = left[2];
				if (vector == left[1])
				{
					vector = right[2];
				}
			}
			if (!Polygon.IsClockwise(left[0], left[1], right[1]) && !Polygon.IsColinear(left[0], left[1], right[1]))
			{
				List<Vector3> list = left;
				left = right;
				right = list;
			}
			funnelPath.Add(left[0]);
			Vector3 vector2 = left[0];
			Vector3 vector3 = left[1];
			Vector3 vector4 = right[1];
			int num = 0;
			int num2 = 1;
			int num3 = 1;
			for (int i = 2; i < left.Count; i++)
			{
				if (funnelPath.Count > 2000)
				{
					UnityEngine.Debug.LogWarning("Avoiding infinite loop. Remove this check if you have this long paths.");
					break;
				}
				Vector3 vector5 = left[i];
				Vector3 vector6 = right[i];
				if (Polygon.TriangleArea2(vector2, vector4, vector6) >= 0f)
				{
					if (!(vector2 == vector4) && !(Polygon.TriangleArea2(vector2, vector3, vector6) <= 0f))
					{
						funnelPath.Add(vector3);
						vector2 = vector3;
						num = num3;
						vector3 = vector2;
						vector4 = vector2;
						num3 = num;
						num2 = num;
						i = num;
						continue;
					}
					vector4 = vector6;
					num2 = i;
				}
				if (Polygon.TriangleArea2(vector2, vector3, vector5) <= 0f)
				{
					if (vector2 == vector3 || Polygon.TriangleArea2(vector2, vector4, vector5) >= 0f)
					{
						vector3 = vector5;
						num3 = i;
						continue;
					}
					funnelPath.Add(vector4);
					vector2 = vector4;
					num = num2;
					vector3 = vector2;
					vector4 = vector2;
					num3 = num;
					num2 = num;
					i = num;
				}
			}
			funnelPath.Add(left[left.Count - 1]);
			return true;
		}
	}
	public interface IFunnelGraph
	{
		void BuildFunnelCorridor(List<GraphNode> path, int sIndex, int eIndex, List<Vector3> left, List<Vector3> right);

		void AddPortal(GraphNode n1, GraphNode n2, List<Vector3> left, List<Vector3> right);
	}
	[Flags]
	public enum ModifierData
	{
		All = -1,
		StrictNodePath = 0x1,
		NodePath = 0x2,
		StrictVectorPath = 0x4,
		VectorPath = 0x8,
		Original = 0x10,
		None = 0x0,
		Nodes = 0x3,
		Vector = 0xC
	}
	public interface IPathModifier
	{
		int Priority
		{
			get;
			set;
		}

		ModifierData input
		{
			get;
		}

		ModifierData output
		{
			get;
		}

		void ApplyOriginal(Path p);

		void Apply(Path p, ModifierData source);

		void PreProcess(Path p);
	}
	[Serializable]
	public abstract class PathModifier : IPathModifier
	{
		public int priority;

		[NonSerialized]
		public Seeker seeker;

		public abstract ModifierData input
		{
			get;
		}

		public abstract ModifierData output
		{
			get;
		}

		public int Priority
		{
			get
			{
				return priority;
			}
			set
			{
				priority = value;
			}
		}

		public void Awake(Seeker s)
		{
			seeker = s;
			if (s != null)
			{
				s.RegisterModifier(this);
			}
		}

		public void OnDestroy(Seeker s)
		{
			if (s != null)
			{
				s.DeregisterModifier(this);
			}
		}

		[Obsolete]
		public virtual void ApplyOriginal(Path p)
		{
		}

		public abstract void Apply(Path p, ModifierData source);

		[Obsolete]
		public virtual void PreProcess(Path p)
		{
		}
	}
	[Serializable]
	public abstract class MonoModifier : MonoBehaviour, IPathModifier
	{
		[NonSerialized]
		public Seeker seeker;

		public int priority;

		public int Priority
		{
			get
			{
				return priority;
			}
			set
			{
				priority = value;
			}
		}

		public abstract ModifierData input
		{
			get;
		}

		public abstract ModifierData output
		{
			get;
		}

		public void OnEnable()
		{
		}

		public void OnDisable()
		{
		}

		public void Awake()
		{
			seeker = GetComponent<Seeker>();
			if (seeker != null)
			{
				seeker.RegisterModifier(this);
			}
		}

		public void OnDestroy()
		{
			if (seeker != null)
			{
				seeker.DeregisterModifier(this);
			}
		}

		[Obsolete]
		public virtual void ApplyOriginal(Path p)
		{
		}

		public abstract void Apply(Path p, ModifierData source);

		[Obsolete]
		public virtual void PreProcess(Path p)
		{
		}

		[Obsolete]
		public virtual Vector3[] Apply(GraphNode[] path, Vector3 start, Vector3 end, int startIndex, int endIndex, NavGraph graph)
		{
			Vector3[] array = new Vector3[endIndex - startIndex];
			for (int i = startIndex; i < endIndex; i++)
			{
				array[i - startIndex] = (Vector3)path[i].position;
			}
			return array;
		}

		[Obsolete]
		public virtual Vector3[] Apply(Vector3[] path, Vector3 start, Vector3 end)
		{
			return path;
		}
	}
	public class ModifierConverter
	{
		public static bool AllBits(ModifierData a, ModifierData b)
		{
			return (a & b) == b;
		}

		public static bool AnyBits(ModifierData a, ModifierData b)
		{
			return (a & b) != 0;
		}

		public static ModifierData Convert(Path p, ModifierData input, ModifierData output)
		{
			if (!CanConvert(input, output))
			{
				UnityEngine.Debug.LogError("Can't convert " + input + " to " + output);
				return ModifierData.None;
			}
			if (AnyBits(input, output))
			{
				return input;
			}
			if (AnyBits(input, ModifierData.Nodes) && AnyBits(output, ModifierData.Vector))
			{
				p.vectorPath.Clear();
				for (int i = 0; i < p.vectorPath.Count; i++)
				{
					p.vectorPath.Add((Vector3)p.path[i].position);
				}
				return (ModifierData)(8 | (AnyBits(input, ModifierData.StrictNodePath) ? 4 : 0));
			}
			UnityEngine.Debug.LogError("This part should not be reached - Error in ModifierConverted\nInput: " + input + " (" + (int)input + ")\nOutput: " + output + " (" + (int)output + ")");
			return ModifierData.None;
		}

		public static bool CanConvert(ModifierData input, ModifierData output)
		{
			ModifierData b = CanConvertTo(input);
			return AnyBits(output, b);
		}

		public static ModifierData CanConvertTo(ModifierData a)
		{
			if (a == ModifierData.All)
			{
				return ModifierData.All;
			}
			ModifierData modifierData = a;
			if (AnyBits(a, ModifierData.Nodes))
			{
				modifierData |= ModifierData.VectorPath;
			}
			if (AnyBits(a, ModifierData.StrictNodePath))
			{
				modifierData |= ModifierData.StrictVectorPath;
			}
			if (AnyBits(a, ModifierData.StrictVectorPath))
			{
				modifierData |= ModifierData.VectorPath;
			}
			return modifierData;
		}
	}
}
[AddComponentMenu("Pathfinding/Modifiers/Radius Offset")]
public class RadiusModifier : MonoModifier
{
	private enum TangentType
	{
		OuterRight = 1,
		InnerRightLeft = 2,
		InnerLeftRight = 4,
		OuterLeft = 8,
		Outer = 9,
		Inner = 6
	}

	public float radius = 1f;

	public float detail = 10f;

	private float[] radi = new float[10];

	private float[] a1 = new float[10];

	private float[] a2 = new float[10];

	private bool[] dir = new bool[10];

	public override ModifierData input => ModifierData.Vector;

	public override ModifierData output => ModifierData.VectorPath;

	private bool CalculateCircleInner(Vector3 p1, Vector3 p2, float r1, float r2, out float a, out float sigma)
	{
		float magnitude = (p1 - p2).magnitude;
		if (r1 + r2 > magnitude)
		{
			a = 0f;
			sigma = 0f;
			return false;
		}
		a = (float)Math.Acos((r1 + r2) / magnitude);
		sigma = (float)Math.Atan2(p2.z - p1.z, p2.x - p1.x);
		return true;
	}

	private bool CalculateCircleOuter(Vector3 p1, Vector3 p2, float r1, float r2, out float a, out float sigma)
	{
		float magnitude = (p1 - p2).magnitude;
		if (Math.Abs(r1 - r2) > magnitude)
		{
			a = 0f;
			sigma = 0f;
			return false;
		}
		a = (float)Math.Acos((r1 - r2) / magnitude);
		sigma = (float)Math.Atan2(p2.z - p1.z, p2.x - p1.x);
		return true;
	}

	private TangentType CalculateTangentType(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4)
	{
		bool flag = Pathfinding.Polygon.Left(p1, p2, p3);
		bool flag2 = Pathfinding.Polygon.Left(p2, p3, p4);
		return (TangentType)(1 << (flag ? 2 : 0) + (flag2 ? 1 : 0));
	}

	private TangentType CalculateTangentTypeSimple(Vector3 p1, Vector3 p2, Vector3 p3)
	{
		bool flag = Pathfinding.Polygon.Left(p1, p2, p3);
		bool flag2 = flag;
		return (TangentType)(1 << (flag2 ? 2 : 0) + (flag ? 1 : 0));
	}

	private void DrawCircle(Vector3 p1, float rad, Color col, float start = 0f, float end = (float)Math.PI * 2f)
	{
		Vector3 start2 = new Vector3((float)Math.Cos(start), 0f, (float)Math.Sin(start)) * rad + p1;
		for (float num = start; num < end; num += (float)Math.PI / 100f)
		{
			Vector3 vector = new Vector3((float)Math.Cos(num), 0f, (float)Math.Sin(num)) * rad + p1;
			UnityEngine.Debug.DrawLine(start2, vector, col);
			start2 = vector;
		}
		if ((double)end == Math.PI * 2.0)
		{
			Vector3 end2 = new Vector3((float)Math.Cos(start), 0f, (float)Math.Sin(start)) * rad + p1;
			UnityEngine.Debug.DrawLine(start2, end2, col);
		}
	}

	public override void Apply(Pathfinding.Path p, ModifierData source)
	{
		List<Vector3> vectorPath = p.vectorPath;
		List<Vector3> list = Apply(vectorPath);
		if (list != vectorPath)
		{
			ListPool<Vector3>.Release(p.vectorPath);
			p.vectorPath = list;
		}
	}

	public List<Vector3> Apply(List<Vector3> vs)
	{
		if (vs == null || vs.Count < 3)
		{
			return vs;
		}
		if (radi.Length < vs.Count)
		{
			radi = new float[vs.Count];
			a1 = new float[vs.Count];
			this.a2 = new float[vs.Count];
			dir = new bool[vs.Count];
		}
		for (int i = 0; i < vs.Count; i++)
		{
			radi[i] = radius;
		}
		radi[0] = 0f;
		radi[vs.Count - 1] = 0f;
		int num = 0;
		for (int j = 0; j < vs.Count - 1; j++)
		{
			num++;
			if (num > 2 * vs.Count)
			{
				UnityEngine.Debug.LogWarning("Could not resolve radiuses, the path is too complex. Try reducing the base radius");
				break;
			}
			TangentType tangentType = (j == 0) ? CalculateTangentTypeSimple(vs[j], vs[j + 1], vs[j + 2]) : ((j != vs.Count - 2) ? CalculateTangentType(vs[j - 1], vs[j], vs[j + 1], vs[j + 2]) : CalculateTangentTypeSimple(vs[j - 1], vs[j], vs[j + 1]));
			float a2;
			float sigma2;
			if ((tangentType & TangentType.Inner) != 0)
			{
				if (!CalculateCircleInner(vs[j], vs[j + 1], radi[j], radi[j + 1], out float a, out float sigma))
				{
					float magnitude = (vs[j + 1] - vs[j]).magnitude;
					radi[j] = magnitude * (radi[j] / (radi[j] + radi[j + 1]));
					radi[j + 1] = magnitude - radi[j];
					radi[j] *= 0.99f;
					radi[j + 1] *= 0.99f;
					j -= 2;
				}
				else if (tangentType == TangentType.InnerRightLeft)
				{
					this.a2[j] = sigma - a;
					a1[j + 1] = sigma - a + (float)Math.PI;
					dir[j] = true;
				}
				else
				{
					this.a2[j] = sigma + a;
					a1[j + 1] = sigma + a + (float)Math.PI;
					dir[j] = false;
				}
			}
			else if (!CalculateCircleOuter(vs[j], vs[j + 1], radi[j], radi[j + 1], out a2, out sigma2))
			{
				if (j == vs.Count - 2)
				{
					radi[j] = (vs[j + 1] - vs[j]).magnitude;
					radi[j] *= 0.99f;
					j--;
				}
				else
				{
					if (radi[j] > radi[j + 1])
					{
						radi[j + 1] = radi[j] - (vs[j + 1] - vs[j]).magnitude;
					}
					else
					{
						radi[j + 1] = radi[j] + (vs[j + 1] - vs[j]).magnitude;
					}
					radi[j + 1] *= 0.99f;
				}
				j--;
			}
			else if (tangentType == TangentType.OuterRight)
			{
				this.a2[j] = sigma2 - a2;
				a1[j + 1] = sigma2 - a2;
				dir[j] = true;
			}
			else
			{
				this.a2[j] = sigma2 + a2;
				a1[j + 1] = sigma2 + a2;
				dir[j] = false;
			}
		}
		List<Vector3> list = ListPool<Vector3>.Claim();
		list.Add(vs[0]);
		if (detail < 1f)
		{
			detail = 1f;
		}
		float num2 = (float)Math.PI * 2f / detail;
		for (int k = 1; k < vs.Count - 1; k++)
		{
			float num3 = a1[k];
			float num4 = this.a2[k];
			float d = radi[k];
			if (dir[k])
			{
				if (num4 < num3)
				{
					num4 += (float)Math.PI * 2f;
				}
				for (float num5 = num3; num5 < num4; num5 += num2)
				{
					list.Add(new Vector3((float)Math.Cos(num5), 0f, (float)Math.Sin(num5)) * d + vs[k]);
				}
				continue;
			}
			if (num3 < num4)
			{
				num3 += (float)Math.PI * 2f;
			}
			for (float num6 = num3; num6 > num4; num6 -= num2)
			{
				list.Add(new Vector3((float)Math.Cos(num6), 0f, (float)Math.Sin(num6)) * d + vs[k]);
			}
		}
		list.Add(vs[vs.Count - 1]);
		return list;
	}
}
namespace Pathfinding
{
	[Serializable]
	[AddComponentMenu("Pathfinding/Modifiers/Raycast Simplifier")]
	public class RaycastModifier : MonoModifier
	{
		[HideInInspector]
		public bool useRaycasting = true;

		[HideInInspector]
		public LayerMask mask = -1;

		[HideInInspector]
		public bool thickRaycast;

		[HideInInspector]
		public float thickRaycastRadius;

		[HideInInspector]
		public Vector3 raycastOffset = Vector3.zero;

		[HideInInspector]
		public bool subdivideEveryIter;

		public int iterations = 2;

		[HideInInspector]
		public bool useGraphRaycasting;

		private static List<Vector3> nodes;

		public override ModifierData input => ModifierData.Vector;

		public override ModifierData output => ModifierData.VectorPath;

		public override void Apply(Path p, ModifierData source)
		{
			if (iterations <= 0)
			{
				return;
			}
			if (nodes == null)
			{
				nodes = new List<Vector3>(p.vectorPath.Count);
			}
			else
			{
				nodes.Clear();
			}
			nodes.AddRange(p.vectorPath);
			for (int i = 0; i < iterations; i++)
			{
				if (subdivideEveryIter && i != 0)
				{
					if (nodes.Capacity < nodes.Count * 3)
					{
						nodes.Capacity = nodes.Count * 3;
					}
					int count = nodes.Count;
					for (int j = 0; j < count - 1; j++)
					{
						nodes.Add(Vector3.zero);
						nodes.Add(Vector3.zero);
					}
					for (int num = count - 1; num > 0; num--)
					{
						Vector3 from = nodes[num];
						Vector3 to = nodes[num + 1];
						nodes[num * 3] = nodes[num];
						if (num != count - 1)
						{
							nodes[num * 3 + 1] = Vector3.Lerp(from, to, 0.33f);
							nodes[num * 3 + 2] = Vector3.Lerp(from, to, 0.66f);
						}
					}
				}
				int num2 = 0;
				while (num2 < nodes.Count - 2)
				{
					Vector3 v = nodes[num2];
					Vector3 v2 = nodes[num2 + 2];
					Stopwatch stopwatch = new Stopwatch();
					stopwatch.Start();
					if (ValidateLine(null, null, v, v2))
					{
						nodes.RemoveAt(num2 + 1);
					}
					else
					{
						num2++;
					}
					stopwatch.Stop();
				}
			}
			p.vectorPath.Clear();
			p.vectorPath.AddRange(nodes);
		}

		public bool ValidateLine(GraphNode n1, GraphNode n2, Vector3 v1, Vector3 v2)
		{
			if (useRaycasting)
			{
				RaycastHit hitInfo2;
				if (thickRaycast && thickRaycastRadius > 0f)
				{
					if (Physics.SphereCast(v1 + raycastOffset, thickRaycastRadius, v2 - v1, out RaycastHit _, (v2 - v1).magnitude, mask))
					{
						return false;
					}
				}
				else if (Physics.Linecast(v1 + raycastOffset, v2 + raycastOffset, out hitInfo2, mask))
				{
					return false;
				}
			}
			if (useGraphRaycasting && n1 == null)
			{
				NNInfo nearest = AstarPath.active.GetNearest(v1);
				n1 = nearest.node;
				NNInfo nearest2 = AstarPath.active.GetNearest(v2);
				n2 = nearest2.node;
			}
			if (useGraphRaycasting && n1 != null && n2 != null)
			{
				NavGraph graph = AstarData.GetGraph(n1);
				NavGraph graph2 = AstarData.GetGraph(n2);
				if (graph != graph2)
				{
					return false;
				}
				if (graph != null)
				{
					IRaycastableGraph raycastableGraph = graph as IRaycastableGraph;
					if (raycastableGraph != null && raycastableGraph.Linecast(v1, v2, n1))
					{
						return false;
					}
				}
			}
			return true;
		}
	}
	[Serializable]
	[AddComponentMenu("Pathfinding/Modifiers/Simple Smooth")]
	public class SimpleSmoothModifier : MonoModifier
	{
		public enum SmoothType
		{
			Simple,
			Bezier,
			OffsetSimple,
			CurvedNonuniform
		}

		public SmoothType smoothType;

		public int subdivisions = 2;

		public int iterations = 2;

		public float strength = 0.5f;

		public bool uniformLength = true;

		public float maxSegmentLength = 2f;

		public float bezierTangentLength = 0.4f;

		public float offset = 0.2f;

		public float factor = 0.1f;

		public override ModifierData input => ModifierData.All;

		public override ModifierData output
		{
			get
			{
				ModifierData modifierData = ModifierData.VectorPath;
				if (iterations == 0 && smoothType == SmoothType.Simple && !uniformLength)
				{
					modifierData |= ModifierData.StrictVectorPath;
				}
				return modifierData;
			}
		}

		public override void Apply(Path p, ModifierData source)
		{
			if (p.vectorPath == null)
			{
				UnityEngine.Debug.LogWarning("Can't process NULL path (has another modifier logged an error?)");
				return;
			}
			List<Vector3> list = null;
			switch (smoothType)
			{
			case SmoothType.Simple:
				list = SmoothSimple(p.vectorPath);
				break;
			case SmoothType.Bezier:
				list = SmoothBezier(p.vectorPath);
				break;
			case SmoothType.OffsetSimple:
				list = SmoothOffsetSimple(p.vectorPath);
				break;
			case SmoothType.CurvedNonuniform:
				list = CurvedNonuniform(p.vectorPath);
				break;
			}
			if (list != p.vectorPath)
			{
				ListPool<Vector3>.Release(p.vectorPath);
				p.vectorPath = list;
			}
		}

		public List<Vector3> CurvedNonuniform(List<Vector3> path)
		{
			if (maxSegmentLength <= 0f)
			{
				UnityEngine.Debug.LogWarning("Max Segment Length is <= 0 which would cause DivByZero-exception or other nasty errors (avoid this)");
				return path;
			}
			int num = 0;
			for (int i = 0; i < path.Count - 1; i++)
			{
				float magnitude = (path[i] - path[i + 1]).magnitude;
				for (float num2 = 0f; num2 <= magnitude; num2 += maxSegmentLength)
				{
					num++;
				}
			}
			List<Vector3> list = ListPool<Vector3>.Claim(num);
			Vector3 vector = (path[1] - path[0]).normalized;
			for (int j = 0; j < path.Count - 1; j++)
			{
				float magnitude2 = (path[j] - path[j + 1]).magnitude;
				Vector3 a = vector;
				Vector3 vector2 = (j >= path.Count - 2) ? (path[j + 1] - path[j]).normalized : ((path[j + 2] - path[j + 1]).normalized - (path[j] - path[j + 1]).normalized).normalized;
				Vector3 tan = a * magnitude2 * factor;
				Vector3 tan2 = vector2 * magnitude2 * factor;
				Vector3 a2 = path[j];
				Vector3 b = path[j + 1];
				float num3 = 1f / magnitude2;
				for (float num4 = 0f; num4 <= magnitude2; num4 += maxSegmentLength)
				{
					float t = num4 * num3;
					list.Add(GetPointOnCubic(a2, b, tan, tan2, t));
				}
				vector = vector2;
			}
			list[list.Count - 1] = path[path.Count - 1];
			return list;
		}

		public static Vector3 GetPointOnCubic(Vector3 a, Vector3 b, Vector3 tan1, Vector3 tan2, float t)
		{
			float num = t * t;
			float num2 = num * t;
			float d = 2f * num2 - 3f * num + 1f;
			float d2 = -2f * num2 + 3f * num;
			float d3 = num2 - 2f * num + t;
			float d4 = num2 - num;
			return d * a + d2 * b + d3 * tan1 + d4 * tan2;
		}

		public List<Vector3> SmoothOffsetSimple(List<Vector3> path)
		{
			if (path.Count <= 2 || iterations <= 0)
			{
				return path;
			}
			if (iterations > 12)
			{
				UnityEngine.Debug.LogWarning("A very high iteration count was passed, won't let this one through");
				return path;
			}
			int num = (path.Count - 2) * (int)Mathf.Pow(2f, iterations) + 2;
			List<Vector3> list = ListPool<Vector3>.Claim(num);
			List<Vector3> list2 = ListPool<Vector3>.Claim(num);
			for (int i = 0; i < num; i++)
			{
				list.Add(Vector3.zero);
				list2.Add(Vector3.zero);
			}
			for (int j = 0; j < path.Count; j++)
			{
				list[j] = path[j];
			}
			for (int k = 0; k < iterations; k++)
			{
				int num2 = (path.Count - 2) * (int)Mathf.Pow(2f, k) + 2;
				List<Vector3> list3 = list;
				list = list2;
				list2 = list3;
				float d = 1f;
				for (int l = 0; l < num2 - 1; l++)
				{
					Vector3 vector = list2[l];
					Vector3 vector2 = list2[l + 1];
					Vector3 normalized = Vector3.Cross(vector2 - vector, Vector3.up).normalized;
					bool flag = false;
					bool flag2 = false;
					bool flag3 = false;
					bool flag4 = false;
					if (l != 0 && !Polygon.IsColinear(vector, vector2, list2[l - 1]))
					{
						flag3 = true;
						flag = Polygon.Left(vector, vector2, list2[l - 1]);
					}
					if (l < num2 - 1 && !Polygon.IsColinear(vector, vector2, list2[l + 2]))
					{
						flag4 = true;
						flag2 = Polygon.Left(vector, vector2, list2[l + 2]);
					}
					if (flag3)
					{
						list[l * 2] = vector + ((!flag) ? (-normalized * offset * d) : (normalized * offset * d));
					}
					else
					{
						list[l * 2] = vector;
					}
					if (flag4)
					{
						list[l * 2 + 1] = vector2 + ((!flag2) ? (-normalized * offset * d) : (normalized * offset * d));
					}
					else
					{
						list[l * 2 + 1] = vector2;
					}
				}
				list[(path.Count - 2) * (int)Mathf.Pow(2f, k + 1) + 2 - 1] = list2[num2 - 1];
			}
			ListPool<Vector3>.Release(list2);
			return list;
		}

		public List<Vector3> SmoothSimple(List<Vector3> path)
		{
			if (path.Count < 2)
			{
				return path;
			}
			if (uniformLength)
			{
				int num = 0;
				maxSegmentLength = ((!(maxSegmentLength < 0.005f)) ? maxSegmentLength : 0.005f);
				for (int i = 0; i < path.Count - 1; i++)
				{
					float num2 = Vector3.Distance(path[i], path[i + 1]);
					num += Mathf.FloorToInt(num2 / maxSegmentLength);
				}
				List<Vector3> list = ListPool<Vector3>.Claim(num + 1);
				int num3 = 0;
				float num4 = 0f;
				for (int j = 0; j < path.Count - 1; j++)
				{
					float num5 = Vector3.Distance(path[j], path[j + 1]);
					int num6 = Mathf.FloorToInt((num5 + num4) / maxSegmentLength);
					float num7 = num4 / num5;
					Vector3 a = path[j + 1] - path[j];
					for (int k = 0; k < num6; k++)
					{
						list.Add(a * Math.Max(0f, (float)k / (float)num6 - num7) + path[j]);
						num3++;
					}
					num4 = (num5 + num4) % maxSegmentLength;
				}
				list.Add(path[path.Count - 1]);
				if (strength != 0f)
				{
					for (int l = 0; l < iterations; l++)
					{
						Vector3 a2 = list[0];
						for (int m = 1; m < list.Count - 1; m++)
						{
							Vector3 vector = list[m];
							list[m] = Vector3.Lerp(vector, (a2 + list[m + 1]) / 2f, strength);
							a2 = vector;
						}
					}
				}
				return list;
			}
			List<Vector3> list2 = ListPool<Vector3>.Claim();
			if (subdivisions < 0)
			{
				subdivisions = 0;
			}
			int num8 = 1 << subdivisions;
			for (int n = 0; n < path.Count - 1; n++)
			{
				for (int num9 = 0; num9 < num8; num9++)
				{
					list2.Add(Vector3.Lerp(path[n], path[n + 1], (float)num9 / (float)num8));
				}
			}
			for (int num10 = 0; num10 < iterations; num10++)
			{
				Vector3 a3 = list2[0];
				for (int num11 = 1; num11 < list2.Count - 1; num11++)
				{
					Vector3 vector2 = list2[num11];
					list2[num11] = Vector3.Lerp(vector2, (a3 + list2[num11 + 1]) / 2f, strength);
					a3 = vector2;
				}
			}
			return list2;
		}

		public List<Vector3> SmoothBezier(List<Vector3> path)
		{
			if (subdivisions < 0)
			{
				subdivisions = 0;
			}
			int num = 1 << subdivisions;
			List<Vector3> list = ListPool<Vector3>.Claim();
			for (int i = 0; i < path.Count - 1; i++)
			{
				Vector3 zero = Vector3.zero;
				Vector3 zero2 = Vector3.zero;
				zero = ((i != 0) ? (path[i + 1] - path[i - 1]) : (path[i + 1] - path[i]));
				zero2 = ((i != path.Count - 2) ? (path[i] - path[i + 2]) : (path[i] - path[i + 1]));
				zero *= bezierTangentLength;
				zero2 *= bezierTangentLength;
				Vector3 vector = path[i];
				Vector3 p = vector + zero;
				Vector3 vector2 = path[i + 1];
				Vector3 p2 = vector2 + zero2;
				for (int j = 0; j < num; j++)
				{
					list.Add(AstarMath.CubicBezier(vector, p, p2, vector2, (float)j / (float)num));
				}
			}
			list.Add(path[path.Count - 1]);
			return list;
		}
	}
	[Serializable]
	public class StartEndModifier : PathModifier
	{
		public enum Exactness
		{
			SnapToNode,
			Original,
			Interpolate,
			ClosestOnNode
		}

		public bool addPoints;

		public Exactness exactStartPoint = Exactness.ClosestOnNode;

		public Exactness exactEndPoint = Exactness.ClosestOnNode;

		public bool useRaycasting;

		public LayerMask mask = -1;

		public bool useGraphRaycasting;

		public override ModifierData input => ModifierData.Vector;

		public override ModifierData output => (ModifierData)(((!addPoints) ? 4 : 0) | 8);

		public override void Apply(Path _p, ModifierData source)
		{
			ABPath aBPath = _p as ABPath;
			if (aBPath == null || aBPath.vectorPath.Count == 0)
			{
				return;
			}
			if (aBPath.vectorPath.Count < 2 && !addPoints)
			{
				aBPath.vectorPath.Add(aBPath.vectorPath[0]);
			}
			Vector3 zero = Vector3.zero;
			Vector3 zero2 = Vector3.zero;
			if (exactStartPoint == Exactness.Original)
			{
				zero = GetClampedPoint((Vector3)aBPath.path[0].position, aBPath.originalStartPoint, aBPath.path[0]);
			}
			else if (exactStartPoint == Exactness.ClosestOnNode)
			{
				zero = GetClampedPoint((Vector3)aBPath.path[0].position, aBPath.startPoint, aBPath.path[0]);
			}
			else if (exactStartPoint == Exactness.Interpolate)
			{
				zero = GetClampedPoint((Vector3)aBPath.path[0].position, aBPath.originalStartPoint, aBPath.path[0]);
				zero = AstarMath.NearestPointStrict((Vector3)aBPath.path[0].position, (Vector3)aBPath.path[(1 < aBPath.path.Count) ? 1 : 0].position, zero);
			}
			else
			{
				zero = (Vector3)aBPath.path[0].position;
			}
			if (exactEndPoint == Exactness.Original)
			{
				zero2 = GetClampedPoint((Vector3)aBPath.path[aBPath.path.Count - 1].position, aBPath.originalEndPoint, aBPath.path[aBPath.path.Count - 1]);
			}
			else if (exactEndPoint == Exactness.ClosestOnNode)
			{
				zero2 = GetClampedPoint((Vector3)aBPath.path[aBPath.path.Count - 1].position, aBPath.endPoint, aBPath.path[aBPath.path.Count - 1]);
			}
			else if (exactEndPoint == Exactness.Interpolate)
			{
				zero2 = GetClampedPoint((Vector3)aBPath.path[aBPath.path.Count - 1].position, aBPath.originalEndPoint, aBPath.path[aBPath.path.Count - 1]);
				zero2 = AstarMath.NearestPointStrict((Vector3)aBPath.path[aBPath.path.Count - 1].position, (Vector3)aBPath.path[(aBPath.path.Count - 2 >= 0) ? (aBPath.path.Count - 2) : 0].position, zero2);
			}
			else
			{
				zero2 = (Vector3)aBPath.path[aBPath.path.Count - 1].position;
			}
			if (!addPoints)
			{
				aBPath.vectorPath[0] = zero;
				aBPath.vectorPath[aBPath.vectorPath.Count - 1] = zero2;
				return;
			}
			if (exactStartPoint != 0)
			{
				aBPath.vectorPath.Insert(0, zero);
			}
			if (exactEndPoint != 0)
			{
				aBPath.vectorPath.Add(zero2);
			}
		}

		public Vector3 GetClampedPoint(Vector3 from, Vector3 to, GraphNode hint)
		{
			Vector3 vector = to;
			if (useRaycasting && Physics.Linecast(from, to, out RaycastHit hitInfo, mask))
			{
				vector = hitInfo.point;
			}
			if (useGraphRaycasting && hint != null)
			{
				NavGraph graph = AstarData.GetGraph(hint);
				if (graph != null)
				{
					IRaycastableGraph raycastableGraph = graph as IRaycastableGraph;
					if (raycastableGraph != null && raycastableGraph.Linecast(from, vector, hint, out GraphHitInfo hit))
					{
						vector = hit.point;
					}
				}
			}
			return vector;
		}
	}
	public class NavmeshAdd : MonoBehaviour
	{
		public enum MeshType
		{
			Rectangle,
			CustomMesh
		}

		private static List<NavmeshAdd> allCuts = new List<NavmeshAdd>();

		public MeshType type;

		public Mesh mesh;

		private Vector3[] verts;

		private int[] tris;

		public Vector2 rectangleSize = new Vector2(1f, 1f);

		public float meshScale = 1f;

		public Vector3 center;

		private Bounds bounds;

		public bool useRotation;

		protected Transform tr;

		public static readonly Color GizmoColor = new Color(94f / 255f, 239f / 255f, 37f / 255f);

		public Vector3 Center => tr.position + ((!useRotation) ? center : tr.TransformPoint(center));

		private static void Add(NavmeshAdd obj)
		{
			allCuts.Add(obj);
		}

		private static void Remove(NavmeshAdd obj)
		{
			allCuts.Remove(obj);
		}

		public static List<NavmeshAdd> GetAllInRange(Bounds b)
		{
			List<NavmeshAdd> list = ListPool<NavmeshAdd>.Claim();
			for (int i = 0; i < allCuts.Count; i++)
			{
				if (allCuts[i].enabled && Intersects(b, allCuts[i].GetBounds()))
				{
					list.Add(allCuts[i]);
				}
			}
			return list;
		}

		private static bool Intersects(Bounds b1, Bounds b2)
		{
			Vector3 min = b1.min;
			Vector3 max = b1.max;
			Vector3 min2 = b2.min;
			Vector3 max2 = b2.max;
			return min.x <= max2.x && max.x >= min2.x && min.z <= max2.z && max.z >= min2.z;
		}

		public static List<NavmeshAdd> GetAll()
		{
			return allCuts;
		}

		public void Awake()
		{
			Add(this);
		}

		public void OnEnable()
		{
			tr = base.transform;
		}

		public void OnDestroy()
		{
			Remove(this);
		}

		[ContextMenu("Rebuild Mesh")]
		public void RebuildMesh()
		{
			if (type == MeshType.CustomMesh)
			{
				if (mesh == null)
				{
					verts = null;
					tris = null;
				}
				else
				{
					verts = mesh.vertices;
					tris = mesh.triangles;
				}
				return;
			}
			if (verts == null || verts.Length != 4 || tris == null || tris.Length != 6)
			{
				verts = new Vector3[4];
				tris = new int[6];
			}
			tris[0] = 0;
			tris[1] = 1;
			tris[2] = 2;
			tris[3] = 0;
			tris[4] = 2;
			tris[5] = 3;
			verts[0] = new Vector3((0f - rectangleSize.x) * 0.5f, 0f, (0f - rectangleSize.y) * 0.5f);
			verts[1] = new Vector3(rectangleSize.x * 0.5f, 0f, (0f - rectangleSize.y) * 0.5f);
			verts[2] = new Vector3(rectangleSize.x * 0.5f, 0f, rectangleSize.y * 0.5f);
			verts[3] = new Vector3((0f - rectangleSize.x) * 0.5f, 0f, rectangleSize.y * 0.5f);
		}

		public Bounds GetBounds()
		{
			switch (type)
			{
			case MeshType.Rectangle:
				if (useRotation)
				{
					Matrix4x4 matrix4x2 = Matrix4x4.TRS(tr.position, tr.rotation, Vector3.one);
					this.bounds = new Bounds(matrix4x2.MultiplyPoint3x4(center + new Vector3(0f - rectangleSize.x, 0f, 0f - rectangleSize.y) * 0.5f), Vector3.zero);
					this.bounds.Encapsulate(matrix4x2.MultiplyPoint3x4(center + new Vector3(rectangleSize.x, 0f, 0f - rectangleSize.y) * 0.5f));
					this.bounds.Encapsulate(matrix4x2.MultiplyPoint3x4(center + new Vector3(rectangleSize.x, 0f, rectangleSize.y) * 0.5f));
					this.bounds.Encapsulate(matrix4x2.MultiplyPoint3x4(center + new Vector3(0f - rectangleSize.x, 0f, rectangleSize.y) * 0.5f));
				}
				else
				{
					this.bounds = new Bounds(tr.position + center, new Vector3(rectangleSize.x, 0f, rectangleSize.y));
				}
				break;
			case MeshType.CustomMesh:
				if (!(mesh == null))
				{
					Bounds bounds = mesh.bounds;
					if (useRotation)
					{
						Matrix4x4 matrix4x = Matrix4x4.TRS(tr.position, tr.rotation, Vector3.one * meshScale);
						this.bounds = new Bounds(matrix4x.MultiplyPoint3x4(center + bounds.center), Vector3.zero);
						Vector3 max = bounds.max;
						Vector3 min = bounds.min;
						this.bounds.Encapsulate(matrix4x.MultiplyPoint3x4(center + new Vector3(max.x, min.y, max.z)));
						this.bounds.Encapsulate(matrix4x.MultiplyPoint3x4(center + new Vector3(min.x, min.y, max.z)));
						this.bounds.Encapsulate(matrix4x.MultiplyPoint3x4(center + new Vector3(min.x, max.y, min.z)));
						this.bounds.Encapsulate(matrix4x.MultiplyPoint3x4(center + new Vector3(max.x, max.y, min.z)));
					}
					else
					{
						Vector3 size = bounds.size * meshScale;
						this.bounds = new Bounds(base.transform.position + center + bounds.center * meshScale, size);
					}
				}
				break;
			}
			return this.bounds;
		}

		public void GetMesh(Int3 offset, ref Int3[] vbuffer, out int[] tbuffer)
		{
			if (verts == null)
			{
				RebuildMesh();
			}
			if (verts == null)
			{
				tbuffer = new int[0];
				return;
			}
			if (vbuffer == null || vbuffer.Length < verts.Length)
			{
				vbuffer = new Int3[verts.Length];
			}
			tbuffer = tris;
			if (useRotation)
			{
				Matrix4x4 matrix4x = Matrix4x4.TRS(tr.position + center, tr.rotation, tr.localScale * meshScale);
				for (int i = 0; i < verts.Length; i++)
				{
					vbuffer[i] = offset + (Int3)matrix4x.MultiplyPoint3x4(verts[i]);
				}
			}
			else
			{
				Vector3 a = tr.position + center;
				for (int j = 0; j < verts.Length; j++)
				{
					vbuffer[j] = offset + (Int3)(a + verts[j] * meshScale);
				}
			}
		}
	}
	[AddComponentMenu("Pathfinding/Navmesh/Navmesh Cut")]
	public class NavmeshCut : MonoBehaviour
	{
		public enum MeshType
		{
			Rectangle,
			Circle,
			CustomMesh
		}

		private static List<NavmeshCut> allCuts = new List<NavmeshCut>();

		public MeshType type;

		public Mesh mesh;

		public Vector2 rectangleSize = new Vector2(1f, 1f);

		public float circleRadius = 1f;

		public int circleResolution = 6;

		public float height = 1f;

		public float meshScale = 1f;

		public Vector3 center;

		public float updateDistance = 0.4f;

		public bool isDual;

		public bool cutsAddedGeom = true;

		public float updateRotationDistance = 10f;

		public bool useRotation;

		private Vector3[][] contours;

		protected Transform tr;

		private Mesh lastMesh;

		private Vector3 lastPosition;

		private Quaternion lastRotation;

		private bool wasEnabled;

		private Bounds bounds;

		private Bounds lastBounds;

		private static readonly Dictionary<Int2, int> edges = new Dictionary<Int2, int>();

		private static readonly Dictionary<int, int> pointers = new Dictionary<int, int>();

		public static readonly Color GizmoColor = new Color(37f / 255f, 184f / 255f, 239f / 255f);

		public Bounds LastBounds => lastBounds;

		public static event Action<NavmeshCut> OnDestroyCallback;

		private static void AddCut(NavmeshCut obj)
		{
			allCuts.Add(obj);
		}

		private static void RemoveCut(NavmeshCut obj)
		{
			allCuts.Remove(obj);
		}

		public static List<NavmeshCut> GetAllInRange(Bounds b)
		{
			List<NavmeshCut> list = ListPool<NavmeshCut>.Claim();
			for (int i = 0; i < allCuts.Count; i++)
			{
				if (allCuts[i].enabled && Intersects(b, allCuts[i].GetBounds()))
				{
					list.Add(allCuts[i]);
				}
			}
			return list;
		}

		private static bool Intersects(Bounds b1, Bounds b2)
		{
			Vector3 min = b1.min;
			Vector3 max = b1.max;
			Vector3 min2 = b2.min;
			Vector3 max2 = b2.max;
			return min.x <= max2.x && max.x >= min2.x && min.y <= max2.y && max.y >= min2.y && min.z <= max2.z && max.z >= min2.z;
		}

		public static List<NavmeshCut> GetAll()
		{
			return allCuts;
		}

		public void Awake()
		{
			AddCut(this);
		}

		public void OnEnable()
		{
			tr = base.transform;
			lastPosition = new Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity);
			lastRotation = tr.rotation;
		}

		public void OnDestroy()
		{
			if (NavmeshCut.OnDestroyCallback != null)
			{
				NavmeshCut.OnDestroyCallback(this);
			}
			RemoveCut(this);
		}

		public void ForceUpdate()
		{
			lastPosition = new Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity);
		}

		public bool RequiresUpdate()
		{
			return wasEnabled != base.enabled || (wasEnabled && ((tr.position - lastPosition).sqrMagnitude > updateDistance * updateDistance || (useRotation && Quaternion.Angle(lastRotation, tr.rotation) > updateRotationDistance)));
		}

		public virtual void UsedForCut()
		{
		}

		public void NotifyUpdated()
		{
			wasEnabled = base.enabled;
			if (wasEnabled)
			{
				lastPosition = tr.position;
				lastBounds = GetBounds();
				if (useRotation)
				{
					lastRotation = tr.rotation;
				}
			}
		}

		private void CalculateMeshContour()
		{
			if (mesh == null)
			{
				return;
			}
			edges.Clear();
			pointers.Clear();
			Vector3[] vertices = mesh.vertices;
			int[] triangles = mesh.triangles;
			for (int i = 0; i < triangles.Length; i += 3)
			{
				if (Polygon.IsClockwise(vertices[triangles[i]], vertices[triangles[i + 1]], vertices[triangles[i + 2]]))
				{
					int num = triangles[i];
					triangles[i] = triangles[i + 2];
					triangles[i + 2] = num;
				}
				edges[new Int2(triangles[i], triangles[i + 1])] = i;
				edges[new Int2(triangles[i + 1], triangles[i + 2])] = i;
				edges[new Int2(triangles[i + 2], triangles[i])] = i;
			}
			for (int j = 0; j < triangles.Length; j += 3)
			{
				for (int k = 0; k < 3; k++)
				{
					if (!edges.ContainsKey(new Int2(triangles[j + (k + 1) % 3], triangles[j + k % 3])))
					{
						pointers[triangles[j + k % 3]] = triangles[j + (k + 1) % 3];
					}
				}
			}
			List<Vector3[]> list = new List<Vector3[]>();
			List<Vector3> list2 = ListPool<Vector3>.Claim();
			for (int l = 0; l < vertices.Length; l++)
			{
				if (!pointers.ContainsKey(l))
				{
					continue;
				}
				list2.Clear();
				int num2 = l;
				do
				{
					int num3 = pointers[num2];
					if (num3 == -1)
					{
						break;
					}
					pointers[num2] = -1;
					list2.Add(vertices[num2]);
					num2 = num3;
					if (num2 == -1)
					{
						UnityEngine.Debug.LogError("Invalid Mesh '" + mesh.name + " in " + base.gameObject.name);
						break;
					}
				}
				while (num2 != l);
				if (list2.Count > 0)
				{
					list.Add(list2.ToArray());
				}
			}
			ListPool<Vector3>.Release(list2);
			contours = list.ToArray();
		}

		public Bounds GetBounds()
		{
			switch (type)
			{
			case MeshType.Rectangle:
				if (useRotation)
				{
					Matrix4x4 localToWorldMatrix2 = tr.localToWorldMatrix;
					this.bounds = new Bounds(localToWorldMatrix2.MultiplyPoint3x4(center + new Vector3(0f - rectangleSize.x, 0f - height, 0f - rectangleSize.y) * 0.5f), Vector3.zero);
					this.bounds.Encapsulate(localToWorldMatrix2.MultiplyPoint3x4(center + new Vector3(rectangleSize.x, 0f - height, 0f - rectangleSize.y) * 0.5f));
					this.bounds.Encapsulate(localToWorldMatrix2.MultiplyPoint3x4(center + new Vector3(rectangleSize.x, 0f - height, rectangleSize.y) * 0.5f));
					this.bounds.Encapsulate(localToWorldMatrix2.MultiplyPoint3x4(center + new Vector3(0f - rectangleSize.x, 0f - height, rectangleSize.y) * 0.5f));
					this.bounds.Encapsulate(localToWorldMatrix2.MultiplyPoint3x4(center + new Vector3(0f - rectangleSize.x, height, 0f - rectangleSize.y) * 0.5f));
					this.bounds.Encapsulate(localToWorldMatrix2.MultiplyPoint3x4(center + new Vector3(rectangleSize.x, height, 0f - rectangleSize.y) * 0.5f));
					this.bounds.Encapsulate(localToWorldMatrix2.MultiplyPoint3x4(center + new Vector3(rectangleSize.x, height, rectangleSize.y) * 0.5f));
					this.bounds.Encapsulate(localToWorldMatrix2.MultiplyPoint3x4(center + new Vector3(0f - rectangleSize.x, height, rectangleSize.y) * 0.5f));
				}
				else
				{
					this.bounds = new Bounds(tr.position + center, new Vector3(rectangleSize.x, height, rectangleSize.y));
				}
				break;
			case MeshType.Circle:
				if (useRotation)
				{
					this.bounds = new Bounds(tr.localToWorldMatrix.MultiplyPoint3x4(center), new Vector3(circleRadius * 2f, height, circleRadius * 2f));
				}
				else
				{
					this.bounds = new Bounds(base.transform.position + center, new Vector3(circleRadius * 2f, height, circleRadius * 2f));
				}
				break;
			case MeshType.CustomMesh:
				if (!(mesh == null))
				{
					Bounds bounds = mesh.bounds;
					if (useRotation)
					{
						Matrix4x4 localToWorldMatrix = tr.localToWorldMatrix;
						bounds.center *= meshScale;
						bounds.size *= meshScale;
						this.bounds = new Bounds(localToWorldMatrix.MultiplyPoint3x4(center + bounds.center), Vector3.zero);
						Vector3 max = bounds.max;
						Vector3 min = bounds.min;
						this.bounds.Encapsulate(localToWorldMatrix.MultiplyPoint3x4(center + new Vector3(max.x, max.y, max.z)));
						this.bounds.Encapsulate(localToWorldMatrix.MultiplyPoint3x4(center + new Vector3(min.x, max.y, max.z)));
						this.bounds.Encapsulate(localToWorldMatrix.MultiplyPoint3x4(center + new Vector3(min.x, max.y, min.z)));
						this.bounds.Encapsulate(localToWorldMatrix.MultiplyPoint3x4(center + new Vector3(max.x, max.y, min.z)));
						this.bounds.Encapsulate(localToWorldMatrix.MultiplyPoint3x4(center + new Vector3(max.x, min.y, max.z)));
						this.bounds.Encapsulate(localToWorldMatrix.MultiplyPoint3x4(center + new Vector3(min.x, min.y, max.z)));
						this.bounds.Encapsulate(localToWorldMatrix.MultiplyPoint3x4(center + new Vector3(min.x, min.y, min.z)));
						this.bounds.Encapsulate(localToWorldMatrix.MultiplyPoint3x4(center + new Vector3(max.x, min.y, min.z)));
						Vector3 size = this.bounds.size;
						float y = size.y;
						float num = height;
						Vector3 lossyScale = tr.lossyScale;
						size.y = Mathf.Max(y, num * lossyScale.y);
						this.bounds.size = size;
					}
					else
					{
						Vector3 size2 = bounds.size * meshScale;
						size2.y = Mathf.Max(size2.y, height);
						this.bounds = new Bounds(base.transform.position + center + bounds.center * meshScale, size2);
					}
				}
				break;
			}
			return this.bounds;
		}

		public void GetContour(List<List<IntPoint>> buffer)
		{
			if (circleResolution < 3)
			{
				circleResolution = 3;
			}
			Vector3 position = tr.position;
			switch (type)
			{
			case MeshType.Rectangle:
			{
				List<IntPoint> list = ListPool<IntPoint>.Claim();
				if (useRotation)
				{
					Matrix4x4 localToWorldMatrix2 = tr.localToWorldMatrix;
					list.Add(V3ToIntPoint(localToWorldMatrix2.MultiplyPoint3x4(center + new Vector3(0f - rectangleSize.x, 0f, 0f - rectangleSize.y) * 0.5f)));
					list.Add(V3ToIntPoint(localToWorldMatrix2.MultiplyPoint3x4(center + new Vector3(rectangleSize.x, 0f, 0f - rectangleSize.y) * 0.5f)));
					list.Add(V3ToIntPoint(localToWorldMatrix2.MultiplyPoint3x4(center + new Vector3(rectangleSize.x, 0f, rectangleSize.y) * 0.5f)));
					list.Add(V3ToIntPoint(localToWorldMatrix2.MultiplyPoint3x4(center + new Vector3(0f - rectangleSize.x, 0f, rectangleSize.y) * 0.5f)));
				}
				else
				{
					position += center;
					list.Add(V3ToIntPoint(position + new Vector3(0f - rectangleSize.x, 0f, 0f - rectangleSize.y) * 0.5f));
					list.Add(V3ToIntPoint(position + new Vector3(rectangleSize.x, 0f, 0f - rectangleSize.y) * 0.5f));
					list.Add(V3ToIntPoint(position + new Vector3(rectangleSize.x, 0f, rectangleSize.y) * 0.5f));
					list.Add(V3ToIntPoint(position + new Vector3(0f - rectangleSize.x, 0f, rectangleSize.y) * 0.5f));
				}
				buffer.Add(list);
				break;
			}
			case MeshType.Circle:
			{
				List<IntPoint> list = ListPool<IntPoint>.Claim(circleResolution);
				if (useRotation)
				{
					Matrix4x4 localToWorldMatrix3 = tr.localToWorldMatrix;
					for (int l = 0; l < circleResolution; l++)
					{
						list.Add(V3ToIntPoint(localToWorldMatrix3.MultiplyPoint3x4(center + new Vector3(Mathf.Cos((float)(l * 2) * (float)Math.PI / (float)circleResolution), 0f, Mathf.Sin((float)(l * 2) * (float)Math.PI / (float)circleResolution)) * circleRadius)));
					}
				}
				else
				{
					position += center;
					for (int m = 0; m < circleResolution; m++)
					{
						list.Add(V3ToIntPoint(position + new Vector3(Mathf.Cos((float)(m * 2) * (float)Math.PI / (float)circleResolution), 0f, Mathf.Sin((float)(m * 2) * (float)Math.PI / (float)circleResolution)) * circleRadius));
					}
				}
				buffer.Add(list);
				break;
			}
			case MeshType.CustomMesh:
			{
				if (mesh != lastMesh || contours == null)
				{
					CalculateMeshContour();
					lastMesh = mesh;
				}
				if (contours == null)
				{
					break;
				}
				position += center;
				bool flag = Vector3.Dot(tr.up, Vector3.up) < 0f;
				for (int i = 0; i < contours.Length; i++)
				{
					Vector3[] array = contours[i];
					List<IntPoint> list = ListPool<IntPoint>.Claim(array.Length);
					if (useRotation)
					{
						Matrix4x4 localToWorldMatrix = tr.localToWorldMatrix;
						for (int j = 0; j < array.Length; j++)
						{
							list.Add(V3ToIntPoint(localToWorldMatrix.MultiplyPoint3x4(center + array[j] * meshScale)));
						}
					}
					else
					{
						for (int k = 0; k < array.Length; k++)
						{
							list.Add(V3ToIntPoint(position + array[k] * meshScale));
						}
					}
					if (flag)
					{
						list.Reverse();
					}
					buffer.Add(list);
				}
				break;
			}
			}
		}

		public IntPoint V3ToIntPoint(Vector3 p)
		{
			Int3 @int = (Int3)p;
			return new IntPoint(@int.x, @int.z);
		}

		public Vector3 IntPointToV3(IntPoint p)
		{
			Int3 ob = new Int3((int)p.X, 0, (int)p.Y);
			return (Vector3)ob;
		}

		public void OnDrawGizmos()
		{
			if (tr == null)
			{
				tr = base.transform;
			}
			List<List<IntPoint>> list = ListPool<List<IntPoint>>.Claim();
			GetContour(list);
			Gizmos.color = GizmoColor;
			Bounds bounds = GetBounds();
			Vector3 min = bounds.min;
			float y = min.y;
			Vector3 up = Vector3.up;
			Vector3 max = bounds.max;
			Vector3 b = up * (max.y - y);
			for (int i = 0; i < list.Count; i++)
			{
				List<IntPoint> list2 = list[i];
				for (int j = 0; j < list2.Count; j++)
				{
					Vector3 vector = IntPointToV3(list2[j]);
					vector.y = y;
					Vector3 vector2 = IntPointToV3(list2[(j + 1) % list2.Count]);
					vector2.y = y;
					Gizmos.DrawLine(vector, vector2);
					Gizmos.DrawLine(vector + b, vector2 + b);
					Gizmos.DrawLine(vector, vector + b);
					Gizmos.DrawLine(vector2, vector2 + b);
				}
			}
			ListPool<List<IntPoint>>.Release(list);
		}

		public void OnDrawGizmosSelected()
		{
			Gizmos.color = Color.Lerp(GizmoColor, new Color(1f, 1f, 1f, 0.2f), 0.9f);
			Bounds bounds = GetBounds();
			Gizmos.DrawCube(bounds.center, bounds.size);
			Gizmos.DrawWireCube(bounds.center, bounds.size);
		}
	}
	[AddComponentMenu("Pathfinding/Navmesh/RelevantGraphSurface")]
	public class RelevantGraphSurface : MonoBehaviour
	{
		private static RelevantGraphSurface root;

		public float maxRange = 1f;

		private RelevantGraphSurface prev;

		private RelevantGraphSurface next;

		private Vector3 position;

		public Vector3 Position => position;

		public RelevantGraphSurface Next => next;

		public RelevantGraphSurface Prev => prev;

		public static RelevantGraphSurface Root => root;

		public void UpdatePosition()
		{
			position = base.transform.position;
		}

		private void OnEnable()
		{
			UpdatePosition();
			if (root == null)
			{
				root = this;
				return;
			}
			next = root;
			root.prev = this;
			root = this;
		}

		private void OnDisable()
		{
			if (root == this)
			{
				root = next;
				if (root != null)
				{
					root.prev = null;
				}
			}
			else
			{
				if (prev != null)
				{
					prev.next = next;
				}
				if (next != null)
				{
					next.prev = prev;
				}
			}
			prev = null;
			next = null;
		}

		public static void UpdateAllPositions()
		{
			RelevantGraphSurface relevantGraphSurface = root;
			while (relevantGraphSurface != null)
			{
				relevantGraphSurface.UpdatePosition();
				relevantGraphSurface = relevantGraphSurface.Next;
			}
		}

		public static void FindAllGraphSurfaces()
		{
			RelevantGraphSurface[] array = UnityEngine.Object.FindObjectsOfType(typeof(RelevantGraphSurface)) as RelevantGraphSurface[];
			for (int i = 0; i < array.Length; i++)
			{
				array[i].OnDisable();
				array[i].OnEnable();
			}
		}

		public void OnDrawGizmos()
		{
			Gizmos.color = new Color(19f / 85f, 211f / 255f, 46f / 255f, 0.4f);
			Gizmos.DrawLine(base.transform.position - Vector3.up * maxRange, base.transform.position + Vector3.up * maxRange);
		}

		public void OnDrawGizmosSelected()
		{
			Gizmos.color = new Color(19f / 85f, 211f / 255f, 46f / 255f);
			Gizmos.DrawLine(base.transform.position - Vector3.up * maxRange, base.transform.position + Vector3.up * maxRange);
		}
	}
	public class TileHandlerHelper : MonoBehaviour
	{
		private TileHandler handler;

		public float updateInterval;

		private float lastUpdateTime = -999f;

		private List<Bounds> forcedReloadBounds = new List<Bounds>();

		public void UseSpecifiedHandler(TileHandler handler)
		{
			this.handler = handler;
		}

		private void OnEnable()
		{
			NavmeshCut.OnDestroyCallback += HandleOnDestroyCallback;
		}

		private void OnDisable()
		{
			NavmeshCut.OnDestroyCallback -= HandleOnDestroyCallback;
		}

		public void DiscardPending()
		{
			List<NavmeshCut> all = NavmeshCut.GetAll();
			for (int i = 0; i < all.Count; i++)
			{
				if (all[i].RequiresUpdate())
				{
					all[i].NotifyUpdated();
				}
			}
		}

		private void Start()
		{
			if (UnityEngine.Object.FindObjectsOfType(typeof(TileHandlerHelper)).Length > 1)
			{
				UnityEngine.Debug.LogError("There should only be one TileHandlerHelper per scene. Destroying.");
				UnityEngine.Object.Destroy(this);
			}
			else if (handler == null)
			{
				if (AstarPath.active == null || AstarPath.active.astarData.recastGraph == null)
				{
					UnityEngine.Debug.LogWarning("No AstarPath object in the scene or no RecastGraph on that AstarPath object");
				}
				handler = new TileHandler(AstarPath.active.astarData.recastGraph);
				handler.CreateTileTypesFromGraph();
			}
		}

		private void HandleOnDestroyCallback(NavmeshCut obj)
		{
			forcedReloadBounds.Add(obj.LastBounds);
			lastUpdateTime = -999f;
		}

		private void Update()
		{
			if (updateInterval != -1f && !(Time.realtimeSinceStartup - lastUpdateTime < updateInterval) && handler != null)
			{
				ForceUpdate();
			}
		}

		public void ForceUpdate()
		{
			if (handler == null)
			{
				throw new Exception("Cannot update graphs. No TileHandler. Do not call this method in Awake.");
			}
			lastUpdateTime = Time.realtimeSinceStartup;
			List<NavmeshCut> all = NavmeshCut.GetAll();
			if (forcedReloadBounds.Count == 0)
			{
				int num = 0;
				for (int i = 0; i < all.Count; i++)
				{
					if (all[i].RequiresUpdate())
					{
						num++;
						break;
					}
				}
				if (num == 0)
				{
					return;
				}
			}
			bool flag = handler.StartBatchLoad();
			for (int j = 0; j < forcedReloadBounds.Count; j++)
			{
				handler.ReloadInBounds(forcedReloadBounds[j]);
			}
			forcedReloadBounds.Clear();
			for (int k = 0; k < all.Count; k++)
			{
				if (all[k].enabled)
				{
					if (all[k].RequiresUpdate())
					{
						handler.ReloadInBounds(all[k].LastBounds);
						handler.ReloadInBounds(all[k].GetBounds());
					}
				}
				else if (all[k].RequiresUpdate())
				{
					handler.ReloadInBounds(all[k].LastBounds);
				}
			}
			for (int l = 0; l < all.Count; l++)
			{
				if (all[l].RequiresUpdate())
				{
					all[l].NotifyUpdated();
				}
			}
			if (flag)
			{
				handler.EndBatchLoad();
			}
		}
	}
	public class ABPath : Path
	{
		public bool recalcStartEndCosts = true;

		public GraphNode startNode;

		public GraphNode endNode;

		public GraphNode startHint;

		public GraphNode endHint;

		public Vector3 originalStartPoint;

		public Vector3 originalEndPoint;

		public Vector3 startPoint;

		public Vector3 endPoint;

		protected bool hasEndPoint = true;

		public Int3 startIntPoint;

		public bool calculatePartial;

		protected PathNode partialBestTarget;

		protected int[] endNodeCosts;

		[Obsolete("Use PathPool<T>.GetPath instead")]
		public ABPath(Vector3 start, Vector3 end, OnPathDelegate callbackDelegate)
		{
			Reset();
			Setup(start, end, callbackDelegate);
		}

		public ABPath()
		{
		}

		public static ABPath Construct(Vector3 start, Vector3 end, OnPathDelegate callback = null)
		{
			ABPath path = PathPool<ABPath>.GetPath();
			path.Setup(start, end, callback);
			return path;
		}

		protected void Setup(Vector3 start, Vector3 end, OnPathDelegate callbackDelegate)
		{
			callback = callbackDelegate;
			UpdateStartEnd(start, end);
		}

		protected void UpdateStartEnd(Vector3 start, Vector3 end)
		{
			originalStartPoint = start;
			originalEndPoint = end;
			startPoint = start;
			endPoint = end;
			startIntPoint = (Int3)start;
			hTarget = (Int3)end;
		}

		public override uint GetConnectionSpecialCost(GraphNode a, GraphNode b, uint currentCost)
		{
			if (startNode != null && endNode != null)
			{
				if (a == startNode)
				{
					return (uint)((double)(startIntPoint - ((b != endNode) ? b.position : hTarget)).costMagnitude * ((double)currentCost * 1.0 / (double)(a.position - b.position).costMagnitude));
				}
				if (b == startNode)
				{
					return (uint)((double)(startIntPoint - ((a != endNode) ? a.position : hTarget)).costMagnitude * ((double)currentCost * 1.0 / (double)(a.position - b.position).costMagnitude));
				}
				if (a == endNode)
				{
					return (uint)((double)(hTarget - b.position).costMagnitude * ((double)currentCost * 1.0 / (double)(a.position - b.position).costMagnitude));
				}
				if (b == endNode)
				{
					return (uint)((double)(hTarget - a.position).costMagnitude * ((double)currentCost * 1.0 / (double)(a.position - b.position).costMagnitude));
				}
			}
			else
			{
				if (a == startNode)
				{
					return (uint)((double)(startIntPoint - b.position).costMagnitude * ((double)currentCost * 1.0 / (double)(a.position - b.position).costMagnitude));
				}
				if (b == startNode)
				{
					return (uint)((double)(startIntPoint - a.position).costMagnitude * ((double)currentCost * 1.0 / (double)(a.position - b.position).costMagnitude));
				}
			}
			return currentCost;
		}

		public override void Reset()
		{
			base.Reset();
			startNode = null;
			endNode = null;
			startHint = null;
			endHint = null;
			originalStartPoint = Vector3.zero;
			originalEndPoint = Vector3.zero;
			startPoint = Vector3.zero;
			endPoint = Vector3.zero;
			calculatePartial = false;
			partialBestTarget = null;
			hasEndPoint = true;
			startIntPoint = default(Int3);
			hTarget = default(Int3);
			endNodeCosts = null;
		}

		public override void Prepare()
		{
			nnConstraint.tags = enabledTags;
			NNInfo nearest = AstarPath.active.GetNearest(startPoint, nnConstraint, startHint);
			(nnConstraint as PathNNConstraint)?.SetStart(nearest.node);
			startPoint = nearest.clampedPosition;
			startIntPoint = (Int3)startPoint;
			startNode = nearest.node;
			if (hasEndPoint)
			{
				NNInfo nearest2 = AstarPath.active.GetNearest(endPoint, nnConstraint, endHint);
				endPoint = nearest2.clampedPosition;
				hTarget = (Int3)endPoint;
				endNode = nearest2.node;
			}
			if (startNode == null && hasEndPoint && endNode == null)
			{
				Error();
				LogError("Couldn't find close nodes to the start point or the end point");
			}
			else if (startNode == null)
			{
				Error();
				LogError("Couldn't find a close node to the start point");
			}
			else if (endNode == null && hasEndPoint)
			{
				Error();
				LogError("Couldn't find a close node to the end point");
			}
			else if (!startNode.Walkable)
			{
				Error();
				LogError("The node closest to the start point is not walkable");
			}
			else if (hasEndPoint && !endNode.Walkable)
			{
				Error();
				LogError("The node closest to the end point is not walkable");
			}
			else if (hasEndPoint && startNode.Area != endNode.Area)
			{
				Error();
				LogError("There is no valid path to the target (start area: " + startNode.Area + ", target area: " + endNode.Area + ")");
			}
		}

		public override void Initialize()
		{
			if (startNode != null)
			{
				pathHandler.GetPathNode(startNode).flag2 = true;
			}
			if (endNode != null)
			{
				pathHandler.GetPathNode(endNode).flag2 = true;
			}
			if (hasEndPoint && startNode == endNode)
			{
				PathNode pathNode = pathHandler.GetPathNode(endNode);
				pathNode.node = endNode;
				pathNode.parent = null;
				pathNode.H = 0u;
				pathNode.G = 0u;
				Trace(pathNode);
				base.CompleteState = PathCompleteState.Complete;
				return;
			}
			PathNode pathNode2 = pathHandler.GetPathNode(startNode);
			pathNode2.node = startNode;
			pathNode2.pathID = pathHandler.PathID;
			pathNode2.parent = null;
			pathNode2.cost = 0u;
			pathNode2.G = GetTraversalCost(startNode);
			pathNode2.H = CalculateHScore(startNode);
			startNode.Open(this, pathNode2, pathHandler);
			searchedNodes++;
			partialBestTarget = pathNode2;
			if (pathHandler.HeapEmpty())
			{
				if (!calculatePartial)
				{
					Error();
					LogError("No open points, the start node didn't open any nodes");
					return;
				}
				base.CompleteState = PathCompleteState.Partial;
				Trace(partialBestTarget);
			}
			currentR = pathHandler.PopNode();
		}

		public override void Cleanup()
		{
			if (startNode != null)
			{
				pathHandler.GetPathNode(startNode).flag2 = false;
			}
			if (endNode != null)
			{
				pathHandler.GetPathNode(endNode).flag2 = false;
			}
		}

		public override void CalculateStep(long targetTick)
		{
			int num = 0;
			while (base.CompleteState == PathCompleteState.NotCalculated)
			{
				searchedNodes++;
				if (currentR.node == endNode)
				{
					base.CompleteState = PathCompleteState.Complete;
					break;
				}
				if (currentR.H < partialBestTarget.H)
				{
					partialBestTarget = currentR;
				}
				currentR.node.Open(this, currentR, pathHandler);
				if (pathHandler.HeapEmpty())
				{
					Error();
					LogError("No open points, whole area searched");
					return;
				}
				currentR = pathHandler.PopNode();
				if (num > 500)
				{
					if (DateTime.UtcNow.Ticks >= targetTick)
					{
						return;
					}
					num = 0;
					if (searchedNodes > 1000000)
					{
						throw new Exception("Probable infinite loop. Over 1,000,000 nodes searched");
					}
				}
				num++;
			}
			if (base.CompleteState == PathCompleteState.Complete)
			{
				Trace(currentR);
			}
			else if (calculatePartial && partialBestTarget != null)
			{
				base.CompleteState = PathCompleteState.Partial;
				Trace(partialBestTarget);
			}
		}

		public void ResetCosts(Path p)
		{
		}

		public override string DebugString(PathLog logMode)
		{
			if (logMode == PathLog.None || (!base.error && logMode == PathLog.OnlyErrors))
			{
				return string.Empty;
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append((!base.error) ? "Path Completed : " : "Path Failed : ");
			stringBuilder.Append("Computation Time ");
			stringBuilder.Append(duration.ToString((logMode != PathLog.Heavy) ? "0.00" : "0.000"));
			stringBuilder.Append(" ms Searched Nodes ");
			stringBuilder.Append(searchedNodes);
			if (!base.error)
			{
				stringBuilder.Append(" Path Length ");
				stringBuilder.Append((path != null) ? path.Count.ToString() : "Null");
				if (logMode == PathLog.Heavy)
				{
					stringBuilder.Append("\nSearch Iterations " + searchIterations);
					if (hasEndPoint && endNode != null)
					{
						PathNode pathNode = pathHandler.GetPathNode(endNode);
						stringBuilder.Append("\nEnd Node\n\tG: ");
						stringBuilder.Append(pathNode.G);
						stringBuilder.Append("\n\tH: ");
						stringBuilder.Append(pathNode.H);
						stringBuilder.Append("\n\tF: ");
						stringBuilder.Append(pathNode.F);
						stringBuilder.Append("\n\tPoint: ");
						stringBuilder.Append(endPoint.ToString());
						stringBuilder.Append("\n\tGraph: ");
						stringBuilder.Append(endNode.GraphIndex);
					}
					stringBuilder.Append("\nStart Node");
					stringBuilder.Append("\n\tPoint: ");
					stringBuilder.Append(startPoint.ToString());
					stringBuilder.Append("\n\tGraph: ");
					if (startNode != null)
					{
						stringBuilder.Append(startNode.GraphIndex);
					}
					else
					{
						stringBuilder.Append("< null startNode >");
					}
				}
			}
			if (base.error)
			{
				stringBuilder.Append("\nError: ");
				stringBuilder.Append(base.errorLog);
			}
			if (logMode == PathLog.Heavy && !AstarPath.IsUsingMultithreading)
			{
				stringBuilder.Append("\nCallback references ");
				if (callback != null)
				{
					stringBuilder.Append(callback.Target.GetType().FullName).AppendLine();
				}
				else
				{
					stringBuilder.AppendLine("NULL");
				}
			}
			stringBuilder.Append("\nPath Number ");
			stringBuilder.Append(pathID);
			return stringBuilder.ToString();
		}

		protected override void Recycle()
		{
			PathPool<ABPath>.Recycle(this);
		}

		public Vector3 GetMovementVector(Vector3 point)
		{
			if (vectorPath == null || vectorPath.Count == 0)
			{
				return Vector3.zero;
			}
			if (vectorPath.Count == 1)
			{
				return vectorPath[0] - point;
			}
			float num = float.PositiveInfinity;
			int num2 = 0;
			for (int i = 0; i < vectorPath.Count - 1; i++)
			{
				Vector3 a = AstarMath.NearestPointStrict(vectorPath[i], vectorPath[i + 1], point);
				float sqrMagnitude = (a - point).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					num = sqrMagnitude;
					num2 = i;
				}
			}
			return vectorPath[num2 + 1] - point;
		}
	}
	public class ConstantPath : Path
	{
		public GraphNode startNode;

		public Vector3 startPoint;

		public Vector3 originalStartPoint;

		public List<GraphNode> allNodes;

		public PathEndingCondition endingCondition;

		public ConstantPath()
		{
		}

		[Obsolete("Please use the Construct method instead")]
		public ConstantPath(Vector3 start, OnPathDelegate callbackDelegate)
		{
			throw new Exception("This constructor is obsolete, please use the Construct method instead");
		}

		[Obsolete("Please use the Construct method instead")]
		public ConstantPath(Vector3 start, int maxGScore, OnPathDelegate callbackDelegate)
		{
			throw new Exception("This constructor is obsolete, please use the Construct method instead");
		}

		public static ConstantPath Construct(Vector3 start, int maxGScore, OnPathDelegate callback = null)
		{
			ConstantPath path = PathPool<ConstantPath>.GetPath();
			path.Setup(start, maxGScore, callback);
			return path;
		}

		protected void Setup(Vector3 start, int maxGScore, OnPathDelegate callback)
		{
			base.callback = callback;
			startPoint = start;
			originalStartPoint = startPoint;
			endingCondition = new EndingConditionDistance(this, maxGScore);
		}

		public override void OnEnterPool()
		{
			base.OnEnterPool();
			if (allNodes != null)
			{
				ListPool<GraphNode>.Release(allNodes);
			}
		}

		protected override void Recycle()
		{
			PathPool<ConstantPath>.Recycle(this);
		}

		public override void Reset()
		{
			base.Reset();
			allNodes = ListPool<GraphNode>.Claim();
			endingCondition = null;
			originalStartPoint = Vector3.zero;
			startPoint = Vector3.zero;
			startNode = null;
			heuristic = Heuristic.None;
		}

		public override void Prepare()
		{
			nnConstraint.tags = enabledTags;
			NNInfo nearest = AstarPath.active.GetNearest(startPoint, nnConstraint);
			startNode = nearest.node;
			if (startNode == null)
			{
				Error();
				LogError("Could not find close node to the start point");
			}
		}

		public override void Initialize()
		{
			PathNode pathNode = pathHandler.GetPathNode(startNode);
			pathNode.node = startNode;
			pathNode.pathID = pathHandler.PathID;
			pathNode.parent = null;
			pathNode.cost = 0u;
			pathNode.G = GetTraversalCost(startNode);
			pathNode.H = CalculateHScore(startNode);
			startNode.Open(this, pathNode, pathHandler);
			searchedNodes++;
			pathNode.flag1 = true;
			allNodes.Add(startNode);
			if (pathHandler.HeapEmpty())
			{
				base.CompleteState = PathCompleteState.Complete;
			}
			else
			{
				currentR = pathHandler.PopNode();
			}
		}

		public override void Cleanup()
		{
			int count = allNodes.Count;
			for (int i = 0; i < count; i++)
			{
				pathHandler.GetPathNode(allNodes[i]).flag1 = false;
			}
		}

		public override void CalculateStep(long targetTick)
		{
			int num = 0;
			while (true)
			{
				if (base.CompleteState != 0)
				{
					return;
				}
				searchedNodes++;
				if (endingCondition.TargetFound(currentR))
				{
					base.CompleteState = PathCompleteState.Complete;
					return;
				}
				if (!currentR.flag1)
				{
					allNodes.Add(currentR.node);
					currentR.flag1 = true;
				}
				currentR.node.Open(this, currentR, pathHandler);
				if (pathHandler.HeapEmpty())
				{
					base.CompleteState = PathCompleteState.Complete;
					return;
				}
				currentR = pathHandler.PopNode();
				if (num > 500)
				{
					if (DateTime.UtcNow.Ticks >= targetTick)
					{
						return;
					}
					num = 0;
					if (searchedNodes > 1000000)
					{
						break;
					}
				}
				num++;
			}
			throw new Exception("Probable infinite loop. Over 1,000,000 nodes searched");
		}
	}
	public class EndingConditionDistance : PathEndingCondition
	{
		public int maxGScore = 100;

		public EndingConditionDistance(Path p, int maxGScore)
			: base(p)
		{
			this.maxGScore = maxGScore;
		}

		public override bool TargetFound(PathNode node)
		{
			return node.G >= maxGScore;
		}
	}
	public class FleePath : RandomPath
	{
		[Obsolete("Please use the Construct method instead")]
		public FleePath(Vector3 start, Vector3 avoid, int length, OnPathDelegate callbackDelegate = null)
			: base(start, length, callbackDelegate)
		{
			throw new Exception("Please use the Construct method instead");
		}

		public FleePath()
		{
		}

		public static FleePath Construct(Vector3 start, Vector3 avoid, int searchLength, OnPathDelegate callback = null)
		{
			FleePath path = PathPool<FleePath>.GetPath();
			path.Setup(start, avoid, searchLength, callback);
			return path;
		}

		protected void Setup(Vector3 start, Vector3 avoid, int searchLength, OnPathDelegate callback)
		{
			Setup(start, searchLength, callback);
			aim = avoid - start;
			aim *= 10f;
			aim = start - aim;
		}

		protected override void Recycle()
		{
			PathPool<FleePath>.Recycle(this);
		}
	}
	public class FloodPath : Path
	{
		public Vector3 originalStartPoint;

		public Vector3 startPoint;

		public GraphNode startNode;

		protected Dictionary<GraphNode, GraphNode> parents;

		[Obsolete("Please use the Construct method instead")]
		public FloodPath(Vector3 start, OnPathDelegate callbackDelegate)
		{
			Setup(start, callbackDelegate);
			heuristic = Heuristic.None;
		}

		public FloodPath()
		{
		}

		public bool HasPathTo(GraphNode node)
		{
			return parents != null && parents.ContainsKey(node);
		}

		public GraphNode GetParent(GraphNode node)
		{
			return parents[node];
		}

		public static FloodPath Construct(Vector3 start, OnPathDelegate callback = null)
		{
			FloodPath path = PathPool<FloodPath>.GetPath();
			path.Setup(start, callback);
			return path;
		}

		protected void Setup(Vector3 start, OnPathDelegate callback)
		{
			base.callback = callback;
			originalStartPoint = start;
			startPoint = start;
			heuristic = Heuristic.None;
		}

		public override void Reset()
		{
			base.Reset();
			originalStartPoint = Vector3.zero;
			startPoint = Vector3.zero;
			startNode = null;
			parents = new Dictionary<GraphNode, GraphNode>();
		}

		protected override void Recycle()
		{
			PathPool<FloodPath>.Recycle(this);
		}

		public override void Prepare()
		{
			nnConstraint.tags = enabledTags;
			NNInfo nearest = AstarPath.active.GetNearest(originalStartPoint, nnConstraint);
			startPoint = nearest.clampedPosition;
			startNode = nearest.node;
			if (startNode == null)
			{
				Error();
				LogError("Couldn't find a close node to the start point");
			}
			else if (!startNode.Walkable)
			{
				Error();
				LogError("The node closest to the start point is not walkable");
			}
		}

		public override void Initialize()
		{
			PathNode pathNode = pathHandler.GetPathNode(startNode);
			pathNode.node = startNode;
			pathNode.pathID = pathHandler.PathID;
			pathNode.parent = null;
			pathNode.cost = 0u;
			pathNode.G = GetTraversalCost(startNode);
			pathNode.H = CalculateHScore(startNode);
			parents[startNode] = null;
			startNode.Open(this, pathNode, pathHandler);
			searchedNodes++;
			if (pathHandler.HeapEmpty())
			{
				base.CompleteState = PathCompleteState.Complete;
			}
			currentR = pathHandler.PopNode();
		}

		public override void CalculateStep(long targetTick)
		{
			int num = 0;
			while (true)
			{
				if (base.CompleteState != 0)
				{
					return;
				}
				searchedNodes++;
				currentR.node.Open(this, currentR, pathHandler);
				parents[currentR.node] = currentR.parent.node;
				if (pathHandler.HeapEmpty())
				{
					base.CompleteState = PathCompleteState.Complete;
					return;
				}
				currentR = pathHandler.PopNode();
				if (num > 500)
				{
					if (DateTime.UtcNow.Ticks >= targetTick)
					{
						return;
					}
					num = 0;
					if (searchedNodes > 1000000)
					{
						break;
					}
				}
				num++;
			}
			throw new Exception("Probable infinite loop. Over 1,000,000 nodes searched");
		}
	}
	public class FloodPathConstraint : NNConstraint
	{
		private FloodPath path;

		public FloodPathConstraint(FloodPath path)
		{
			if (path == null)
			{
				UnityEngine.Debug.LogWarning("FloodPathConstraint should not be used with a NULL path");
			}
			this.path = path;
		}

		public override bool Suitable(GraphNode node)
		{
			return base.Suitable(node) && path.HasPathTo(node);
		}
	}
	public class FloodPathTracer : ABPath
	{
		protected FloodPath flood;

		[Obsolete("Use the Construct method instead")]
		public FloodPathTracer(Vector3 start, FloodPath flood, OnPathDelegate callbackDelegate)
		{
			throw new Exception("This constructor is obsolete");
		}

		public FloodPathTracer()
		{
		}

		public static FloodPathTracer Construct(Vector3 start, FloodPath flood, OnPathDelegate callback = null)
		{
			FloodPathTracer path = PathPool<FloodPathTracer>.GetPath();
			path.Setup(start, flood, callback);
			return path;
		}

		protected void Setup(Vector3 start, FloodPath flood, OnPathDelegate callback)
		{
			this.flood = flood;
			if (flood == null || flood.GetState() < PathState.Returned)
			{
				throw new ArgumentException("You must supply a calculated FloodPath to the 'flood' argument");
			}
			Setup(start, flood.originalStartPoint, callback);
			nnConstraint = new FloodPathConstraint(flood);
			hasEndPoint = false;
		}

		public override void Reset()
		{
			base.Reset();
			flood = null;
		}

		protected override void Recycle()
		{
			PathPool<FloodPathTracer>.Recycle(this);
		}

		public override void Initialize()
		{
			if (startNode != null && flood.HasPathTo(startNode))
			{
				Trace(startNode);
				base.CompleteState = PathCompleteState.Complete;
			}
			else
			{
				Error();
				LogError("Could not find valid start node");
			}
		}

		public override void CalculateStep(long targetTick)
		{
			if (!IsDone())
			{
				Error();
				LogError("Something went wrong. At this point the path should be completed");
			}
		}

		public void Trace(GraphNode from)
		{
			GraphNode graphNode = from;
			int num = 0;
			do
			{
				if (graphNode != null)
				{
					path.Add(graphNode);
					vectorPath.Add((Vector3)graphNode.position);
					graphNode = flood.GetParent(graphNode);
					num++;
					continue;
				}
				return;
			}
			while (num <= 1024);
			UnityEngine.Debug.LogWarning("Inifinity loop? >1024 node path. Remove this message if you really have that long paths (FloodPathTracer.cs, Trace function)");
		}
	}
	public class MultiTargetPath : ABPath
	{
		public enum HeuristicMode
		{
			None,
			Average,
			MovingAverage,
			Midpoint,
			MovingMidpoint,
			Sequential
		}

		public OnPathDelegate[] callbacks;

		public GraphNode[] targetNodes;

		protected int targetNodeCount;

		public bool[] targetsFound;

		public Vector3[] targetPoints;

		public Vector3[] originalTargetPoints;

		public List<Vector3>[] vectorPaths;

		public List<GraphNode>[] nodePaths;

		public int endsFound;

		public bool pathsForAll = true;

		public int chosenTarget = -1;

		public int sequentialTarget;

		public HeuristicMode heuristicMode = HeuristicMode.Sequential;

		public bool inverted = true;

		public MultiTargetPath()
		{
		}

		[Obsolete("Please use the Construct method instead")]
		public MultiTargetPath(Vector3[] startPoints, Vector3 target, OnPathDelegate[] callbackDelegates, OnPathDelegate callbackDelegate = null)
			: this(target, startPoints, callbackDelegates, callbackDelegate)
		{
			inverted = true;
		}

		[Obsolete("Please use the Construct method instead")]
		public MultiTargetPath(Vector3 start, Vector3[] targets, OnPathDelegate[] callbackDelegates, OnPathDelegate callbackDelegate = null)
		{
		}

		public static MultiTargetPath Construct(Vector3[] startPoints, Vector3 target, OnPathDelegate[] callbackDelegates, OnPathDelegate callback = null)
		{
			MultiTargetPath multiTargetPath = Construct(target, startPoints, callbackDelegates, callback);
			multiTargetPath.inverted = true;
			return multiTargetPath;
		}

		public static MultiTargetPath Construct(Vector3 start, Vector3[] targets, OnPathDelegate[] callbackDelegates, OnPathDelegate callback = null)
		{
			MultiTargetPath path = PathPool<MultiTargetPath>.GetPath();
			path.Setup(start, targets, callbackDelegates, callback);
			return path;
		}

		protected void Setup(Vector3 start, Vector3[] targets, OnPathDelegate[] callbackDelegates, OnPathDelegate callback)
		{
			inverted = false;
			base.callback = callback;
			callbacks = callbackDelegates;
			targetPoints = targets;
			originalStartPoint = start;
			startPoint = start;
			startIntPoint = (Int3)start;
			if (targets.Length == 0)
			{
				Error();
				LogError("No targets were assigned to the MultiTargetPath");
				return;
			}
			endPoint = targets[0];
			originalTargetPoints = new Vector3[targetPoints.Length];
			for (int i = 0; i < targetPoints.Length; i++)
			{
				originalTargetPoints[i] = targetPoints[i];
			}
		}

		protected override void Recycle()
		{
			PathPool<MultiTargetPath>.Recycle(this);
		}

		public override void OnEnterPool()
		{
			if (vectorPaths != null)
			{
				for (int i = 0; i < vectorPaths.Length; i++)
				{
					if (vectorPaths[i] != null)
					{
						ListPool<Vector3>.Release(vectorPaths[i]);
					}
				}
			}
			vectorPaths = null;
			vectorPath = null;
			if (nodePaths != null)
			{
				for (int j = 0; j < nodePaths.Length; j++)
				{
					if (nodePaths[j] != null)
					{
						ListPool<GraphNode>.Release(nodePaths[j]);
					}
				}
			}
			nodePaths = null;
			path = null;
			base.OnEnterPool();
		}

		public override void ReturnPath()
		{
			if (base.error)
			{
				if (callbacks != null)
				{
					for (int i = 0; i < callbacks.Length; i++)
					{
						if (callbacks[i] != null)
						{
							callbacks[i](this);
						}
					}
				}
				if (callback != null)
				{
					callback(this);
				}
				return;
			}
			bool flag = false;
			Vector3 originalStartPoint = base.originalStartPoint;
			Vector3 startPoint = base.startPoint;
			GraphNode startNode = base.startNode;
			for (int j = 0; j < nodePaths.Length; j++)
			{
				path = nodePaths[j];
				if (path != null)
				{
					base.CompleteState = PathCompleteState.Complete;
					flag = true;
				}
				else
				{
					base.CompleteState = PathCompleteState.Error;
				}
				if (callbacks != null && callbacks[j] != null)
				{
					vectorPath = vectorPaths[j];
					if (inverted)
					{
						endPoint = startPoint;
						endNode = startNode;
						base.startNode = targetNodes[j];
						base.startPoint = targetPoints[j];
						originalEndPoint = originalStartPoint;
						base.originalStartPoint = originalTargetPoints[j];
					}
					else
					{
						endPoint = targetPoints[j];
						originalEndPoint = originalTargetPoints[j];
						endNode = targetNodes[j];
					}
					callbacks[j](this);
					vectorPaths[j] = vectorPath;
				}
			}
			if (flag)
			{
				base.CompleteState = PathCompleteState.Complete;
				if (!pathsForAll)
				{
					path = nodePaths[chosenTarget];
					vectorPath = vectorPaths[chosenTarget];
					if (inverted)
					{
						endPoint = startPoint;
						endNode = startNode;
						base.startNode = targetNodes[chosenTarget];
						base.startPoint = targetPoints[chosenTarget];
						originalEndPoint = originalStartPoint;
						base.originalStartPoint = originalTargetPoints[chosenTarget];
					}
					else
					{
						endPoint = targetPoints[chosenTarget];
						originalEndPoint = originalTargetPoints[chosenTarget];
						endNode = targetNodes[chosenTarget];
					}
				}
			}
			else
			{
				base.CompleteState = PathCompleteState.Error;
			}
			if (callback != null)
			{
				callback(this);
			}
		}

		public void FoundTarget(PathNode nodeR, int i)
		{
			nodeR.flag1 = false;
			Trace(nodeR);
			vectorPaths[i] = vectorPath;
			nodePaths[i] = path;
			vectorPath = ListPool<Vector3>.Claim();
			path = ListPool<GraphNode>.Claim();
			targetsFound[i] = true;
			targetNodeCount--;
			if (!pathsForAll)
			{
				base.CompleteState = PathCompleteState.Complete;
				chosenTarget = i;
				targetNodeCount = 0;
			}
			else if (targetNodeCount <= 0)
			{
				base.CompleteState = PathCompleteState.Complete;
			}
			else if (heuristicMode == HeuristicMode.MovingAverage)
			{
				Vector3 zero = Vector3.zero;
				int num = 0;
				for (int j = 0; j < targetPoints.Length; j++)
				{
					if (!targetsFound[j])
					{
						zero += (Vector3)targetNodes[j].position;
						num++;
					}
				}
				if (num > 0)
				{
					zero /= (float)num;
				}
				hTarget = (Int3)zero;
				RebuildOpenList();
			}
			else if (heuristicMode == HeuristicMode.MovingMidpoint)
			{
				Vector3 vector = Vector3.zero;
				Vector3 vector2 = Vector3.zero;
				bool flag = false;
				for (int k = 0; k < targetPoints.Length; k++)
				{
					if (!targetsFound[k])
					{
						if (!flag)
						{
							vector = (Vector3)targetNodes[k].position;
							vector2 = (Vector3)targetNodes[k].position;
							flag = true;
						}
						else
						{
							vector = Vector3.Min((Vector3)targetNodes[k].position, vector);
							vector2 = Vector3.Max((Vector3)targetNodes[k].position, vector2);
						}
					}
				}
				Int3 @int = hTarget = (Int3)((vector + vector2) * 0.5f);
				RebuildOpenList();
			}
			else
			{
				if (heuristicMode != HeuristicMode.Sequential || sequentialTarget != i)
				{
					return;
				}
				float num2 = 0f;
				for (int l = 0; l < targetPoints.Length; l++)
				{
					if (!targetsFound[l])
					{
						float sqrMagnitude = (targetNodes[l].position - startNode.position).sqrMagnitude;
						if (sqrMagnitude > num2)
						{
							num2 = sqrMagnitude;
							hTarget = (Int3)targetPoints[l];
							sequentialTarget = l;
						}
					}
				}
				RebuildOpenList();
			}
		}

		protected void RebuildOpenList()
		{
			BinaryHeapM heap = pathHandler.GetHeap();
			for (int i = 0; i < heap.numberOfItems; i++)
			{
				PathNode node = heap.GetNode(i);
				node.H = CalculateHScore(node.node);
			}
			pathHandler.RebuildHeap();
		}

		public override void Prepare()
		{
			nnConstraint.tags = enabledTags;
			NNInfo nearest = AstarPath.active.GetNearest(startPoint, nnConstraint, startHint);
			startNode = nearest.node;
			if (startNode == null)
			{
				LogError("Could not find start node for multi target path");
				Error();
				return;
			}
			if (!startNode.Walkable)
			{
				LogError("Nearest node to the start point is not walkable");
				Error();
				return;
			}
			(nnConstraint as PathNNConstraint)?.SetStart(nearest.node);
			vectorPaths = new List<Vector3>[targetPoints.Length];
			nodePaths = new List<GraphNode>[targetPoints.Length];
			targetNodes = new GraphNode[targetPoints.Length];
			targetsFound = new bool[targetPoints.Length];
			targetNodeCount = targetPoints.Length;
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			for (int i = 0; i < targetPoints.Length; i++)
			{
				NNInfo nearest2 = AstarPath.active.GetNearest(targetPoints[i], nnConstraint);
				targetNodes[i] = nearest2.node;
				targetPoints[i] = nearest2.clampedPosition;
				if (targetNodes[i] != null)
				{
					flag3 = true;
					endNode = targetNodes[i];
				}
				bool flag4 = false;
				if (nearest2.node != null && nearest2.node.Walkable)
				{
					flag = true;
				}
				else
				{
					flag4 = true;
				}
				if (nearest2.node != null && nearest2.node.Area == startNode.Area)
				{
					flag2 = true;
				}
				else
				{
					flag4 = true;
				}
				if (flag4)
				{
					targetsFound[i] = true;
					targetNodeCount--;
				}
			}
			startPoint = nearest.clampedPosition;
			startIntPoint = (Int3)startPoint;
			if (startNode == null || !flag3)
			{
				LogError("Couldn't find close nodes to either the start or the end (start = " + ((startNode == null) ? "not found" : "found") + " end = " + ((!flag3) ? "none found" : "at least one found") + ")");
				Error();
			}
			else if (!startNode.Walkable)
			{
				LogError("The node closest to the start point is not walkable");
				Error();
			}
			else if (!flag)
			{
				LogError("No target nodes were walkable");
				Error();
			}
			else if (!flag2)
			{
				LogError("There are no valid paths to the targets");
				Error();
			}
			else if (pathsForAll)
			{
				if (heuristicMode == HeuristicMode.None)
				{
					heuristic = Heuristic.None;
					heuristicScale = 0f;
				}
				else if (heuristicMode == HeuristicMode.Average || heuristicMode == HeuristicMode.MovingAverage)
				{
					Vector3 zero = Vector3.zero;
					for (int j = 0; j < targetNodes.Length; j++)
					{
						zero += (Vector3)targetNodes[j].position;
					}
					zero /= (float)targetNodes.Length;
					hTarget = (Int3)zero;
				}
				else if (heuristicMode == HeuristicMode.Midpoint || heuristicMode == HeuristicMode.MovingMidpoint)
				{
					Vector3 vector = Vector3.zero;
					Vector3 vector2 = Vector3.zero;
					bool flag5 = false;
					for (int k = 0; k < targetPoints.Length; k++)
					{
						if (!targetsFound[k])
						{
							if (!flag5)
							{
								vector = (Vector3)targetNodes[k].position;
								vector2 = (Vector3)targetNodes[k].position;
								flag5 = true;
							}
							else
							{
								vector = Vector3.Min((Vector3)targetNodes[k].position, vector);
								vector2 = Vector3.Max((Vector3)targetNodes[k].position, vector2);
							}
						}
					}
					Vector3 ob = (vector + vector2) * 0.5f;
					hTarget = (Int3)ob;
				}
				else
				{
					if (heuristicMode != HeuristicMode.Sequential)
					{
						return;
					}
					float num = 0f;
					for (int l = 0; l < targetNodes.Length; l++)
					{
						if (!targetsFound[l])
						{
							float sqrMagnitude = (targetNodes[l].position - startNode.position).sqrMagnitude;
							if (sqrMagnitude > num)
							{
								num = sqrMagnitude;
								hTarget = (Int3)targetPoints[l];
								sequentialTarget = l;
							}
						}
					}
				}
			}
			else
			{
				heuristic = Heuristic.None;
				heuristicScale = 0f;
			}
		}

		public override void Initialize()
		{
			for (int i = 0; i < targetNodes.Length; i++)
			{
				if (startNode == targetNodes[i])
				{
					PathNode pathNode = pathHandler.GetPathNode(startNode);
					FoundTarget(pathNode, i);
				}
				else if (targetNodes[i] != null)
				{
					pathHandler.GetPathNode(targetNodes[i]).flag1 = true;
				}
			}
			AstarPath.OnPathPostSearch = (OnPathDelegate)Delegate.Combine(AstarPath.OnPathPostSearch, new OnPathDelegate(ResetFlags));
			if (targetNodeCount <= 0)
			{
				base.CompleteState = PathCompleteState.Complete;
				return;
			}
			PathNode pathNode2 = pathHandler.GetPathNode(startNode);
			pathNode2.node = startNode;
			pathNode2.pathID = pathID;
			pathNode2.parent = null;
			pathNode2.cost = 0u;
			pathNode2.G = GetTraversalCost(startNode);
			pathNode2.H = CalculateHScore(startNode);
			startNode.Open(this, pathNode2, pathHandler);
			searchedNodes++;
			if (pathHandler.HeapEmpty())
			{
				LogError("No open points, the start node didn't open any nodes");
				Error();
			}
			else
			{
				currentR = pathHandler.PopNode();
			}
		}

		public void ResetFlags(Path p)
		{
			AstarPath.OnPathPostSearch = (OnPathDelegate)Delegate.Remove(AstarPath.OnPathPostSearch, new OnPathDelegate(ResetFlags));
			if (p != this)
			{
				UnityEngine.Debug.LogError("This should have been cleared after it was called on 'this' path. Was it not called? Or did the delegate reset not work?");
			}
			for (int i = 0; i < targetNodes.Length; i++)
			{
				if (targetNodes[i] != null)
				{
					pathHandler.GetPathNode(targetNodes[i]).flag1 = false;
				}
			}
		}

		public override void CalculateStep(long targetTick)
		{
			int num = 0;
			while (true)
			{
				if (base.CompleteState != 0)
				{
					return;
				}
				searchedNodes++;
				if (currentR.flag1)
				{
					for (int i = 0; i < targetNodes.Length; i++)
					{
						if (!targetsFound[i] && currentR.node == targetNodes[i])
						{
							FoundTarget(currentR, i);
							if (base.CompleteState != 0)
							{
								break;
							}
						}
					}
					if (targetNodeCount <= 0)
					{
						base.CompleteState = PathCompleteState.Complete;
						return;
					}
				}
				currentR.node.Open(this, currentR, pathHandler);
				if (pathHandler.HeapEmpty())
				{
					break;
				}
				currentR = pathHandler.PopNode();
				if (num > 500)
				{
					if (DateTime.UtcNow.Ticks >= targetTick)
					{
						return;
					}
					num = 0;
				}
				num++;
			}
			base.CompleteState = PathCompleteState.Complete;
		}

		protected override void Trace(PathNode node)
		{
			base.Trace(node);
			if (inverted)
			{
				int num = path.Count / 2;
				for (int i = 0; i < num; i++)
				{
					GraphNode value = path[i];
					path[i] = path[path.Count - i - 1];
					path[path.Count - i - 1] = value;
				}
				for (int j = 0; j < num; j++)
				{
					Vector3 value2 = vectorPath[j];
					vectorPath[j] = vectorPath[vectorPath.Count - j - 1];
					vectorPath[vectorPath.Count - j - 1] = value2;
				}
			}
		}

		public override string DebugString(PathLog logMode)
		{
			if (logMode == PathLog.None || (!base.error && logMode == PathLog.OnlyErrors))
			{
				return string.Empty;
			}
			StringBuilder debugStringBuilder = pathHandler.DebugStringBuilder;
			debugStringBuilder.Length = 0;
			debugStringBuilder.Append((!base.error) ? "Path Completed : " : "Path Failed : ");
			debugStringBuilder.Append("Computation Time ");
			debugStringBuilder.Append(duration.ToString((logMode != PathLog.Heavy) ? "0.00" : "0.000"));
			debugStringBuilder.Append(" ms Searched Nodes ");
			debugStringBuilder.Append(searchedNodes);
			if (!base.error)
			{
				debugStringBuilder.Append("\nLast Found Path Length ");
				debugStringBuilder.Append((path != null) ? path.Count.ToString() : "Null");
				if (logMode == PathLog.Heavy)
				{
					debugStringBuilder.Append("\nSearch Iterations " + searchIterations);
					debugStringBuilder.Append("\nPaths (").Append(targetsFound.Length).Append("):");
					for (int i = 0; i < targetsFound.Length; i++)
					{
						debugStringBuilder.Append("\n\n\tPath " + i).Append(" Found: ").Append(targetsFound[i]);
						GraphNode graphNode = (nodePaths[i] != null) ? nodePaths[i][nodePaths[i].Count - 1] : null;
						debugStringBuilder.Append("\n\t\tLength: ");
						debugStringBuilder.Append(nodePaths[i].Count);
						if (graphNode != null)
						{
							PathNode pathNode = pathHandler.GetPathNode(endNode);
							if (pathNode != null)
							{
								debugStringBuilder.Append("\n\t\tEnd Node");
								debugStringBuilder.Append("\n\t\t\tG: ");
								debugStringBuilder.Append(pathNode.G);
								debugStringBuilder.Append("\n\t\t\tH: ");
								debugStringBuilder.Append(pathNode.H);
								debugStringBuilder.Append("\n\t\t\tF: ");
								debugStringBuilder.Append(pathNode.F);
								debugStringBuilder.Append("\n\t\t\tPoint: ");
								debugStringBuilder.Append(endPoint.ToString());
								debugStringBuilder.Append("\n\t\t\tGraph: ");
								debugStringBuilder.Append(endNode.GraphIndex);
							}
							else
							{
								debugStringBuilder.Append("\n\t\tEnd Node: Null");
							}
						}
					}
					debugStringBuilder.Append("\nStart Node");
					debugStringBuilder.Append("\n\tPoint: ");
					debugStringBuilder.Append(endPoint.ToString());
					debugStringBuilder.Append("\n\tGraph: ");
					debugStringBuilder.Append(startNode.GraphIndex);
					debugStringBuilder.Append("\nBinary Heap size at completion: ");
					debugStringBuilder.AppendLine((pathHandler.GetHeap() != null) ? (pathHandler.GetHeap().numberOfItems - 2).ToString() : "Null");
				}
			}
			if (base.error)
			{
				debugStringBuilder.Append("\nError: ");
				debugStringBuilder.Append(base.errorLog);
				debugStringBuilder.AppendLine();
			}
			if (logMode == PathLog.Heavy && !AstarPath.IsUsingMultithreading)
			{
				debugStringBuilder.Append("\nCallback references ");
				if (callback != null)
				{
					debugStringBuilder.Append(callback.Target.GetType().FullName).AppendLine();
				}
				else
				{
					debugStringBuilder.AppendLine("NULL");
				}
			}
			debugStringBuilder.Append("\nPath Number ");
			debugStringBuilder.Append(pathID);
			return debugStringBuilder.ToString();
		}
	}
	public class RandomPath : ABPath
	{
		public int searchLength;

		public int spread;

		public bool uniform;

		public float aimStrength;

		private PathNode chosenNodeR;

		private PathNode maxGScoreNodeR;

		private int maxGScore;

		public Vector3 aim;

		private int nodesEvaluatedRep;

		private System.Random rnd = new System.Random();

		public RandomPath()
		{
		}

		public RandomPath(Vector3 start, int length, OnPathDelegate callback = null)
		{
			throw new Exception("This constructor is obsolete. Please use the pooling API and the Setup methods");
		}

		public override void Reset()
		{
			base.Reset();
			searchLength = 5000;
			spread = 5000;
			uniform = true;
			aimStrength = 0f;
			chosenNodeR = null;
			maxGScoreNodeR = null;
			maxGScore = 0;
			aim = Vector3.zero;
			nodesEvaluatedRep = 0;
			hasEndPoint = false;
		}

		protected override void Recycle()
		{
			PathPool<RandomPath>.Recycle(this);
		}

		public static RandomPath Construct(Vector3 start, int length, OnPathDelegate callback = null)
		{
			RandomPath path = PathPool<RandomPath>.GetPath();
			path.Setup(start, length, callback);
			return path;
		}

		protected RandomPath Setup(Vector3 start, int length, OnPathDelegate callback)
		{
			base.callback = callback;
			searchLength = length;
			originalStartPoint = start;
			originalEndPoint = Vector3.zero;
			startPoint = start;
			endPoint = Vector3.zero;
			startIntPoint = (Int3)start;
			hasEndPoint = false;
			return this;
		}

		public override void ReturnPath()
		{
			if (path != null && path.Count > 0)
			{
				endNode = path[path.Count - 1];
				endPoint = (Vector3)endNode.position;
				originalEndPoint = endPoint;
				hTarget = endNode.position;
			}
			if (callback != null)
			{
				callback(this);
			}
		}

		public override void Prepare()
		{
			nnConstraint.tags = enabledTags;
			NNInfo nearest = AstarPath.active.GetNearest(startPoint, nnConstraint, startHint);
			startPoint = nearest.clampedPosition;
			endPoint = startPoint;
			startIntPoint = (Int3)startPoint;
			hTarget = (Int3)aim;
			startNode = nearest.node;
			endNode = startNode;
			if (startNode == null || endNode == null)
			{
				LogError("Couldn't find close nodes to the start point");
				Error();
			}
			else if (!startNode.Walkable)
			{
				LogError("The node closest to the start point is not walkable");
				Error();
			}
			else
			{
				heuristicScale = aimStrength;
			}
		}

		public override void Initialize()
		{
			PathNode pathNode = pathHandler.GetPathNode(startNode);
			pathNode.node = startNode;
			if (searchLength + spread <= 0)
			{
				base.CompleteState = PathCompleteState.Complete;
				Trace(pathNode);
				return;
			}
			pathNode.pathID = pathID;
			pathNode.parent = null;
			pathNode.cost = 0u;
			pathNode.G = GetTraversalCost(startNode);
			pathNode.H = CalculateHScore(startNode);
			startNode.Open(this, pathNode, pathHandler);
			searchedNodes++;
			if (pathHandler.HeapEmpty())
			{
				LogError("No open points, the start node didn't open any nodes");
				Error();
			}
			else
			{
				currentR = pathHandler.PopNode();
			}
		}

		public override void CalculateStep(long targetTick)
		{
			int num = 0;
			while (base.CompleteState == PathCompleteState.NotCalculated)
			{
				searchedNodes++;
				if (currentR.G >= searchLength)
				{
					nodesEvaluatedRep++;
					if (chosenNodeR == null)
					{
						chosenNodeR = currentR;
					}
					else if (rnd.NextDouble() <= (double)(1f / (float)nodesEvaluatedRep))
					{
						chosenNodeR = currentR;
					}
					if (currentR.G >= searchLength + spread)
					{
						base.CompleteState = PathCompleteState.Complete;
						break;
					}
				}
				else if (currentR.G > maxGScore)
				{
					maxGScore = (int)currentR.G;
					maxGScoreNodeR = currentR;
				}
				currentR.node.Open(this, currentR, pathHandler);
				if (pathHandler.HeapEmpty())
				{
					if (chosenNodeR != null)
					{
						base.CompleteState = PathCompleteState.Complete;
					}
					else if (maxGScoreNodeR != null)
					{
						chosenNodeR = maxGScoreNodeR;
						base.CompleteState = PathCompleteState.Complete;
					}
					else
					{
						LogError("Not a single node found to search");
						Error();
					}
					break;
				}
				currentR = pathHandler.PopNode();
				if (num > 500)
				{
					if (DateTime.UtcNow.Ticks >= targetTick)
					{
						return;
					}
					num = 0;
					if (searchedNodes > 1000000)
					{
						throw new Exception("Probable infinite loop. Over 1,000,000 nodes searched");
					}
				}
				num++;
			}
			if (base.CompleteState == PathCompleteState.Complete)
			{
				Trace(chosenNodeR);
			}
		}
	}
	public class PathEndingCondition
	{
		protected Path p;

		protected PathEndingCondition()
		{
		}

		public PathEndingCondition(Path p)
		{
			if (p == null)
			{
				throw new ArgumentNullException("Please supply a non-null path");
			}
			this.p = p;
		}

		public virtual bool TargetFound(PathNode node)
		{
			return true;
		}
	}
	public class ABPathEndingCondition : PathEndingCondition
	{
		protected ABPath abPath;

		public ABPathEndingCondition(ABPath p)
		{
			if (p == null)
			{
				throw new ArgumentNullException("Please supply a non-null path");
			}
			abPath = p;
		}

		public override bool TargetFound(PathNode node)
		{
			return node.node == abPath.endNode;
		}
	}
}
namespace Pathfinding.RVO
{
	[AddComponentMenu("Pathfinding/Local Avoidance/RVO Controller")]
	public class RVOController : MonoBehaviour
	{
		[Tooltip("Radius of the agent")]
		public float radius = 5f;

		[Tooltip("Max speed of the agent. In world units/second")]
		public float maxSpeed = 2f;

		[Tooltip("Height of the agent. In world units")]
		public float height = 1f;

		[Tooltip("A locked unit cannot move. Other units will still avoid it. But avoidance quailty is not the best")]
		public bool locked;

		[Tooltip("Automatically set #locked to true when desired velocity is approximately zero")]
		public bool lockWhenNotMoving = true;

		[Tooltip("How far in the time to look for collisions with other agents")]
		public float agentTimeHorizon = 2f;

		[HideInInspector]
		public float obstacleTimeHorizon = 2f;

		[Tooltip("Maximum distance to other agents to take them into account for collisions.\nDecreasing this value can lead to better performance, increasing it can lead to better quality of the simulation")]
		public float neighbourDist = 10f;

		[Tooltip("Max number of other agents to take into account.\nA smaller value can reduce CPU load, a higher value can lead to better local avoidance quality.")]
		public int maxNeighbours = 10;

		[Tooltip("Layer mask for the ground. The RVOController will raycast down to check for the ground to figure out where to place the agent")]
		public LayerMask mask = -1;

		public RVOLayer layer = RVOLayer.DefaultAgent;

		[AstarEnumFlag]
		public RVOLayer collidesWith = (RVOLayer)(-1);

		[HideInInspector]
		public float wallAvoidForce = 1f;

		[HideInInspector]
		public float wallAvoidFalloff = 1f;

		[Tooltip("Center of the agent relative to the pivot point of this game object")]
		public Vector3 center;

		private IAgent rvoAgent;

		public bool enableRotation = true;

		public float rotationSpeed = 30f;

		private Simulator simulator;

		private float adjustedY;

		private Transform tr;

		private Vector3 desiredVelocity;

		public bool debug;

		private Vector3 lastPosition;

		private static readonly Color GizmoColor = new Color(0.9411765f, 71f / 85f, 0.117647059f);

		public Vector3 position => rvoAgent.InterpolatedPosition;

		public Vector3 velocity => rvoAgent.Velocity;

		public void OnDisable()
		{
			if (simulator != null)
			{
				simulator.RemoveAgent(rvoAgent);
			}
		}

		public void Awake()
		{
			tr = base.transform;
			RVOSimulator rVOSimulator = UnityEngine.Object.FindObjectOfType(typeof(RVOSimulator)) as RVOSimulator;
			if (rVOSimulator == null)
			{
				UnityEngine.Debug.LogError("No RVOSimulator component found in the scene. Please add one.");
			}
			else
			{
				simulator = rVOSimulator.GetSimulator();
			}
		}

		public void OnEnable()
		{
			if (simulator != null)
			{
				if (rvoAgent != null)
				{
					simulator.AddAgent(rvoAgent);
				}
				else
				{
					rvoAgent = simulator.AddAgent(base.transform.position);
				}
				UpdateAgentProperties();
				rvoAgent.Position = base.transform.position;
				Vector3 position = rvoAgent.Position;
				adjustedY = position.y;
			}
		}

		protected void UpdateAgentProperties()
		{
			rvoAgent.Radius = radius;
			rvoAgent.MaxSpeed = maxSpeed;
			rvoAgent.Height = height;
			rvoAgent.AgentTimeHorizon = agentTimeHorizon;
			rvoAgent.ObstacleTimeHorizon = obstacleTimeHorizon;
			rvoAgent.Locked = locked;
			rvoAgent.MaxNeighbours = maxNeighbours;
			rvoAgent.DebugDraw = debug;
			rvoAgent.NeighbourDist = neighbourDist;
			rvoAgent.Layer = layer;
			rvoAgent.CollidesWith = collidesWith;
		}

		public void Move(Vector3 vel)
		{
			desiredVelocity = vel;
		}

		public void Teleport(Vector3 pos)
		{
			tr.position = pos;
			lastPosition = pos;
			rvoAgent.Teleport(pos);
			adjustedY = pos.y;
		}

		public void Update()
		{
			if (rvoAgent == null)
			{
				return;
			}
			if (lastPosition != tr.position)
			{
				Teleport(tr.position);
			}
			if (lockWhenNotMoving)
			{
				locked = (desiredVelocity == Vector3.zero);
			}
			UpdateAgentProperties();
			Vector3 interpolatedPosition = rvoAgent.InterpolatedPosition;
			interpolatedPosition.y = adjustedY;
			if ((int)mask != 0 && Physics.Raycast(interpolatedPosition + Vector3.up * height * 0.5f, Vector3.down, out RaycastHit hitInfo, float.PositiveInfinity, mask))
			{
				Vector3 point = hitInfo.point;
				adjustedY = point.y;
			}
			else
			{
				adjustedY = 0f;
			}
			interpolatedPosition.y = adjustedY;
			IAgent agent = rvoAgent;
			Vector3 position = rvoAgent.Position;
			float x = position.x;
			float y = adjustedY;
			Vector3 position2 = rvoAgent.Position;
			agent.Position = new Vector3(x, y, position2.z);
			Vector3 zero = Vector3.zero;
			if (wallAvoidFalloff > 0f && wallAvoidForce > 0f)
			{
				List<ObstacleVertex> neighbourObstacles = rvoAgent.NeighbourObstacles;
				if (neighbourObstacles != null)
				{
					for (int i = 0; i < neighbourObstacles.Count; i++)
					{
						Vector3 position3 = neighbourObstacles[i].position;
						Vector3 position4 = neighbourObstacles[i].next.position;
						Vector3 vector = this.position - AstarMath.NearestPointStrict(position3, position4, this.position);
						if (!(vector == position3) && !(vector == position4))
						{
							float sqrMagnitude = vector.sqrMagnitude;
							vector /= sqrMagnitude * wallAvoidFalloff;
							zero += vector;
						}
					}
				}
			}
			rvoAgent.DesiredVelocity = desiredVelocity + zero * wallAvoidForce;
			tr.position = interpolatedPosition + Vector3.up * height * 0.5f - center;
			lastPosition = tr.position;
			if (enableRotation && velocity != Vector3.zero)
			{
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.LookRotation(velocity), Time.deltaTime * rotationSpeed * Mathf.Min(velocity.magnitude, 0.2f));
			}
		}

		public void OnDrawGizmos()
		{
			Gizmos.color = GizmoColor;
			Gizmos.DrawWireSphere(base.transform.position + center - Vector3.up * height * 0.5f + Vector3.up * radius * 0.5f, radius);
			Gizmos.DrawLine(base.transform.position + center - Vector3.up * height * 0.5f, base.transform.position + center + Vector3.up * height * 0.5f);
			Gizmos.DrawWireSphere(base.transform.position + center + Vector3.up * height * 0.5f - Vector3.up * radius * 0.5f, radius);
		}
	}
	[AddComponentMenu("Pathfinding/Local Avoidance/RVO Navmesh")]
	public class RVONavmesh : GraphModifier
	{
		public float wallHeight = 5f;

		private List<ObstacleVertex> obstacles = new List<ObstacleVertex>();

		private Simulator lastSim;

		public override void OnPostCacheLoad()
		{
			OnLatePostScan();
		}

		public override void OnLatePostScan()
		{
			if (UnityEngine.Application.isPlaying)
			{
				RemoveObstacles();
				NavGraph[] graphs = AstarPath.active.graphs;
				RVOSimulator rVOSimulator = UnityEngine.Object.FindObjectOfType(typeof(RVOSimulator)) as RVOSimulator;
				if (rVOSimulator == null)
				{
					throw new NullReferenceException("No RVOSimulator could be found in the scene. Please add one to any GameObject");
				}
				Simulator simulator = rVOSimulator.GetSimulator();
				for (int i = 0; i < graphs.Length; i++)
				{
					AddGraphObstacles(simulator, graphs[i]);
				}
				simulator.UpdateObstacles();
			}
		}

		public void RemoveObstacles()
		{
			if (lastSim != null)
			{
				Simulator simulator = lastSim;
				lastSim = null;
				for (int i = 0; i < obstacles.Count; i++)
				{
					simulator.RemoveObstacle(obstacles[i]);
				}
				obstacles.Clear();
			}
		}

		public void AddGraphObstacles(Simulator sim, NavGraph graph)
		{
			if (obstacles.Count > 0 && lastSim != null && lastSim != sim)
			{
				UnityEngine.Debug.LogError("Simulator has changed but some old obstacles are still added for the previous simulator. Deleting previous obstacles.");
				RemoveObstacles();
			}
			lastSim = sim;
			INavmesh navmesh = graph as INavmesh;
			if (navmesh != null)
			{
				int[] uses = new int[20];
				navmesh.GetNodes(delegate(GraphNode _node)
				{
					TriangleMeshNode triangleMeshNode = _node as TriangleMeshNode;
					uses[0] = (uses[1] = (uses[2] = 0));
					if (triangleMeshNode != null)
					{
						for (int i = 0; i < triangleMeshNode.connections.Length; i++)
						{
							TriangleMeshNode triangleMeshNode2 = triangleMeshNode.connections[i] as TriangleMeshNode;
							if (triangleMeshNode2 != null)
							{
								int num = triangleMeshNode.SharedEdge(triangleMeshNode2);
								if (num != -1)
								{
									uses[num] = 1;
								}
							}
						}
						for (int j = 0; j < 3; j++)
						{
							if (uses[j] == 0)
							{
								Vector3 a = (Vector3)triangleMeshNode.GetVertex(j);
								Vector3 b = (Vector3)triangleMeshNode.GetVertex((j + 1) % triangleMeshNode.GetVertexCount());
								float val = Math.Abs(a.y - b.y);
								val = Math.Max(val, 5f);
								obstacles.Add(sim.AddObstacle(a, b, wallHeight));
							}
						}
					}
					return true;
				});
			}
		}
	}
	public abstract class RVOObstacle : MonoBehaviour
	{
		public enum ObstacleVertexWinding
		{
			KeepOut,
			KeepIn,
			Both
		}

		public ObstacleVertexWinding obstacleMode;

		protected Simulator sim;

		private List<ObstacleVertex> addedObstacles;

		private List<Vector3[]> sourceObstacles;

		private bool gizmoDrawing;

		private List<Vector3[]> gizmoVerts;

		private ObstacleVertexWinding _obstacleMode;

		private Matrix4x4 prevUpdateMatrix;

		protected abstract bool ExecuteInEditor
		{
			get;
		}

		protected abstract bool LocalCoordinates
		{
			get;
		}

		protected abstract bool StaticObstacle
		{
			get;
		}

		protected abstract void CreateObstacles();

		protected abstract bool AreGizmosDirty();

		public void OnDrawGizmos()
		{
			OnDrawGizmos(selected: false);
		}

		public void OnDrawGizmosSelected()
		{
			OnDrawGizmos(selected: true);
		}

		public void OnDrawGizmos(bool selected)
		{
			gizmoDrawing = true;
			Gizmos.color = new Color(0.615f, 1f, 0.06f, (!selected) ? 0.7f : 1f);
			if (gizmoVerts == null || AreGizmosDirty() || _obstacleMode != obstacleMode)
			{
				_obstacleMode = obstacleMode;
				if (gizmoVerts == null)
				{
					gizmoVerts = new List<Vector3[]>();
				}
				else
				{
					gizmoVerts.Clear();
				}
				CreateObstacles();
			}
			Matrix4x4 matrix = GetMatrix();
			for (int i = 0; i < gizmoVerts.Count; i++)
			{
				Vector3[] array = gizmoVerts[i];
				int num = 0;
				int num2 = array.Length - 1;
				while (num < array.Length)
				{
					Gizmos.DrawLine(matrix.MultiplyPoint3x4(array[num]), matrix.MultiplyPoint3x4(array[num2]));
					num2 = num++;
				}
				if (!selected || obstacleMode == ObstacleVertexWinding.Both)
				{
					continue;
				}
				int num3 = 0;
				int num4 = array.Length - 1;
				while (num3 < array.Length)
				{
					Vector3 vector = matrix.MultiplyPoint3x4(array[num4]);
					Vector3 vector2 = matrix.MultiplyPoint3x4(array[num3]);
					Vector3 vector3 = (vector + vector2) * 0.5f;
					Vector3 normalized = (vector2 - vector).normalized;
					if (!(normalized == Vector3.zero))
					{
						Vector3 vector4 = Vector3.Cross(Vector3.up, normalized);
						Gizmos.DrawLine(vector3, vector3 + vector4);
						Gizmos.DrawLine(vector3 + vector4, vector3 + vector4 * 0.5f + normalized * 0.5f);
						Gizmos.DrawLine(vector3 + vector4, vector3 + vector4 * 0.5f - normalized * 0.5f);
					}
					num4 = num3++;
				}
			}
			gizmoDrawing = false;
		}

		protected virtual Matrix4x4 GetMatrix()
		{
			if (LocalCoordinates)
			{
				return base.transform.localToWorldMatrix;
			}
			return Matrix4x4.identity;
		}

		public void OnDisable()
		{
			if (addedObstacles != null)
			{
				if (sim == null)
				{
					throw new Exception("This should not happen! Make sure you are not overriding the OnEnable function");
				}
				for (int i = 0; i < addedObstacles.Count; i++)
				{
					sim.RemoveObstacle(addedObstacles[i]);
				}
			}
		}

		public void OnEnable()
		{
			if (addedObstacles != null)
			{
				if (sim == null)
				{
					throw new Exception("This should not happen! Make sure you are not overriding the OnDisable function");
				}
				for (int i = 0; i < addedObstacles.Count; i++)
				{
					sim.AddObstacle(addedObstacles[i]);
				}
			}
		}

		public void Start()
		{
			addedObstacles = new List<ObstacleVertex>();
			sourceObstacles = new List<Vector3[]>();
			prevUpdateMatrix = GetMatrix();
			CreateObstacles();
		}

		public void Update()
		{
			Matrix4x4 matrix = GetMatrix();
			if (matrix != prevUpdateMatrix)
			{
				for (int i = 0; i < addedObstacles.Count; i++)
				{
					sim.UpdateObstacle(addedObstacles[i], sourceObstacles[i], matrix);
				}
				prevUpdateMatrix = matrix;
			}
		}

		protected void FindSimulator()
		{
			RVOSimulator rVOSimulator = UnityEngine.Object.FindObjectOfType(typeof(RVOSimulator)) as RVOSimulator;
			if (rVOSimulator == null)
			{
				throw new InvalidOperationException("No RVOSimulator could be found in the scene. Please add one to any GameObject");
			}
			sim = rVOSimulator.GetSimulator();
		}

		protected void AddObstacle(Vector3[] vertices, float height)
		{
			if (vertices == null)
			{
				throw new ArgumentNullException("Vertices Must Not Be Null");
			}
			if (height < 0f)
			{
				throw new ArgumentOutOfRangeException("Height must be non-negative");
			}
			if (vertices.Length < 2)
			{
				throw new ArgumentException("An obstacle must have at least two vertices");
			}
			if (gizmoDrawing)
			{
				Vector3[] array = new Vector3[vertices.Length];
				WindCorrectly(vertices);
				Array.Copy(vertices, array, vertices.Length);
				gizmoVerts.Add(array);
				return;
			}
			if (sim == null)
			{
				FindSimulator();
			}
			if (vertices.Length == 2)
			{
				AddObstacleInternal(vertices, height);
			}
			else if (obstacleMode == ObstacleVertexWinding.Both)
			{
				int num = 0;
				int num2 = vertices.Length - 1;
				while (num < vertices.Length)
				{
					AddObstacleInternal(new Vector3[2]
					{
						vertices[num2],
						vertices[num]
					}, height);
					num2 = num++;
				}
			}
			else
			{
				WindCorrectly(vertices);
				AddObstacleInternal(vertices, height);
			}
		}

		private void AddObstacleInternal(Vector3[] vertices, float height)
		{
			addedObstacles.Add(sim.AddObstacle(vertices, height, GetMatrix()));
			sourceObstacles.Add(vertices);
		}

		private void WindCorrectly(Vector3[] vertices)
		{
			if (obstacleMode == ObstacleVertexWinding.Both)
			{
				return;
			}
			int num = 0;
			float num2 = float.PositiveInfinity;
			for (int i = 0; i < vertices.Length; i++)
			{
				if (vertices[i].x < num2)
				{
					num = i;
					num2 = vertices[i].x;
				}
			}
			if (Polygon.IsClockwise(vertices[(num - 1 + vertices.Length) % vertices.Length], vertices[num], vertices[(num + 1) % vertices.Length]))
			{
				if (obstacleMode == ObstacleVertexWinding.KeepOut)
				{
					Array.Reverse(vertices);
				}
			}
			else if (obstacleMode == ObstacleVertexWinding.KeepIn)
			{
				Array.Reverse(vertices);
			}
		}
	}
	[AddComponentMenu("Pathfinding/Local Avoidance/RVO Simulator")]
	public class RVOSimulator : MonoBehaviour
	{
		[Tooltip("Calculate local avoidance in between frames")]
		public bool doubleBuffering = true;

		[Tooltip("Interpolate positions between simulation timesteps")]
		public bool interpolation = true;

		[Tooltip("Desired FPS for rvo simulation. It is usually not necessary to run a crowd simulation at a very high fps.\nUsually 10-30 fps is enough, but can be increased for better quality.\nThe rvo simulation will never run at a higher fps than the game")]
		public int desiredSimulatonFPS = 20;

		[Tooltip("Number of RVO worker threads. If set to None, no multithreading will be used.")]
		public ThreadCount workerThreads = ThreadCount.Two;

		[Tooltip("A higher value will result in lower quality local avoidance but faster calculations. [0...1]")]
		public float qualityCutoff = 0.05f;

		public float stepScale = 1.5f;

		[Tooltip("Higher values will raise the penalty for agent-agent intersection")]
		public float incompressibility = 30f;

		public float desiredVelocityWeight = 0.1f;

		private Simulator simulator;

		public Simulator GetSimulator()
		{
			if (simulator == null)
			{
				Awake();
			}
			return simulator;
		}

		private void Awake()
		{
			if (desiredSimulatonFPS < 1)
			{
				desiredSimulatonFPS = 1;
			}
			if (simulator == null)
			{
				int workers = AstarPath.CalculateThreadCount(workerThreads);
				simulator = new Simulator(workers, doubleBuffering);
				simulator.Interpolation = interpolation;
				simulator.DesiredDeltaTime = 1f / (float)desiredSimulatonFPS;
			}
		}

		private void Update()
		{
			if (desiredSimulatonFPS < 1)
			{
				desiredSimulatonFPS = 1;
			}
			Agent.DesiredVelocityWeight = desiredVelocityWeight;
			Agent.GlobalIncompressibility = incompressibility;
			GetSimulator().DesiredDeltaTime = 1f / (float)desiredSimulatonFPS;
			GetSimulator().Interpolation = interpolation;
			GetSimulator().stepScale = stepScale;
			GetSimulator().qualityCutoff = qualityCutoff;
			GetSimulator().Update();
		}

		private void OnDestroy()
		{
			simulator.OnDestroy();
		}
	}
	[AddComponentMenu("Pathfinding/Local Avoidance/Square Obstacle (disabled)")]
	public class RVOSquareObstacle : RVOObstacle
	{
		public float height = 1f;

		public Vector2 size = Vector3.one;

		protected override bool StaticObstacle => false;

		protected override bool ExecuteInEditor => true;

		protected override bool LocalCoordinates => true;

		protected override bool AreGizmosDirty()
		{
			return false;
		}

		protected override void CreateObstacles()
		{
			size.x = Mathf.Abs(size.x);
			size.y = Mathf.Abs(size.y);
			height = Mathf.Abs(height);
			Vector3[] array = new Vector3[4]
			{
				new Vector3(1f, 0f, -1f),
				new Vector3(1f, 0f, 1f),
				new Vector3(-1f, 0f, 1f),
				new Vector3(-1f, 0f, -1f)
			};
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Scale(new Vector3(size.x, 0f, size.y));
			}
			AddObstacle(array, height);
		}
	}
}
namespace Pathfinding.Util
{
	public class Checksum
	{
		private static readonly uint[] CRCTable = new uint[256]
		{
			0u,
			1996959894u,
			3993919788u,
			2567524794u,
			124634137u,
			1886057615u,
			3915621685u,
			2657392035u,
			249268274u,
			2044508324u,
			3772115230u,
			2547177864u,
			162941995u,
			2125561021u,
			3887607047u,
			2428444049u,
			498536548u,
			1789927666u,
			4089016648u,
			2227061214u,
			450548861u,
			1843258603u,
			4107580753u,
			2211677639u,
			325883990u,
			1684777152u,
			4251122042u,
			2321926636u,
			335633487u,
			1661365465u,
			4195302755u,
			2366115317u,
			997073096u,
			1281953886u,
			3579855332u,
			2724688242u,
			1006888145u,
			1258607687u,
			3524101629u,
			2768942443u,
			901097722u,
			1119000684u,
			3686517206u,
			2898065728u,
			853044451u,
			1172266101u,
			3705015759u,
			2882616665u,
			651767980u,
			1373503546u,
			3369554304u,
			3218104598u,
			565507253u,
			1454621731u,
			3485111705u,
			3099436303u,
			671266974u,
			1594198024u,
			3322730930u,
			2970347812u,
			795835527u,
			1483230225u,
			3244367275u,
			3060149565u,
			1994146192u,
			31158534u,
			2563907772u,
			4023717930u,
			1907459465u,
			112637215u,
			2680153253u,
			3904427059u,
			2013776290u,
			251722036u,
			2517215374u,
			3775830040u,
			2137656763u,
			141376813u,
			2439277719u,
			3865271297u,
			1802195444u,
			476864866u,
			2238001368u,
			4066508878u,
			1812370925u,
			453092731u,
			2181625025u,
			4111451223u,
			1706088902u,
			314042704u,
			2344532202u,
			4240017532u,
			1658658271u,
			366619977u,
			2362670323u,
			4224994405u,
			1303535960u,
			984961486u,
			2747007092u,
			3569037538u,
			1256170817u,
			1037604311u,
			2765210733u,
			3554079995u,
			1131014506u,
			879679996u,
			2909243462u,
			3663771856u,
			1141124467u,
			855842277u,
			2852801631u,
			3708648649u,
			1342533948u,
			654459306u,
			3188396048u,
			3373015174u,
			1466479909u,
			544179635u,
			3110523913u,
			3462522015u,
			1591671054u,
			702138776u,
			2966460450u,
			3352799412u,
			1504918807u,
			783551873u,
			3082640443u,
			3233442989u,
			3988292384u,
			2596254646u,
			62317068u,
			1957810842u,
			3939845945u,
			2647816111u,
			81470997u,
			1943803523u,
			3814918930u,
			2489596804u,
			225274430u,
			2053790376u,
			3826175755u,
			2466906013u,
			167816743u,
			2097651377u,
			4027552580u,
			2265490386u,
			503444072u,
			1762050814u,
			4150417245u,
			2154129355u,
			426522225u,
			1852507879u,
			4275313526u,
			2312317920u,
			282753626u,
			1742555852u,
			4189708143u,
			2394877945u,
			397917763u,
			1622183637u,
			3604390888u,
			2714866558u,
			953729732u,
			1340076626u,
			3518719985u,
			2797360999u,
			1068828381u,
			1219638859u,
			3624741850u,
			2936675148u,
			906185462u,
			1090812512u,
			3747672003u,
			2825379669u,
			829329135u,
			1181335161u,
			3412177804u,
			3160834842u,
			628085408u,
			1382605366u,
			3423369109u,
			3138078467u,
			570562233u,
			1426400815u,
			3317316542u,
			2998733608u,
			733239954u,
			1555261956u,
			3268935591u,
			3050360625u,
			752459403u,
			1541320221u,
			2607071920u,
			3965973030u,
			1969922972u,
			40735498u,
			2617837225u,
			3943577151u,
			1913087877u,
			83908371u,
			2512341634u,
			3803740692u,
			2075208622u,
			213261112u,
			2463272603u,
			3855990285u,
			2094854071u,
			198958881u,
			2262029012u,
			4057260610u,
			1759359992u,
			534414190u,
			2176718541u,
			4139329115u,
			1873836001u,
			414664567u,
			2282248934u,
			4279200368u,
			1711684554u,
			285281116u,
			2405801727u,
			4167216745u,
			1634467795u,
			376229701u,
			2685067896u,
			3608007406u,
			1308918612u,
			956543938u,
			2808555105u,
			3495958263u,
			1231636301u,
			1047427035u,
			2932959818u,
			3654703836u,
			1088359270u,
			936918000u,
			2847714899u,
			3736837829u,
			1202900863u,
			817233897u,
			3183342108u,
			3401237130u,
			1404277552u,
			615818150u,
			3134207493u,
			3453421203u,
			1423857449u,
			601450431u,
			3009837614u,
			3294710456u,
			1567103746u,
			711928724u,
			3020668471u,
			3272380065u,
			1510334235u,
			755167117u
		};

		public static uint GetChecksum(byte[] Value)
		{
			uint cRCVal = uint.MaxValue;
			return GetChecksum(Value, cRCVal);
		}

		public static uint GetChecksum(byte[] Value, uint CRCVal)
		{
			for (int i = 0; i < Value.Length; i++)
			{
				CRCVal = ((CRCVal >> 8) ^ CRCTable[(CRCVal & 0xFF) ^ Value[i]]);
			}
			return CRCVal;
		}
	}
	public static class Memory
	{
		public static void MemSet(byte[] array, byte value)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			int num = 32;
			int num2 = 0;
			int num3 = Math.Min(num, array.Length);
			while (num2 < num3)
			{
				array[num2++] = value;
			}
			num3 = array.Length;
			while (num2 < num3)
			{
				Buffer.BlockCopy(array, 0, array, num2, Math.Min(num, num3 - num2));
				num2 += num;
				num *= 2;
			}
		}

		public static void MemSet<T>(T[] array, T value, int byteSize) where T : struct
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			int num = 32;
			int i = 0;
			int num2;
			for (num2 = Math.Min(num, array.Length); i < num2; i++)
			{
				array[i] = value;
			}
			num2 = array.Length;
			while (i < num2)
			{
				Buffer.BlockCopy(array, 0, array, i * byteSize, Math.Min(num, num2 - i) * byteSize);
				i += num;
				num *= 2;
			}
		}

		public static void MemSet<T>(T[] array, T value, int totalSize, int byteSize) where T : struct
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			int num = 32;
			int i = 0;
			int num2;
			for (num2 = Math.Min(num, totalSize); i < num2; i++)
			{
				array[i] = value;
			}
			num2 = totalSize;
			while (i < num2)
			{
				Buffer.BlockCopy(array, 0, array, i * byteSize, Math.Min(num, totalSize - i) * byteSize);
				i += num;
				num *= 2;
			}
		}
	}
}
namespace Pathfinding
{
	public class AstarProfiler
	{
		public class ProfilePoint
		{
			public Stopwatch watch = new Stopwatch();

			public int totalCalls;

			public long tmpBytes;

			public long totalBytes;
		}

		private static Dictionary<string, ProfilePoint> profiles = new Dictionary<string, ProfilePoint>();

		private static DateTime startTime = DateTime.UtcNow;

		public static ProfilePoint[] fastProfiles;

		public static string[] fastProfileNames;

		private AstarProfiler()
		{
		}

		[Conditional("ProfileAstar")]
		public static void InitializeFastProfile(string[] profileNames)
		{
			fastProfileNames = new string[profileNames.Length + 2];
			Array.Copy(profileNames, fastProfileNames, profileNames.Length);
			fastProfileNames[fastProfileNames.Length - 2] = "__Control1__";
			fastProfileNames[fastProfileNames.Length - 1] = "__Control2__";
			fastProfiles = new ProfilePoint[fastProfileNames.Length];
			for (int i = 0; i < fastProfiles.Length; i++)
			{
				fastProfiles[i] = new ProfilePoint();
			}
		}

		[Conditional("ProfileAstar")]
		public static void StartFastProfile(int tag)
		{
			fastProfiles[tag].watch.Start();
		}

		[Conditional("ProfileAstar")]
		public static void EndFastProfile(int tag)
		{
			ProfilePoint profilePoint = fastProfiles[tag];
			profilePoint.totalCalls++;
			profilePoint.watch.Stop();
		}

		[Conditional("UNITY_PRO_PROFILER")]
		public static void EndProfile()
		{
		}

		[Conditional("ProfileAstar")]
		public static void StartProfile(string tag)
		{
			profiles.TryGetValue(tag, out ProfilePoint value);
			if (value == null)
			{
				value = new ProfilePoint();
				profiles[tag] = value;
			}
			value.tmpBytes = GC.GetTotalMemory(forceFullCollection: false);
			value.watch.Start();
		}

		[Conditional("ProfileAstar")]
		public static void EndProfile(string tag)
		{
			if (!profiles.ContainsKey(tag))
			{
				UnityEngine.Debug.LogError("Can only end profiling for a tag which has already been started (tag was " + tag + ")");
				return;
			}
			ProfilePoint profilePoint = profiles[tag];
			profilePoint.totalCalls++;
			profilePoint.watch.Stop();
			profilePoint.totalBytes += GC.GetTotalMemory(forceFullCollection: false) - profilePoint.tmpBytes;
		}

		[Conditional("ProfileAstar")]
		public static void Reset()
		{
			profiles.Clear();
			startTime = DateTime.UtcNow;
			if (fastProfiles != null)
			{
				for (int i = 0; i < fastProfiles.Length; i++)
				{
					fastProfiles[i] = new ProfilePoint();
				}
			}
		}

		[Conditional("ProfileAstar")]
		public static void PrintFastResults()
		{
			for (int i = 0; i < 1000; i++)
			{
			}
			double num = fastProfiles[fastProfiles.Length - 2].watch.Elapsed.TotalMilliseconds / 1000.0;
			TimeSpan timeSpan = DateTime.UtcNow - startTime;
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("============================\n\t\t\t\tProfile results:\n============================\n");
			stringBuilder.Append("Name\t\t|\tTotal Time\t|\tTotal Calls\t|\tAvg/Call\t|\tBytes");
			for (int j = 0; j < fastProfiles.Length; j++)
			{
				string text = fastProfileNames[j];
				ProfilePoint profilePoint = fastProfiles[j];
				int totalCalls = profilePoint.totalCalls;
				double num2 = profilePoint.watch.Elapsed.TotalMilliseconds - num * (double)totalCalls;
				if (totalCalls >= 1)
				{
					stringBuilder.Append("\n").Append(text.PadLeft(10)).Append("|   ");
					stringBuilder.Append(num2.ToString("0.0 ").PadLeft(10)).Append(profilePoint.watch.Elapsed.TotalMilliseconds.ToString("(0.0)").PadLeft(10)).Append("|   ");
					stringBuilder.Append(totalCalls.ToString().PadLeft(10)).Append("|   ");
					stringBuilder.Append((num2 / (double)totalCalls).ToString("0.000").PadLeft(10));
				}
			}
			stringBuilder.Append("\n\n============================\n\t\tTotal runtime: ");
			stringBuilder.Append(timeSpan.TotalSeconds.ToString("F3"));
			stringBuilder.Append(" seconds\n============================");
			UnityEngine.Debug.Log(stringBuilder.ToString());
		}

		[Conditional("ProfileAstar")]
		public static void PrintResults()
		{
			TimeSpan timeSpan = DateTime.UtcNow - startTime;
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("============================\n\t\t\t\tProfile results:\n============================\n");
			int num = 5;
			foreach (KeyValuePair<string, ProfilePoint> profile in profiles)
			{
				num = Math.Max(profile.Key.Length, num);
			}
			stringBuilder.Append(" Name ".PadRight(num)).Append("|").Append(" Total Time\t".PadRight(20))
				.Append("|")
				.Append(" Total Calls ".PadRight(20))
				.Append("|")
				.Append(" Avg/Call ".PadRight(20));
			foreach (KeyValuePair<string, ProfilePoint> profile2 in profiles)
			{
				double totalMilliseconds = profile2.Value.watch.Elapsed.TotalMilliseconds;
				int totalCalls = profile2.Value.totalCalls;
				if (totalCalls >= 1)
				{
					string key = profile2.Key;
					stringBuilder.Append("\n").Append(key.PadRight(num)).Append("| ");
					stringBuilder.Append(totalMilliseconds.ToString("0.0").PadRight(20)).Append("| ");
					stringBuilder.Append(totalCalls.ToString().PadRight(20)).Append("| ");
					stringBuilder.Append((totalMilliseconds / (double)totalCalls).ToString("0.000").PadRight(20));
					stringBuilder.Append(AstarMath.FormatBytesBinary((int)profile2.Value.totalBytes).PadLeft(10));
				}
			}
			stringBuilder.Append("\n\n============================\n\t\tTotal runtime: ");
			stringBuilder.Append(timeSpan.TotalSeconds.ToString("F3"));
			stringBuilder.Append(" seconds\n============================");
			UnityEngine.Debug.Log(stringBuilder.ToString());
		}
	}
}
namespace Pathfinding.Util
{
	public struct Guid
	{
		private const string hex = "0123456789ABCDEF";

		public static readonly Guid zero = new Guid(new byte[16]);

		public static readonly string zeroString = new Guid(new byte[16]).ToString();

		private ulong _a;

		private ulong _b;

		private static System.Random random = new System.Random();

		private static StringBuilder text;

		public Guid(byte[] bytes)
		{
			_a = (bytes[0] | ((ulong)bytes[1] << 8) | ((ulong)bytes[2] << 16) | ((ulong)bytes[3] << 24) | ((ulong)bytes[4] << 32) | ((ulong)bytes[5] << 40) | ((ulong)bytes[6] << 48) | ((ulong)bytes[7] << 56));
			_b = (bytes[8] | ((ulong)bytes[9] << 8) | ((ulong)bytes[10] << 16) | ((ulong)bytes[11] << 24) | ((ulong)bytes[12] << 32) | ((ulong)bytes[13] << 40) | ((ulong)bytes[14] << 48) | ((ulong)bytes[15] << 56));
		}

		public Guid(string str)
		{
			_a = 0uL;
			_b = 0uL;
			if (str.Length < 32)
			{
				throw new FormatException("Invalid Guid format");
			}
			int num = 0;
			int num2 = 0;
			int num3 = 60;
			while (num < 16)
			{
				if (num2 >= str.Length)
				{
					throw new FormatException("Invalid Guid format. String too short");
				}
				char c = str[num2];
				if (c != '-')
				{
					int num4 = "0123456789ABCDEF".IndexOf(char.ToUpperInvariant(c));
					if (num4 == -1)
					{
						throw new FormatException("Invalid Guid format : " + c + " is not a hexadecimal character");
					}
					_a |= (ulong)((long)num4 << num3);
					num3 -= 4;
					num++;
				}
				num2++;
			}
			num3 = 60;
			char c2;
			while (true)
			{
				if (num >= 32)
				{
					return;
				}
				if (num2 >= str.Length)
				{
					throw new FormatException("Invalid Guid format. String too short");
				}
				c2 = str[num2];
				if (c2 != '-')
				{
					int num5 = "0123456789ABCDEF".IndexOf(char.ToUpperInvariant(c2));
					if (num5 == -1)
					{
						break;
					}
					_b |= (ulong)((long)num5 << num3);
					num3 -= 4;
					num++;
				}
				num2++;
			}
			throw new FormatException("Invalid Guid format : " + c2 + " is not a hexadecimal character");
		}

		public static Guid Parse(string input)
		{
			return new Guid(input);
		}

		public byte[] ToByteArray()
		{
			byte[] array = new byte[16];
			byte[] bytes = BitConverter.GetBytes(_a);
			byte[] bytes2 = BitConverter.GetBytes(_b);
			for (int i = 0; i < 8; i++)
			{
				array[i] = bytes[i];
				array[i + 8] = bytes2[i];
			}
			return array;
		}

		public static Guid NewGuid()
		{
			byte[] array = new byte[16];
			random.NextBytes(array);
			return new Guid(array);
		}

		public override bool Equals(object _rhs)
		{
			if (!(_rhs is Guid))
			{
				return false;
			}
			Guid guid = (Guid)_rhs;
			return _a == guid._a && _b == guid._b;
		}

		public override int GetHashCode()
		{
			ulong num = _a ^ _b;
			return (int)(num >> 32) ^ (int)num;
		}

		public override string ToString()
		{
			//Discarded unreachable code: IL_0072
			if (text == null)
			{
				text = new StringBuilder();
			}
			lock (text)
			{
				text.Length = 0;
				text.Append(_a.ToString("x16")).Append('-').Append(_b.ToString("x16"));
				return text.ToString();
			}
		}

		public static bool operator ==(Guid lhs, Guid rhs)
		{
			return lhs._a == rhs._a && lhs._b == rhs._b;
		}

		public static bool operator !=(Guid lhs, Guid rhs)
		{
			return lhs._a != rhs._a || lhs._b != rhs._b;
		}
	}
}
namespace Pathfinding
{
	public static class GraphUpdateUtilities
	{
		[Obsolete("This function has been moved to Pathfinding.Util.PathUtilities. Please use the version in that class")]
		public static bool IsPathPossible(GraphNode n1, GraphNode n2)
		{
			return n1.Walkable && n2.Walkable && n1.Area == n2.Area;
		}

		[Obsolete("This function has been moved to Pathfinding.Util.PathUtilities. Please use the version in that class")]
		public static bool IsPathPossible(List<GraphNode> nodes)
		{
			uint area = nodes[0].Area;
			for (int i = 0; i < nodes.Count; i++)
			{
				if (!nodes[i].Walkable || nodes[i].Area != area)
				{
					return false;
				}
			}
			return true;
		}

		public static bool UpdateGraphsNoBlock(GraphUpdateObject guo, GraphNode node1, GraphNode node2, bool alwaysRevert = false)
		{
			List<GraphNode> list = ListPool<GraphNode>.Claim();
			list.Add(node1);
			list.Add(node2);
			bool result = UpdateGraphsNoBlock(guo, list, alwaysRevert);
			ListPool<GraphNode>.Release(list);
			return result;
		}

		public static bool UpdateGraphsNoBlock(GraphUpdateObject guo, List<GraphNode> nodes, bool alwaysRevert = false)
		{
			for (int i = 0; i < nodes.Count; i++)
			{
				if (!nodes[i].Walkable)
				{
					return false;
				}
			}
			guo.trackChangedNodes = true;
			bool worked = true;
			AstarPath.RegisterSafeUpdate(delegate
			{
				AstarPath.active.UpdateGraphs(guo);
				AstarPath.active.QueueGraphUpdates();
				AstarPath.active.FlushGraphUpdates();
				worked = (worked && PathUtilities.IsPathPossible(nodes));
				if (!worked || alwaysRevert)
				{
					guo.RevertFromBackup();
					AstarPath.active.FloodFill();
				}
			}, threadSafe: true);
			AstarPath.active.FlushThreadSafeCallbacks();
			guo.trackChangedNodes = false;
			return worked;
		}
	}
}
namespace Pathfinding.Util
{
	public class LockFreeStack
	{
		public Path head;

		public void Push(Path p)
		{
			Path path;
			do
			{
				p.next = head;
				path = Interlocked.CompareExchange(ref head, p, p.next);
			}
			while (path != p.next);
		}

		public Path PopAll()
		{
			return Interlocked.Exchange(ref head, null);
		}
	}
}
namespace Pathfinding
{
	public static class PathUtilities
	{
		public static bool IsPathPossible(GraphNode n1, GraphNode n2)
		{
			return n1.Walkable && n2.Walkable && n1.Area == n2.Area;
		}

		public static bool IsPathPossible(List<GraphNode> nodes)
		{
			uint area = nodes[0].Area;
			for (int i = 0; i < nodes.Count; i++)
			{
				if (!nodes[i].Walkable || nodes[i].Area != area)
				{
					return false;
				}
			}
			return true;
		}

		public static List<GraphNode> GetReachableNodes(GraphNode seed, int tagMask = -1)
		{
			Stack<GraphNode> stack = StackPool<GraphNode>.Claim();
			List<GraphNode> list = ListPool<GraphNode>.Claim();
			HashSet<GraphNode> map = new HashSet<GraphNode>();
			GraphNodeDelegate graphNodeDelegate = (tagMask != -1) ? ((GraphNodeDelegate)delegate(GraphNode node)
			{
				if (node.Walkable && ((tagMask >> (int)node.Tag) & 1) != 0 && map.Add(node))
				{
					list.Add(node);
					stack.Push(node);
				}
			}) : ((GraphNodeDelegate)delegate(GraphNode node)
			{
				if (node.Walkable && map.Add(node))
				{
					list.Add(node);
					stack.Push(node);
				}
			});
			graphNodeDelegate(seed);
			while (stack.Count > 0)
			{
				stack.Pop().GetConnections(graphNodeDelegate);
			}
			StackPool<GraphNode>.Release(stack);
			return list;
		}

		public static List<GraphNode> BFS(GraphNode seed, int depth, int tagMask = -1)
		{
			List<GraphNode> que = ListPool<GraphNode>.Claim();
			List<GraphNode> list = ListPool<GraphNode>.Claim();
			Dictionary<GraphNode, int> map = new Dictionary<GraphNode, int>();
			int currentDist = 0;
			GraphNodeDelegate graphNodeDelegate = (tagMask != -1) ? ((GraphNodeDelegate)delegate(GraphNode node)
			{
				if (node.Walkable && ((tagMask >> (int)node.Tag) & 1) != 0 && !map.ContainsKey(node))
				{
					map.Add(node, currentDist + 1);
					list.Add(node);
					que.Add(node);
				}
			}) : ((GraphNodeDelegate)delegate(GraphNode node)
			{
				if (node.Walkable && !map.ContainsKey(node))
				{
					map.Add(node, currentDist + 1);
					list.Add(node);
					que.Add(node);
				}
			});
			map[seed] = currentDist;
			graphNodeDelegate(seed);
			while (que.Count > 0 && currentDist < depth)
			{
				GraphNode graphNode = que[que.Count - 1];
				currentDist = map[graphNode];
				que.RemoveAt(que.Count - 1);
				graphNode.GetConnections(graphNodeDelegate);
			}
			ListPool<GraphNode>.Release(que);
			return list;
		}

		public static List<Vector3> GetSpiralPoints(int count, float clearance)
		{
			List<Vector3> list = ListPool<Vector3>.Claim(count);
			float num = clearance / ((float)Math.PI * 2f);
			float num2 = 0f;
			list.Add(InvoluteOfCircle(num, num2));
			for (int i = 0; i < count; i++)
			{
				Vector3 b = list[list.Count - 1];
				float num3 = (0f - num2) / 2f + Mathf.Sqrt(num2 * num2 / 4f + 2f * clearance / num);
				float num4 = num2 + num3;
				float num5 = num2 + 2f * num3;
				while (num5 - num4 > 0.01f)
				{
					float num6 = (num4 + num5) / 2f;
					Vector3 a = InvoluteOfCircle(num, num6);
					if ((a - b).sqrMagnitude < clearance * clearance)
					{
						num4 = num6;
					}
					else
					{
						num5 = num6;
					}
				}
				list.Add(InvoluteOfCircle(num, num5));
				num2 = num5;
			}
			return list;
		}

		private static Vector3 InvoluteOfCircle(float a, float t)
		{
			return new Vector3(a * (Mathf.Cos(t) + t * Mathf.Sin(t)), 0f, a * (Mathf.Sin(t) - t * Mathf.Cos(t)));
		}

		public static void GetPointsAroundPointWorld(Vector3 p, IRaycastableGraph g, List<Vector3> previousPoints, float radius, float clearanceRadius)
		{
			if (previousPoints.Count != 0)
			{
				Vector3 zero = Vector3.zero;
				for (int i = 0; i < previousPoints.Count; i++)
				{
					zero += previousPoints[i];
				}
				zero /= (float)previousPoints.Count;
				for (int j = 0; j < previousPoints.Count; j++)
				{
					List<Vector3> list;
					List<Vector3> list2 = list = previousPoints;
					int index;
					int index2 = index = j;
					Vector3 a = list[index];
					list2[index2] = a - zero;
				}
				GetPointsAroundPoint(p, g, previousPoints, radius, clearanceRadius);
			}
		}

		public static void GetPointsAroundPoint(Vector3 p, IRaycastableGraph g, List<Vector3> previousPoints, float radius, float clearanceRadius)
		{
			if (g == null)
			{
				throw new ArgumentNullException("g");
			}
			NavGraph navGraph = g as NavGraph;
			if (navGraph == null)
			{
				throw new ArgumentException("g is not a NavGraph");
			}
			NNInfo nearestForce = navGraph.GetNearestForce(p, NNConstraint.Default);
			p = nearestForce.clampedPosition;
			if (nearestForce.node == null)
			{
				return;
			}
			radius = Mathf.Max(radius, 1.4142f * clearanceRadius * Mathf.Sqrt(previousPoints.Count));
			clearanceRadius *= clearanceRadius;
			for (int i = 0; i < previousPoints.Count; i++)
			{
				Vector3 b = previousPoints[i];
				float magnitude = b.magnitude;
				if (magnitude > 0f)
				{
					b /= magnitude;
				}
				float num = radius;
				b *= num;
				bool flag = false;
				int num2 = 0;
				do
				{
					Vector3 vector = p + b;
					if (g.Linecast(p, vector, nearestForce.node, out GraphHitInfo hit))
					{
						vector = hit.point;
					}
					for (float num3 = 0.1f; num3 <= 1f; num3 += 0.05f)
					{
						Vector3 vector2 = (vector - p) * num3 + p;
						flag = true;
						for (int j = 0; j < i; j++)
						{
							if ((previousPoints[j] - vector2).sqrMagnitude < clearanceRadius)
							{
								flag = false;
								break;
							}
						}
						if (flag)
						{
							previousPoints[i] = vector2;
							break;
						}
					}
					if (!flag)
					{
						if (num2 > 8)
						{
							flag = true;
							continue;
						}
						clearanceRadius *= 0.9f;
						b = UnityEngine.Random.onUnitSphere * Mathf.Lerp(num, radius, num2 / 5);
						b.y = 0f;
						num2++;
					}
				}
				while (!flag);
			}
		}

		public static List<Vector3> GetPointsOnNodes(List<GraphNode> nodes, int count, float clearanceRadius = 0f)
		{
			if (nodes == null)
			{
				throw new ArgumentNullException("nodes");
			}
			if (nodes.Count == 0)
			{
				throw new ArgumentException("no nodes passed");
			}
			System.Random random = new System.Random();
			List<Vector3> list = ListPool<Vector3>.Claim(count);
			clearanceRadius *= clearanceRadius;
			if (nodes[0] is TriangleMeshNode || nodes[0] is GridNode)
			{
				List<float> list2 = ListPool<float>.Claim(nodes.Count);
				float num = 0f;
				for (int i = 0; i < nodes.Count; i++)
				{
					TriangleMeshNode triangleMeshNode = nodes[i] as TriangleMeshNode;
					if (triangleMeshNode != null)
					{
						float num2 = Math.Abs(Polygon.TriangleArea(triangleMeshNode.GetVertex(0), triangleMeshNode.GetVertex(1), triangleMeshNode.GetVertex(2)));
						num += num2;
						list2.Add(num);
						continue;
					}
					GridNode gridNode = nodes[i] as GridNode;
					if (gridNode != null)
					{
						GridGraph gridGraph = GridNode.GetGridGraph(gridNode.GraphIndex);
						float num3 = gridGraph.nodeSize * gridGraph.nodeSize;
						num += num3;
						list2.Add(num);
					}
					else
					{
						list2.Add(num);
					}
				}
				for (int j = 0; j < count; j++)
				{
					int num4 = 0;
					int num5 = 10;
					bool flag = false;
					while (!flag)
					{
						flag = true;
						if (num4 >= num5)
						{
							clearanceRadius *= 0.8f;
							num5 += 10;
							if (num5 > 100)
							{
								clearanceRadius = 0f;
							}
						}
						float item = (float)random.NextDouble() * num;
						int num6 = list2.BinarySearch(item);
						if (num6 < 0)
						{
							num6 = ~num6;
						}
						if (num6 >= nodes.Count)
						{
							flag = false;
							continue;
						}
						TriangleMeshNode triangleMeshNode2 = nodes[num6] as TriangleMeshNode;
						Vector3 vector;
						if (triangleMeshNode2 != null)
						{
							float num7;
							float num8;
							do
							{
								num7 = (float)random.NextDouble();
								num8 = (float)random.NextDouble();
							}
							while (num7 + num8 > 1f);
							vector = (Vector3)(triangleMeshNode2.GetVertex(1) - triangleMeshNode2.GetVertex(0)) * num7 + (Vector3)(triangleMeshNode2.GetVertex(2) - triangleMeshNode2.GetVertex(0)) * num8 + (Vector3)triangleMeshNode2.GetVertex(0);
						}
						else
						{
							GridNode gridNode2 = nodes[num6] as GridNode;
							if (gridNode2 == null)
							{
								list.Add((Vector3)nodes[num6].position);
								break;
							}
							GridGraph gridGraph2 = GridNode.GetGridGraph(gridNode2.GraphIndex);
							float num9 = (float)random.NextDouble();
							float num10 = (float)random.NextDouble();
							vector = (Vector3)gridNode2.position + new Vector3(num9 - 0.5f, 0f, num10 - 0.5f) * gridGraph2.nodeSize;
						}
						if (clearanceRadius > 0f)
						{
							for (int k = 0; k < list.Count; k++)
							{
								if ((list[k] - vector).sqrMagnitude < clearanceRadius)
								{
									flag = false;
									break;
								}
							}
						}
						if (flag)
						{
							list.Add(vector);
							break;
						}
						num4++;
					}
				}
				ListPool<float>.Release(list2);
			}
			else
			{
				for (int l = 0; l < count; l++)
				{
					list.Add((Vector3)nodes[random.Next(nodes.Count)].position);
				}
			}
			return list;
		}
	}
	internal class Profile
	{
		private const bool PROFILE_MEM = false;

		public string name;

		private Stopwatch w;

		private int counter;

		private long mem;

		private long smem;

		private int control = 1073741824;

		private bool dontCountFirst;

		public Profile(string name)
		{
			this.name = name;
			w = new Stopwatch();
		}

		public int ControlValue()
		{
			return control;
		}

		[Conditional("PROFILE")]
		public void Start()
		{
			if (!dontCountFirst || counter != 1)
			{
				w.Start();
			}
		}

		[Conditional("PROFILE")]
		public void Stop()
		{
			counter++;
			if (!dontCountFirst || counter != 1)
			{
				w.Stop();
			}
		}

		[Conditional("PROFILE")]
		public void Log()
		{
			UnityEngine.Debug.Log(ToString());
		}

		[Conditional("PROFILE")]
		public void ConsoleLog()
		{
			Console.WriteLine(ToString());
		}

		[Conditional("PROFILE")]
		public void Stop(int control)
		{
			counter++;
			if (!dontCountFirst || counter != 1)
			{
				w.Stop();
				if (this.control == 1073741824)
				{
					this.control = control;
				}
				else if (this.control != control)
				{
					throw new Exception("Control numbers do not match " + this.control + " != " + control);
				}
			}
		}

		[Conditional("PROFILE")]
		public void Control(Profile other)
		{
			if (ControlValue() != other.ControlValue())
			{
				throw new Exception("Control numbers do not match (" + name + " " + other.name + ") " + ControlValue() + " != " + other.ControlValue());
			}
		}

		public override string ToString()
		{
			return name + " #" + counter + " " + w.Elapsed.TotalMilliseconds.ToString("0.0 ms") + " avg: " + (w.Elapsed.TotalMilliseconds / (double)counter).ToString("0.00 ms");
		}
	}
	[ExecuteInEditMode]
	public class UnityReferenceHelper : MonoBehaviour
	{
		[SerializeField]
		[HideInInspector]
		private string guid;

		public string GetGUID()
		{
			return guid;
		}

		public void Awake()
		{
			Reset();
		}

		public void Reset()
		{
			if (guid == null || guid == string.Empty)
			{
				guid = Pathfinding.Util.Guid.NewGuid().ToString();
				UnityEngine.Debug.Log("Created new GUID - " + guid);
				return;
			}
			UnityReferenceHelper[] array = UnityEngine.Object.FindObjectsOfType(typeof(UnityReferenceHelper)) as UnityReferenceHelper[];
			int num = 0;
			while (true)
			{
				if (num < array.Length)
				{
					UnityReferenceHelper unityReferenceHelper = array[num];
					if (unityReferenceHelper != this && guid == unityReferenceHelper.guid)
					{
						break;
					}
					num++;
					continue;
				}
				return;
			}
			guid = Pathfinding.Util.Guid.NewGuid().ToString();
			UnityEngine.Debug.Log("Created new GUID - " + guid);
		}
	}
}
public enum AudioCueID : uint
{
	MUSICCUE_ENDLESSDUNGEON_EXPLORATION = 1u,
	MUSICCUE_ENDLESSDUNGEON_OPENDOOR = 3u,
	MUSICCUE_ENDLESSDUNGEON_ENDBATTLE = 6u
}
public enum AudioParameterID : uint
{
	MUSICPARAM_ENDLESSDUNGEON_JINGLE = 1u
}
[Serializable]
public struct LoadingImageOverride
{
	public Texture Texture;

	public string DateStr;
}
public class BackgroundImageBootstrapper : Amplitude.Unity.Framework.BackgroundImageBootstrapper
{
	[SerializeField]
	private LoadingImageOverride[] loadingImageOverrides;

	protected override Texture BackgroundTexture
	{
		get
		{
			string b = DateTime.Today.ToString("dd/MM/yyyy");
			for (int i = 0; i < loadingImageOverrides.Length; i++)
			{
				if (loadingImageOverrides[i].DateStr == b)
				{
					return loadingImageOverrides[i].Texture;
				}
			}
			return backgroundTexture;
		}
	}
}
public class CommandLineArguments : Amplitude.Unity.Framework.CommandLineArguments
{
	[CommandLineArgument("+connect_lobby", CommandLineArgumentType.ShortKeyValue)]
	public ulong ConnectLobby
	{
		get;
		set;
	}

	public override string ToString()
	{
		return $"Command line arguments: ConnectLobby={ConnectLobby}.";
	}
}
public enum BuildEnvironment
{
	PUBLIC,
	PRESS,
	QA,
	VIP,
	DEV,
	EXPO
}
public class DungeonsApplication : Amplitude.Unity.Framework.Application
{
	public delegate void UserStorageDataLoadedHandler();

	public static float PreviousRealtimeSinceStartup;

	public static string Hash;

	public static BuildEnvironment Environment;

	public static bool IsWindows10;

	private static Amplitude.Unity.Framework.CommandLineArguments commandLineArguments;

	public static bool IsFreeingMemory
	{
		get;
		private set;
	}

	public static CommandLineArguments CommandLineArguments
	{
		get
		{
			if (commandLineArguments == null)
			{
				commandLineArguments = new CommandLineArguments();
				string[] commandLineArgs = System.Environment.GetCommandLineArgs();
				CommandLineArgumentsParser.Interpret(commandLineArgs, ref commandLineArguments);
			}
			return commandLineArguments as CommandLineArguments;
		}
	}

	public static event UserStorageDataLoadedHandler OnUserStorageDataLoaded;

	static DungeonsApplication()
	{
		Amplitude.Unity.Framework.Application.Name = "Dungeon of the Endless";
		Hash = "0x941742317E8BECFED80B305DEE7ED97D";
		Environment = BuildEnvironment.PUBLIC;
		Amplitude.Unity.Framework.Application.Version = new Amplitude.Unity.Framework.Version
		{
			Major = 1,
			Minor = 1,
			Revision = 5,
			Accessibility = Accessibility.Public,
			Serial = 19,
			Label = string.Empty
		};
	}

	public static float GetRealtimeDelta()
	{
		return Time.realtimeSinceStartup - PreviousRealtimeSinceStartup;
	}

	public static IEnumerator FreeMemory()
	{
		Diagnostics.Log("FreeMemory...");
		IsFreeingMemory = true;
		GameObjectPoolManager goPoolManager = SingletonManager.Get<GameObjectPoolManager>();
		goPoolManager.Clear();
		int freeCount = 3;
		for (int i = 0; i < freeCount; i++)
		{
			UnityEngine.AsyncOperation unloadAsync = Resources.UnloadUnusedAssets();
			while (!unloadAsync.isDone)
			{
				yield return null;
			}
			GC.Collect();
			GC.WaitForPendingFinalizers();
		}
		IsFreeingMemory = false;
		Diagnostics.Log("FreeMemory done!");
	}

	protected override void Awake()
	{
		base.Awake();
		Diagnostics.Log("Application: " + Amplitude.Unity.Framework.Application.Name + " " + Amplitude.Unity.Framework.Application.Version + " (" + Amplitude.Unity.Framework.Application.Version.Accessibility + ") " + Hash);
		if (int.TryParse(GetRegistryValue("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", "CurrentMajorVersionNumber"), out int result))
		{
			IsWindows10 = (result == 10);
		}
	}

	protected override void FormatDiagnosticsFileName(ref string outputDebugFileName)
	{
		outputDebugFileName = string.Format("{0}_{1}", outputDebugFileName, DateTime.Now.ToString("yyyyMMdd_HHmmss"));
	}

	private void LateUpdate()
	{
		PreviousRealtimeSinceStartup = Time.realtimeSinceStartup;
	}

	private void MemoryMonitoringUpdate()
	{
		Diagnostics.Log("System total memory={0}", GC.GetTotalMemory(forceFullCollection: false));
	}

	public string GetRegistryValue(string path, string key)
	{
		//Discarded unreachable code: IL_002f, IL_0040
		try
		{
			RegistryKey registryKey = Microsoft.Win32.Registry.LocalMachine.OpenSubKey(path);
			if (registryKey == null)
			{
				return string.Empty;
			}
			return registryKey.GetValue(key).ToString();
		}
		catch
		{
			return string.Empty;
		}
	}
}
public class AudioEmitter : Amplitude.Unity.Audio.AudioEmitter
{
	private Dictionary<StaticString, List<FMOD.Event>> playingEventsByName = new Dictionary<StaticString, List<FMOD.Event>>();

	public FMOD.Event PlayAndStoreEvent(StaticString eventName, bool onlyOneEvent = false, params object[] parameters)
	{
		if (playingEventsByName.ContainsKey(eventName))
		{
			if (onlyOneEvent && playingEventsByName[eventName].Count > 0)
			{
				return null;
			}
		}
		else
		{
			playingEventsByName.Add(eventName, new List<FMOD.Event>());
		}
		FMOD.Event @event = PlayEvent(eventName, parameters);
		playingEventsByName[eventName].Add(@event);
		return @event;
	}

	public void StopStoredEvents(StaticString eventName)
	{
		if (playingEventsByName.ContainsKey(eventName))
		{
			for (int i = 0; i < playingEventsByName[eventName].Count; i++)
			{
				StopEvent(playingEventsByName[eventName][i]);
			}
			playingEventsByName[eventName].Clear();
		}
	}

	private void OnDestroy()
	{
		IEnumerator<StaticString> enumerator = playingEventsByName.Keys.GetEnumerator();
		while (enumerator.MoveNext())
		{
			StaticString current = enumerator.Current;
			for (int i = 0; i < playingEventsByName[current].Count; i++)
			{
				StopEvent(playingEventsByName[current][i]);
			}
		}
		playingEventsByName.Clear();
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}
}
[Serializable]
public class AudioManager : Amplitude.Unity.Audio.AudioManager
{
	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		SetAmbientReverb("Dungeons_01");
	}
}
public class AudioReceiver : Amplitude.Unity.Audio.AudioReceiver
{
}
public class AudioReceiverLocator : Amplitude.Unity.Framework.Behaviour
{
	public float GroundDistancePercent;

	private Transform parentTransform;

	protected override IEnumerator Start()
	{
		Diagnostics.Assert(base.transform != null);
		parentTransform = base.transform.parent;
		yield break;
	}

	protected virtual void LateUpdate()
	{
		Diagnostics.Assert(base.transform != null && parentTransform != null);
		Vector3 position = parentTransform.position;
		float y = position.y;
		Vector3 eulerAngles = parentTransform.eulerAngles;
		float num = y / Mathf.Cos((90f - eulerAngles.x) * ((float)Math.PI / 180f));
		Transform transform = base.transform;
		Vector3 localPosition = base.transform.localPosition;
		float x = localPosition.x;
		Vector3 localPosition2 = base.transform.localPosition;
		transform.localPosition = new Vector3(x, localPosition2.y, num * GroundDistancePercent);
	}
}
public class AudioVolumeManager : Manager, IAudioVolumeService, IService
{
	private IAudioService audioManager;

	public event OnAudioVolumesChangedEventHandler OnAudioVolumesChanged;

	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		SetLastError(0, "Waiting for service dependencies...");
		yield return BindService(delegate(IAudioService service)
		{
			audioManager = service;
		});
		Services.AddService((IAudioVolumeService)this);
	}

	public float GetMasterVolume()
	{
		return audioManager.MasterVolume;
	}

	public float GetBGMVolume()
	{
		return audioManager.MusicVolume;
	}

	public float GetAmbianceVolume()
	{
		return audioManager.AmbianceVolume;
	}

	public float GetSFXVolume()
	{
		return audioManager.SFXVolume;
	}

	public float GetGUIVolume()
	{
		return audioManager.GUIVolume;
	}

	public void SetMasterVolume(float volume)
	{
		audioManager.MasterVolume = volume;
		if (this.OnAudioVolumesChanged != null)
		{
			this.OnAudioVolumesChanged();
		}
	}

	public void SetBGMVolume(float volume)
	{
		audioManager.MusicVolume = volume;
		if (this.OnAudioVolumesChanged != null)
		{
			this.OnAudioVolumesChanged();
		}
	}

	public void SetAmbianceVolume(float volume)
	{
		audioManager.AmbianceVolume = volume;
		if (this.OnAudioVolumesChanged != null)
		{
			this.OnAudioVolumesChanged();
		}
	}

	public void SetSFXVolume(float volume)
	{
		audioManager.SFXVolume = volume;
		if (this.OnAudioVolumesChanged != null)
		{
			this.OnAudioVolumesChanged();
		}
	}

	public void SetGUIVolume(float volume)
	{
		audioManager.GUIVolume = volume;
		if (this.OnAudioVolumesChanged != null)
		{
			this.OnAudioVolumesChanged();
		}
	}
}
public interface IAudioVolumeService : IService
{
	event OnAudioVolumesChangedEventHandler OnAudioVolumesChanged;

	float GetMasterVolume();

	float GetBGMVolume();

	float GetAmbianceVolume();

	float GetSFXVolume();

	float GetGUIVolume();

	void SetMasterVolume(float volume);

	void SetBGMVolume(float volume);

	void SetAmbianceVolume(float volume);

	void SetSFXVolume(float volume);

	void SetGUIVolume(float volume);
}
public enum XBoxOneAudioClipType
{
	None,
	MainMenuTheme,
	InGame,
	CrystalPhase,
	Defeat,
	LevelVictory,
	GameVictory
}
[Serializable]
public struct XBoxOneAudioClip
{
	public XBoxOneAudioClipType Type;

	public AudioClip[] Clips;
}
public class XBoxOneAudio : MonoBehaviour
{
	[SerializeField]
	private XBoxOneAudioClip[] clips;

	private AudioSource source;

	private XBoxOneAudioClipType currentClipType;

	private void Awake()
	{
		source = GetComponent<AudioSource>();
	}

	public void Play(XBoxOneAudioClipType clipType)
	{
		if (clipType == currentClipType)
		{
			return;
		}
		source.Stop();
		AudioClip audioClip = null;
		for (int i = 0; i < clips.Length; i++)
		{
			if (clips[i].Type == clipType && clips[i].Clips.Length > 0)
			{
				audioClip = clips[i].Clips.GetRandom();
				break;
			}
		}
		if (audioClip != null)
		{
			source.clip = audioClip;
			source.Play();
			currentClipType = clipType;
		}
	}
}
public class ClickUpInfo
{
	public ClickDownInfo ClickDownInfo
	{
		get;
		private set;
	}

	public bool Dragged
	{
		get;
		private set;
	}

	public ClickUpInfo(ClickDownInfo clickDownInfo, bool dragged)
	{
		ClickDownInfo = clickDownInfo;
		Dragged = dragged;
	}
}
public class GameControlManager : Manager, IGameControlService, IService
{
	public static readonly string PauseForbiddenInMultiplayerError = "Pause_ForbiddenInMultiplayer";

	public static readonly string PauseForbiddenByShipError = "Pause_ForbiddenByShip";

	public static readonly int HeroGroupCount = 10;

	[SerializeField]
	private Texture2D roomPowerToggleCursorTexture;

	private IGuiService guiManager;

	private IGameEventService gameEventManager;

	private IMatchMakingService matchMakingManager;

	private IRuntimeService runtimeManager;

	private IInputService inputService;

	private EndLevelPanel endLevelPanel;

	private HeroListPanel heroListPanel;

	private ServicesMultiplayerSessionReference pendingMPJoin_sessionReference;

	private ulong pendingMPJoin_lobbyID;

	private bool pendingMPJoin_checkLobbyType;

	public bool RoomPowerMode
	{
		get;
		private set;
	}

	public string ConstructionBPName
	{
		get;
		set;
	}

	public bool MultipleModuleConstructionsMode
	{
		get;
		set;
	}

	public bool MultipleHeroSelectionMode
	{
		get;
		set;
	}

	public bool HeroGroupAssignationMode
	{
		get;
		set;
	}

	public bool IsMajorModuleCategorySelected
	{
		get;
		set;
	}

	public bool IsMinorModuleCategorySelected
	{
		get;
		set;
	}

	public bool ModuleDestructionMode
	{
		get;
		set;
	}

	public bool ForbidGamePause
	{
		get;
		set;
	}

	public StaticString[][] HeroGroups
	{
		get;
		set;
	}

	public event RoomPowerModeChangedEventHandler OnRoomPowerToggleModeChanged;

	public event HeroStatsPanelChangedEventHandler OnHeroStatsPanelChanged;

	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		SetLastError(0, "Waiting for service dependencies...");
		yield return BindService(delegate(IGuiService service)
		{
			guiManager = service;
		});
		yield return BindService(delegate(IGameEventService service)
		{
			gameEventManager = service;
		});
		yield return BindService(delegate(IRuntimeService service)
		{
			runtimeManager = service;
		});
		yield return BindService(delegate(IMatchMakingService service)
		{
			matchMakingManager = service;
		});
		HeroGroups = new StaticString[HeroGroupCount][];
		Services.AddService((IGameControlService)this);
	}

	public void SetRoomPowerToggleMode(bool on)
	{
		RoomPowerMode = on;
		if (on)
		{
			guiManager.ChangeCursor(roomPowerToggleCursorTexture);
		}
		else
		{
			guiManager.ChangeCursorToDefault();
		}
		if (this.OnRoomPowerToggleModeChanged != null)
		{
			this.OnRoomPowerToggleModeChanged(on);
		}
	}

	public void StartNewSinglePlayerGame()
	{
		Dungeon.PrepareForNewGame(multiplayer: false);
		StartSinglePlayerGame();
	}

	public void StartSavedSinglePlayerGame(string saveKey)
	{
		Dungeon.PrepareForSavedGame(saveKey, multiplayer: false);
		StartSinglePlayerGame();
	}

	public void StartNextLevelSinglePlayerGame()
	{
		Dungeon.PrepareForNextLevel();
		StopGame();
		StartSinglePlayerGame();
	}

	public void StartLevelXSinglePlayerGame(int level)
	{
		Dungeon.PrepareForLevelX(level);
		StopGame();
		StartSinglePlayerGame();
	}

	public void StartNewMultiplayerGame()
	{
		Dungeon.PrepareForNewGame(multiplayer: true);
		runtimeManager.Runtime.FiniteStateMachine.PostStateChange(typeof(RuntimeState_Lobby), SessionMode.Public);
	}

	public void StartSavedMultiplayerGame(string saveKey, int slotCount)
	{
		Dungeon.PrepareForSavedGame(saveKey, multiplayer: true);
		runtimeManager.Runtime.FiniteStateMachine.PostStateChange(typeof(RuntimeState_Lobby), SessionMode.Public, saveKey, slotCount);
	}

	public void JoinMultiplayerGame(ulong lobbyID, bool checkLobbyType = true)
	{
		try
		{
			if (matchMakingManager.RequestLobbyList(Steamworks.SteamMatchMaking.ELobbyDistanceFilter.k_ELobbyDistanceFilterWorldwide))
			{
				pendingMPJoin_lobbyID = lobbyID;
				pendingMPJoin_checkLobbyType = checkLobbyType;
				matchMakingManager.MatchMakingRequestLobbyList += MatchMaking_CallbackRequestLobbyList;
			}
			else
			{
				Diagnostics.LogWarning("Failed to request the list of lobbies.");
				pendingMPJoin_sessionReference = null;
			}
		}
		catch
		{
			matchMakingManager.MatchMakingRequestLobbyList -= MatchMaking_CallbackRequestLobbyList;
		}
	}

	private void MatchMaking_CallbackRequestLobbyList(object sender, MatchMakingRequestLobbyListEventArgs e)
	{
		matchMakingManager.MatchMakingRequestLobbyList -= MatchMaking_CallbackRequestLobbyList;
		DoJoinMultiplayerGame();
	}

	public void DoJoinMultiplayerGame()
	{
		//Discarded unreachable code: IL_0208
		Diagnostics.Log("DoJoinMultiplayerGame(), pendingMPJoin_lobbyID: {0}, pendingMPJoin_sessionReference: {1}.", pendingMPJoin_lobbyID, (!(pendingMPJoin_sessionReference == null)) ? pendingMPJoin_sessionReference.SessionName : "null");
		ulong lobbyByMultiplayerSessionReference = pendingMPJoin_lobbyID;
		if (pendingMPJoin_sessionReference != null)
		{
			lobbyByMultiplayerSessionReference = ((XboxOneManager)matchMakingManager).GetLobbyByMultiplayerSessionReference(pendingMPJoin_sessionReference);
		}
		Diagnostics.Log("DoJoinMultiplayerGame(), Using lobbyID: {0}.", lobbyByMultiplayerSessionReference);
		pendingMPJoin_sessionReference = null;
		pendingMPJoin_lobbyID = 0uL;
		if (lobbyByMultiplayerSessionReference == 0L)
		{
			Diagnostics.LogWarning("DoJoinMultiplayerGame(), Canceled! because the session reference couldn't be found (maybe closed or turned private).");
			RequesterPanel requesterPanel = SingletonManager.Get<RequesterPanel>();
			if (requesterPanel != null)
			{
				requesterPanel.Display("%Error_LobbyJoinAvailability");
			}
			SingletonManager.Get<XboxMainMenuPanel>().EndOfFirstPrompt();
		}
		else
		{
			try
			{
				LobbyDescription lobbyDescription = new LobbyDescription(matchMakingManager, lobbyByMultiplayerSessionReference);
				if (!lobbyDescription.IsJoinable(pendingMPJoin_checkLobbyType, reportErrors: true))
				{
					Diagnostics.LogWarning("DoJoinMultiplayerGame(), Canceled! because the lobby isn't joinable.");
				}
				else
				{
					Diagnostics.Log("DoJoinMultiplayerGame(), Proceeding...");
					if (!string.IsNullOrEmpty(lobbyDescription.SaveKey))
					{
						Dungeon.PrepareForSavedGame(null, multiplayer: true);
						runtimeManager.Runtime.FiniteStateMachine.PostStateChange(typeof(RuntimeState_Lobby), SessionMode.Public, lobbyByMultiplayerSessionReference, lobbyDescription.SaveKey, lobbyDescription.PlayerIDs.Length);
					}
					else
					{
						Dungeon.PrepareForNewGame(multiplayer: true);
						runtimeManager.Runtime.FiniteStateMachine.PostStateChange(typeof(RuntimeState_Lobby), lobbyByMultiplayerSessionReference);
					}
					SingletonManager.Get<MPSaveListPanel>().Hide(instant: true);
					SingletonManager.Get<RequesterPanel>().Hide(instant: true);
				}
			}
			catch (Exception ex)
			{
				Diagnostics.LogWarning("DoJoinMultiplayerGame(), Exception caught: {0}", ex.ToString());
				throw;
			}
		}
	}

	public void StartNextLevelMultiplayerGame()
	{
		GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
		if (!gameNetworkManager.IsMultiplayerSession())
		{
			Diagnostics.LogError("StartNextLevelMultiplayerGame should only be called in multiplayer games!");
			return;
		}
		if (!gameNetworkManager.IsServer())
		{
			Diagnostics.LogError("StartNextLevelMultiplayerGame should only be called by server!");
			return;
		}
		ISessionService service = Services.GetService<ISessionService>();
		if (service == null)
		{
			Diagnostics.LogError("Unable to get session manager!");
			return;
		}
		Session session = service.Session as Session;
		if (session == null)
		{
			Diagnostics.LogError("Unable to get session from manager!");
		}
		else
		{
			session.GameServer.PostStateChange(typeof(GameServerState_RestartGame));
		}
	}

	public void GoBackToMainMenu(bool killAutoSave = true)
	{
		Diagnostics.Log("GameControlManager.GoBackToMainMenu");
		GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
		gameNetworkManager.StopMonitorPlayerLeft();
		gameNetworkManager.StopMonitorServerLeft();
		StopGame(killAutoSave);
		SingletonManager.Get<SessionListPanel>().Hide();
		SingletonManager.Get<MPSaveListPanel>().Hide();
		SingletonManager.Get<HeroPanel>().Hide();
		SingletonManager.Get<StoryDialogPanel>().Hide();
	}

	public void SetHeroStatsPanelDisplay(bool on, bool displayInventory = true, bool autoHideMerchantPanel = true)
	{
		if (inputService == null)
		{
			inputService = Services.GetService<IInputService>();
		}
		HeroPanel heroPanel = SingletonManager.Get<HeroPanel>();
		if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			HeroStatsPanel heroStatsPanel = SingletonManager.Get<HeroStatsPanel>(mandatory: false);
			if (Hero.SelectedHeroes.Count >= 1 && on)
			{
				if (Hero.SelectedHeroes.Count > 1)
				{
					Hero.SelectedHeroes[0].Select();
				}
				if (heroStatsPanel != null && heroStatsPanel.BoundHero != Hero.SelectedHeroes[0])
				{
					heroStatsPanel.Unbind();
					if (heroStatsPanel.IsVisible)
					{
						heroStatsPanel.Hide(instant: true);
					}
					heroStatsPanel.Bind(Hero.SelectedHeroes[0], 0);
				}
				if (heroPanel.IsVisible && !heroPanel.IsHiding)
				{
					heroPanel.RefreshContent();
				}
				else
				{
					heroPanel.ShowWhenFinishedHiding();
				}
			}
			else
			{
				heroPanel.Hide();
				heroStatsPanel.Unbind();
			}
		}
		else if (on)
		{
			if (heroPanel.IsVisible)
			{
				heroPanel.RefreshContent();
			}
			else
			{
				heroPanel.ShowWhenFinishedHiding();
			}
		}
		else
		{
			heroPanel.Hide();
		}
		if (this.OnHeroStatsPanelChanged != null)
		{
			this.OnHeroStatsPanelChanged(on);
		}
		if (inputService.CurrentControlScheme != 0)
		{
			return;
		}
		SingletonManager.Get<MainGameScreen>().SetSharedInventoryPanelDisplay(on && displayInventory);
		if (autoHideMerchantPanel && !on)
		{
			MerchantPanel merchantPanel = SingletonManager.Get<MainGameScreen>().MerchantPanel;
			if (merchantPanel.IsVisible)
			{
				merchantPanel.Hide();
			}
		}
	}

	public void ToggleHeroStatsPanelDisplay()
	{
		SetHeroStatsPanelDisplay(!SingletonManager.Get<HeroPanel>().IsVisible);
	}

	public void ClosePanelsAtStartOfInteraction()
	{
		if (Services.GetService<IInputService>().CurrentControlScheme == ControlScheme.XBoxOneController && !CanPauseGame() && SingletonManager.Get<HeroPanel>().IsVisible)
		{
			SetHeroStatsPanelDisplay(on: false);
			SingletonManager.Get<SelectableManager>().SetCategory(SelectionCategory.RoomForMove);
		}
		SelectionCategoryData currentCategory = SingletonManager.Get<SelectableManager>().CurrentCategory;
		SelectionCategory category = currentCategory.Category;
		if (category == SelectionCategory.BuildMenu || category == SelectionCategory.RoomForBuild || category == SelectionCategory.Module)
		{
			SingletonManager.Get<SelectableManager>().SetCategory(SelectionCategory.RoomForMove);
		}
		if (PopupMenuPanel.GetTopPopupMenuPanel() != null)
		{
			PopupMenuPanel.CloseTopPopupMenuPanelForEscapeBehavior();
		}
		MerchantPanel merchantPanel = SingletonManager.Get<MerchantPanel>();
		if (merchantPanel != null && merchantPanel.IsVisible)
		{
			merchantPanel.Hide(instant: true);
		}
		StelePanel stelePanel = SingletonManager.Get<StelePanel>();
		if (stelePanel != null)
		{
			stelePanel.Hide(instant: true);
		}
	}

	public void SetSharedInventoryPanelDisplay(bool on)
	{
		MainGameScreen mainGameScreen = SingletonManager.Get<MainGameScreen>();
		if (mainGameScreen != null)
		{
			if (on)
			{
				mainGameScreen.CloseConcurrentInventoryPanel(mainGameScreen.SharedInventoryPanel);
				mainGameScreen.DisplayInventoryPanel(mainGameScreen.SharedInventoryPanel, SingletonManager.Get<Dungeon>().SharedInventory);
			}
			else
			{
				mainGameScreen.SharedInventoryPanel.Hide();
			}
		}
	}

	public bool CanPauseGame(List<GuiError> guiErrors = null, bool ignoreShipConfig = false)
	{
		Dungeon dungeon = SingletonManager.Get<Dungeon>(mandatory: false);
		if (dungeon == null)
		{
			return false;
		}
		if (!dungeon.IsStarted || !dungeon.IsDisplayed)
		{
			return false;
		}
		if (dungeon.IsLevelOver)
		{
			return false;
		}
		if (ForbidGamePause)
		{
			return false;
		}
		if (endLevelPanel == null)
		{
			endLevelPanel = SingletonManager.Get<EndLevelPanel>();
		}
		if (endLevelPanel.IsVisible)
		{
			return false;
		}
		GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
		if (gameNetworkManager != null && gameNetworkManager.IsMultiplayerSession())
		{
			GuiError.Add(guiErrors, PauseForbiddenInMultiplayerError);
			return false;
		}
		if (dungeon.ShipConfig != null && dungeon.ShipConfig.ForbidPause && !ignoreShipConfig)
		{
			GuiError.Add(guiErrors, PauseForbiddenByShipError);
			return false;
		}
		return true;
	}

	public void ToggleGamePause()
	{
		SetGamePause(Time.timeScale != 0f);
		if (Time.timeScale == 0f)
		{
			SingletonManager.Get<AchievementManagerDOTE>().AddToStatistic(StatisticName.PAUSE_USES_NEGATIVE, -1f);
		}
	}

	public void SetGamePause(bool paused, bool ignoreCheck = false)
	{
		if (paused && !ignoreCheck && !CanPauseGame())
		{
			Diagnostics.LogError("Cannot pause game!");
			return;
		}
		GamePausePanel gamePausePanel = SingletonManager.Get<GamePausePanel>();
		IAudioService service = Services.GetService<IAudioService>();
		Diagnostics.Assert(service != null);
		if (paused)
		{
			Time.timeScale = 0f;
			gamePausePanel.Show();
			service.SetCategoryVolume("InGameSFX/SFX/SFX_Pause", 0f, 0.5f);
		}
		else
		{
			Time.timeScale = 1f;
			gamePausePanel.Hide();
			service.SetCategoryVolume("InGameSFX/SFX/SFX_Pause", 1f, 0.5f);
		}
		SingletonManager.Get<TurnPanel>().RefreshContent();
	}

	private void StartSinglePlayerGame()
	{
		runtimeManager.Runtime.FiniteStateMachine.PostStateChange(typeof(RuntimeState_Lobby), SessionMode.Single);
	}

	private void StopGame(params object[] parameters)
	{
		bool killAutoSave = true;
		if (parameters.Length == 1 && parameters[0] is bool)
		{
			killAutoSave = (bool)parameters[0];
		}
		gameEventManager.TriggerGameStoppedEvent(killAutoSave);
		runtimeManager.Runtime.FiniteStateMachine.PostStateChange(typeof(RuntimeState_OutGame), parameters);
	}

	public void AssignHeroGroup(int index)
	{
		HeroGroups[index] = new StaticString[Hero.SelectedHeroes.Count];
		for (int i = 0; i < Hero.SelectedHeroes.Count; i++)
		{
			HeroGroups[index][i] = Hero.SelectedHeroes[i].Config.Name;
		}
		if (heroListPanel == null)
		{
			heroListPanel = SingletonManager.Get<HeroListPanel>();
		}
		if (heroListPanel != null)
		{
			heroListPanel.RefreshContent();
		}
	}
}
public class GameEventManager : Manager, IGameEventService, IService
{
	public event InGameClickDownEventHandler OnInGameClickDown;

	public event DungeonFIDSChangedEventHandler OnDungeonFIDSChanged;

	public event DungeonTurnChangedEventHandler OnDungeonTurnChanged;

	public event LastDoorOpenedEventHandler OnLastDoorOpened;

	public event GamePhaseChangedEventHandler OnGamePhaseChanged;

	public event HeroSelectionEventHandler OnHeroSelectionChanged;

	public event RoomSelectionEventHandler OnRoomSelectionChanged;

	public event ModuleBuiltEventHandler OnModuleBuilt;

	public event DisplayedHeroStatsRefreshedEventHandler OnDisplayedHeroStatsRefreshed;

	public event ItemListSelectedEventHandler OnItemListSelected;

	public event GameVictoryEventHandler OnGameVictory;

	public event GameStoppedEventHandler OnGameStopped;

	public event GameStartedEventHandler OnGameStarted;

	public event HeroListChangedEventHandler OnHeroListChanged;

	public event MajorModuleCategorySelectedEventHandler OnMajorModuleCategorySelected;

	public event MajorModuleCategoryUnselectedEventHandler OnMajorModuleCategoryUnselected;

	public event MinorModuleCategorySelectedEventHandler OnMinorModuleCategorySelected;

	public event MinorModuleCategoryUnselectedEventHandler OnMinorModuleCategoryUnselected;

	public event Action OnRoomEventFinished;

	public event DoorOpenedByHeroTutorialEventHandler OnDoorOpenedByHero;

	public event HeroMovedToRoomTutorialEventHandler OnHeroMovedToRoom;

	public event RoomPoweredTutorialEventHandler OnRoomPowered;

	public event BuiltModuleTutorialEventHandler OnBuiltModule;

	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		SetLastError(0, "Waiting for service dependencies...");
		Services.AddService((IGameEventService)this);
	}

	public void TriggerInGameClickDownEvent(MouseButton mouseButton)
	{
		if (this.OnInGameClickDown != null)
		{
			this.OnInGameClickDown(mouseButton);
		}
	}

	public void TriggerDungeonFIDSChangedEvent()
	{
		if (this.OnDungeonFIDSChanged != null)
		{
			this.OnDungeonFIDSChanged();
		}
	}

	public void TriggerDungeonTurnChangedEvent()
	{
		if (this.OnDungeonTurnChanged != null)
		{
			this.OnDungeonTurnChanged();
		}
	}

	public void TriggerLastDoorOpenedEvent()
	{
		if (this.OnLastDoorOpened != null)
		{
			this.OnLastDoorOpened();
		}
	}

	public void TriggerGamePhaseChangedEvent()
	{
		if (this.OnGamePhaseChanged != null)
		{
			this.OnGamePhaseChanged();
		}
	}

	public void TriggerHeroSelectionEvent()
	{
		if (this.OnHeroSelectionChanged != null)
		{
			this.OnHeroSelectionChanged();
		}
	}

	public void TriggerRoomSelectionEvent(Room selectedRoom)
	{
		if (this.OnRoomSelectionChanged != null)
		{
			this.OnRoomSelectionChanged(selectedRoom);
		}
	}

	public void TriggerModuleBuiltEvent(BluePrintConfig bpConfig)
	{
		if (this.OnModuleBuilt != null)
		{
			this.OnModuleBuilt(bpConfig);
		}
	}

	public void TriggerDisplayedHeroStatsRefreshedEvent(Hero displayedHero)
	{
		if (this.OnDisplayedHeroStatsRefreshed != null)
		{
			this.OnDisplayedHeroStatsRefreshed(displayedHero);
		}
	}

	public void TriggerItemListSelectedEvent(InventoryListPanel sender, InventoryGuiItem inventoryGuiItem)
	{
		if (this.OnItemListSelected != null)
		{
			this.OnItemListSelected(sender, inventoryGuiItem);
		}
	}

	public void TriggerGameVictoryEvent()
	{
		if (this.OnGameVictory != null)
		{
			this.OnGameVictory();
		}
	}

	public void TriggerGameStartedEvent()
	{
		if (this.OnGameStarted != null)
		{
			this.OnGameStarted();
		}
	}

	public void TriggerGameStoppedEvent(bool killAutoSave)
	{
		if (this.OnGameStopped != null)
		{
			this.OnGameStopped(killAutoSave);
		}
	}

	public void TriggerHeroListChangedEvent()
	{
		if (this.OnHeroListChanged != null)
		{
			this.OnHeroListChanged();
		}
	}

	public void TriggerMajorModuleCategorySelectedEvent()
	{
		if (this.OnMajorModuleCategorySelected != null)
		{
			this.OnMajorModuleCategorySelected();
		}
	}

	public void TriggerMajorModuleCategoryUnselectedEvent()
	{
		if (this.OnMajorModuleCategoryUnselected != null)
		{
			this.OnMajorModuleCategoryUnselected();
		}
	}

	public void TriggerMinorModuleCategorySelectedEvent()
	{
		if (this.OnMinorModuleCategorySelected != null)
		{
			this.OnMinorModuleCategorySelected();
		}
	}

	public void TriggerMinorModuleCategoryUnselectedEvent()
	{
		if (this.OnMinorModuleCategoryUnselected != null)
		{
			this.OnMinorModuleCategoryUnselected();
		}
	}

	public void TriggerDoorOpenedByHeroTutorialEvent()
	{
		if (this.OnDoorOpenedByHero != null)
		{
			this.OnDoorOpenedByHero();
		}
	}

	public void TriggerHeroMovedToRoomTutorialEvent()
	{
		if (this.OnHeroMovedToRoom != null)
		{
			this.OnHeroMovedToRoom();
		}
	}

	public void TriggerRoomPoweredTutorialEvent()
	{
		if (this.OnRoomPowered != null)
		{
			this.OnRoomPowered();
		}
	}

	public void TriggerBuiltModuleTutorialEvent()
	{
		if (this.OnBuiltModule != null)
		{
			this.OnBuiltModule();
		}
	}

	public void TriggerRoomEventFinished()
	{
		if (this.OnRoomEventFinished != null)
		{
			this.OnRoomEventFinished();
		}
	}
}
public interface IGameControlService : IService
{
	bool RoomPowerMode
	{
		get;
	}

	string ConstructionBPName
	{
		get;
		set;
	}

	bool MultipleModuleConstructionsMode
	{
		get;
		set;
	}

	bool MultipleHeroSelectionMode
	{
		get;
		set;
	}

	bool HeroGroupAssignationMode
	{
		get;
		set;
	}

	bool IsMajorModuleCategorySelected
	{
		get;
		set;
	}

	bool IsMinorModuleCategorySelected
	{
		get;
		set;
	}

	bool ModuleDestructionMode
	{
		get;
		set;
	}

	StaticString[][] HeroGroups
	{
		get;
		set;
	}

	bool ForbidGamePause
	{
		get;
		set;
	}

	event RoomPowerModeChangedEventHandler OnRoomPowerToggleModeChanged;

	event HeroStatsPanelChangedEventHandler OnHeroStatsPanelChanged;

	void SetRoomPowerToggleMode(bool on);

	void StartNewSinglePlayerGame();

	void StartSavedSinglePlayerGame(string saveKey);

	void StartNextLevelSinglePlayerGame();

	void StartLevelXSinglePlayerGame(int level);

	void StartNewMultiplayerGame();

	void StartSavedMultiplayerGame(string saveKey, int slotCount);

	void StartNextLevelMultiplayerGame();

	void JoinMultiplayerGame(ulong lobbyID, bool checkLobbyType = true);

	void GoBackToMainMenu(bool killAutoSave = true);

	void SetHeroStatsPanelDisplay(bool on, bool displayInventory = true, bool autoHideMerchantPanel = true);

	void ToggleHeroStatsPanelDisplay();

	void ClosePanelsAtStartOfInteraction();

	void SetSharedInventoryPanelDisplay(bool on);

	bool CanPauseGame(List<GuiError> guiErrors = null, bool ignoreShipConfig = false);

	void ToggleGamePause();

	void SetGamePause(bool paused, bool ignoreCheck = false);

	void AssignHeroGroup(int index);
}
public interface IGameEventService : IService
{
	event InGameClickDownEventHandler OnInGameClickDown;

	event DungeonFIDSChangedEventHandler OnDungeonFIDSChanged;

	event DungeonTurnChangedEventHandler OnDungeonTurnChanged;

	event LastDoorOpenedEventHandler OnLastDoorOpened;

	event GamePhaseChangedEventHandler OnGamePhaseChanged;

	event HeroSelectionEventHandler OnHeroSelectionChanged;

	event RoomSelectionEventHandler OnRoomSelectionChanged;

	event ModuleBuiltEventHandler OnModuleBuilt;

	event DisplayedHeroStatsRefreshedEventHandler OnDisplayedHeroStatsRefreshed;

	event ItemListSelectedEventHandler OnItemListSelected;

	event GameVictoryEventHandler OnGameVictory;

	event GameStartedEventHandler OnGameStarted;

	event GameStoppedEventHandler OnGameStopped;

	event HeroListChangedEventHandler OnHeroListChanged;

	event MajorModuleCategorySelectedEventHandler OnMajorModuleCategorySelected;

	event MajorModuleCategoryUnselectedEventHandler OnMajorModuleCategoryUnselected;

	event MinorModuleCategorySelectedEventHandler OnMinorModuleCategorySelected;

	event MinorModuleCategoryUnselectedEventHandler OnMinorModuleCategoryUnselected;

	event Action OnRoomEventFinished;

	event DoorOpenedByHeroTutorialEventHandler OnDoorOpenedByHero;

	event HeroMovedToRoomTutorialEventHandler OnHeroMovedToRoom;

	event RoomPoweredTutorialEventHandler OnRoomPowered;

	event BuiltModuleTutorialEventHandler OnBuiltModule;

	void TriggerInGameClickDownEvent(MouseButton mouseButton);

	void TriggerDungeonFIDSChangedEvent();

	void TriggerDungeonTurnChangedEvent();

	void TriggerLastDoorOpenedEvent();

	void TriggerGamePhaseChangedEvent();

	void TriggerHeroSelectionEvent();

	void TriggerRoomSelectionEvent(Room selectedRoom);

	void TriggerModuleBuiltEvent(BluePrintConfig bpConfig);

	void TriggerDisplayedHeroStatsRefreshedEvent(Hero displayedHero);

	void TriggerItemListSelectedEvent(InventoryListPanel sender, InventoryGuiItem inventoryGuiItem);

	void TriggerGameVictoryEvent();

	void TriggerGameStartedEvent();

	void TriggerGameStoppedEvent(bool killAutoSave);

	void TriggerHeroListChangedEvent();

	void TriggerMajorModuleCategorySelectedEvent();

	void TriggerMajorModuleCategoryUnselectedEvent();

	void TriggerMinorModuleCategorySelectedEvent();

	void TriggerMinorModuleCategoryUnselectedEvent();

	void TriggerDoorOpenedByHeroTutorialEvent();

	void TriggerHeroMovedToRoomTutorialEvent();

	void TriggerRoomPoweredTutorialEvent();

	void TriggerBuiltModuleTutorialEvent();

	void TriggerRoomEventFinished();
}
public enum UserChangePolicy
{
	Normal,
	Silent,
	Ignore
}
public interface IXboxGameControlService : IService
{
	UserChangePolicy UserChangePolicy
	{
		get;
		set;
	}

	void RequestSignIn(uint joystickId = 0);

	void XboxGoBackToMainMenu(StaticString message, bool ignoreSigningProcedure, bool forceMessage = false, bool killAutoSave = true);
}
public class InputManager : Manager, IInputService, IService
{
	private struct AxisButtonConfig
	{
		public InputAxis Axis;

		public bool Positive;
	}

	private struct CustomButtonStatus
	{
		public bool CurrentlyDown;

		public bool JustDown;

		public bool JustUp;
	}

	private const int KL_NAMELENGTH = 9;

	public static readonly StaticString KeyboardControlsBaseRegistryPath = "Settings/Controls/Keyboard/";

	private StaticString[] controlToRegistryPath;

	private StaticString[] controlKBLToRegistryPath;

	private readonly StaticString edgeScrollingEnabledRegistryPath = "Settings/Controls/EdgeScrollingEnabled";

	private readonly StaticString edgeScrollingBordersWidthRegistryPath = "Settings/Controls/EdgeScrollingBordersWidth";

	[SerializeField]
	private LayerMask gameMouseClickLayerMask;

	[SerializeField]
	private LayerMask tacticalMapClickLayerMask;

	private bool stopClickEventPropagation;

	private bool stopMouseWheelEventPropagation;

	private List<ClickDownInfo> leftClickInfos;

	private List<ClickDownInfo> rightClickInfos;

	private List<ClickDownInfo> middleClickInfos;

	private static readonly StaticString xBoxOneControlsBaseRegistryPath = "Settings/Controls/XBoxOneController/";

	private readonly Dictionary<StaticString, AxisButtonConfig> axisButtonConfigs = new Dictionary<StaticString, AxisButtonConfig>
	{
		{
			"LT",
			new AxisButtonConfig
			{
				Axis = InputAxis.LT,
				Positive = true
			}
		},
		{
			"RT",
			new AxisButtonConfig
			{
				Axis = InputAxis.RT
			}
		},
		{
			"DPadLeft",
			new AxisButtonConfig
			{
				Axis = InputAxis.DPadX
			}
		},
		{
			"DPadRight",
			new AxisButtonConfig
			{
				Axis = InputAxis.DPadX,
				Positive = true
			}
		},
		{
			"DPadDown",
			new AxisButtonConfig
			{
				Axis = InputAxis.DPadY
			}
		},
		{
			"DPadUp",
			new AxisButtonConfig
			{
				Axis = InputAxis.DPadY,
				Positive = true
			}
		},
		{
			"LeftStickLeft",
			new AxisButtonConfig
			{
				Axis = InputAxis.LeftStickX
			}
		},
		{
			"LeftStickRight",
			new AxisButtonConfig
			{
				Axis = InputAxis.LeftStickX,
				Positive = true
			}
		},
		{
			"LeftStickDown",
			new AxisButtonConfig
			{
				Axis = InputAxis.LeftStickY
			}
		},
		{
			"LeftStickUp",
			new AxisButtonConfig
			{
				Axis = InputAxis.LeftStickY,
				Positive = true
			}
		},
		{
			"RightStickLeft",
			new AxisButtonConfig
			{
				Axis = InputAxis.RightStickX
			}
		},
		{
			"RightStickRight",
			new AxisButtonConfig
			{
				Axis = InputAxis.RightStickX,
				Positive = true
			}
		},
		{
			"RightStickDown",
			new AxisButtonConfig
			{
				Axis = InputAxis.RightStickY
			}
		},
		{
			"RightStickUp",
			new AxisButtonConfig
			{
				Axis = InputAxis.RightStickY,
				Positive = true
			}
		}
	};

	private Dictionary<StaticString, CustomButtonStatus> axisButtonStatuses = new Dictionary<StaticString, CustomButtonStatus>();

	private StaticString[] xbcControlToRegistryPath;

	private readonly char inputsSeparator = ' ';

	private readonly char simultaneousInputsSeparator = '+';

	public static readonly StaticString EnableXBoxControllerRegistryPath = "Settings/Controls/EnableXBoxController";

	[SerializeField]
	private Texture2D roomPowerToggleCursorTexture;

	[SerializeField]
	private float roomSwitchCooldown;

	[SerializeField]
	private float heroSwitchToFocusTime;

	[SerializeField]
	private float roomSwitchMaxDist;

	[SerializeField]
	private float camOffsetMinValue;

	[SerializeField]
	private float axisValueThreshold;

	[SerializeField]
	private string xboxOneControllerName;

	[SerializeField]
	private bool debug;

	private bool manageMode;

	private bool previousManageMode;

	private string heroSwitchButtonName;

	private float heroSwitchDuration;

	private bool previousDPadLeftInput;

	private bool previousDPadRightInput;

	private bool previousDPadDownInput;

	private bool previousDPadUpInput;

	private HeroListPanel heroListPanel;

	private Album album;

	private IGameCameraService gameCameraManager;

	private IGameEventService gameEventManager;

	private IGameControlService gameControlManager;

	private InputMode mode;

	private bool isServiceReady;

	private Dictionary<StaticString, StaticString[][]> inputsMapping = new Dictionary<StaticString, StaticString[][]>();

	private List<Control> frameConsumedControlDown = new List<Control>();

	private InteractivityLockedPanel interactivityLockedPanel;

	private XboxModalErrorPanel xboxErrorModalPanel;

	private Dictionary<StaticString, float> cachedAxisValues = new Dictionary<StaticString, float>();

	private Dictionary<StaticString, Dictionary<ControlStatus, bool>> cachedXBoxButtonStatuses = new Dictionary<StaticString, Dictionary<ControlStatus, bool>>();

	private Dictionary<Control, Dictionary<ControlStatus, bool>> cachedControlStatuses = new Dictionary<Control, Dictionary<ControlStatus, bool>>(new ControlEqualityComparer());

	private Dictionary<string, KeyCode> stringToKeyCode;

	private StaticString[][] _inputs;

	private StaticString[] _simultaneousInputs;

	private StaticString _simultaneousInput;

	private List<InteractivityLockReason> interactivityLockReasons = new List<InteractivityLockReason>();

	private Dictionary<InputAxis, StaticString> inputAxisStrings = new Dictionary<InputAxis, StaticString>();

	public ControlScheme CurrentControlScheme
	{
		get;
		set;
	}

	public bool KeyboardShortcutEnabled
	{
		get;
		private set;
	}

	public string KeyboardLayoutName
	{
		get;
		private set;
	}

	public bool EdgeScrollingEnabled
	{
		get;
		private set;
	}

	public float EdgeScrollingBordersWidth
	{
		get;
		private set;
	}

	public List<ClickDownInfo> LeftClickInfos => leftClickInfos;

	public List<ClickDownInfo> RightClickInfos => rightClickInfos;

	public List<ClickDownInfo> MiddleClickInfos => middleClickInfos;

	public bool BlockControls
	{
		get;
		set;
	}

	public List<InteractivityLockReason> InteractivityLockReasons => interactivityLockReasons;

	public event InputModeSelectedEventHandler OnInputModeSelected;

	[DllImport("user32.dll")]
	private static extern long GetKeyboardLayoutName(StringBuilder pwszKLID);

	private StaticString[][] GetKeyboardInputs(Control control)
	{
		if (controlToRegistryPath == null)
		{
			string[] names = Enum.GetNames(typeof(Control));
			Control[] array = Enum.GetValues(typeof(Control)) as Control[];
			controlToRegistryPath = new StaticString[names.Length];
			for (int i = 0; i < names.Length; i++)
			{
				Diagnostics.Assert(array[i] == (Control)i);
				controlToRegistryPath[i] = (string)KeyboardControlsBaseRegistryPath + "Default/" + array[i];
			}
			controlKBLToRegistryPath = new StaticString[names.Length];
			for (int j = 0; j < names.Length; j++)
			{
				Diagnostics.Assert(array[j] == (Control)j);
				controlKBLToRegistryPath[j] = (string)KeyboardControlsBaseRegistryPath + "KBL_" + KeyboardLayoutName + "/" + array[j];
			}
		}
		StaticString[][] inputsFromPath = GetInputsFromPath(controlKBLToRegistryPath[(int)control]);
		if (inputsFromPath != null && inputsFromPath.Length > 0)
		{
			return inputsFromPath;
		}
		return GetInputsFromPath(controlToRegistryPath[(int)control]);
	}

	public void EnableKeyboardShortcuts()
	{
		KeyboardShortcutEnabled = true;
	}

	public void DisableKeyboardShortcuts()
	{
		KeyboardShortcutEnabled = false;
	}

	public void StopClickEventPropagation()
	{
		if (debug)
		{
			Diagnostics.LogWarning("StopClickEventPropagation");
		}
		stopClickEventPropagation = true;
	}

	private void TriggerClickDownEvent(string eventName, ref List<ClickDownInfo> clickInfosContainer)
	{
		stopClickEventPropagation = false;
		LayerMask mask = (!gameCameraManager.IsTacticalMapActive()) ? gameMouseClickLayerMask : tacticalMapClickLayerMask;
		RaycastHit[] array = Physics.RaycastAll(gameCameraManager.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, mask);
		Array.Sort(array, (RaycastHit hitInfo1, RaycastHit hitInfo2) => hitInfo1.distance.CompareTo(hitInfo2.distance));
		if (debug)
		{
			Diagnostics.LogWarning(eventName + " > " + array.Length + " hits");
		}
		clickInfosContainer = new List<ClickDownInfo>();
		int num = 0;
		RaycastHit[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			RaycastHit raycastHit = array2[i];
			ClickDownInfo item = new ClickDownInfo(raycastHit.collider, raycastHit.point, num, array.Length);
			clickInfosContainer.Add(item);
		}
		foreach (ClickDownInfo item2 in clickInfosContainer)
		{
			if (debug)
			{
				Diagnostics.Log(eventName + "@" + num + "=" + item2.HitCollider.name + " @" + item2.WorldPosition);
			}
			item2.HitCollider.SendMessage(eventName, item2, SendMessageOptions.DontRequireReceiver);
			num++;
			if (stopClickEventPropagation)
			{
				break;
			}
		}
	}

	private void TriggerClickUpEvent(string eventName, ref List<ClickDownInfo> clickInfosContainer)
	{
		if (debug)
		{
			Diagnostics.LogWarning(eventName + " > " + clickInfosContainer.Count + " hits");
		}
		stopClickEventPropagation = false;
		bool isDragging = SingletonManager.Get<CameraDragSupport>().IsDragging;
		foreach (ClickDownInfo item in clickInfosContainer)
		{
			if (item.HitCollider != null)
			{
				if (debug)
				{
					Diagnostics.Log(eventName + "@" + item.Index + "=" + item.HitCollider.name);
				}
				item.HitCollider.SendMessage(eventName, new ClickUpInfo(item, isDragging), SendMessageOptions.DontRequireReceiver);
				if (stopClickEventPropagation)
				{
					break;
				}
			}
		}
		clickInfosContainer = null;
	}

	public void StopMouseWheelEventPropagation()
	{
		if (debug)
		{
			Diagnostics.LogWarning("StopMouseWheelEventPropagation");
		}
		stopMouseWheelEventPropagation = true;
	}

	private void TriggerMouseWheelEvent(string eventName)
	{
		LayerMask mask = (!gameCameraManager.IsTacticalMapActive()) ? gameMouseClickLayerMask : tacticalMapClickLayerMask;
		RaycastHit[] array = Physics.RaycastAll(gameCameraManager.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, mask);
		Array.Sort(array, (RaycastHit hitInfo1, RaycastHit hitInfo2) => hitInfo1.distance.CompareTo(hitInfo2.distance));
		stopMouseWheelEventPropagation = false;
		RaycastHit[] array2 = array;
		foreach (RaycastHit raycastHit in array2)
		{
			raycastHit.collider.SendMessage(eventName, SendMessageOptions.DontRequireReceiver);
			if (stopMouseWheelEventPropagation)
			{
				break;
			}
		}
	}

	private void OnInGameClickDown(MouseButton mouseButton)
	{
		if (gameControlManager.RoomPowerMode && mouseButton == MouseButton.Right)
		{
			gameControlManager.SetRoomPowerToggleMode(on: false);
		}
	}

	private void Update_MouseEvents()
	{
		if (CurrentControlScheme != 0)
		{
			return;
		}
		if (!AgeManager.IsMouseCovered)
		{
			if (Input.GetMouseButtonDown(0))
			{
				TriggerClickDownEvent("OnLeftClickDown", ref leftClickInfos);
			}
			if (Input.GetMouseButtonDown(1))
			{
				TriggerClickDownEvent("OnRightClickDown", ref rightClickInfos);
			}
			if (Input.GetMouseButtonDown(2))
			{
				TriggerClickDownEvent("OnMiddleClickDown", ref middleClickInfos);
			}
			float axis = Input.GetAxis("MouseWheel");
			if (axis != 0f)
			{
				TriggerMouseWheelEvent((!(axis > 0f)) ? "OnMouseWheelDown" : "OnMouseWheelUp");
			}
		}
		if (Input.GetMouseButtonUp(0) && leftClickInfos != null)
		{
			TriggerClickUpEvent("OnLeftClickUp", ref leftClickInfos);
		}
		if (Input.GetMouseButtonUp(1) && rightClickInfos != null)
		{
			TriggerClickUpEvent("OnRightClickUp", ref rightClickInfos);
		}
		if (Input.GetMouseButtonUp(2) && middleClickInfos != null)
		{
			TriggerClickUpEvent("OnMiddleClickUp", ref middleClickInfos);
		}
	}

	private StaticString[][] GetXBCInputs(Control control)
	{
		if (xbcControlToRegistryPath == null)
		{
			string[] names = Enum.GetNames(typeof(Control));
			Control[] array = Enum.GetValues(typeof(Control)) as Control[];
			xbcControlToRegistryPath = new StaticString[names.Length];
			for (int i = 0; i < names.Length; i++)
			{
				Diagnostics.Assert(array[i] == (Control)i);
				xbcControlToRegistryPath[i] = (string)xBoxOneControlsBaseRegistryPath + array[i];
			}
		}
		return GetInputsFromPath(xbcControlToRegistryPath[(int)control]);
	}

	private void Update_CustomControls()
	{
		if (CurrentControlScheme != ControlScheme.XBoxOneController)
		{
			return;
		}
		Dictionary<StaticString, AxisButtonConfig>.Enumerator enumerator = axisButtonConfigs.GetEnumerator();
		CustomButtonStatus value3 = default(CustomButtonStatus);
		while (enumerator.MoveNext())
		{
			StaticString key = enumerator.Current.Key;
			AxisButtonConfig value = enumerator.Current.Value;
			if (!axisButtonStatuses.TryGetValue(key, out CustomButtonStatus value2))
			{
				value2 = default(CustomButtonStatus);
				axisButtonStatuses.Add(key, value2);
			}
			bool currentlyDown = value2.CurrentlyDown;
			StaticString inputAxisString = GetInputAxisString(value.Axis);
			value3.CurrentlyDown = ((!value.Positive) ? (GetAxis(inputAxisString) <= 0f - axisValueThreshold) : (GetAxis(inputAxisString) >= axisValueThreshold));
			value3.JustDown = (!currentlyDown && value3.CurrentlyDown);
			value3.JustUp = (currentlyDown && !value3.CurrentlyDown);
			axisButtonStatuses[key] = value3;
		}
	}

	private void UpdateAllowedJoysticks(bool useSigningJoystick = false)
	{
	}

	private void XboxUserService_OnGamepadsChanged(object sender, GamepadsChangedEventArgs e)
	{
		if (xboxErrorModalPanel == null)
		{
			xboxErrorModalPanel = SingletonManager.Get<XboxModalErrorPanel>(mandatory: false);
		}
		if (xboxErrorModalPanel == null)
		{
			return;
		}
		if (e.IsAnyGamepadDetected)
		{
			xboxErrorModalPanel.Hide();
			xboxErrorModalPanel = null;
		}
		else
		{
			xboxErrorModalPanel.Display("%XboxNoControllers");
			if (gameControlManager.CanPauseGame())
			{
				gameControlManager.SetGamePause(paused: true);
			}
		}
		UpdateAllowedJoysticks();
	}

	private void UsersManager_OnControllerPairingChanged(string controllerType, ulong controllerId, User previousUser, User user)
	{
		UpdateAllowedJoysticks();
	}

	private void UsersManager_OnUserSignOut(int id)
	{
		UpdateAllowedJoysticks();
	}

	private void UsersManager_OnUserSignIn(int id)
	{
		UpdateAllowedJoysticks();
	}

	private void XboxOneInput_OnGamepadStateChanged(uint ctrlIndex, bool isConnected)
	{
		UpdateAllowedJoysticks();
	}

	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		SetLastError(0, "Waiting for service dependencies...");
		yield return BindService(delegate(IGameCameraService service)
		{
			gameCameraManager = service;
		});
		yield return BindService(delegate(IGameEventService service)
		{
			gameEventManager = service;
		});
		yield return BindService(delegate(IGameControlService service)
		{
			gameControlManager = service;
		});
		IPlatformService platformManager = null;
		yield return BindService(delegate(IPlatformService service)
		{
			platformManager = service;
		});
		platformManager.OnCurrentUserChanged += PlatformService_OnCurrentUserChangedButNotRetrieved;
		CurrentControlScheme = (Amplitude.Unity.Framework.Application.Registry.GetValue<bool>(EnableXBoxControllerRegistryPath) ? ControlScheme.XBoxOneController : ControlScheme.MouseAndKeyboard);
		UnityEngine.Cursor.visible = (CurrentControlScheme == ControlScheme.MouseAndKeyboard);
		UnityEngine.Cursor.lockState = ((!UnityEngine.Cursor.visible) ? CursorLockMode.Locked : CursorLockMode.Confined);
		Diagnostics.Log("CurrentControlScheme: " + CurrentControlScheme);
		EdgeScrollingEnabled = (Amplitude.Unity.Framework.Application.Registry.GetValue(edgeScrollingEnabledRegistryPath, defaultValue: true) && CurrentControlScheme != ControlScheme.XBoxOneController);
		EdgeScrollingBordersWidth = Amplitude.Unity.Framework.Application.Registry.GetValue<float>(edgeScrollingBordersWidthRegistryPath);
		EnableKeyboardShortcuts();
		gameEventManager.OnInGameClickDown += OnInGameClickDown;
		StringBuilder keyboardLayoutNameBuilder = new StringBuilder(9);
		GetKeyboardLayoutName(keyboardLayoutNameBuilder);
		KeyboardLayoutName = keyboardLayoutNameBuilder.ToString();
		Diagnostics.Log("Keyboard layout name: " + KeyboardLayoutName);
		Services.AddService((IInputService)this);
		isServiceReady = true;
	}

	private void PlatformService_OnCurrentUserChangedButNotRetrieved(object sender, EventArgs e)
	{
		UpdateAllowedJoysticks(useSigningJoystick: true);
	}

	public void SetInputMode(InputMode mode)
	{
		this.mode = mode;
		if (this.OnInputModeSelected != null)
		{
			this.OnInputModeSelected();
		}
	}

	public InputMode GetInputMode()
	{
		return mode;
	}

	private StaticString[][] GetInputsFromPath(StaticString registryPath)
	{
		if (!inputsMapping.ContainsKey(registryPath))
		{
			string value = Amplitude.Unity.Framework.Application.Registry.GetValue(registryPath);
			if (string.IsNullOrEmpty(value))
			{
				inputsMapping.Add(registryPath, null);
			}
			else
			{
				string[] array = value.Split(inputsSeparator);
				StaticString[][] array2 = new StaticString[array.Length][];
				int num = array.Length;
				for (int i = 0; i < num; i++)
				{
					string[] array3 = array[i].Split(simultaneousInputsSeparator);
					array2[i] = new StaticString[array3.Length];
					for (int j = 0; j < array3.Length; j++)
					{
						array2[i][j] = array3[j];
					}
				}
				inputsMapping.Add(registryPath, array2);
			}
		}
		return inputsMapping[registryPath];
	}

	public bool GetControl(Control control)
	{
		return GetControlStatus(control, ControlStatus.CurrentlyDown);
	}

	public bool GetControlDown(Control control)
	{
		bool controlStatus = GetControlStatus(control, ControlStatus.JustDown);
		if (controlStatus)
		{
			if (frameConsumedControlDown.Contains(control))
			{
				if (debug)
				{
					Diagnostics.LogWarning("Already consumed {0} control down", control.ToString());
				}
				return false;
			}
			if (debug)
			{
				Diagnostics.Log("Consuming {0} control down", control.ToString());
			}
			frameConsumedControlDown.Add(control);
		}
		return controlStatus;
	}

	private void LateUpdate()
	{
		frameConsumedControlDown.Clear();
		cachedAxisValues.Clear();
		Dictionary<StaticString, Dictionary<ControlStatus, bool>>.Enumerator enumerator = cachedXBoxButtonStatuses.GetEnumerator();
		while (enumerator.MoveNext())
		{
			enumerator.Current.Value.Clear();
		}
		Dictionary<Control, Dictionary<ControlStatus, bool>>.Enumerator enumerator2 = cachedControlStatuses.GetEnumerator();
		while (enumerator2.MoveNext())
		{
			enumerator2.Current.Value.Clear();
		}
	}

	public bool GetControlUp(Control control)
	{
		return GetControlStatus(control, ControlStatus.JustUp);
	}

	private bool GetControlStatus(Control control, ControlStatus controlStatus)
	{
		if (BlockControls)
		{
			return false;
		}
		Dictionary<ControlStatus, bool> value = null;
		if (!cachedControlStatuses.TryGetValue(control, out value))
		{
			value = new Dictionary<ControlStatus, bool>(new ControlStatusEqualityComparer());
			cachedControlStatuses.Add(control, value);
		}
		bool value2 = false;
		if (!value.TryGetValue(controlStatus, out value2))
		{
			switch (CurrentControlScheme)
			{
			case ControlScheme.MouseAndKeyboard:
			{
				_inputs = GetKeyboardInputs(control);
				if (_inputs == null || _inputs.Length == 0)
				{
					break;
				}
				for (int k = 0; k < _inputs.Length; k++)
				{
					_simultaneousInputs = _inputs[k];
					int num = 0;
					int num2 = 0;
					int num3 = _simultaneousInputs.Length;
					for (int l = 0; l < num3; l++)
					{
						_simultaneousInput = _simultaneousInputs[l];
						KeyCode key = _simultaneousInput.ToEnum<KeyCode>();
						bool currentlyDown = Input.GetKey(key);
						bool flag;
						switch (controlStatus)
						{
						case ControlStatus.JustDown:
							flag = Input.GetKeyDown(key);
							break;
						case ControlStatus.JustUp:
							flag = Input.GetKeyUp(key);
							break;
						default:
							flag = currentlyDown;
							break;
						}
						if (flag)
						{
							num++;
						}
						if (currentlyDown)
						{
							num2++;
						}
					}
					if (controlStatus == ControlStatus.JustDown && num3 > 1)
					{
						if (num2 == num3 && num > 0)
						{
							value2 = true;
							break;
						}
					}
					else if (num == num3)
					{
						value2 = true;
						break;
					}
				}
				break;
			}
			case ControlScheme.XBoxOneController:
			{
				_inputs = GetXBCInputs(control);
				if (_inputs == null || _inputs.Length == 0)
				{
					break;
				}
				for (int i = 0; i < _inputs.Length; i++)
				{
					_simultaneousInputs = _inputs[i];
					int num = 0;
					int num2 = 0;
					for (int j = 0; j < _simultaneousInputs.Length; j++)
					{
						_simultaneousInput = _simultaneousInputs[j];
						if (axisButtonConfigs.ContainsKey(_simultaneousInput))
						{
							CustomButtonStatus customButtonStatus = axisButtonStatuses[_simultaneousInput];
							bool currentlyDown = customButtonStatus.CurrentlyDown;
							bool flag;
							switch (controlStatus)
							{
							case ControlStatus.JustDown:
							{
								CustomButtonStatus customButtonStatus3 = axisButtonStatuses[_simultaneousInput];
								flag = customButtonStatus3.JustDown;
								break;
							}
							case ControlStatus.JustUp:
							{
								CustomButtonStatus customButtonStatus2 = axisButtonStatuses[_simultaneousInput];
								flag = customButtonStatus2.JustUp;
								break;
							}
							default:
								flag = currentlyDown;
								break;
							}
							if (flag)
							{
								num++;
							}
							if (currentlyDown)
							{
								num2++;
							}
						}
						else
						{
							bool currentlyDown = Input.GetButton(_simultaneousInput);
							bool flag;
							switch (controlStatus)
							{
							case ControlStatus.JustDown:
								flag = Input.GetButtonDown(_simultaneousInput);
								break;
							case ControlStatus.JustUp:
								flag = Input.GetButtonUp(_simultaneousInput);
								break;
							default:
								flag = currentlyDown;
								break;
							}
							if (flag)
							{
								num++;
							}
							if (currentlyDown)
							{
								num2++;
							}
						}
					}
					if (controlStatus == ControlStatus.JustDown && _simultaneousInputs.Length > 1)
					{
						if (num2 == _simultaneousInputs.Length && num > 0)
						{
							value2 = true;
							break;
						}
					}
					else if (num == _simultaneousInputs.Length)
					{
						value2 = true;
						break;
					}
				}
				break;
			}
			}
			value.Add(controlStatus, value2);
		}
		return value2;
	}

	private float GetAxis(StaticString axisName)
	{
		float value = 0f;
		if (!cachedAxisValues.TryGetValue(axisName, out value))
		{
			value = Input.GetAxis(axisName);
			cachedAxisValues.Add(axisName, value);
		}
		return value;
	}

	public float GetAxisValue(InputAxis axis)
	{
		if (BlockControls)
		{
			return 0f;
		}
		StaticString inputAxisString = GetInputAxisString(axis);
		float axis2 = GetAxis(inputAxisString);
		if (Mathf.Abs(axis2) >= axisValueThreshold)
		{
			return axis2;
		}
		return 0f;
	}

	private void Update()
	{
		if (!isServiceReady || !Amplitude.Unity.Framework.Application.HasFocus)
		{
			return;
		}
		if (CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			Update_CustomControls();
		}
		if (CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			Update_MouseEvents();
		}
		if (CurrentControlScheme == ControlScheme.MouseAndKeyboard && GetControlDown(Control.GUIToggle))
		{
			AgeRenderer[] array = UnityEngine.Object.FindObjectsOfType<AgeRenderer>();
			AgeRenderer[] array2 = array;
			foreach (AgeRenderer ageRenderer in array2)
			{
				ageRenderer.GetComponent<Camera>().enabled = !ageRenderer.GetComponent<Camera>().enabled;
			}
		}
	}

	public void ClearCachedInputs()
	{
		if (inputsMapping != null)
		{
			inputsMapping.Clear();
		}
	}

	public void LockInteractivity(InteractivityLockReason lockReason)
	{
		Diagnostics.Log("InputManager.LockInteractivity lockReason={0}", lockReason);
		if (interactivityLockReasons.Contains(lockReason))
		{
			Diagnostics.LogWarning("InputManager.LockInteractivity: {0} already used :/", lockReason);
			return;
		}
		interactivityLockReasons.Add(lockReason);
		if (interactivityLockReasons.Count == 1)
		{
			Diagnostics.Log("InputManager.LockInteractivity > LOCK!");
			Lock();
		}
	}

	public void UnlockInteractivity(InteractivityLockReason lockReason)
	{
		Diagnostics.Log("InputManager.UnlockInteractivity lockReason={0}", lockReason);
		if (!interactivityLockReasons.Contains(lockReason))
		{
			Diagnostics.LogWarning("InputManager.UnlockInteractivity: {0} not currently used :/", lockReason);
			return;
		}
		interactivityLockReasons.Remove(lockReason);
		if (interactivityLockReasons.Count == 0)
		{
			Diagnostics.Log("InputManager.LockInteractivity > UNLOCK!");
			Unlock();
		}
	}

	private void NetworkService_ConnectionStateChanged(object sender, ConnectionStateChangedEventArgs e)
	{
		if (e.OnlineState != XboxOneOnlineState.Online && interactivityLockReasons.Contains(InteractivityLockReason.SessionLife))
		{
			UnlockInteractivity(InteractivityLockReason.SessionLife);
		}
	}

	public void ClearAllInteractivityLocks()
	{
		interactivityLockReasons.Clear();
		Unlock();
	}

	private void Lock()
	{
		if (interactivityLockedPanel == null)
		{
			interactivityLockedPanel = SingletonManager.Get<InteractivityLockedPanel>();
		}
		if (interactivityLockedPanel != null)
		{
			interactivityLockedPanel.Show();
		}
		BlockControls = true;
	}

	private void Unlock()
	{
		if (interactivityLockedPanel == null)
		{
			interactivityLockedPanel = SingletonManager.Get<InteractivityLockedPanel>();
		}
		if (interactivityLockedPanel != null)
		{
			interactivityLockedPanel.Hide();
		}
		BlockControls = false;
	}

	private void PlatformManager_OnUserSignOutStarted(object sender, UserChangedEventArgs e)
	{
		if (interactivityLockReasons.Contains(InteractivityLockReason.SessionLife))
		{
			UnlockInteractivity(InteractivityLockReason.SessionLife);
		}
	}

	private StaticString GetInputAxisString(InputAxis axis)
	{
		StaticString value = null;
		if (!inputAxisStrings.TryGetValue(axis, out value))
		{
			InputAxis key = axis;
			if (DungeonsApplication.IsWindows10)
			{
				string[] joystickNames = Input.GetJoystickNames();
				for (int i = 0; i < joystickNames.Length; i++)
				{
					if (joystickNames[i].ToLower() == xboxOneControllerName)
					{
						switch (axis)
						{
						case InputAxis.DPadX:
							axis = InputAxis.DPadY;
							break;
						case InputAxis.DPadY:
							axis = InputAxis.DPadY_X1_Win10;
							break;
						case InputAxis.RT:
							axis = InputAxis.DPadX;
							break;
						}
						break;
					}
				}
			}
			value = new StaticString(axis.ToString());
			inputAxisStrings.Add(key, value);
		}
		return value;
	}

	public void SetPadMode(bool enable)
	{
		UnityEngine.Cursor.visible = !enable;
		UnityEngine.Cursor.lockState = (enable ? CursorLockMode.Locked : CursorLockMode.Confined);
		CurrentControlScheme = (enable ? ControlScheme.XBoxOneController : ControlScheme.MouseAndKeyboard);
	}
}
public class InputTester : MonoBehaviour
{
	[SerializeField]
	private bool monitorKeys;

	[SerializeField]
	private string[] axes;

	[SerializeField]
	private string[] buttons;

	private void Update()
	{
		if (monitorKeys)
		{
			KeyCode[] enumValues = GenericUtilities.GetEnumValues<KeyCode>();
			foreach (KeyCode keyCode in enumValues)
			{
				if (Input.GetKeyDown(keyCode))
				{
					UnityEngine.Debug.Log(keyCode);
				}
			}
		}
		string[] array = axes;
		foreach (string text in array)
		{
			float axis = Input.GetAxis(text);
			if (axis != 0f)
			{
				UnityEngine.Debug.Log(text + "=" + axis);
			}
		}
		string[] array2 = buttons;
		foreach (string text2 in array2)
		{
			if (Input.GetButtonDown(text2))
			{
				UnityEngine.Debug.Log(text2);
			}
		}
	}
}
[RequireComponent(typeof(AgeControlDropListInput))]
public class AGEDropListSelectable : AGESelectable
{
	private AgeControlDropListInput dropList;

	private bool doUpdate;

	private IInputService inputService;

	protected override void Awake()
	{
		base.Awake();
		dropList = GetComponent<AgeControlDropListInput>();
		inputService = Services.GetService<IInputService>();
	}

	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent);
		doUpdate = true;
	}

	public override void OnUnselect()
	{
		base.OnUnselect();
		doUpdate = false;
	}

	private void Update()
	{
		if (doUpdate)
		{
			if (inputService.GetControlDown(Control.NextSelectableRight))
			{
				dropList.SelectNext();
			}
			else if (inputService.GetControlDown(Control.NextSelectableLeft))
			{
				dropList.SelectPrevious();
			}
		}
	}
}
public class AGERowSelectable : AGESelectable
{
	public int Row
	{
		get;
		set;
	}

	public int Index
	{
		get;
		set;
	}
}
public class AGEScrollViewSelectable : AGESelectable
{
	[SerializeField]
	private float scrollValue = 0.01f;

	[SerializeField]
	private AgeControlScrollView scrollView;

	protected override void Awake()
	{
		base.Awake();
		if (scrollView == null)
		{
			scrollView = GetComponentInChildren<AgeControlScrollView>();
		}
	}

	public void Scroll(int direction)
	{
		if (scrollView != null)
		{
			scrollView.MouseWheel(scrollValue * (float)direction);
		}
	}
}
public class AGEScrollableTableHelper : MonoBehaviour
{
	public int ViewportRowCapacity;

	public float PadScrollValue = 0.125f;

	public AgeControlScrollView ScrollView;

	private int currentSelectedItemRow;

	private int upperDisplayedItemRow;

	private IInputService inputService;

	private void Awake()
	{
		if (ScrollView == null)
		{
			ScrollView = GetComponentInChildren<AgeControlScrollView>();
		}
	}

	public void OnChildSelected(AGESelectable selectable)
	{
		int row = (selectable as AGERowSelectable).Row;
		if (inputService == null)
		{
			inputService = Services.GetService<IInputService>();
		}
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController && row != currentSelectedItemRow)
		{
			if (row < upperDisplayedItemRow || row >= upperDisplayedItemRow + ViewportRowCapacity)
			{
				int num = currentSelectedItemRow - row;
				ScrollView.MouseWheel(PadScrollValue * (float)num);
				upperDisplayedItemRow -= num;
			}
			currentSelectedItemRow = row;
		}
	}

	public void Reset()
	{
		currentSelectedItemRow = 0;
		upperDisplayedItemRow = 0;
	}
}
public class AGESelectable : Selectable
{
	[SerializeField]
	private SelectionCategory nextCategory;

	[SerializeField]
	private bool monitorPositionChanges = true;

	[SerializeField]
	private bool monitorVisibilityChanges;

	[SerializeField]
	private AgeTransform positionAgeTfm;

	[SerializeField]
	private bool centerXPosition;

	[SerializeField]
	private Vector2 twoDPositionOffset;

	[SerializeField]
	private Vector2 cursorPositionOffset;

	[SerializeField]
	private AGESelectionMarker marker;

	[SerializeField]
	private bool visibilitySetsCategory;

	[SerializeField]
	private bool returnToPreviousCategoryOnInvisible;

	[SerializeField]
	private bool closePanelOnUndisplay;

	private AgeControl ageControl;

	private AgeAudio ageAudio;

	private AgeManager ageManager;

	private Vector2 position;

	private bool registerOnVisible;

	private bool previouslyVisible;

	private SelectionCategoryData previousCategory;

	public SelectionCategory NextCategory => nextCategory;

	public AgeTransform AgeTfm
	{
		get;
		protected set;
	}

	public event Action<AGESelectable> OnSelectEvent;

	public event Action<AGESelectable> OnUnselectEvent;

	protected virtual void Awake()
	{
		AgeTfm = GetComponent<AgeTransform>();
		ageControl = GetComponent<AgeControl>();
		ageAudio = GetComponent<AgeAudio>();
		if (positionAgeTfm == null)
		{
			positionAgeTfm = AgeTfm;
		}
	}

	protected override IEnumerator Start()
	{
		yield return StartCoroutine(base.Start());
		IInputService inputManager = Services.GetService<IInputService>();
		if (inputManager.CurrentControlScheme != ControlScheme.XBoxOneController)
		{
			if (marker != null)
			{
				marker.SetDisplay(display: false);
			}
		}
		else
		{
			ageManager = SingletonManager.Get<AgeManager>();
			ComputePosition();
		}
	}

	private void ComputePosition()
	{
		positionAgeTfm.ComputeGlobalPosition(out Rect globalPosition);
		position = new Vector2(globalPosition.xMin + ((!centerXPosition) ? 0f : (globalPosition.width / 2f)), globalPosition.yMin + globalPosition.height / 2f);
	}

	public override void SetDisplay(bool display)
	{
		bool isDisplayed = base.IsDisplayed;
		base.SetDisplay(display);
		if (marker != null)
		{
			if (!display)
			{
				marker.SetDisplay(display: false);
			}
			else if (display && base.IsSelected)
			{
				marker.SetDisplay(display: true);
			}
		}
		if (!closePanelOnUndisplay || !isDisplayed || display)
		{
			return;
		}
		AutoCloseGuiPanel componentInParent = GetComponentInParent<AutoCloseGuiPanel>();
		if (componentInParent != null)
		{
			AutoCloseGuiPanel autoCloseGuiPanel = componentInParent;
			if (autoCloseGuiPanel != null)
			{
				autoCloseGuiPanel.ClosePanel();
			}
			else
			{
				componentInParent.Hide();
			}
		}
		else
		{
			Diagnostics.LogError("[Selectable] {0} > Unable to find parent panel!", base.name);
		}
	}

	public override void OnSelect(bool silent = false)
	{
		if (this.OnSelectEvent != null)
		{
			this.OnSelectEvent(this);
		}
		base.OnSelect(silent);
		if (categoryConfig.ForceAgeCursorPosition)
		{
			ForcedCursorPosition();
		}
		if (marker != null)
		{
			marker.SetDisplay(display: true);
		}
	}

	public override void OnUnselect()
	{
		if (this.OnUnselectEvent != null)
		{
			this.OnUnselectEvent(this);
		}
		base.OnUnselect();
		if (categoryConfig.ForceAgeCursorPosition)
		{
			ageManager.ForceCursorPosition = false;
		}
		if (marker != null)
		{
			marker.SetDisplay(display: false);
		}
	}

	public void ForcedCursorPosition()
	{
		if (monitorPositionChanges)
		{
			ComputePosition();
		}
		if (ageManager != null)
		{
			ageManager.ForceCursorPosition = true;
			ageManager.ForcedCursorPosition = GetCursorPosition();
		}
	}

	public override void Confirm(Control confirmedControl)
	{
		base.Confirm(confirmedControl);
		if (nextCategory != SelectionCategory.None)
		{
			GetManager().SetCategory(nextCategory);
		}
		if (ageControl != null && ageControl.AgeTransform.Enable)
		{
			if (monitorPositionChanges)
			{
				ComputePosition();
			}
			AgeMouseEventData ageMouseEventData = default(AgeMouseEventData);
			ageMouseEventData.Cursor = GetCursorPosition();
			AgeMouseEventData mouseEventData = ageMouseEventData;
			ageControl.MouseEnter(GetCursorPosition());
			ageControl.MouseDown(mouseEventData);
			ageControl.MouseUp(mouseEventData);
			if (ageAudio != null)
			{
				ageAudio.MouseUp(mouseEventData);
			}
		}
	}

	public override Vector2 Get2DPosition()
	{
		if (monitorPositionChanges)
		{
			ComputePosition();
		}
		Vector2 vector = position + twoDPositionOffset;
		return new Vector2(vector.x, 0f - vector.y);
	}

	private Vector2 GetCursorPosition()
	{
		return position + cursorPositionOffset;
	}

	private void Update()
	{
		if (monitorVisibilityChanges)
		{
			bool flag = AgeTfm.IsGloballyVisible() && AgeTfm.Enable;
			if (visibilitySetsCategory)
			{
				if (!previouslyVisible && flag)
				{
					if (debug)
					{
						Diagnostics.Log("[Selectable] {0} > AGESelectable: became visible", base.name);
					}
					previousCategory = GetManager().CurrentCategory;
					GetManager().SetCategory(category, subCategoryID);
				}
				else if (previouslyVisible && !flag)
				{
					if (debug)
					{
						Diagnostics.Log("[Selectable] {0} > AGESelectable: became invisible", base.name);
					}
					SelectionCategoryData currentCategory = GetManager().CurrentCategory;
					if (currentCategory.Category == category)
					{
						SelectionCategoryData currentCategory2 = GetManager().CurrentCategory;
						if (currentCategory2.SubCategoryID == subCategoryID)
						{
							if (returnToPreviousCategoryOnInvisible)
							{
								GetManager().SetCategory(previousCategory, overrideHigherLevelCategory: true);
							}
							else
							{
								GetManager().SetCategory(SelectionCategory.RoomForMove);
							}
						}
					}
				}
			}
			if (base.IsRegistered && !flag)
			{
				Unregister();
				registerOnVisible = true;
			}
			else if (!base.IsRegistered && registerOnVisible && flag)
			{
				Register();
				registerOnVisible = false;
			}
			previouslyVisible = flag;
		}
		if (!monitorPositionChanges || !base.IsSelected)
		{
			return;
		}
		SelectionCategoryData currentCategory3 = GetManager().CurrentCategory;
		if (currentCategory3.Category == category)
		{
			SelectionCategoryData currentCategory4 = GetManager().CurrentCategory;
			if (currentCategory4.SubCategoryID == subCategoryID)
			{
				ForcedCursorPosition();
			}
		}
	}
}
public class AGESelectableCategorySetter : MonoBehaviour
{
	[SerializeField]
	private SelectionCategory category;

	[SerializeField]
	private int subCategoryID = -1;

	[SerializeField]
	private bool revertCategoryOnHide = true;

	[SerializeField]
	private bool debug;

	private AgeTransform ageTfm;

	private bool previousVisibility;

	private SelectableManager selectableManager;

	private void Awake()
	{
		ageTfm = GetComponent<AgeTransform>();
		ageTfm.OnVisibilityChanged += OnVisibilityChanged;
		selectableManager = SingletonManager.Get<SelectableManager>();
		if (!debug && selectableManager.Debug)
		{
			debug = true;
		}
	}

	private void OnVisibilityChanged()
	{
		bool flag = ageTfm.IsGloballyVisible();
		if (!previousVisibility && flag)
		{
			if (debug)
			{
				Diagnostics.Log("[Selectable] {0} became visible, setting {1}/{2} selectable category", base.name, category, subCategoryID);
			}
			selectableManager.SetCategory(category, subCategoryID);
		}
		else if (previousVisibility && !flag && revertCategoryOnHide)
		{
			if (debug)
			{
				Diagnostics.Log("[Selectable] {0} became invisible, reverting {1}/{2} selectable category", base.name, category, subCategoryID);
			}
			selectableManager.UnsetCategory(category, subCategoryID);
		}
		previousVisibility = flag;
	}
}
public class AGESelectionMarker : MonoBehaviour
{
	public AgeTransform AgeTfm
	{
		get;
		private set;
	}

	private void Awake()
	{
		AgeTfm = GetComponent<AgeTransform>();
	}

	private IEnumerator Start()
	{
		IInputService inputManager = null;
		while (inputManager == null)
		{
			inputManager = Services.GetService<IInputService>();
			yield return null;
		}
		if (inputManager.CurrentControlScheme != ControlScheme.XBoxOneController)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public void SetDisplay(bool display)
	{
		AgeTfm.Visible = display;
	}
}
[RequireComponent(typeof(AgeControlSlider))]
public class AGESliderSelectable : AGESelectable
{
	[SerializeField]
	private float padDragValue;

	private IInputService inputService;

	private AgeControlSlider slider;

	private bool doUpdate;

	protected override void Awake()
	{
		base.Awake();
		slider = GetComponent<AgeControlSlider>();
		inputService = Services.GetService<IInputService>();
	}

	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent);
		doUpdate = true;
		slider.MouseEnter(Vector2.zero);
		slider.MouseDown(default(AgeMouseEventData));
	}

	public override void OnUnselect()
	{
		base.OnUnselect();
		doUpdate = false;
		slider.MouseUp(default(AgeMouseEventData));
		slider.MouseLeave(Vector2.zero);
	}

	private void Update()
	{
		if (doUpdate)
		{
			if (inputService.GetControl(Control.NextSelectableRight))
			{
				slider.MouseDrag(Vector2.right * padDragValue);
			}
			else if (inputService.GetControl(Control.NextSelectableLeft))
			{
				slider.MouseDrag(Vector2.right * (0f - padDragValue));
			}
		}
	}
}
public class AgeControlDropListInput : AgeControlDropList
{
	private IInputService inputService;

	protected override void Awake()
	{
		base.Awake();
		inputService = Services.GetService<IInputService>();
	}

	public override void MouseEnter(Vector2 cursor)
	{
		if (inputService.CurrentControlScheme != ControlScheme.XBoxOneController)
		{
			base.MouseEnter(cursor);
		}
	}

	public override void MouseUp(AgeMouseEventData mouseEventData)
	{
		if (inputService.CurrentControlScheme != ControlScheme.XBoxOneController)
		{
			base.MouseUp(mouseEventData);
		}
	}

	public override void MouseDown(AgeMouseEventData mouseEventData)
	{
		if (inputService.CurrentControlScheme != ControlScheme.XBoxOneController)
		{
			base.MouseDown(mouseEventData);
		}
		else
		{
			SelectNext();
		}
	}

	public void SelectNext()
	{
		if (base.SelectedItem < base.ItemTable.Length - 2)
		{
			base.SelectedItem++;
		}
		else
		{
			base.SelectedItem = 0;
		}
		if ((bool)OnSelectionObject && !string.IsNullOrEmpty(OnSelectionMethod))
		{
			OnSelectionObject.SendMessage(OnSelectionMethod, base.gameObject, SendMessageOptions.RequireReceiver);
		}
	}

	public void SelectPrevious()
	{
		if (base.SelectedItem > 0)
		{
			base.SelectedItem--;
		}
		else
		{
			base.SelectedItem = base.ItemTable.Length - 1;
		}
		if ((bool)OnSelectionObject && !string.IsNullOrEmpty(OnSelectionMethod))
		{
			OnSelectionObject.SendMessage(OnSelectionMethod, base.gameObject, SendMessageOptions.RequireReceiver);
		}
	}
}
public class ConstructibleModuleCategorySelectable : AGESelectable
{
	[SerializeField]
	private int moduleCategoryIndex;

	private ConstructionPanel constructionPanel;

	protected override IEnumerator Start()
	{
		yield return StartCoroutine(base.Start());
		IInputService inputManager = Services.GetService<IInputService>();
		if (inputManager.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			constructionPanel = SingletonManager.Get<ConstructionPanel>();
		}
	}

	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent);
		if (constructionPanel != null)
		{
			constructionPanel.SelectCategoryByIndex(moduleCategoryIndex);
		}
		Vector2 vector = Get2DPosition();
		ConstructibleModuleSelectable.CategoryXPosition = vector.x;
	}
}
public class ConstructibleModuleSelectable : AGESelectable
{
	public static float CategoryXPosition;

	[SerializeField]
	private int moduleCategoryIndex;

	private ConstructibleModuleItem modulePanel;

	protected override IEnumerator Start()
	{
		yield return StartCoroutine(base.Start());
		modulePanel = GetComponent<ConstructibleModuleItem>();
	}

	public override void Confirm(Control confirmedControl)
	{
		base.Confirm(confirmedControl);
		modulePanel.Select();
		GetManager().SetCategory(SelectionCategory.RoomForBuild);
	}

	public override Vector2 Get2DPosition()
	{
		Vector2 vector = base.Get2DPosition();
		return new Vector2(CategoryXPosition, vector.y);
	}
}
public class ConstructibleModuleSelectableRadial : AGESelectable
{
	private ConstructibleModuleItem moduleItem;

	protected override void Awake()
	{
		base.Awake();
		moduleItem = GetComponent<ConstructibleModuleItem>();
	}

	public override void Confirm(Control confirmedControl)
	{
		Services.GetService<IGameControlService>().ConstructionBPName = moduleItem.BPConfig.Name;
		base.Confirm(confirmedControl);
		GetManager().SetCategory(SelectionCategory.RoomForBuild);
	}

	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent: false);
		AgeControlToggle component = GetComponent<AgeControlToggle>();
		component.State = true;
		moduleItem.Select();
	}

	public override void OnUnselect()
	{
		base.OnUnselect();
		AgeControlToggle component = GetComponent<AgeControlToggle>();
		component.State = false;
	}
}
public class CrystalSelectable : GameSelectable
{
	private MajorModule crystal;

	protected virtual void Awake()
	{
		crystal = GetComponent<MajorModule>();
	}

	public override void Confirm(Control confirmedControl)
	{
		base.Confirm(confirmedControl);
		foreach (Hero selectedHero in Hero.SelectedHeroes)
		{
			selectedHero.MoveToCrystal(crystal);
		}
	}
}
public class DestructibleModuleSelectableRadial : AGESelectable
{
	private ConstructibleModuleItem moduleItem;

	protected override void Awake()
	{
		base.Awake();
		moduleItem = GetComponent<ConstructibleModuleItem>();
	}

	public override void Confirm(Control confirmedControl)
	{
		base.Confirm(confirmedControl);
		Selectable categorySelectedElement = GetManager().GetCategorySelectedElement(SelectionCategory.RoomForMove);
		if (categorySelectedElement is RoomSelectable)
		{
			GetManager().SetCategory(SelectionCategory.Module, (categorySelectedElement as RoomSelectable).Room.UniqueID.ID);
		}
		else
		{
			GetManager().SetCategory(SelectionCategory.RoomForMove);
		}
	}

	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent: false);
		AgeControlToggle component = GetComponent<AgeControlToggle>();
		component.State = true;
		moduleItem.Select();
	}

	public override void OnUnselect()
	{
		base.OnUnselect();
		AgeControlToggle component = GetComponent<AgeControlToggle>();
		component.State = false;
	}
}
public class DoorSelectable : GameSelectable
{
	private Door door;

	protected virtual void Awake()
	{
		door = GetComponent<Door>();
	}

	public override void SetDisplay(bool display)
	{
		base.SetDisplay(display);
		if (display && base.IsSelected)
		{
			IGameCameraService service = Services.GetService<IGameCameraService>();
			service.AssertVisibility(door.transform.position);
		}
	}

	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent);
		IGameCameraService service = Services.GetService<IGameCameraService>();
		service.AssertVisibility(door.transform.position);
	}

	public override void Confirm(Control confirmedControl)
	{
		base.Confirm(confirmedControl);
		for (int i = 0; i < Hero.SelectedHeroes.Count; i++)
		{
			Hero.SelectedHeroes[i].MoveToDoor(door);
		}
	}
}
public class EquipmentSlotItemSelectable : ItemHolderSelectable
{
	private TabHeroesEquipmentPanel heroesEquipmentPadPanel;

	private MerchantPadPanel merchantPadPanel;

	private SelectableManager selectableManager;

	private Selectable selectable;

	public EquipmentSlotItem SlotPanel
	{
		get;
		private set;
	}

	protected override void Awake()
	{
		base.Awake();
		SlotPanel = GetComponent<EquipmentSlotItem>();
		selectable = GetComponent<Selectable>();
		heroesEquipmentPadPanel = SingletonManager.Get<TabHeroesEquipmentPanel>(mandatory: false);
		merchantPadPanel = (SingletonManager.Get<MainGameScreen>().MerchantPanel as MerchantPadPanel);
		selectableManager = SingletonManager.Get<SelectableManager>();
	}

	public override void Confirm(Control confirmedControl)
	{
		InventoryItem item = SlotPanel.GetItem();
		if (merchantPadPanel.IsVisible && item != null && item.CurrentInventory == null && InventoryListPanel.SelectedGuiItem == null)
		{
			return;
		}
		bool flag = false;
		if (InventoryListPanel.SelectedGuiItem != null && InventoryListPanel.SelectedGuiItem.GetItem() != null)
		{
			base.Confirm(confirmedControl);
			flag = true;
		}
		else if (item != null)
		{
			if (item.ItemConfig.CannotBeUnequipped)
			{
				return;
			}
			InventoryListPanel.SelectItemStatic(SlotPanel);
			if (heroesEquipmentPadPanel.IsVisible)
			{
				heroesEquipmentPadPanel.OnItemConfirmed(SlotPanel);
				flag = true;
			}
			else if (merchantPadPanel.IsVisible)
			{
				merchantPadPanel.OnItemConfirmed(SlotPanel);
				flag = true;
			}
		}
		if (flag && selectable.IsRegistered)
		{
			selectableManager.Select(selectable);
		}
	}

	public override bool CanHoldItem(InventoryItem item)
	{
		if (SlotPanel.Slot != null && (SlotPanel.Slot.EquippedItem == null || SlotPanel.Slot.EquippedItem != item))
		{
			return SlotPanel.Slot.CanHoldItem(item);
		}
		return false;
	}

	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent);
		if (heroesEquipmentPadPanel.IsVisible)
		{
			heroesEquipmentPadPanel.OnItemSelected(SlotPanel.Slot.EquippedItem, SlotPanel.Slot.ParentHero);
		}
		else if (merchantPadPanel.IsVisible)
		{
			merchantPadPanel.OnItemSelected(SlotPanel.Slot.EquippedItem, SlotPanel.Slot.ParentHero);
		}
	}

	public override void OnUnselect()
	{
		base.OnUnselect();
		if (heroesEquipmentPadPanel.IsVisible)
		{
			heroesEquipmentPadPanel.OnItemSelected(null);
		}
		else if (merchantPadPanel.IsVisible)
		{
			merchantPadPanel.OnItemSelected(null);
		}
	}
}
public abstract class GameSelectable : Selectable
{
	[SerializeField]
	protected SpriteAnimationRuntime2 markerAnim;

	public override void SetDisplay(bool display)
	{
		base.SetDisplay(display);
		if (display)
		{
			markerAnim.Play();
		}
		else if (!isBeingDestroyed)
		{
			StartCoroutine(HideCoroutine());
		}
	}

	private IEnumerator HideCoroutine()
	{
		markerAnim.Animator.Play("Unselected");
		yield return null;
		markerAnim.Stop();
	}

	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent);
		markerAnim.SetBool(SpriteAnimationBool.IsSelected, value: true);
	}

	public override void OnUnselect()
	{
		base.OnUnselect();
		markerAnim.SetBool(SpriteAnimationBool.IsSelected, value: false);
	}

	public override void Confirm(Control confirmedControl)
	{
		base.Confirm(confirmedControl);
		markerAnim.Trigger(SpriteAnimationTrigger.OnConfirm);
	}

	public override Vector2 Get2DPosition()
	{
		Vector3 position = base.transform.position;
		float x = 0f - position.x;
		Vector3 position2 = base.transform.position;
		return new Vector2(x, 0f - position2.z);
	}
}
public class HeroItemSelectable : AGESelectable
{
	public bool IsShipLocked
	{
		get;
		set;
	}

	public override void Confirm(Control confirmedControl)
	{
		if (!IsShipLocked)
		{
			base.Confirm(confirmedControl);
		}
	}
}
public class HeroSelectable : GameSelectable
{
	private Hero hero;

	protected virtual void Awake()
	{
		hero = GetComponent<Hero>();
	}

	public override void Confirm(Control confirmedControl)
	{
		base.Confirm(confirmedControl);
		foreach (Hero selectedHero in Hero.SelectedHeroes)
		{
			selectedHero.MoveToHero(hero);
		}
	}
}
public class HeroSlotSelectable : AGESelectable
{
	[SerializeField]
	private CompetitorSlot competitorSlot;
}
public class InventoryItemSelectable : AGERowSelectable
{
	private InventoryPanel sharedInventoryPanel;

	private InventoryPanel backpackInventoryPanel;

	private SelectableManager selectableManager;

	private TabHeroesEquipmentPanel heroesEquipmentPadPanel;

	private MerchantPadPanel merchantPadPanel;

	private AGESelectable _parentAGESelectable;

	public InventoryGuiItem InventoryGuiItem
	{
		get;
		private set;
	}

	protected override void Awake()
	{
		base.Awake();
		InventoryGuiItem = GetComponent<InventoryGuiItem>();
		sharedInventoryPanel = SingletonManager.Get<InventoryPanel>();
		backpackInventoryPanel = sharedInventoryPanel.SubInventoryPanel;
		selectableManager = SingletonManager.Get<SelectableManager>();
		heroesEquipmentPadPanel = SingletonManager.Get<TabHeroesEquipmentPanel>(mandatory: false);
		merchantPadPanel = (SingletonManager.Get<MainGameScreen>().MerchantPanel as MerchantPadPanel);
	}

	public override void Confirm(Control confirmedControl)
	{
		if (InventoryGuiItem != null && InventoryGuiItem.CurrentItem != null)
		{
			InventoryGuiItem.SelectItem();
			if (heroesEquipmentPadPanel.IsVisible)
			{
				heroesEquipmentPadPanel.OnItemConfirmed(InventoryGuiItem);
			}
			else if (merchantPadPanel.IsVisible)
			{
				merchantPadPanel.OnItemConfirmed(InventoryGuiItem);
			}
		}
	}

	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent);
		if (InventoryGuiItem != null && InventoryGuiItem.CurrentItem != null)
		{
			if (heroesEquipmentPadPanel.IsVisible)
			{
				heroesEquipmentPadPanel.OnItemSelected(InventoryGuiItem.CurrentItem);
			}
			else if (merchantPadPanel.IsVisible)
			{
				merchantPadPanel.OnItemSelected(InventoryGuiItem.CurrentItem);
			}
		}
	}

	public override void OnUnselect()
	{
		base.OnUnselect();
		if (heroesEquipmentPadPanel.IsVisible)
		{
			heroesEquipmentPadPanel.OnItemSelected(null);
		}
		else if (merchantPadPanel.IsVisible)
		{
			merchantPadPanel.OnItemSelected(null);
		}
	}

	public override void SetDisplay(bool display)
	{
		base.SetDisplay(display);
		if (!display && selectableManager.GetCurrentCategorySelectedElement() == this)
		{
			HideInputText();
		}
	}

	private void HideInputText()
	{
		backpackInventoryPanel.XboxInputText.Visible = false;
		sharedInventoryPanel.XboxInputText.Visible = false;
	}
}
public class InventorySelectable : ItemHolderSelectable
{
	[SerializeField]
	private InventoryPanel inventoryPanel;

	private GameNetworkManager gameNetworkManager;

	public Inventory[] Inventories => inventoryPanel.Inventories;

	protected override void Awake()
	{
		base.Awake();
		gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
	}

	public override bool CanHoldItem(InventoryItem item)
	{
		ulong localPlayerID = gameNetworkManager.GetLocalPlayerID();
		for (int i = 0; i < inventoryPanel.Inventories.Length; i++)
		{
			if (inventoryPanel.Inventories[i].IsAvailableForPlayer(localPlayerID) && !inventoryPanel.Inventories[i].Items.Contains(item))
			{
				return true;
			}
		}
		return false;
	}
}
public abstract class ItemHolderSelectable : AGESelectable
{
	[SerializeField]
	private AgeTransform highlight;

	public abstract bool CanHoldItem(InventoryItem item);

	public void SetHighlight(bool show)
	{
		if (highlight != null)
		{
			highlight.Visible = show;
		}
	}

	public override void Unregister()
	{
		base.Unregister();
		SetHighlight(show: false);
	}
}
public class MerchantBuyInventorySelectable : AGESelectable
{
	[SerializeField]
	private MerchantPanel merchantPanel;

	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent);
		merchantPanel.OnSwitchBuyButtonClick();
	}
}
public class MerchantSelectable : GameSelectable
{
	private NPCMerchant merchant;

	protected virtual void Awake()
	{
		merchant = GetComponent<NPCMerchant>();
	}

	public override void Confirm(Control confirmedControl)
	{
		base.Confirm(confirmedControl);
		foreach (Hero selectedHero in Hero.SelectedHeroes)
		{
			selectedHero.MoveToNPC(merchant);
		}
	}
}
public class MerchantSellInventorySelectable : AGESelectable
{
	[SerializeField]
	private MerchantPanel merchantPanel;

	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent);
		merchantPanel.OnSwitchSellButtonClick();
	}
}
public class ModuleSelectable : GameSelectable
{
	private Module module;

	protected virtual void Awake()
	{
		module = GetComponent<Module>();
	}

	public override void Confirm(Control confirmedControl)
	{
		base.Confirm(confirmedControl);
		MajorModule component = GetComponent<MajorModule>();
		if (!module.IsBuilding && (component == null || !component.IsCrystal) && !module.Config.Unremovable && module.HealthCpnt.IsAlive())
		{
			module.DoRemove(checkOwnership: false);
			SingletonManager.Get<ConstructionModeDestructionPane>().DestructionIcon.StartAllModifiers();
		}
	}
}
public class PassiveSkillSelectable : AGESelectable
{
	[SerializeField]
	private string CallbackName;

	private HeroStatsPanel heroStatsPanel;

	public override void OnSelect(bool silent = false)
	{
		if (heroStatsPanel == null)
		{
			heroStatsPanel = SingletonManager.Get<HeroStatsPanel>();
		}
		heroStatsPanel.Invoke(CallbackName, 0f);
	}
}
public class RoomForBuildSelectable : RoomSelectable
{
	private RoomForMoveSelectable moveSelectable;

	protected override void Awake()
	{
		base.Awake();
		moveSelectable = GetComponent<RoomForMoveSelectable>();
	}

	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent);
		if (!moveSelectable.IsSelected)
		{
			moveSelectable.Select();
		}
	}

	public override void Confirm(Control confirmedControl)
	{
		base.Confirm(confirmedControl);
		ulong localPlayerID = SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID();
		base.Room.BuildModule(Services.GetService<IGameControlService>().ConstructionBPName, localPlayerID, instantBuild: false, restoration: false, checkRoomPower: true, consumeIndustry: true, -1f);
	}
}
public class RoomForMoveSelectable : RoomSelectable
{
	private RoomForBuildSelectable buildSelectable;

	protected override void Awake()
	{
		base.Awake();
		buildSelectable = GetComponent<RoomForBuildSelectable>();
	}

	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent);
		if (!buildSelectable.IsSelected)
		{
			buildSelectable.Select();
		}
	}

	public override void Confirm(Control confirmedControl)
	{
		base.Confirm(confirmedControl);
		foreach (Hero selectedHero in Hero.SelectedHeroes)
		{
			selectedHero.MoveToRoom(base.Room);
		}
	}
}
public abstract class RoomSelectable : GameSelectable
{
	[SerializeField]
	private GameObject markerBottomLeft;

	[SerializeField]
	private GameObject markerBottomRight;

	[SerializeField]
	private GameObject markerUpLeft;

	[SerializeField]
	private GameObject markerUpRight;

	private IGameEventService gameEventManager;

	private IGameCameraService gameCameraManager;

	private IInputService inputManager;

	public Room Room
	{
		get;
		private set;
	}

	protected virtual void Awake()
	{
		Room = GetComponent<Room>();
		gameEventManager = Services.GetService<IGameEventService>();
		gameCameraManager = Services.GetService<IGameCameraService>();
		inputManager = Services.GetService<IInputService>();
	}

	public void SetSize(Vector3 size)
	{
		SetSize(size.x, size.z);
	}

	public void SetSize(Vector2 size)
	{
		SetSize(size.x, size.y);
	}

	public void SetSize(float width, float height)
	{
		Transform transform = markerBottomLeft.transform;
		float x = width / 2f;
		Vector3 localPosition = markerBottomLeft.transform.localPosition;
		transform.localPosition = new Vector3(x, localPosition.y, height / 2f);
		Transform transform2 = markerBottomRight.transform;
		float x2 = (0f - width) / 2f;
		Vector3 localPosition2 = markerBottomRight.transform.localPosition;
		transform2.localPosition = new Vector3(x2, localPosition2.y, height / 2f);
		Transform transform3 = markerUpLeft.transform;
		float x3 = width / 2f;
		Vector3 localPosition3 = markerUpLeft.transform.localPosition;
		transform3.localPosition = new Vector3(x3, localPosition3.y, (0f - height) / 2f);
		Transform transform4 = markerUpRight.transform;
		float x4 = (0f - width) / 2f;
		Vector3 localPosition4 = markerUpRight.transform.localPosition;
		transform4.localPosition = new Vector3(x4, localPosition4.y, (0f - height) / 2f);
	}

	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent);
		gameEventManager.TriggerRoomSelectionEvent(Room);
		if (!silent)
		{
			gameCameraManager.Focus(Room.CenterPosition, LerpType.Linear, -1f);
		}
	}

	private void Update()
	{
		if (!base.IsSelected)
		{
			return;
		}
		SelectionCategoryData currentCategory = GetManager().CurrentCategory;
		if (currentCategory.Category == category && inputManager.GetControlDown(Control.RoomPowerToggle))
		{
			bool isPowered = Room.IsPowered;
			Room.TogglePower();
			if (Room.IsPowered != isPowered)
			{
				SingletonManager.Get<MainGameScreen>().XboxRoomPowerIcon.StartAllModifiers();
			}
		}
	}
}
public abstract class Selectable : MonoBehaviour
{
	public delegate void SelectedHandler();

	public delegate void UnselectedHandler();

	[SerializeField]
	protected SelectionCategory category;

	[SerializeField]
	protected int subCategoryID = -1;

	[SerializeField]
	protected bool autoRegister;

	[SerializeField]
	protected bool debug;

	protected SelectableManager _manager;

	protected SelectionCategoryConfig categoryConfig;

	protected bool isBeingDestroyed;

	public bool KeepDisplayOnStart
	{
		get;
		set;
	}

	public bool IsRegistered
	{
		get;
		protected set;
	}

	public bool IsDisplayed
	{
		get;
		protected set;
	}

	public bool IsSelected
	{
		get;
		protected set;
	}

	public SelectionCategory Category => category;

	public int SubCategoryID => subCategoryID;

	public event SelectedHandler OnSelected;

	public event UnselectedHandler OnUnselected;

	protected virtual IEnumerator Start()
	{
		IInputService inputManager = null;
		while (inputManager == null)
		{
			inputManager = Services.GetService<IInputService>();
			yield return null;
		}
		if (inputManager.CurrentControlScheme != ControlScheme.XBoxOneController)
		{
			base.enabled = false;
			yield break;
		}
		categoryConfig = GetManager().GetCategoryConfig(category);
		if (!debug && GetManager().Debug)
		{
			debug = true;
		}
		if (!KeepDisplayOnStart)
		{
			SetDisplay(display: false);
		}
		if (autoRegister)
		{
			Register();
		}
	}

	protected SelectableManager GetManager()
	{
		if (_manager == null)
		{
			_manager = SingletonManager.Get<SelectableManager>();
		}
		return _manager;
	}

	public virtual void Register()
	{
		if (base.enabled && !IsRegistered)
		{
			GetManager().RegisterSelectable(this);
			IsRegistered = true;
		}
	}

	public void Register(SelectionCategory category, int subCategoryID = -1)
	{
		this.category = category;
		this.subCategoryID = subCategoryID;
		Register();
	}

	public virtual void Unregister()
	{
		if (base.enabled && IsRegistered)
		{
			GetManager().UnregisterSelectable(this);
			IsRegistered = false;
		}
	}

	public void Select(bool silent = false)
	{
		if (base.enabled)
		{
			GetManager().Select(this, silent);
		}
	}

	public virtual void OnSelect(bool silent = false)
	{
		if (debug)
		{
			Diagnostics.LogWarning("[Selectable] {0} > OnSelect", base.name);
		}
		IsSelected = true;
		if (this.OnSelected != null)
		{
			this.OnSelected();
		}
	}

	public virtual void OnUnselect()
	{
		if (debug)
		{
			Diagnostics.Log("[Selectable] {0} > Unselect", base.name);
		}
		IsSelected = false;
		if (this.OnUnselected != null)
		{
			this.OnUnselected();
		}
	}

	public virtual void SetDisplay(bool display)
	{
		if (debug)
		{
		}
		IsDisplayed = display;
		KeepDisplayOnStart = false;
	}

	public virtual void Confirm(Control confirmedControl)
	{
		if (base.enabled && debug)
		{
			Diagnostics.LogWarning("[Selectable] {0} > Confirm", base.name);
		}
	}

	public abstract Vector2 Get2DPosition();

	private void OnDestroy()
	{
		isBeingDestroyed = true;
		if (IsRegistered)
		{
			Unregister();
		}
	}
}
[Serializable]
public struct SelectionCategoryConfig
{
	public SelectionCategory Category;

	public SelectionMode Mode;

	[FormerlySerializedAs("Heuristic")]
	public DefaultSelectionHeuristic DefaultSelectionHeuristic;

	public bool AllowSelectionLoop;

	public bool AllowDiagonals;

	public float MaxPositionDelta;

	public float MaxPosDeltaToInputDirAngle;

	public Vector2 InputDirectionModifier;

	public bool ForceAgeCursorPosition;

	public bool EnableGameMenuOrCloseTopMenuControl;

	public bool EnableNonContextualControl;

	public InputAxis RadialModeXAxis;

	public InputAxis RadialModeYAxis;

	public float AutoConfirmTimeout;

	public Control[] ConfirmControls;

	public bool ResetPreviousSelected;
}
public class SelectableManager : MonoBehaviour
{
	[SerializeField]
	private SelectionCategoryConfig defaultCategoryConfig;

	[SerializeField]
	private SelectionCategoryConfig[] categoryConfigs;

	private Dictionary<SelectionCategory, SelectionCategoryConfig> categoryConfigsByCategory;

	private IGameControlService gameControlManager;

	private IGameCameraService gameCameraService;

	private GameNetworkManager gameNetworkManager;

	private bool skipNextUpdate;

	private float selectionTime;

	private bool autoConfirmTimerEngaged;

	private HeroPanel heroStatsPanel;

	private SelectionCategoryConfig _currentCategoryConfig;

	private RoomSelectable _selectedRoom;

	private Selectable _selected;

	private Selectable _previousSelected;

	private Selectable _selectable;

	private List<Selectable> _selectables;

	private Selectable _bestSelectable;

	private readonly int defaultCategoryLevel;

	private readonly int categoryLevelCount = 6;

	private readonly SelectionCategoryData emptyCategoryData = new SelectionCategoryData(SelectionCategory.None, -1);

	private readonly Dictionary<SelectionCategory, int> categoryLevels = new Dictionary<SelectionCategory, int>
	{
		{
			SelectionCategory.TopPanel,
			1
		},
		{
			SelectionCategory.SessionListPanel,
			1
		},
		{
			SelectionCategory.GameSelectionPanel,
			1
		},
		{
			SelectionCategory.EndLevelPanel,
			1
		},
		{
			SelectionCategory.VictoryPanel,
			1
		},
		{
			SelectionCategory.GameOverPanel,
			1
		},
		{
			SelectionCategory.Journal,
			1
		},
		{
			SelectionCategory.Credits,
			1
		},
		{
			SelectionCategory.Options,
			1
		},
		{
			SelectionCategory.MPSaveListPanel,
			2
		},
		{
			SelectionCategory.Album,
			4
		},
		{
			SelectionCategory.RequesterPanel,
			5
		}
	};

	[SerializeField]
	private bool debug;

	private Dictionary<StaticString, List<Selectable>> selectablesByCategoryName = new Dictionary<StaticString, List<Selectable>>();

	private Dictionary<StaticString, Selectable> selectedByCategoryName = new Dictionary<StaticString, Selectable>();

	private string currentCategoryName;

	private IInputService inputManager;

	private AgeManager ageManager;

	private Dungeon dungeon;

	private ConstructionPanel constructionPanel;

	private ConstructibleModuleCategorySelectable constructibleModuleCategorySelectable;

	private Dictionary<SelectionCategory, Dictionary<int, string>> cachedCategoryName = new Dictionary<SelectionCategory, Dictionary<int, string>>();

	public RoomSelectable SelectedRoom => _selectedRoom;

	public bool IsActive
	{
		get;
		private set;
	}

	public SelectionCategoryData CurrentCategory
	{
		get;
		private set;
	}

	public ConstructionPanel ConstructionPanel
	{
		get
		{
			Diagnostics.Assert(inputManager.CurrentControlScheme == ControlScheme.MouseAndKeyboard);
			if (constructionPanel == null)
			{
				constructionPanel = SingletonManager.Get<ConstructionPanel>();
			}
			return constructionPanel;
		}
		private set
		{
			constructionPanel = value;
		}
	}

	public SelectionCategoryData[] CategoryPipe
	{
		get;
		private set;
	}

	public Dictionary<StaticString, List<Selectable>> SelectablesByCategoryName => selectablesByCategoryName;

	public bool Debug => debug;

	public event SelectionCategoryChangedHandler OnSelectionCategoryChanged;

	public SelectionCategoryConfig GetCurrentCategoryConfig()
	{
		SelectionCategoryData currentCategory = CurrentCategory;
		return GetCategoryConfig(currentCategory.Category);
	}

	public SelectionCategoryConfig GetCategoryConfig(SelectionCategory category)
	{
		if (categoryConfigsByCategory == null)
		{
			categoryConfigsByCategory = new Dictionary<SelectionCategory, SelectionCategoryConfig>();
			for (int i = 0; i < categoryConfigs.Length; i++)
			{
				categoryConfigsByCategory.Add(categoryConfigs[i].Category, categoryConfigs[i]);
			}
		}
		if (!categoryConfigsByCategory.ContainsKey(category))
		{
			return defaultCategoryConfig;
		}
		return categoryConfigsByCategory[category];
	}

	private void Update()
	{
		if (!Amplitude.Unity.Framework.Application.HasFocus || string.IsNullOrEmpty(currentCategoryName))
		{
			return;
		}
		if (skipNextUpdate)
		{
			skipNextUpdate = false;
			return;
		}
		if (inputManager == null)
		{
			inputManager = Services.GetService<IInputService>();
		}
		if (gameControlManager == null)
		{
			gameControlManager = Services.GetService<IGameControlService>();
		}
		if (gameCameraService.IsTacticalMapActive())
		{
			return;
		}
		_currentCategoryConfig = GetCurrentCategoryConfig();
		ConstructionControlPanel constructionControlPanel = SingletonManager.Get<ConstructionControlPanel>();
		HeroesPadPanel heroesPadPanel = SingletonManager.Get<HeroPanel>() as HeroesPadPanel;
		SelectionCategoryData currentCategory = CurrentCategory;
		switch (currentCategory.Category)
		{
		case SelectionCategory.RoomForMove:
			_selectedRoom = (GetCategorySelectedElement(SelectionCategory.RoomForMove) as RoomSelectable);
			if (_selectedRoom != null && inputManager.GetControl(Control.ModuleSelectionHold))
			{
				SetCategory(SelectionCategory.Module, _selectedRoom.Room.UniqueID.ID);
			}
			else if (inputManager.GetControlDown(Control.BuildMenuToggle))
			{
				if (!constructionControlPanel.ConstructionModeSelectionPane.IsShowing && !constructionControlPanel.ConstructionModeSelectionPane.IsHiding)
				{
					SetCategory(SelectionCategory.BuildMenu);
					gameControlManager.MultipleModuleConstructionsMode = true;
				}
			}
			else if (inputManager.GetControlDown(Control.HeroStatsToggleXB1))
			{
				if (heroesPadPanel != null && !heroesPadPanel.IsShowing && !heroesPadPanel.IsHiding && !constructionControlPanel.ConstructionModeInitialPane.IsShowing && !constructionControlPanel.ConstructionModeInitialPane.IsHiding)
				{
					DisplayHeroesStats(on: true);
				}
			}
			else
			{
				if (!(_selectedRoom != null) || !inputManager.GetControlDown(Control.RoomInteraction))
				{
					break;
				}
				if (Hero.SelectedHeroes.Count == 0 && gameNetworkManager.IsMultiplayerSession())
				{
					_selectedRoom.Room.InteractWithRoomInteractible();
					break;
				}
				for (int i = 0; i < Hero.SelectedHeroes.Count; i++)
				{
					Hero hero = Hero.SelectedHeroes[i];
					hero.MoveToRoomInteractibleElement(_selectedRoom.Room);
				}
			}
			break;
		case SelectionCategory.Module:
			if (!constructionControlPanel.ConstructionModeDestructionPane.IsShowing && !constructionControlPanel.ConstructionModeDestructionPane.IsHiding && inputManager.GetControlDown(Control.HeroStatsToggleXB1) && heroesPadPanel != null && !heroesPadPanel.IsShowing && !heroesPadPanel.IsHiding)
			{
				DisplayHeroesStats(on: true);
			}
			break;
		case SelectionCategory.BuildMenu:
			if (!constructionControlPanel.ConstructionModeSelectionPane.IsShowing && !constructionControlPanel.ConstructionModeSelectionPane.IsHiding && inputManager.GetControlDown(Control.HeroStatsToggleXB1) && heroesPadPanel != null && !heroesPadPanel.IsShowing && !heroesPadPanel.IsHiding)
			{
				DisplayHeroesStats(on: true);
			}
			break;
		case SelectionCategory.RoomForBuild:
			if (!constructionControlPanel.ConstructionModePlacementPane.IsShowing && !constructionControlPanel.ConstructionModePlacementPane.IsHiding && inputManager.GetControlDown(Control.HeroStatsToggleXB1) && heroesPadPanel != null && !heroesPadPanel.IsShowing && !heroesPadPanel.IsHiding)
			{
				DisplayHeroesStats(on: true);
			}
			break;
		case SelectionCategory.HeroStatsPanel_Merchant:
			if (inputManager.GetControlDown(Control.EscapeBehavior))
			{
				SingletonManager.Get<MainGameScreen>().MerchantPanel.OnEscapeBehavior();
			}
			else if (inputManager.GetControlDown(Control.HeroStatsToggleXB1))
			{
				SingletonManager.Get<MainGameScreen>().MerchantPanel.Hide();
				if (heroesPadPanel != null)
				{
					heroesPadPanel.CurrentTabIndex = 1;
				}
				if (heroesPadPanel != null && !heroesPadPanel.IsShowing && !heroesPadPanel.IsHiding)
				{
					DisplayHeroesStats(on: true);
				}
			}
			break;
		case SelectionCategory.HeroStatsPanel_Attributes:
		case SelectionCategory.HeroStatsPanel_Equipment:
		case SelectionCategory.HeroStatsPanel_Skills:
		case SelectionCategory.HeroStatsPanel_Inventory:
		case SelectionCategory.HeroStatsPanel_BackPack:
		case SelectionCategory.HeroStatsPanel_Biography:
		case SelectionCategory.PlayerList:
		case SelectionCategory.SystemMenu:
			if (heroesPadPanel != null && !heroesPadPanel.IsShowing && !heroesPadPanel.IsHiding)
			{
				if (inputManager.GetControlDown(Control.EscapeBehavior))
				{
					heroesPadPanel.OnEscapeBehavior();
				}
				else if (inputManager.GetControlDown(Control.HeroStatsToggleXB1) && !heroesPadPanel.IsShowing && !heroesPadPanel.IsHiding && !constructionControlPanel.ConstructionModeInitialPane.IsShowing && !constructionControlPanel.ConstructionModeInitialPane.IsHiding)
				{
					heroesPadPanel.Hide();
					SetCategory(SelectionCategory.RoomForMove);
				}
			}
			break;
		}
		_currentCategoryConfig = GetCurrentCategoryConfig();
		_selected = GetCurrentCategorySelectedElement();
		_selectables = selectablesByCategoryName[currentCategoryName];
		Vector2 b = new Vector2((float)Screen.width / 2f, (float)Screen.height / 2f);
		switch (_currentCategoryConfig.Mode)
		{
		case SelectionMode.StepByStep:
		{
			if (_selected == null && _currentCategoryConfig.DefaultSelectionHeuristic != DefaultSelectionHeuristic.None)
			{
				if (_selectables.Count <= 0)
				{
					break;
				}
				Vector2 vector3 = Vector2.zero;
				for (int l = 0; l < _selectables.Count; l++)
				{
					_selectable = _selectables[l];
					if (!(_selectable == null))
					{
						Vector2 vector4 = _selectable.Get2DPosition();
						bool flag = false;
						switch (_currentCategoryConfig.DefaultSelectionHeuristic)
						{
						case DefaultSelectionHeuristic.TopLeft:
							flag = (vector4.y > vector3.y || (vector4.y == vector3.y && vector4.x < vector3.x));
							break;
						case DefaultSelectionHeuristic.LeftTop:
							flag = (vector4.x < vector3.x || (vector4.x == vector3.x && vector4.y > vector3.y));
							break;
						}
						if (_selected == null || flag)
						{
							_selected = _selectable;
							vector3 = vector4;
						}
					}
				}
				if (!(_selected != null))
				{
					break;
				}
				_selected.Select();
			}
			Vector2 vector = (inputManager.GetControlDown(Control.NextSelectableLeft) ? (-1) : (inputManager.GetControlDown(Control.NextSelectableRight) ? 1 : 0)) * Vector2.right + (inputManager.GetControlDown(Control.NextSelectableDown) ? (-1) : (inputManager.GetControlDown(Control.NextSelectableUp) ? 1 : 0)) * Vector2.up;
			if (_currentCategoryConfig.InputDirectionModifier != Vector2.zero)
			{
				vector = new Vector2(vector.x * _currentCategoryConfig.InputDirectionModifier.x, vector.y * _currentCategoryConfig.InputDirectionModifier.y);
			}
			if (vector.sqrMagnitude == 0f)
			{
				break;
			}
			float num = float.NegativeInfinity;
			_bestSelectable = null;
			for (int m = 0; m < _selectables.Count; m++)
			{
				_selectable = _selectables[m];
				if (!(_selectable == null) && !(_selectable == _selected))
				{
					float num2 = GetSelectableWeight(_selectable, _selected, vector, _currentCategoryConfig);
					if (num2 > num)
					{
						_bestSelectable = _selectable;
						num = num2;
					}
				}
			}
			if (_bestSelectable == null && _currentCategoryConfig.AllowSelectionLoop)
			{
				num = float.NegativeInfinity;
				for (int n = 0; n < _selectables.Count; n++)
				{
					_selectable = _selectables[n];
					if (!(_selectable == null) && !(_selectable == _selected))
					{
						float num2 = GetSelectableInverseWeight(_selectable, _selected, vector, _currentCategoryConfig);
						if (num2 > num)
						{
							_bestSelectable = _selectable;
							num = num2;
						}
					}
				}
			}
			if (_bestSelectable != null)
			{
				Select(_bestSelectable);
				_selected = _bestSelectable;
			}
			break;
		}
		case SelectionMode.Radial:
		{
			Vector2 vector = inputManager.GetAxisValue(_currentCategoryConfig.RadialModeXAxis) * Vector2.right + inputManager.GetAxisValue(_currentCategoryConfig.RadialModeYAxis) * Vector2.up;
			if ((_selected == null || vector.sqrMagnitude == 0f) && _currentCategoryConfig.DefaultSelectionHeuristic != DefaultSelectionHeuristic.None)
			{
				if (_selectables.Count <= 0)
				{
					break;
				}
				Vector2 a = (!(_selected == null)) ? _selected.Get2DPosition() : Vector2.zero;
				for (int j = 0; j < _selectables.Count; j++)
				{
					_selectable = _selectables[j];
					if (!(_selectable == null))
					{
						Vector2 vector2 = _selectable.Get2DPosition();
						if (_selected == null || (vector2 - b).sqrMagnitude < (a - b).sqrMagnitude)
						{
							_selected = _selectable;
							a = vector2;
						}
					}
				}
				if (!(_selected != null))
				{
					break;
				}
				if (!_selected.IsSelected)
				{
					_selected.Select();
				}
			}
			if (vector.sqrMagnitude == 0f)
			{
				if (_currentCategoryConfig.DefaultSelectionHeuristic == DefaultSelectionHeuristic.None)
				{
					if (_selected != null)
					{
						_selected.OnUnselect();
					}
					_selected = null;
				}
				break;
			}
			float num = float.NegativeInfinity;
			_bestSelectable = null;
			for (int k = 0; k < _selectables.Count; k++)
			{
				_selectable = _selectables[k];
				if (!(_selectable == null))
				{
					float num2 = Vector2.Dot(((!(_selected != null)) ? (_selectable.Get2DPosition() - b) : (_selectable.Get2DPosition() - _selected.Get2DPosition())).normalized, vector.normalized);
					if (num2 > num)
					{
						_bestSelectable = _selectable;
						num = num2;
					}
				}
			}
			if (_bestSelectable != null && !_bestSelectable.IsSelected)
			{
				Select(_bestSelectable);
				_selected = _bestSelectable;
			}
			break;
		}
		case SelectionMode.Scroll:
		{
			if (_selected == null && _selectables.Count > 0)
			{
				_selected = _selectables[0];
				_selected.Select(silent: true);
			}
			AGEScrollViewSelectable aGEScrollViewSelectable = _selected as AGEScrollViewSelectable;
			if (aGEScrollViewSelectable != null)
			{
				float axisValue = inputManager.GetAxisValue(_currentCategoryConfig.RadialModeYAxis);
				if ((axisValue * Vector2.up).sqrMagnitude != 0f)
				{
					aGEScrollViewSelectable.Scroll(Math.Sign(axisValue));
				}
			}
			break;
		}
		}
		if (_selected != null && _selected != _previousSelected)
		{
			selectionTime = Time.time;
			autoConfirmTimerEngaged = true;
		}
		_previousSelected = _selected;
		if (!(_selected != null))
		{
			return;
		}
		Control control = Control.None;
		if (_currentCategoryConfig.AutoConfirmTimeout > 0f && autoConfirmTimerEngaged && Time.time - selectionTime >= _currentCategoryConfig.AutoConfirmTimeout)
		{
			control = Control.Auto;
		}
		else
		{
			for (int num3 = 0; num3 < _currentCategoryConfig.ConfirmControls.Length; num3++)
			{
				if (inputManager.GetControlDown(_currentCategoryConfig.ConfirmControls[num3]))
				{
					control = _currentCategoryConfig.ConfirmControls[num3];
					break;
				}
			}
		}
		if (control != Control.None)
		{
			_selected.Confirm(control);
			autoConfirmTimerEngaged = false;
		}
	}

	private void DisplayHeroesStats(bool on)
	{
		if (heroStatsPanel == null)
		{
			heroStatsPanel = SingletonManager.Get<HeroPanel>();
		}
		if (heroStatsPanel.IsShowing || heroStatsPanel.IsHiding)
		{
			return;
		}
		if (on && gameControlManager.CanPauseGame())
		{
			if (Time.timeScale != 0f)
			{
				if (heroStatsPanel == null)
				{
					heroStatsPanel = SingletonManager.Get<HeroPanel>();
				}
				heroStatsPanel.UnpauseOnHide = true;
			}
			gameControlManager.SetGamePause(paused: true, ignoreCheck: true);
		}
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		if (on)
		{
			if (dungeon != null && !dungeon.IsLevelOver)
			{
				gameControlManager.SetHeroStatsPanelDisplay(on: true);
			}
		}
		else
		{
			gameControlManager.SetHeroStatsPanelDisplay(on: false);
		}
	}

	private float GetSelectableWeight(Selectable selectable, Selectable selected, Vector2 inputDir, SelectionCategoryConfig selectConfig)
	{
		if (!selectConfig.AllowDiagonals)
		{
			inputDir = inputDir.RemoveDiagonals();
		}
		Vector2 from = selectable.Get2DPosition() - selected.Get2DPosition();
		if (selectConfig.MaxPositionDelta > 0f && from.sqrMagnitude > selectConfig.MaxPositionDelta * selectConfig.MaxPositionDelta)
		{
			return float.NegativeInfinity;
		}
		float num = Vector2.Angle(from, inputDir);
		if (num <= selectConfig.MaxPosDeltaToInputDirAngle)
		{
			float num2 = Vector2.Dot(from.normalized, inputDir);
			if (selectConfig.AllowDiagonals)
			{
				return num2 * num2 * num2 / from.sqrMagnitude;
			}
			float num3 = num2 * from.sqrMagnitude;
			if (num3 != 0f)
			{
				return 1f / num3;
			}
			return float.NegativeInfinity;
		}
		return float.NegativeInfinity;
	}

	private float GetSelectableInverseWeight(Selectable selectable, Selectable selected, Vector2 inputDir, SelectionCategoryConfig selectConfig)
	{
		inputDir = -inputDir;
		if (!selectConfig.AllowDiagonals)
		{
			inputDir = inputDir.RemoveDiagonals();
		}
		Vector2 from = selectable.Get2DPosition() - selected.Get2DPosition();
		float num = Vector2.Angle(from, inputDir);
		if (num <= selectConfig.MaxPosDeltaToInputDirAngle)
		{
			float num2 = Vector2.Dot(from.normalized, inputDir);
			if (selectConfig.AllowDiagonals)
			{
				return num2 * num2 * num2 / from.sqrMagnitude;
			}
			float num3 = num2 * num2 * num2 * from.sqrMagnitude;
			if (num3 != 0f)
			{
				return num3;
			}
			return float.NegativeInfinity;
		}
		return float.NegativeInfinity;
	}

	private IEnumerator Start()
	{
		IInputService inputManager = null;
		while (inputManager == null)
		{
			inputManager = Services.GetService<IInputService>();
			yield return null;
		}
		IsActive = (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController);
		if (!IsActive)
		{
			base.enabled = false;
			yield break;
		}
		this.inputManager = Services.GetService<IInputService>();
		gameCameraService = Services.GetService<IGameCameraService>();
		gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
		CurrentCategory = default(SelectionCategoryData);
		CategoryPipe = new SelectionCategoryData[categoryLevelCount];
		for (int level = 0; level < CategoryPipe.Length; level++)
		{
			CategoryPipe[level] = emptyCategoryData;
		}
	}

	private int GetCategoryLevel(SelectionCategory category)
	{
		int value = defaultCategoryLevel;
		categoryLevels.TryGetValue(category, out value);
		return value;
	}

	public Selectable GetCategorySelectedElement(SelectionCategory category, int subCategoryId = -1)
	{
		string categoryName = GetCategoryName(category, subCategoryId);
		return GetCategorySelectedElement(categoryName);
	}

	public Selectable GetCategorySelectedElement(string categoryName)
	{
		AssertCategoryIsSet(categoryName);
		return selectedByCategoryName[categoryName];
	}

	public Selectable GetCurrentCategorySelectedElement()
	{
		if (string.IsNullOrEmpty(currentCategoryName))
		{
			return null;
		}
		return GetCategorySelectedElement(currentCategoryName);
	}

	public List<Selectable> GetSelectablesFromCategory(SelectionCategory category)
	{
		if (selectablesByCategoryName.TryGetValue(category.ToString(), out List<Selectable> value))
		{
			return value;
		}
		return new List<Selectable>();
	}

	public void RegisterSelectable(Selectable selectable)
	{
		if (IsActive)
		{
			string categoryName = GetCategoryName(selectable.Category, selectable.SubCategoryID);
			if (debug)
			{
				Diagnostics.Log("[Selectable] SelectableManager.RegisterSelectable categoryName={0}, selectable={1}", categoryName, selectable);
			}
			AssertCategoryIsSet(categoryName);
			selectablesByCategoryName[categoryName].Add(selectable);
			if (currentCategoryName == categoryName)
			{
				selectable.SetDisplay(display: true);
			}
		}
	}

	public void UnregisterSelectable(Selectable selectable)
	{
		if (!IsActive)
		{
			return;
		}
		string categoryName = GetCategoryName(selectable.Category, selectable.SubCategoryID);
		if (debug)
		{
			Diagnostics.Log("[Selectable] SelectableManager.UnregisterSelectable categoryName={0}, selectable={1}", categoryName, selectable);
		}
		AssertCategoryIsSet(categoryName);
		if (!selectablesByCategoryName[categoryName].Contains(selectable))
		{
			Diagnostics.LogError("[Selectable] SelectableManager.UnregisterSelectable: {1} not registered for {0} category", categoryName, selectable);
			return;
		}
		selectablesByCategoryName[categoryName].Remove(selectable);
		if (selectedByCategoryName[categoryName] == selectable)
		{
			selectedByCategoryName[categoryName] = null;
			selectable.OnUnselect();
		}
		if (currentCategoryName == categoryName)
		{
			selectable.SetDisplay(display: false);
		}
	}

	public void SetCategory(SelectionCategory newCategory, int newSubCategoryId = -1, bool overrideHigherLevelCategory = false)
	{
		if (IsActive)
		{
			SetCategory(new SelectionCategoryData(newCategory, newSubCategoryId), overrideHigherLevelCategory);
		}
	}

	public void SetCategory(SelectionCategoryData newCategoryData, bool overrideHigherLevelCategory = false)
	{
		if (!IsActive)
		{
			return;
		}
		string categoryName = GetCategoryName(newCategoryData);
		if (categoryName == currentCategoryName)
		{
			return;
		}
		SelectionCategoryData currentCategory = CurrentCategory;
		int categoryLevel = GetCategoryLevel(currentCategory.Category);
		int categoryLevel2 = GetCategoryLevel(newCategoryData.Category);
		bool flag = categoryLevel2 >= categoryLevel || overrideHigherLevelCategory;
		if (debug)
		{
			object[] array = new object[5];
			SelectionCategoryData currentCategory2 = CurrentCategory;
			array[0] = currentCategory2.Category;
			array[1] = categoryLevel;
			array[2] = categoryName;
			array[3] = categoryLevel2;
			array[4] = flag;
			Diagnostics.LogWarning("[Selectable] SelectableManager.SetCategory {0}({1}) > {2}({3}) changeCurrentCategory={4}", array);
		}
		if (flag)
		{
			if (!string.IsNullOrEmpty(currentCategoryName))
			{
				for (int i = 0; i < selectablesByCategoryName[currentCategoryName].Count; i++)
				{
					Selectable selectable = selectablesByCategoryName[currentCategoryName][i];
					if (!(selectable == null))
					{
						selectable.SetDisplay(display: false);
					}
				}
			}
			if (categoryLevel2 < categoryLevel)
			{
				CategoryPipe[categoryLevel] = emptyCategoryData;
			}
			CurrentCategory = newCategoryData;
			currentCategoryName = categoryName;
		}
		CategoryPipe[categoryLevel2] = newCategoryData;
		if (!flag)
		{
			return;
		}
		SelectionCategoryConfig currentCategoryConfig = GetCurrentCategoryConfig();
		AssertCategoryIsSet(currentCategoryName);
		for (int j = 0; j < selectablesByCategoryName[currentCategoryName].Count; j++)
		{
			Selectable selectable2 = selectablesByCategoryName[currentCategoryName][j];
			if (!(selectable2 == null))
			{
				if (currentCategoryConfig.ResetPreviousSelected && j == 0)
				{
					Select(selectable2);
				}
				selectable2.SetDisplay(display: true);
			}
		}
		if (ageManager == null)
		{
			ageManager = SingletonManager.Get<AgeManager>();
		}
		if (currentCategoryConfig.ForceAgeCursorPosition)
		{
			AGESelectable aGESelectable = GetCurrentCategorySelectedElement() as AGESelectable;
			if (aGESelectable != null)
			{
				aGESelectable.ForcedCursorPosition();
			}
		}
		if (dungeon == null)
		{
			dungeon = SingletonManager.Get<Dungeon>(mandatory: false);
		}
		if (dungeon != null)
		{
			dungeon.EnableGameMenuOrCloseTopMenuControl = currentCategoryConfig.EnableGameMenuOrCloseTopMenuControl;
		}
		skipNextUpdate = true;
		if (this.OnSelectionCategoryChanged != null)
		{
			this.OnSelectionCategoryChanged(newCategoryData);
		}
	}

	public void UnsetCategory(SelectionCategory category, int subCategoryId = -1)
	{
		if (!IsActive)
		{
			return;
		}
		int categoryLevel = GetCategoryLevel(category);
		SelectionCategoryData selectionCategoryData = CategoryPipe[categoryLevel];
		if (selectionCategoryData.Category != category || selectionCategoryData.SubCategoryID != subCategoryId)
		{
			Diagnostics.LogWarning("[Selectable] Cannot unset {0}#{1} category: {2} level category is now {3}#{4}!", category, subCategoryId, categoryLevel, selectionCategoryData.Category, selectionCategoryData.SubCategoryID);
			return;
		}
		SelectionCategoryData currentCategory = CurrentCategory;
		int categoryLevel2 = GetCategoryLevel(currentCategory.Category);
		bool flag = categoryLevel == categoryLevel2;
		if (debug)
		{
			Diagnostics.LogWarning("[Selectable] SelectableManager.UnsetCategory {0}#{1}({2}) currentCategoryLevel={3} changeCurrentCategory={4}", category, subCategoryId, categoryLevel, categoryLevel2, flag);
		}
		CategoryPipe[categoryLevel] = emptyCategoryData;
		if (flag)
		{
			SelectionCategoryData selectionCategoryData2 = emptyCategoryData;
			int num = categoryLevel2;
			while (num > 0 && selectionCategoryData2 == emptyCategoryData)
			{
				num--;
				selectionCategoryData2 = CategoryPipe[num];
			}
			if (selectionCategoryData2 == emptyCategoryData)
			{
				object[] array = new object[2];
				SelectionCategoryData currentCategory2 = CurrentCategory;
				array[0] = currentCategory2.Category;
				SelectionCategoryData currentCategory3 = CurrentCategory;
				array[1] = currentCategory3.SubCategoryID;
				Diagnostics.LogError("[Selectable] Cannot revert {0}#{1} category: no lower category found!", array);
			}
			else
			{
				SetCategory(selectionCategoryData2, overrideHigherLevelCategory: true);
			}
		}
	}

	public void Select(Selectable selectable, bool silent = false)
	{
		if (!IsActive)
		{
			return;
		}
		if (debug)
		{
			Diagnostics.Log("[Selectable] SelectableManager.Select {0}", selectable.name);
		}
		string categoryName = GetCategoryName(selectable.Category, selectable.SubCategoryID);
		AssertCategoryIsSet(categoryName);
		if (selectedByCategoryName[categoryName] != null)
		{
			if (debug)
			{
				Diagnostics.Log("[Selectable] SelectableManager.Select {0} > Unselect {1}", selectable.name, selectedByCategoryName[categoryName].name);
			}
			selectedByCategoryName[categoryName].OnUnselect();
		}
		selectedByCategoryName[categoryName] = selectable;
		selectable.OnSelect(silent);
	}

	private void AssertCategoryIsSet(string categoryName)
	{
		if (!selectablesByCategoryName.ContainsKey(categoryName))
		{
			selectablesByCategoryName.Add(categoryName, new List<Selectable>());
		}
		if (!selectedByCategoryName.ContainsKey(categoryName))
		{
			selectedByCategoryName.Add(categoryName, null);
		}
	}

	private string GetCategoryName(SelectionCategoryData categoryData)
	{
		return GetCategoryName(categoryData.Category, categoryData.SubCategoryID);
	}

	private string GetCategoryName(SelectionCategory category, int subCategoryId = -1)
	{
		if (!cachedCategoryName.ContainsKey(category))
		{
			cachedCategoryName.Add(category, new Dictionary<int, string>());
		}
		if (!cachedCategoryName[category].ContainsKey(subCategoryId))
		{
			string text = category.ToString();
			if (subCategoryId >= 0)
			{
				text = text + "#" + subCategoryId;
			}
			cachedCategoryName[category].Add(subCategoryId, text);
		}
		return cachedCategoryName[category][subCategoryId];
	}
}
public enum SelectionMode
{
	StepByStep,
	Radial,
	Scroll
}
public enum DefaultSelectionHeuristic
{
	TopLeft,
	LeftTop,
	None
}
public enum SelectionCategory
{
	None = -1,
	RoomForMove = 0,
	BuildMenu = 2,
	Module = 3,
	RoomForBuild = 4,
	HeroStatsPanel = 5,
	HeroStatsPanel_Attributes = 6,
	HeroStatsPanel_Equipment = 7,
	HeroStatsPanel_Skills = 8,
	HeroStatsPanel_Inventory = 9,
	HeroStatsPanel_BackPack = 10,
	HeroStatsPanel_Merchant = 13,
	TopPanel = 11,
	RequesterPanel = 12,
	MainMenu = 14,
	SessionListPanel = 0xF,
	GameSelectionPanel = 0x10,
	MPSaveListPanel = 17,
	Album = 18,
	GameMenu = 19,
	EndLevelPanel = 20,
	VictoryPanel = 21,
	GameOverPanel = 22,
	Journal = 23,
	Credits = 24,
	HeroStatsPanel_Biography = 25,
	PlayerList = 26,
	SystemMenu = 27,
	Options = 28
}
public struct SelectionCategoryData
{
	public SelectionCategory Category;

	public int SubCategoryID;

	public SelectionCategoryData(SelectionCategory category = SelectionCategory.None, int subCategoryID = -1)
	{
		Category = category;
		SubCategoryID = subCategoryID;
	}

	public override bool Equals(object obj)
	{
		return (SelectionCategoryData)obj == this;
	}

	public override int GetHashCode()
	{
		return ((ValueType)this).GetHashCode();
	}

	public static bool operator ==(SelectionCategoryData x, SelectionCategoryData y)
	{
		return x.Category == y.Category && x.SubCategoryID == y.SubCategoryID;
	}

	public static bool operator !=(SelectionCategoryData x, SelectionCategoryData y)
	{
		return !(x == y);
	}
}
public class SpecialMajorModuleSelectable : GameSelectable
{
	private SpecialMajorModule specialMajorModule;

	protected virtual void Awake()
	{
		specialMajorModule = GetComponent<SpecialMajorModule>();
	}

	public override void Confirm(Control confirmedControl)
	{
		base.Confirm(confirmedControl);
		foreach (Hero selectedHero in Hero.SelectedHeroes)
		{
			selectedHero.MoveToSpecialMajorModule(specialMajorModule);
		}
	}
}
public class TransferFIDSSelectable : TransferResourceSelectable
{
	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent);
		tabPlayerListPanel.OnSelectResource(base.LineNumber);
	}

	public override void OnUnselect()
	{
		tabPlayerListPanel.OnUnselectResource(base.LineNumber);
		base.OnUnselect();
	}
}
public class TransferHeroSelectable : TransferResourceSelectable
{
	public override void OnSelect(bool silent = false)
	{
		base.OnSelect(silent);
		tabPlayerListPanel.OnSelectHero(base.LineNumber);
	}

	public override void OnUnselect()
	{
		tabPlayerListPanel.OnUnselectHero(base.LineNumber);
		base.OnUnselect();
	}
}
public class TransferResourceSelectable : AGESelectable
{
	protected TabPlayerListPanel tabPlayerListPanel;

	public int LineNumber
	{
		get;
		set;
	}

	protected override void Awake()
	{
		base.Awake();
		tabPlayerListPanel = SingletonManager.Get<TabPlayerListPanel>();
	}
}
public class XboxPlayerCardSelectable : AGESelectable
{
}
public class XboxGameControlManager : Manager, IXboxGameControlService, IService
{
	private IXboxUserService xboxUserService;

	private IGameControlService gameControlService;

	private INetworkingService networkingService;

	private IPlatformService platformManager;

	private IInputService inputService;

	private ISessionService sessionService;

	private GameLoadingScreen loadingScreen;

	private XboxMainMenuPanel xboxMainMenuPanel;

	private int previousUserId = -1;

	private bool isDuringSignOut;

	private int userIdBeforeSigningProcedure = -1;

	private bool isSignedBeforeSigningProcedure = true;

	private float suspendTime;

	private bool alreadyReadyToSuspend;

	public UserChangePolicy UserChangePolicy
	{
		get;
		set;
	}

	protected override void Awake()
	{
		base.Awake();
		UserChangePolicy = UserChangePolicy.Ignore;
	}

	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		SetLastError(0, "Waiting for service dependencies...");
		yield return BindService(delegate(IXboxUserService service)
		{
			xboxUserService = service;
		});
		yield return BindService(delegate(INetworkingService service)
		{
			networkingService = service;
		});
		yield return BindService(delegate(IGameControlService service)
		{
			gameControlService = service;
		});
		yield return BindService(delegate(IPlatformService service)
		{
			platformManager = service;
		});
		yield return BindService(delegate(ISessionService service)
		{
			sessionService = service;
		});
		yield return BindService(delegate(IInputService service)
		{
			inputService = service;
		});
		UsersManager.OnSignInComplete += UsersManager_OnSignInComplete;
		platformManager.OnUserSignOutStarted += XboxUserService_OnUserSignOutStarted;
		platformManager.OnUserSignInMenuClosed += XboxUserService_OnUserSignInMenuClosed;
		platformManager.OnUserChanged += XboxUserService_OnUserChanged;
		networkingService.ConnectionStateChanged += NetworkingService_ConnectionStateChanged;
		Services.AddService((IXboxGameControlService)this);
	}

	private void NetworkingService_ConnectionStateChanged(object sender, ConnectionStateChangedEventArgs e)
	{
		if (e.OnlineState != XboxOneOnlineState.Online)
		{
			bool isVisible = SingletonManager.Get<SessionListPanel>().IsVisible;
			bool flag = SingletonManager.Get<GameNetworkManager>().IsMultiplayerSession();
			if (isVisible || flag)
			{
				XboxGoBackToMainMenu("%XboxConnectionLost", ignoreSigningProcedure: true, forceMessage: true);
			}
		}
	}

	private void OnGoBackToMainMenuConfirm(RequesterPanel.Result result)
	{
		if (result == RequesterPanel.Result.No)
		{
			if (!isDuringSignOut)
			{
				previousUserId = ((xboxUserService.PreviousUser == null) ? xboxUserService.LastValidSignedUserId : xboxUserService.PreviousUser.Id);
				RequestSignIn(0u);
			}
			else
			{
				XboxGoBackToMainMenu(null);
			}
		}
		else
		{
			XboxGoBackToMainMenu(null);
		}
		isDuringSignOut = false;
	}

	public void RequestSignIn(uint joystickId = 0)
	{
		if (UserChangePolicy != UserChangePolicy.Ignore)
		{
			UserChangePolicy = UserChangePolicy.Silent;
		}
		xboxUserService.SigningJoystickId = joystickId;
		xboxUserService.CurrentUser = null;
		inputService.LockInteractivity(InteractivityLockReason.AccountPicker);
		UsersManager.RequestSignIn(AccountPickerOptions.None, ulong.MaxValue);
	}

	private void UsersManager_OnSignInComplete(int resultType, int userId)
	{
		inputService.UnlockInteractivity(InteractivityLockReason.AccountPicker);
	}

	private void XboxUserService_OnUserSignOutStarted(object sender, UserChangedEventArgs e)
	{
		previousUserId = -1;
		isDuringSignOut = true;
		OnUserChanged((int)e.IDUser, userSignedOut: true);
	}

	private void XboxUserService_OnUserChanged(object sender, UserChangedEventArgs e)
	{
		if (e.WasAdded)
		{
			OnUserChanged((int)e.IDUser, userSignedOut: false);
		}
	}

	private void XboxUserService_OnUserSignInMenuClosed(object sender, SignInCompleteEventArgs e)
	{
		if (e.UserId >= 0 && !e.SameUser && (e.UserId != userIdBeforeSigningProcedure || userIdBeforeSigningProcedure == -1))
		{
			OnUserChanged(e.UserId, userSignedOut: false);
		}
		else if (e.UserId == -1 && (xboxUserService.CurrentUser == null || !xboxUserService.CurrentUser.IsSignedIn) && SingletonManager.Get<XboxMainMenuPanel>().IsVisible)
		{
			if (SingletonManager.Get<XboxMainMenuPanel>().IsFirstPrompt)
			{
				UserChangePolicy = UserChangePolicy.Normal;
				SingletonManager.Get<XboxMainMenuPanel>().DisplayUnsigned();
			}
			else if (!xboxUserService.IsSigningOut)
			{
				xboxUserService.CurrentUser = xboxUserService.PreviousUser;
			}
			else
			{
				xboxUserService.IsSigningOut = false;
				SingletonManager.Get<MainMenuPanel>().Hide(instant: true);
			}
		}
		else if (!isDuringSignOut && !e.SameUser)
		{
			EndSigningProcedure(e.SameUser);
		}
	}

	private void OnMenuNotSignedConfirmed(RequesterPanel.Result result)
	{
		if (result == RequesterPanel.Result.Yes)
		{
			UserChangePolicy = UserChangePolicy.Normal;
			SingletonManager.Get<XboxMainMenuPanel>().DisplayUnsigned();
		}
		else
		{
			UserChangePolicy = UserChangePolicy.Ignore;
			RequestSignIn(0u);
		}
	}

	private void OnUserChanged(int newUserId, bool userSignedOut)
	{
		if (SingletonManager.Get<XboxMainMenuPanel>().IsVisible)
		{
			User user = UsersManager.FindUserById(newUserId);
			bool flag = newUserId == -1 || userSignedOut || (user != null && !user.IsSignedIn);
			if (flag)
			{
				UserChangePolicy = UserChangePolicy.Normal;
				SingletonManager.Get<XboxMainMenuPanel>().DisplayUnsigned();
			}
			else
			{
				SingletonManager.Get<MainMenuPanel>().Show();
			}
			if (flag || xboxUserService.PreviousUser == null)
			{
				SingletonManager.Get<Album>().Focus(display: false);
				SingletonManager.Get<CreditsPanel>().Hide();
				SingletonManager.Get<SessionListPanel>().Hide();
				SingletonManager.Get<MPSaveListPanel>().Hide();
				SingletonManager.Get<JournalPanel>().Hide();
				return;
			}
		}
		if (UserChangePolicy == UserChangePolicy.Ignore && !userSignedOut)
		{
			return;
		}
		gameControlService.ForbidGamePause = false;
		if (previousUserId == newUserId || (userSignedOut && !isSignedBeforeSigningProcedure))
		{
			EndSigningProcedure(userSignedOut && !isSignedBeforeSigningProcedure);
		}
		else if (userSignedOut || UsersManager.IsSomeoneSignedIn)
		{
			StaticString staticString = userSignedOut ? ((StaticString)"%XboxUserSignedOutConfirm") : (string.IsNullOrEmpty(xboxUserService.CurrentUserGamertag) ? ((StaticString)AgeLocalizer.Instance.LocalizeString("%XboxUnknownUserChangeConfirm")) : ((StaticString)AgeLocalizer.Instance.LocalizeString("%XboxUserChangeConfirm").Replace("$User", xboxUserService.CurrentUserGamertag)));
			if (gameControlService.CanPauseGame())
			{
				gameControlService.SetGamePause(paused: true);
				gameControlService.ForbidGamePause = true;
			}
			if (userIdBeforeSigningProcedure == -1)
			{
				if (userSignedOut && xboxUserService.CurrentUser != null)
				{
					userIdBeforeSigningProcedure = xboxUserService.CurrentUser.Id;
					isSignedBeforeSigningProcedure = true;
				}
				else if (!userSignedOut)
				{
					if (xboxUserService.PreviousUser != null)
					{
						userIdBeforeSigningProcedure = xboxUserService.PreviousUser.Id;
						isSignedBeforeSigningProcedure = true;
					}
					else
					{
						userIdBeforeSigningProcedure = 0;
						isSignedBeforeSigningProcedure = false;
					}
				}
			}
			if (userSignedOut)
			{
				SingletonManager.Get<XboxMainMenuPanel>().IsFirstPrompt = true;
				XboxGoBackToMainMenu(staticString, ignoreSigningProcedure: false, forceMessage: false, killAutoSave: false);
			}
			else
			{
				SingletonManager.Get<RequesterPanel>().Display(staticString, OnGoBackToMainMenuConfirm, RequesterPanel.ButtonsMode.OK, "%XboxUserChangeConfirmTitle");
			}
		}
		else
		{
			OnGoBackToMainMenuConfirm(RequesterPanel.Result.Yes);
		}
	}

	public void XboxGoBackToMainMenu(StaticString message, bool ignoreSigningProcedure = false, bool forceMessage = false, bool killAutoSave = true)
	{
		if (!ignoreSigningProcedure)
		{
			EndSigningProcedure(forbidGoingBack: true);
		}
		gameControlService.GoBackToMainMenu(killAutoSave);
		if (forceMessage || (UserChangePolicy != UserChangePolicy.Silent && !string.IsNullOrEmpty(message)))
		{
			if (SingletonManager.Get<Dungeon>(mandatory: false) != null)
			{
				SingletonManager.Get<XboxMainMenuPanel>().MessageOnShow = message;
			}
			else
			{
				SingletonManager.Get<RequesterPanel>().Display(message);
			}
		}
	}

	private void EndSigningProcedure(bool forbidGoingBack = false)
	{
		bool flag = (!isSignedBeforeSigningProcedure && xboxUserService.CurrentUser != null && xboxUserService.CurrentUser.IsSignedIn) || (userIdBeforeSigningProcedure > 0 && (xboxUserService.CurrentUser == null || xboxUserService.CurrentUser.Id != userIdBeforeSigningProcedure));
		gameControlService.ForbidGamePause = false;
		isDuringSignOut = false;
		previousUserId = -1;
		userIdBeforeSigningProcedure = -1;
		isSignedBeforeSigningProcedure = true;
		UserChangePolicy = UserChangePolicy.Normal;
		SingletonManager.Get<RequesterPanel>().Hide();
		if (flag && !forbidGoingBack)
		{
			SingletonManager.Get<XboxMainMenuPanel>().MessageOnShow = null;
			gameControlService.GoBackToMainMenu();
		}
	}

	private void OnSuspending()
	{
		Diagnostics.LogWarning("XBoxGameControlManager.OnSuspending");
		suspendTime = Time.realtimeSinceStartup;
		alreadyReadyToSuspend = false;
		if (sessionService != null && sessionService.Session != null && sessionService.Session.SessionMode != 0)
		{
			Diagnostics.Log("XBoxGameControlManager.OnSuspending: MP session running > back to main menu > close session > then ready");
			string lobbyDataString = sessionService.Session.GetLobbyDataString(Session.LOBBYDATA_LOBBY_TYPE);
			if (!string.IsNullOrEmpty(lobbyDataString) && lobbyDataString.ToEnum<LobbyType>() != 0)
			{
				sessionService.Session.SetLobbyData(Session.LOBBYDATA_LOBBY_TYPE, LobbyType.Private.ToString());
			}
			sessionService.SessionChange += OnSuspending_SessionChange;
			XboxGoBackToMainMenu("%XboxSuspendedWhileMP");
			Invoke("AmReadyToSuspendNow", 0.9f);
		}
		else
		{
			Diagnostics.LogWarning("XBoxGameControlManager.OnSuspending > AmReadyToSuspendNow");
			AmReadyToSuspendNow();
		}
	}

	private void OnSuspending_SessionChange(object sender, SessionChangeEventArgs e)
	{
		Diagnostics.Log("XBoxGameControlManager.OnSuspending_SessionChange: {0}", e.Action.ToString());
		SessionChangeAction action = e.Action;
		if (action == SessionChangeAction.Closed)
		{
			Diagnostics.LogWarning("XBoxGameControlManager.OnSuspending_SessionChange: session {0} > AmReadyToSuspendNow", e.Action.ToString());
			sessionService.SessionChange -= OnSuspending_SessionChange;
			AmReadyToSuspendNow();
		}
	}

	private void OnSuspending_XboxSessionClosed()
	{
		Diagnostics.LogWarning("XBoxGameControlManager.OnSuspending_XboxSessionClosed > AmReadyToSuspendNow");
		AmReadyToSuspendNow();
	}

	private void AmReadyToSuspendNow()
	{
		if (alreadyReadyToSuspend)
		{
			Diagnostics.Log("XBoxGameControlManager.AmReadyToSuspendNow > already ready!");
			return;
		}
		Diagnostics.LogWarning("XBoxGameControlManager.AmReadyToSuspendNow > ready in {0} sec.!", Time.realtimeSinceStartup - suspendTime);
		CancelInvoke("AmReadyToSuspendNow");
		alreadyReadyToSuspend = true;
	}
}
public class ArtifactDestructionCursorTarget : ModuleDestructionCursorTarget
{
	protected override Health GetHealthCpnt()
	{
		return GetComponent<Health>();
	}
}
public class ArtifactSelectCursorTarget : CursorTarget
{
	protected override bool IsActive()
	{
		return !Services.GetService<IGameControlService>().ModuleDestructionMode;
	}
}
public class CursorManager : Amplitude.Unity.View.CursorManager
{
	private IInputService inputManager;

	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		ChangeCursor(typeof(DungeonCursor));
	}

	protected override bool ShouldUpdate()
	{
		if (inputManager == null)
		{
			inputManager = Services.GetService<IInputService>();
		}
		if (inputManager != null && inputManager.CurrentControlScheme != 0)
		{
			return false;
		}
		return base.ShouldUpdate();
	}
}
public class CursorTarget : Amplitude.Unity.View.CursorTarget
{
	[SerializeField]
	protected Texture2D hoverCursorTexture;

	protected IGuiService guiManager;

	protected override void Awake()
	{
		base.Awake();
		guiManager = Services.GetService<IGuiService>();
	}

	protected virtual bool IsActive()
	{
		return true;
	}

	protected virtual Texture2D GetHoverCursorTexture()
	{
		return hoverCursorTexture;
	}

	protected override void OnCursorEnter()
	{
		if (IsActive())
		{
			base.OnCursorEnter();
			Texture2D texture2D = GetHoverCursorTexture();
			if (texture2D != null)
			{
				guiManager.ChangeCursor(texture2D);
			}
		}
	}

	protected override void OnCursorExit()
	{
		if (IsActive())
		{
			base.OnCursorExit();
			if (GetHoverCursorTexture() != null)
			{
				guiManager.ChangeCursorToDefault();
			}
		}
	}
}
public class DoorCursorTarget : CursorTarget
{
	[SerializeField]
	private Texture2D hoverCursorTextureDisabled;

	[SerializeField]
	private Door door;

	protected override void OnCursorEnter()
	{
		if (Hero.SelectedHeroes.Count == 1 && Hero.SelectedHeroes[0].HasCrystal)
		{
			if (hoverCursorTextureDisabled != null)
			{
				guiManager.ChangeCursor(hoverCursorTextureDisabled);
			}
		}
		else if (hoverCursorTexture != null)
		{
			guiManager.ChangeCursor(hoverCursorTexture);
		}
	}
}
public class DungeonCursor : Amplitude.Unity.View.Cursor
{
	public DungeonCursor()
	{
		base.LayerMask = GenericUtilities.GetLayerMask(new string[6]
		{
			"Hero",
			"CamDragSupport",
			"MajorModule",
			"MinorModule",
			"Door",
			"Artifact"
		});
		base.TraverseAll = true;
	}
}
public class HeroCursorTarget : CursorTarget
{
}
public class MajorModuleDestructionCursorTarget : ModuleDestructionCursorTarget
{
	[SerializeField]
	protected Texture2D crystalHoverCursorTexture;

	private MajorModule majorModule;

	protected override void Awake()
	{
		majorModule = GetComponent<MajorModule>();
		base.Awake();
	}

	protected override Health GetHealthCpnt()
	{
		return majorModule.HealthCpnt;
	}

	protected override bool IsActive()
	{
		return majorModule.IsCrystal || base.IsActive();
	}

	protected override Texture2D GetHoverCursorTexture()
	{
		return (!majorModule.IsCrystal) ? hoverCursorTexture : crystalHoverCursorTexture;
	}
}
public class MinorModuleDestructionCursorTarget : ModuleDestructionCursorTarget
{
	protected override Health GetHealthCpnt()
	{
		return GetComponentInParent<Health>();
	}
}
public abstract class ModuleDestructionCursorTarget : CursorTarget
{
	protected Health healthCpt;

	protected override void Awake()
	{
		base.Awake();
		healthCpt = GetHealthCpnt();
	}

	protected abstract Health GetHealthCpnt();

	protected override bool IsActive()
	{
		return Services.GetService<IGameControlService>().ModuleDestructionMode;
	}

	protected override void OnCursorEnter()
	{
		if (healthCpt == null || healthCpt.IsAlive())
		{
			base.OnCursorEnter();
		}
	}
}
public class NPCCursorTarget : CursorTarget
{
}
public class SpecialModuleCursorTarget : CursorTarget
{
}
[RequireComponent(typeof(Collider))]
public class TriggerDebug : MonoBehaviour
{
	private void OnTriggerEnter(Collider other)
	{
		Diagnostics.Log("OnTriggerEnter other=" + other, base.gameObject);
	}

	private void OnCollisionEnter(Collision collision)
	{
		Diagnostics.Log("OnCollisionEnter other=" + collision.rigidbody.name, base.gameObject);
	}
}
public class VFXTester : MonoBehaviour
{
	private void Start()
	{
		Hashtable hashtable = new Hashtable();
		hashtable.Add("amount", -256f * Vector3.forward);
		hashtable.Add("time", 3f);
		hashtable.Add("easetype", iTween.EaseType.linear);
		hashtable.Add("looptype", iTween.LoopType.pingPong);
		iTween.MoveBy(base.gameObject, hashtable);
	}
}
public class DoorPlug : MonoBehaviour
{
	[SerializeField]
	private string doorTag;

	public string DoorTag => doorTag;
}
public struct DoorSpotData
{
	public Room Room;

	public string DoorTag;

	public TemplateTag[] RecursiveMandatoryTags;

	public TemplateTag[] RecursiveForbiddenTags;

	public DoorSpotData(Room room, string tag, TemplateTag[] recursiveMandatoryTags, TemplateTag[] recursiveForbiddenTags)
	{
		Room = room;
		DoorTag = tag;
		RecursiveMandatoryTags = recursiveMandatoryTags;
		RecursiveForbiddenTags = recursiveForbiddenTags;
	}
}
public enum Tileset
{
	Random,
	Sewer,
	Laboratory,
	Necro,
	Drakken,
	Ice,
	Jungle
}
public class DungeonGenerator2 : MonoBehaviour
{
	[SerializeField]
	private int randomSeed;

	[SerializeField]
	private string initSlotType;

	[SerializeField]
	private GameObject slotPfb;

	[SerializeField]
	private GameObject lightBlockerPfb;

	[SerializeField]
	private TemplateTag[] mandatoryTags;

	[SerializeField]
	private TemplateTag[] forbiddenTags;

	[SerializeField]
	private TemplateTag[] recursiveMandatoryTags;

	[SerializeField]
	private TemplateTag[] recursiveForbiddenTags;

	[SerializeField]
	private Transform templateDBContainerTfm;

	[SerializeField]
	private Transform testGenerationContainerTfm;

	[SerializeField]
	private int debugMaxRoomCount;

	[SerializeField]
	private float maxFreezeDuration;

	[SerializeField]
	private bool drawLightBlockers = true;

	[SerializeField]
	private bool stepByStepOuhBaby;

	[SerializeField]
	private float stepWait = -1f;

	private Dungeon dungeon;

	private List<Room> dungeonRooms;

	private Room dungeonStartRoom;

	private float generationStartTime;

	private Dictionary<StaticString, List<Template>> templatesByType;

	private Dictionary<Vector3, List<DoorSpotData>> doorSpotsByPosition;

	private Dictionary<Vector3, List<TemplateSlot>> templateSlotsByHotSpotPosition;

	private Dictionary<float, List<Vector2>> lightBlockerSectionsH;

	private Dictionary<float, List<Vector2>> lightBlockerSectionsV;

	private Stopwatch stopWatch;

	private float previousFrameTime;

	private bool pathFindingScanComplete;

	private float currentProgressStep;

	private float progressStepsCount = 26f;

	private LoadingPanel loadingPanel;

	private TemplateManager templateManager;

	private bool IsGeneratingForRuntime => true;

	public int RandomSeed => randomSeed;

	public int PostGenerationSeed
	{
		get;
		private set;
	}

	private void Start()
	{
		templateManager = SingletonManager.Get<TemplateManager>();
	}

	public void Clear()
	{
		Transform transform = (!IsGeneratingForRuntime) ? testGenerationContainerTfm : SingletonManager.Get<Dungeon>().StaticContainer;
		transform.gameObject.SetStaticRecursively(isStatic: false);
		Transform[] children = transform.GetChildren();
		for (int i = 0; i < children.Length; i++)
		{
			UnityEngine.Object.DestroyImmediate(children[i].gameObject);
		}
		transform.localScale = Vector3.one;
	}

	public IEnumerator GenerateDungeonUsingSeedCoroutine(int level, int randomSeed, StaticString shipName)
	{
		this.randomSeed = randomSeed;
		yield return GenerateDungeonCoroutine(level, shipName);
	}

	private void AddDoors(TemplateSlot slot)
	{
		foreach (TemplateHotSpot door in GetDoors(slot))
		{
			Vector3 hotSpotPosition = GetHotSpotPosition(slot, door);
			if (!templateSlotsByHotSpotPosition.TryGetValue(hotSpotPosition, out List<TemplateSlot> value))
			{
				value = new List<TemplateSlot>();
				templateSlotsByHotSpotPosition.Add(hotSpotPosition, value);
			}
			value.Add(slot);
		}
	}

	private void ApplyRecursiveTags(TemplateSlot slot, GameObject map)
	{
		if (slot.RecursiveMandatoryTags.Length <= 0 && slot.RecursiveForbiddenTags.Length <= 0)
		{
			return;
		}
		TemplateSlot[] componentsInChildren = map.GetComponentsInChildren<TemplateSlot>();
		foreach (TemplateSlot templateSlot in componentsInChildren)
		{
			if (slot.RecursiveMandatoryTags.Length > 0)
			{
				List<TemplateTag> list = new List<TemplateTag>(templateSlot.RecursiveMandatoryTags);
				list.AddRange(slot.RecursiveMandatoryTags);
				templateSlot.RecursiveMandatoryTags = list.ToArray();
			}
			if (slot.RecursiveForbiddenTags.Length > 0)
			{
				List<TemplateTag> list2 = new List<TemplateTag>(templateSlot.RecursiveForbiddenTags);
				list2.AddRange(slot.RecursiveForbiddenTags);
				templateSlot.RecursiveForbiddenTags = list2.ToArray();
			}
		}
	}

	private IEnumerator GenerateDungeonCoroutine(int level, StaticString shipName)
	{
		Diagnostics.Log("Starting dungeon generation for level {0}, ship {1}, using {2} seed", level, shipName, randomSeed);
		generationStartTime = Time.realtimeSinceStartup;
		stopWatch = Stopwatch.StartNew();
		previousFrameTime = GetGeneratorTime();
		currentProgressStep = 0f;
		UpdateProgress("Setting up generator");
		RandomGenerator.SetSeed(randomSeed);
		RandomGenerator.WarnOnSeedAlteration = true;
		Tileset tileset = Tileset.Sewer;
		GameConfig gameCfg = null;
		if (IsGeneratingForRuntime)
		{
			gameCfg = GameConfig.GetGameConfig();
			GameConfig.ResetRandomTileset();
			tileset = gameCfg.GetTileset();
		}
		if (IsGeneratingForRuntime)
		{
			yield return ShowLoadingScreen();
		}
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Garbage collection");
		yield return FreeMemory();
		Transform generationContainerTfm = (!IsGeneratingForRuntime) ? testGenerationContainerTfm : SingletonManager.Get<Dungeon>().StaticContainer;
		dungeonStartRoom = null;
		Vector3 tileSize;
		if (IsGeneratingForRuntime)
		{
			dungeon = SingletonManager.Get<Dungeon>();
			tileSize = dungeon.GetTileSize();
			List<TemplateTag> recursiveMandatoryTagsList = new List<TemplateTag>();
			for (int i = 0; i < recursiveMandatoryTags.Length; i++)
			{
				TemplateTag tag = recursiveMandatoryTags[i];
				if (tag.Category != TemplateTagCategory.Level && tag.Category != TemplateTagCategory.Tileset && tag.Category != TemplateTagCategory.Ship)
				{
					recursiveMandatoryTagsList.Add(tag);
				}
			}
			Diagnostics.Log("Generating dungeon for level {0}", level);
			recursiveMandatoryTagsList.Add(new TemplateTag(TemplateTagCategory.Level, "Level" + level));
			Diagnostics.Log("Generating dungeon for tileset {0}", tileset);
			recursiveMandatoryTagsList.Add(new TemplateTag(TemplateTagCategory.Tileset, tileset.ToString()));
			if (level == 1)
			{
				Diagnostics.Log("Generating dungeon for {0} ship", shipName);
				recursiveMandatoryTagsList.Add(new TemplateTag(TemplateTagCategory.Ship, shipName));
			}
			recursiveMandatoryTags = recursiveMandatoryTagsList.ToArray();
		}
		else
		{
			tileSize = 32f * Vector3.one;
		}
		Clear();
		templatesByType = new Dictionary<StaticString, List<Template>>();
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Building templates database (Dungeons)");
		yield return RegisterTemplates("DungeonGeneratorContent/Dungeons");
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Building templates database (RoomPacks)");
		yield return RegisterTemplates("DungeonGeneratorContent/RoomPacks");
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Building templates database (Props)");
		yield return RegisterTemplates("DungeonGeneratorContent/Props");
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Building templates database (Props_" + tileset.ToString() + ")");
		yield return RegisterTemplates("DungeonGeneratorContent/Props_" + tileset.ToString());
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Building templates database (Rooms_" + tileset.ToString() + ")");
		yield return RegisterTemplates("DungeonGeneratorContent/Rooms_" + tileset.ToString());
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Search start slot");
		templateSlotsByHotSpotPosition = new Dictionary<Vector3, List<TemplateSlot>>();
		GameObject dungeonSlotGO = (GameObject)UnityEngine.Object.Instantiate(slotPfb, generationContainerTfm.position, generationContainerTfm.rotation);
		dungeonSlotGO.transform.parent = generationContainerTfm;
		dungeonSlotGO.transform.localScale = Vector3.one;
		TemplateSlot initialSlot = dungeonSlotGO.GetComponent<TemplateSlot>();
		initialSlot.Type = initSlotType;
		initialSlot.MandatoryTags = mandatoryTags;
		initialSlot.ForbiddenTags = forbiddenTags;
		initialSlot.RecursiveMandatoryTags = recursiveMandatoryTags;
		initialSlot.RecursiveForbiddenTags = recursiveForbiddenTags;
		GameObject initMap = null;
		yield return InstanciateRoomPack(initialSlot, delegate(GameObject result)
		{
			initMap = result;
		});
		if (initMap == null)
		{
			Diagnostics.LogError("No template found for: {0}", initialSlot);
		}
		UnityEngine.Object.DestroyImmediate(initialSlot.gameObject);
		TemplateSlot startSlot = null;
		yield return GetStartSlot(initMap, delegate(TemplateSlot result)
		{
			startSlot = result;
		});
		if (startSlot == null)
		{
			Diagnostics.LogError("No start slot found!");
		}
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Apply room count constraint");
		int targetRoomCount = debugMaxRoomCount;
		if (IsGeneratingForRuntime)
		{
			targetRoomCount = RandomGenerator.RangeInt((int)gameCfg.DungeonRoomCountMin.GetValue(), (int)gameCfg.DungeonRoomCountMax.GetValue() + 1);
		}
		List<TemplateSlot> choosenRoomSlots = new List<TemplateSlot>();
		List<TemplateSlot> eligibleRooms = new List<TemplateSlot>();
		List<TemplateSlot> excludedRooms = new List<TemplateSlot>();
		List<TemplateSlot> adjacentRooms2 = null;
		if (null != startSlot)
		{
			choosenRoomSlots.Add(startSlot);
			adjacentRooms2 = null;
			yield return GetAdjacentRooms(startSlot, delegate(List<TemplateSlot> result)
			{
				adjacentRooms2 = result;
			});
			eligibleRooms.AddRange(adjacentRooms2);
		}
		while (choosenRoomSlots.Count < targetRoomCount)
		{
			if (eligibleRooms.Count < 1)
			{
				Diagnostics.LogError("No more elligible rooms! :(");
				break;
			}
			TemplateSlot choosenRoomSlot = eligibleRooms.PullRandom();
			choosenRoomSlots.Add(choosenRoomSlot);
			adjacentRooms2 = null;
			yield return GetAdjacentRooms(choosenRoomSlot, delegate(List<TemplateSlot> result)
			{
				adjacentRooms2 = result;
			});
			foreach (TemplateSlot adjRoom in adjacentRooms2)
			{
				if (!choosenRoomSlots.Contains(adjRoom) && !eligibleRooms.Contains(adjRoom) && !excludedRooms.Contains(adjRoom))
				{
					if (adjRoom.HasPassedProbabilityCheck)
					{
						eligibleRooms.Add(adjRoom);
					}
					else
					{
						excludedRooms.Add(adjRoom);
					}
				}
			}
		}
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Removing not choosen rooms");
		TemplateSlot[] componentsInChildren = initMap.GetComponentsInChildren<TemplateSlot>(includeInactive: true);
		foreach (TemplateSlot slotToRemove in componentsInChildren)
		{
			if (slotToRemove.IsRoomOrRoomPack() && !choosenRoomSlots.Contains(slotToRemove))
			{
				UnityEngine.Object.DestroyImmediate(slotToRemove.gameObject);
			}
		}
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Replacing slots by rooms");
		dungeonRooms = new List<Room>();
		doorSpotsByPosition = new Dictionary<Vector3, List<DoorSpotData>>();
		lightBlockerSectionsH = new Dictionary<float, List<Vector2>>();
		lightBlockerSectionsV = new Dictionary<float, List<Vector2>>();
		while (choosenRoomSlots.Count > 0)
		{
			TemplateSlot slot = choosenRoomSlots.PullRandom();
			bool isStartSlot = slot == startSlot;
			Room room = null;
			yield return InstanciateRoom(slot, delegate(Room result)
			{
				room = result;
			});
			UnityEngine.Object.DestroyImmediate(slot.gameObject);
			if (null == room)
			{
				Diagnostics.LogError("No room could be found to replace slot!");
				continue;
			}
			dungeonRooms.Add(room);
			if (isStartSlot)
			{
				if (dungeonStartRoom != null)
				{
					Diagnostics.LogError("Several start room detected!");
				}
				room.name += "[StartRoom]";
				room.IsStartRoom = true;
				room.Depth = 0;
				dungeonStartRoom = room;
			}
		}
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		if (dungeonStartRoom == null)
		{
			Diagnostics.LogError("No start room found!");
		}
		else
		{
			UpdateProgress("Link rooms");
			foreach (Vector3 doorSpotPos in doorSpotsByPosition.Keys)
			{
				List<DoorSpotData> doorSpotDatas = doorSpotsByPosition[doorSpotPos];
				if (doorSpotDatas.Count != 1)
				{
					DoorSpotData doorSpotData = doorSpotDatas[0];
					Room room2 = doorSpotData.Room;
					DoorSpotData doorSpotData2 = doorSpotDatas[1];
					Room room3 = doorSpotData2.Room;
					if (room2.AdjacentRooms == null)
					{
						room2.AdjacentRooms = new List<Room>();
					}
					room2.AdjacentRooms.Add(room3);
					if (room3.AdjacentRooms == null)
					{
						room3.AdjacentRooms = new List<Room>();
					}
					room3.AdjacentRooms.Add(room2);
				}
			}
			if (NeedToWaitForNextFrame())
			{
				yield return null;
			}
			UpdateProgress("Check holes");
			if (IsGeneratingForRuntime)
			{
				dungeon.RoomCount = dungeonRooms.Count;
			}
			dungeonStartRoom.PropagateDepth(IsGeneratingForRuntime);
			dungeonRooms.Sort((Room x, Room y) => x.Depth - y.Depth);
			Diagnostics.Log("dungeonRooms count={0}", dungeonRooms.Count);
			foreach (Room room4 in dungeonRooms)
			{
				if (room4.Depth >= 0)
				{
					break;
				}
				Diagnostics.LogError("Hole detected! ({0} depth={1})", room4.GetScenePath(), room4.Depth);
			}
			if (NeedToWaitForNextFrame())
			{
				yield return null;
			}
			UpdateProgress("Merge light blockers");
			Dictionary<float, List<Vector2>> mergedLightBlockerSectionsH = GetMergedLightBlockers(lightBlockerSectionsH);
			Dictionary<float, List<Vector2>> mergedLightBlockerSectionsV = GetMergedLightBlockers(lightBlockerSectionsV);
			if (NeedToWaitForNextFrame())
			{
				yield return null;
			}
			UpdateProgress("Place doors");
			foreach (Vector3 doorSpotPos2 in doorSpotsByPosition.Keys)
			{
				List<DoorSpotData> doorSpotDatas2 = doorSpotsByPosition[doorSpotPos2];
				if (doorSpotDatas2.Count != 1)
				{
					DoorSpotData doorSpotData3 = doorSpotDatas2[0];
					Room room2 = doorSpotData3.Room;
					DoorSpotData doorSpotData4 = doorSpotDatas2[1];
					Room room3 = doorSpotData4.Room;
					Vector3 doorDir = room3.transform.position - room2.transform.position;
					bool isVerticalDoor = Mathf.Abs(doorDir.x) > Mathf.Abs(doorDir.z);
					Vector3 doorEulerAngles;
					Vector3 doorOpeningDir;
					if (isVerticalDoor)
					{
						doorEulerAngles = Mathf.Sign(doorDir.x) * 90f * Vector3.up;
						doorOpeningDir = Vector3.forward;
					}
					else
					{
						doorOpeningDir = Vector3.right;
						doorEulerAngles = Vector3.zero;
					}
					List<TemplateTag> doorSlotRecursiveMandatoryTags = new List<TemplateTag>();
					DoorSpotData doorSpotData5 = doorSpotDatas2[0];
					doorSlotRecursiveMandatoryTags.AddRange(doorSpotData5.RecursiveMandatoryTags);
					DoorSpotData doorSpotData6 = doorSpotDatas2[1];
					doorSlotRecursiveMandatoryTags.AddRange(doorSpotData6.RecursiveMandatoryTags);
					List<TemplateTag> doorSlotRecursiveForbiddenTags = new List<TemplateTag>();
					DoorSpotData doorSpotData7 = doorSpotDatas2[0];
					doorSlotRecursiveForbiddenTags.AddRange(doorSpotData7.RecursiveForbiddenTags);
					DoorSpotData doorSpotData8 = doorSpotDatas2[1];
					doorSlotRecursiveForbiddenTags.AddRange(doorSpotData8.RecursiveForbiddenTags);
					GameObject doorStepSlotGO = (GameObject)UnityEngine.Object.Instantiate(slotPfb, doorSpotPos2, Quaternion.Euler(doorEulerAngles));
					doorStepSlotGO.transform.parent = room2.transform;
					TemplateSlot doorStepSlot = doorStepSlotGO.GetComponent<TemplateSlot>();
					doorStepSlot.Type = "DoorStep";
					doorStepSlot.RecursiveMandatoryTags = doorSlotRecursiveMandatoryTags.ToArray();
					doorStepSlot.RecursiveForbiddenTags = doorSlotRecursiveForbiddenTags.ToArray();
					GameObject doorStepGO = null;
					yield return InstanciateProps(doorStepSlot, delegate(GameObject result)
					{
						doorStepGO = result;
					});
					UnityEngine.Object.DestroyImmediate(doorStepSlot.gameObject);
					doorStepGO.transform.parent = generationContainerTfm;
					DoorStep doorStep = doorStepGO.GetComponent<DoorStep>();
					GameObject doorSlotGO = (GameObject)UnityEngine.Object.Instantiate(slotPfb, doorSpotPos2, Quaternion.Euler(doorEulerAngles));
					doorSlotGO.transform.parent = room2.transform;
					TemplateSlot doorSlot = doorSlotGO.GetComponent<TemplateSlot>();
					doorSlot.Type = "Door";
					doorSlot.RecursiveMandatoryTags = doorSlotRecursiveMandatoryTags.ToArray();
					doorSlot.RecursiveForbiddenTags = doorSlotRecursiveForbiddenTags.ToArray();
					GameObject doorGO = null;
					yield return InstanciateProps(doorSlot, delegate(GameObject result)
					{
						doorGO = result;
					});
					UnityEngine.Object.DestroyImmediate(doorSlot.gameObject);
					AddDynamicElementForScaling(doorGO.transform);
					Door door = doorGO.GetComponent<Door>();
					if (IsGeneratingForRuntime)
					{
						door.Init(room2, room3, doorOpeningDir, doorStep);
					}
					DoorPlug[] doorPlugs2 = room2.GetComponentsInChildren<DoorPlug>();
					DoorPlug[] array = doorPlugs2;
					foreach (DoorPlug doorPlug2 in array)
					{
						string doorTag = doorPlug2.DoorTag;
						DoorSpotData doorSpotData9 = doorSpotDatas2[0];
						if (doorTag == doorSpotData9.DoorTag)
						{
							UnityEngine.Object.DestroyImmediate(doorPlug2.gameObject);
							break;
						}
					}
					doorPlugs2 = room3.GetComponentsInChildren<DoorPlug>();
					DoorPlug[] array2 = doorPlugs2;
					foreach (DoorPlug doorPlug in array2)
					{
						string doorTag2 = doorPlug.DoorTag;
						DoorSpotData doorSpotData10 = doorSpotDatas2[1];
						if (doorTag2 == doorSpotData10.DoorTag)
						{
							UnityEngine.Object.DestroyImmediate(doorPlug.gameObject);
							break;
						}
					}
					if (drawLightBlockers)
					{
						List<Vector2> lightBlockerSections = (!isVerticalDoor) ? mergedLightBlockerSectionsH[doorSpotPos2.z] : mergedLightBlockerSectionsV[doorSpotPos2.x];
						Vector2 doorSection = (!isVerticalDoor) ? new Vector2(doorSpotPos2.x - tileSize.x / 2f, doorSpotPos2.x + tileSize.x / 2f) : new Vector2(doorSpotPos2.z - tileSize.z / 2f, doorSpotPos2.z + tileSize.z / 2f);
						for (int sectionIndex = 0; sectionIndex < lightBlockerSections.Count; sectionIndex++)
						{
							float x2 = doorSection.x;
							Vector2 vector = lightBlockerSections[sectionIndex];
							if (x2 >= vector.x)
							{
								float x3 = doorSection.x;
								Vector2 vector2 = lightBlockerSections[sectionIndex];
								if (x3 <= vector2.y)
								{
									float y2 = doorSection.y;
									Vector2 vector3 = lightBlockerSections[sectionIndex];
									if (y2 <= vector3.y)
									{
										float y3 = doorSection.y;
										Vector2 vector4 = lightBlockerSections[sectionIndex];
										lightBlockerSections.Add(new Vector2(y3, vector4.y));
									}
									int index = sectionIndex;
									Vector2 vector5 = lightBlockerSections[sectionIndex];
									lightBlockerSections[index] = new Vector2(vector5.x, doorSection.x);
									break;
								}
							}
							float y4 = doorSection.y;
							Vector2 vector6 = lightBlockerSections[sectionIndex];
							if (y4 >= vector6.x)
							{
								float y5 = doorSection.y;
								Vector2 vector7 = lightBlockerSections[sectionIndex];
								if (y5 <= vector7.y)
								{
									int index2 = sectionIndex;
									float x4 = doorSection.x;
									Vector2 vector8 = lightBlockerSections[sectionIndex];
									lightBlockerSections[index2] = new Vector2(x4, vector8.y);
									break;
								}
							}
						}
					}
				}
			}
			if (NeedToWaitForNextFrame())
			{
				yield return null;
			}
			UpdateProgress("Draw light blockers");
			if (drawLightBlockers)
			{
				foreach (KeyValuePair<float, List<Vector2>> kvp2 in mergedLightBlockerSectionsH)
				{
					foreach (Vector2 section2 in kvp2.Value)
					{
						GameObject lightBlockerGO2 = (GameObject)UnityEngine.Object.Instantiate(lightBlockerPfb, new Vector3((section2.x + section2.y) / 2f, 0f, kvp2.Key), Quaternion.Euler(180f * Vector3.up));
						lightBlockerGO2.transform.parent = generationContainerTfm;
						Transform transform = lightBlockerGO2.transform;
						Vector3 localScale = transform.localScale;
						float num = section2.y - section2.x;
						Vector3 localScale2 = lightBlockerGO2.transform.localScale;
						transform.localScale = localScale + (num - localScale2.x) * Vector3.right;
						GameObject gameObject = lightBlockerGO2;
						string name = gameObject.name;
						gameObject.name = name + "_H_" + kvp2.Key + "_" + section2.x + "_" + section2.y;
					}
				}
				foreach (KeyValuePair<float, List<Vector2>> kvp in mergedLightBlockerSectionsV)
				{
					foreach (Vector2 section in kvp.Value)
					{
						GameObject lightBlockerGO2 = (GameObject)UnityEngine.Object.Instantiate(lightBlockerPfb, new Vector3(kvp.Key, 0f, (section.x + section.y) / 2f), Quaternion.Euler(90f * Vector3.up));
						lightBlockerGO2.transform.parent = generationContainerTfm;
						Transform transform2 = lightBlockerGO2.transform;
						Vector3 localScale3 = transform2.localScale;
						float num2 = section.y - section.x;
						Vector3 localScale4 = lightBlockerGO2.transform.localScale;
						transform2.localScale = localScale3 + (num2 - localScale4.x) * Vector3.right;
						GameObject gameObject2 = lightBlockerGO2;
						string name = gameObject2.name;
						gameObject2.name = name + "_V_" + kvp.Key + "_" + section.x + "_" + section.y;
					}
				}
			}
		}
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Replace remaining template slots");
		List<TemplateSlot> subSlots = new List<TemplateSlot>(generationContainerTfm.GetComponentsInChildren<TemplateSlot>());
		while (subSlots.Count > 0)
		{
			TemplateSlot subSlot = subSlots.PullRandom();
			yield return InstanciateProps(subSlot);
			UnityEngine.Object.DestroyImmediate(subSlot.gameObject);
		}
		if (!IsGeneratingForRuntime)
		{
			Diagnostics.Log("Dungeon generated in {0} seconds (seed={1}/{2})", Time.realtimeSinceStartup - generationStartTime, randomSeed, RandomGenerator.Seed);
			yield break;
		}
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Scale dungeon");
		generationContainerTfm.localScale = dungeon.ContainerScale;
		RoomLight[] roomLights = generationContainerTfm.GetComponentsInChildren<RoomLight>();
		RoomLight[] array3 = roomLights;
		foreach (RoomLight roomLight in array3)
		{
			Transform transform3 = roomLight.transform;
			Vector3 position = roomLight.transform.position;
			float x5 = position.x;
			Vector3 position2 = roomLight.transform.position;
			float y6 = position2.y;
			Vector3 containerScale = dungeon.ContainerScale;
			float y7 = y6 / containerScale.y;
			Vector3 position3 = roomLight.transform.position;
			transform3.position = new Vector3(x5, y7, position3.z);
			Transform transform4 = roomLight.transform;
			Vector3 localScale5 = roomLight.transform.localScale;
			float x6 = localScale5.x;
			Vector3 localScale6 = roomLight.transform.localScale;
			float y8 = localScale6.y;
			Vector3 containerScale2 = dungeon.ContainerScale;
			float y9 = y8 / containerScale2.y;
			Vector3 localScale7 = roomLight.transform.localScale;
			transform4.localScale = new Vector3(x6, y9, localScale7.z);
		}
		dungeon.AssertElementsAreScaled();
		Transform[] templateDBChildren = templateDBContainerTfm.GetChildren();
		for (int templateDBChildIndex = 0; templateDBChildIndex < templateDBChildren.Length; templateDBChildIndex++)
		{
			UnityEngine.Object.DestroyImmediate(templateDBChildren[templateDBChildIndex].gameObject);
		}
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Initialize rooms");
		Bounds dungeonBounds = default(Bounds);
		bool firstBounds = true;
		foreach (Room dungeonRoom2 in dungeonRooms)
		{
			dungeonRoom2.Init();
			Bounds roomBounds = new Bounds(dungeonRoom2.transform.position, dungeonRoom2.Size.MultiplyBy(dungeon.ContainerScale));
			if (firstBounds)
			{
				dungeonBounds = roomBounds;
				firstBounds = false;
			}
			else
			{
				dungeonBounds.Encapsulate(roomBounds);
			}
		}
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Compute pathfinding");
		yield return Amplitude.Coroutine.WaitForNumberOfFrames(1u);
		AstarData data = AstarPath.active.astarData;
		GridGraph gg = data.gridGraph;
		float nodeWidth = gg.nodeSize * gg.aspectRatio;
		float nodeHeight = gg.nodeSize;
		Vector3 size = dungeonBounds.size;
		gg.width = Mathf.CeilToInt(size.x / nodeWidth);
		Vector3 size2 = dungeonBounds.size;
		gg.depth = Mathf.CeilToInt(size2.z / nodeHeight);
		Vector3 center = dungeonBounds.center;
		float x7 = center.x;
		float y10 = gg.center.y;
		Vector3 center2 = dungeonBounds.center;
		gg.center = new Vector3(x7, y10, center2.z);
		float x8 = gg.center.x;
		Vector3 containerScale3 = dungeon.ContainerScale;
		float unscaledCenterX = x8 / containerScale3.x;
		float unscaledCenterX8Multiple = (unscaledCenterX / 8f).RoundHalfAwayFromZero() * 8f;
		float xDelta = Mathf.Abs(unscaledCenterX - unscaledCenterX8Multiple);
		float z = gg.center.z;
		Vector3 containerScale4 = dungeon.ContainerScale;
		float unscaledCenterZ = z / containerScale4.z;
		float unscaledCenterZ8Multiple = (unscaledCenterZ / 8f).RoundHalfAwayFromZero() * 8f;
		float zDelta = Mathf.Abs(unscaledCenterZ - unscaledCenterZ8Multiple);
		if (xDelta >= 0.001f || zDelta >= 0.001f)
		{
			Diagnostics.LogError("Pathfinding grid not correctly centered :(");
		}
		gg.UpdateSizeFromWidthDepth();
		pathFindingScanComplete = false;
		AstarPath.OnLatePostScan = (OnScanDelegate)Delegate.Combine(AstarPath.OnLatePostScan, new OnScanDelegate(GenerateDungeonPostPathfindingScan));
		AstarPath.active.Scan();
		while (!pathFindingScanComplete)
		{
			yield return null;
		}
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Initialize rooms");
		foreach (Room dungeonRoom in dungeonRooms)
		{
			dungeonRoom.AssertIsLoaded();
			dungeonRoom.Hide();
			dungeonRoom.TurnCleanLights(on: false);
			dungeonRoom.TurnDirtyLights(on: false);
			dungeonRoom.TurnLowLights(on: false);
		}
		dungeon.StartRoom = dungeonStartRoom;
		dungeonStartRoom.Open(null, ignoreVisibility: true);
		dungeonStartRoom.InitAgents();
		dungeonStartRoom.PowerByLocalPlayer(displayErrorNotif: false, checkCrystalState: false, consumeDust: true, playPowerVFX: true, syncPowerOverNetwork: false);
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Compute rooms dust loot");
		int remainingDust = GenericUtilities.RoundHalfAwayFromZeroToInt(RandomGenerator.RangeFloat(gameCfg.DungeonRoomDustLootMin.GetValue(), gameCfg.DungeonRoomDustLootMax.GetValue()));
		Dictionary<Room, float> dustLootRoomsWeights = new Dictionary<Room, float>();
		int dungeonRoomsCount = dungeonRooms.Count;
		for (int j = 0; j < dungeonRoomsCount; j++)
		{
			Room dustLootRoom = dungeonRooms[j];
			dustLootRoomsWeights.Add(dustLootRoom, gameCfg.RoomDustLootProbWeight.GetValue(dustLootRoom));
		}
		while (remainingDust > 0 && dustLootRoomsWeights.Count > 0)
		{
			Room dustLootRoom = dustLootRoomsWeights.GetWeightedRandom();
			if (dustLootRoom == null)
			{
				break;
			}
			dustLootRoomsWeights.Remove(dustLootRoom);
			dustLootRoom.SetDustLootAmount(remainingDust);
			remainingDust -= dustLootRoom.DustLootAmount;
		}
		if (remainingDust > 0)
		{
			Diagnostics.LogError("{0} dungeon dust loot remaining!", remainingDust);
		}
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Compute static room events");
		List<Room> staticEventRooms = new List<Room>(dungeonRooms);
		Dictionary<Room, float> staticEventRoomsWeights = new Dictionary<Room, float>();
		StaticRoomEventConfig[] staticRoomEventConfigs = gameCfg.StaticRoomEventConfigs;
		foreach (StaticRoomEventConfig eventCfg in staticRoomEventConfigs)
		{
			staticEventRoomsWeights.Clear();
			int availableRoomCount = staticEventRooms.Count;
			for (int roomIndex = 0; roomIndex < availableRoomCount; roomIndex++)
			{
				Room staticEventRoom = staticEventRooms[roomIndex];
				if (!eventCfg.NeedMajorModuleSlot || !(staticEventRoom.MajorModuleSlot == null))
				{
					staticEventRoomsWeights.Add(staticEventRoom, eventCfg.ProbWeight.GetValue(staticEventRoom));
				}
			}
			RoomEvent roomEvent = eventCfg.Name.ToEnum<RoomEvent>();
			int remainingEventCount = GenericUtilities.RoundHalfAwayFromZeroToInt(RandomGenerator.RangeFloat(eventCfg.CountMin.GetValue(), eventCfg.CountMax.GetValue()));
			while (remainingEventCount > 0 && staticEventRooms.Count > 0 && staticEventRoomsWeights.Count > 0)
			{
				Room staticEventRoom = staticEventRoomsWeights.GetWeightedRandom();
				if (staticEventRoom == null)
				{
					Diagnostics.LogError("No room elligible for {0} static room event!", roomEvent);
					break;
				}
				if (staticEventRoom.StaticRoomEvent != 0)
				{
					Diagnostics.LogError("{0} already marked with {1} event!", staticEventRoom.name, staticEventRoom.StaticRoomEvent);
					break;
				}
				staticEventRoom.StaticRoomEvent = roomEvent;
				staticEventRoom.ForbidDungeonEvent = eventCfg.ForbidDungeonEvent;
				staticEventRooms.Remove(staticEventRoom);
				staticEventRoomsWeights.Remove(staticEventRoom);
				remainingEventCount--;
			}
			if (remainingEventCount > 0)
			{
				Diagnostics.LogError("{0} {1} static room event remaining!", remainingEventCount, roomEvent);
			}
		}
		PostGenerationSeed = RandomGenerator.Seed;
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Static batching");
		generationContainerTfm.gameObject.SetStaticRecursively(isStatic: true);
		if (!GameManager.Preferences.GameGraphicSettings.HxLightTotallyDeactivated)
		{
			GameObject postGenerationDungeonPrefab = Resources.Load("HxLight/PostGenerationDungeon") as GameObject;
			if (postGenerationDungeonPrefab != null)
			{
				LightToLightManagerAdder lightToLightManagerAdder = postGenerationDungeonPrefab.GetComponent<LightToLightManagerAdder>();
				LightToLightManagerAdder newLightToLightManagerAdder = dungeon.gameObject.AddComponent<LightToLightManagerAdder>();
				newLightToLightManagerAdder.LoadFrom(lightToLightManagerAdder);
				newLightToLightManagerAdder.ConvertAllMaterialNow();
				HxDungeonMeshPacker dungeonMeshPacker = postGenerationDungeonPrefab.GetComponent<HxDungeonMeshPacker>();
				HxDungeonMeshPacker newDungeonMeshPacker = generationContainerTfm.gameObject.AddComponent<HxDungeonMeshPacker>();
				newDungeonMeshPacker.LoadFrom(dungeonMeshPacker);
				newDungeonMeshPacker.DoItNow();
			}
		}
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Garbage collection");
		yield return FreeMemory();
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		UpdateProgress("Dungeon generation complete!");
		Diagnostics.Log("Dungeon generated in {0} seconds (seed={1}/{2})", Time.realtimeSinceStartup - generationStartTime, randomSeed, RandomGenerator.Seed);
		if (SingletonManager.Get<GameNetworkManager>().IsMultiplayerSession())
		{
			loadingPanel.DisplayWaitingForOtherPlayersLabel();
		}
	}

	private IEnumerator GetAdjacentRooms(TemplateSlot slot, Action<List<TemplateSlot>> slotsSetter)
	{
		List<TemplateSlot> adjacentRooms = new List<TemplateSlot>();
		foreach (TemplateHotSpot hotSpot in GetDoors(slot))
		{
			Vector3 hotSpotPos = GetHotSpotPosition(slot, hotSpot);
			TemplateSlot adjacentRoom = null;
			yield return GetAdjacentRoom(slot, hotSpotPos, delegate(TemplateSlot result)
			{
				adjacentRoom = result;
			});
			if (null != adjacentRoom)
			{
				adjacentRooms.Add(adjacentRoom);
			}
		}
		slotsSetter(adjacentRooms);
	}

	private IEnumerator GetAdjacentRoom(TemplateSlot slot, Vector3 hotSpotPos, Action<TemplateSlot> slotSetter)
	{
		TemplateSlot connectedSlot2 = GetConnectedSlot(slot, hotSpotPos);
		if (null == connectedSlot2)
		{
			yield break;
		}
		if (connectedSlot2.IsRoom())
		{
			slotSetter(connectedSlot2);
			yield break;
		}
		GameObject map = null;
		yield return InstanciateRoomPack(connectedSlot2, delegate(GameObject result)
		{
			map = result;
		});
		UnityEngine.Object.DestroyImmediate(connectedSlot2.gameObject);
		if (!(null == map))
		{
			connectedSlot2 = null;
			yield return GetAdjacentRoom(slot, hotSpotPos, delegate(TemplateSlot result)
			{
				connectedSlot2 = result;
			});
			slotSetter(connectedSlot2);
		}
	}

	private TemplateSlot GetConnectedSlot(TemplateSlot slot, Vector3 hotSpotPos)
	{
		if (!templateSlotsByHotSpotPosition.TryGetValue(hotSpotPos, out List<TemplateSlot> value))
		{
			return null;
		}
		foreach (TemplateSlot item in value)
		{
			if (!(slot == item))
			{
				return item;
			}
		}
		return null;
	}

	private ICollection<TemplateHotSpot> GetDoors(TemplateSlot slot)
	{
		TemplateTypeData templateTypeData = templateManager.GetTemplateTypeData(slot.Type);
		List<TemplateHotSpot> list = new List<TemplateHotSpot>(4);
		TemplateTag[] array = slot.MandatoryTags;
		foreach (TemplateTag templateTag in array)
		{
			if (templateTag.Category != TemplateTagCategory.Door)
			{
				continue;
			}
			TemplateHotSpot[] hotSpots = templateTypeData.HotSpots;
			for (int j = 0; j < hotSpots.Length; j++)
			{
				TemplateHotSpot item = hotSpots[j];
				if (templateTag.Value == item.AutoTag)
				{
					list.Add(item);
				}
			}
		}
		return list;
	}

	private Vector3 GetHotSpotPosition(TemplateSlot slot, TemplateHotSpot hotSpot)
	{
		Vector3 vector = slot.transform.position + Vector3.Scale(slot.transform.lossyScale, hotSpot.RelPosition);
		return new Vector3(GenericUtilities.RoundHalfAwayFromZero(vector.x), GenericUtilities.RoundHalfAwayFromZero(vector.y), GenericUtilities.RoundHalfAwayFromZero(vector.z));
	}

	private Template GetRandomTemplate(TemplateSlot slot)
	{
		if (!slot.HasPassedProbabilityCheck)
		{
			return null;
		}
		if (!templatesByType.TryGetValue(slot.Type, out List<Template> value))
		{
			Diagnostics.LogError("Unable to find template of type \"{0}\"!", slot.Type);
			return null;
		}
		List<Template> list = new List<Template>();
		foreach (Template item in value)
		{
			if ((slot.MandatoryTags.Length <= 0 || TemplateTag.CheckTags(item.Tags, slot.MandatoryTags, strictCheck: false)) && (slot.ForbiddenTags.Length <= 0 || !TemplateTag.CheckTags(item.Tags, slot.ForbiddenTags, strictCheck: true)) && (slot.RecursiveMandatoryTags.Length <= 0 || TemplateTag.CheckTags(item.Tags, slot.RecursiveMandatoryTags, strictCheck: false)) && (slot.RecursiveForbiddenTags.Length <= 0 || !TemplateTag.CheckTags(item.Tags, slot.RecursiveForbiddenTags, strictCheck: true)))
			{
				list.Add(item);
			}
		}
		if (list.Count < 1)
		{
			return null;
		}
		return list.GetRandom();
	}

	private IEnumerator GetStartSlot(GameObject map, Action<TemplateSlot> slotSetter)
	{
		List<TemplateSlot> startSlots = new List<TemplateSlot>();
		TemplateSlot[] componentsInChildren = map.GetComponentsInChildren<TemplateSlot>(includeInactive: true);
		foreach (TemplateSlot slot in componentsInChildren)
		{
			if (slot.IsStartRoomSlot())
			{
				startSlots.Add(slot);
			}
		}
		Template startTemplate;
		TemplateSlot startSlot2;
		do
		{
			if (startSlots.Count == 0)
			{
				yield break;
			}
			startSlot2 = startSlots.GetRandom();
			if (startSlot2.IsRoom())
			{
				slotSetter(startSlot2);
				yield break;
			}
			startTemplate = GetRandomTemplate(startSlot2);
		}
		while (null == startTemplate && startSlots.Remove(startSlot2));
		GameObject startMap = null;
		yield return InstanciateRoomPack(startSlot2, startTemplate, delegate(GameObject result)
		{
			startMap = result;
		});
		UnityEngine.Object.DestroyImmediate(startSlot2.gameObject);
		startSlot2 = null;
		yield return GetStartSlot(startMap, delegate(TemplateSlot result)
		{
			startSlot2 = result;
		});
		slotSetter(startSlot2);
	}

	private IEnumerator InstanciateProps(TemplateSlot slot, Action<GameObject> propsSetter = null)
	{
		GameObject props = null;
		yield return InstanciateTemplate(slot, delegate(GameObject result)
		{
			props = result;
		});
		if (!(null == props))
		{
			TemplateTypeData templateTypeData = templateManager.GetTemplateTypeData(slot.Type);
			TemplateCategoryData templateCategoryData = templateManager.GetTemplateCategoryData(templateTypeData.Category);
			if (templateCategoryData.SpecificPfb != null)
			{
				GameObject templateParentGO = (GameObject)UnityEngine.Object.Instantiate(templateCategoryData.SpecificPfb, slot.transform.position, slot.transform.rotation);
				templateParentGO.transform.parent = slot.transform.parent;
				templateParentGO.name = props.name;
				props.transform.parent = templateParentGO.transform;
				props.name = "Template_Content";
				props = templateParentGO;
			}
			List<TemplateSlot> subSlots = new List<TemplateSlot>(props.GetComponentsInChildren<TemplateSlot>());
			while (subSlots.Count > 0)
			{
				TemplateSlot subSlot = subSlots.PullRandom();
				yield return InstanciateProps(subSlot);
				UnityEngine.Object.DestroyImmediate(subSlot.gameObject);
			}
			propsSetter?.Invoke(props);
		}
	}

	private IEnumerator InstanciateRoom(TemplateSlot slot, Action<Room> roomSetter)
	{
		if (!slot.IsRoom())
		{
			Diagnostics.LogError("slot must be a slot for room.");
			yield break;
		}
		GameObject templateGO = null;
		yield return InstanciateTemplate(slot, delegate(GameObject result)
		{
			templateGO = result;
		});
		if (null == templateGO)
		{
			yield break;
		}
		TemplateTypeData templateTypeData = templateManager.GetTemplateTypeData(slot.Type);
		TemplateCategoryData templateCategoryData = templateManager.GetTemplateCategoryData(templateTypeData.Category);
		if (templateCategoryData.SpecificPfb == null)
		{
			Diagnostics.LogError("A room type must have a prefab.");
			yield break;
		}
		if (null == templateCategoryData.SpecificPfb.GetComponent<Room>())
		{
			Diagnostics.LogError("The prefab of a room must have a Room component.");
			yield break;
		}
		GameObject templateParentGO = (GameObject)UnityEngine.Object.Instantiate(templateCategoryData.SpecificPfb, slot.transform.position, slot.transform.rotation);
		templateParentGO.name = templateGO.name;
		templateGO.transform.parent = templateParentGO.transform;
		templateGO.name = "Template_Content";
		templateParentGO.transform.parent = slot.transform.parent;
		Room room = templateParentGO.GetComponent<Room>();
		if (!IsGeneratingForRuntime)
		{
			room.Depth = -1;
		}
		room.GetComponent<UniqueID>().RequestUniqueID();
		foreach (TemplateHotSpot hotSpot in GetDoors(slot))
		{
			Vector3 hotSpotPos = GetHotSpotPosition(slot, hotSpot);
			if (!doorSpotsByPosition.ContainsKey(hotSpotPos))
			{
				doorSpotsByPosition.Add(hotSpotPos, new List<DoorSpotData>());
			}
			doorSpotsByPosition[hotSpotPos].Add(new DoorSpotData(room, hotSpot.AutoTag, slot.RecursiveMandatoryTags, slot.RecursiveForbiddenTags));
		}
		BoxCollider roomCollider = room.GetComponent<BoxCollider>();
		roomCollider.size = templateTypeData.Size.DivideBy(room.transform.localScale).MultiplyBy(new Vector3(0.9f, 1f, 0.9f));
		Vector3 size = roomCollider.size;
		roomCollider.center = size.y / 2f * Vector3.up;
		Dictionary<float, List<Vector2>> dictionary = lightBlockerSectionsV;
		Vector3 position = room.transform.position;
		if (!dictionary.ContainsKey(position.x - templateTypeData.Size.x / 2f))
		{
			Dictionary<float, List<Vector2>> dictionary2 = lightBlockerSectionsV;
			Vector3 position2 = room.transform.position;
			dictionary2.Add(position2.x - templateTypeData.Size.x / 2f, new List<Vector2>());
		}
		Dictionary<float, List<Vector2>> dictionary3 = lightBlockerSectionsV;
		Vector3 position3 = room.transform.position;
		List<Vector2> list = dictionary3[position3.x - templateTypeData.Size.x / 2f];
		Vector3 position4 = room.transform.position;
		float x = position4.z - templateTypeData.Size.z / 2f;
		Vector3 position5 = room.transform.position;
		list.Add(new Vector2(x, position5.z + templateTypeData.Size.z / 2f));
		Dictionary<float, List<Vector2>> dictionary4 = lightBlockerSectionsV;
		Vector3 position6 = room.transform.position;
		if (!dictionary4.ContainsKey(position6.x + templateTypeData.Size.x / 2f))
		{
			Dictionary<float, List<Vector2>> dictionary5 = lightBlockerSectionsV;
			Vector3 position7 = room.transform.position;
			dictionary5.Add(position7.x + templateTypeData.Size.x / 2f, new List<Vector2>());
		}
		Dictionary<float, List<Vector2>> dictionary6 = lightBlockerSectionsV;
		Vector3 position8 = room.transform.position;
		List<Vector2> list2 = dictionary6[position8.x + templateTypeData.Size.x / 2f];
		Vector3 position9 = room.transform.position;
		float x2 = position9.z - templateTypeData.Size.z / 2f;
		Vector3 position10 = room.transform.position;
		list2.Add(new Vector2(x2, position10.z + templateTypeData.Size.z / 2f));
		Dictionary<float, List<Vector2>> dictionary7 = lightBlockerSectionsH;
		Vector3 position11 = room.transform.position;
		if (!dictionary7.ContainsKey(position11.z - templateTypeData.Size.z / 2f))
		{
			Dictionary<float, List<Vector2>> dictionary8 = lightBlockerSectionsH;
			Vector3 position12 = room.transform.position;
			dictionary8.Add(position12.z - templateTypeData.Size.z / 2f, new List<Vector2>());
		}
		Dictionary<float, List<Vector2>> dictionary9 = lightBlockerSectionsH;
		Vector3 position13 = room.transform.position;
		List<Vector2> list3 = dictionary9[position13.z - templateTypeData.Size.z / 2f];
		Vector3 position14 = room.transform.position;
		float x3 = position14.x - templateTypeData.Size.x / 2f;
		Vector3 position15 = room.transform.position;
		list3.Add(new Vector2(x3, position15.x + templateTypeData.Size.x / 2f));
		Dictionary<float, List<Vector2>> dictionary10 = lightBlockerSectionsH;
		Vector3 position16 = room.transform.position;
		if (!dictionary10.ContainsKey(position16.z + templateTypeData.Size.z / 2f))
		{
			Dictionary<float, List<Vector2>> dictionary11 = lightBlockerSectionsH;
			Vector3 position17 = room.transform.position;
			dictionary11.Add(position17.z + templateTypeData.Size.z / 2f, new List<Vector2>());
		}
		Dictionary<float, List<Vector2>> dictionary12 = lightBlockerSectionsH;
		Vector3 position18 = room.transform.position;
		List<Vector2> list4 = dictionary12[position18.z + templateTypeData.Size.z / 2f];
		Vector3 position19 = room.transform.position;
		float x4 = position19.x - templateTypeData.Size.x / 2f;
		Vector3 position20 = room.transform.position;
		list4.Add(new Vector2(x4, position20.x + templateTypeData.Size.x / 2f));
		room.SetSize(templateTypeData.Size);
		roomSetter(room);
	}

	private IEnumerator InstanciateRoomPack(TemplateSlot slot, Action<GameObject> mapSetter)
	{
		GameObject map = null;
		yield return InstanciateTemplate(slot, delegate(GameObject result)
		{
			map = result;
		});
		if (null == map)
		{
			yield break;
		}
		RemoveDoors(slot);
		TemplateSlot[] componentsInChildren = map.GetComponentsInChildren<TemplateSlot>();
		foreach (TemplateSlot newSlot in componentsInChildren)
		{
			if (newSlot.IsRoomOrRoomPack())
			{
				AddDoors(newSlot);
			}
		}
		mapSetter(map);
	}

	private IEnumerator InstanciateRoomPack(TemplateSlot slot, Template template, Action<GameObject> mapSetter)
	{
		GameObject map = null;
		yield return InstanciateTemplate(slot, template, delegate(GameObject result)
		{
			map = result;
		});
		RemoveDoors(slot);
		TemplateSlot[] componentsInChildren = map.GetComponentsInChildren<TemplateSlot>();
		foreach (TemplateSlot newSlot in componentsInChildren)
		{
			if (newSlot.IsRoomOrRoomPack())
			{
				AddDoors(newSlot);
			}
		}
		mapSetter(map);
	}

	private IEnumerator InstanciateTemplate(TemplateSlot slot, Action<GameObject> mapSetter)
	{
		Template selectedTemplate = GetRandomTemplate(slot);
		if (!(null == selectedTemplate))
		{
			GameObject map = null;
			yield return InstanciateTemplate(slot, selectedTemplate, delegate(GameObject result)
			{
				map = result;
			});
			mapSetter(map);
		}
	}

	private IEnumerator InstanciateTemplate(TemplateSlot slot, Template template, Action<GameObject> mapSetter)
	{
		GameObject map = (GameObject)UnityEngine.Object.Instantiate(template.GetContent(), slot.transform.position, slot.transform.rotation);
		map.name = template.transform.parent.name;
		map.transform.parent = slot.transform.parent;
		map.transform.localScale = slot.transform.localScale;
		ApplyRecursiveTags(slot, map);
		mapSetter(map);
		yield break;
	}

	private void RemoveDoors(TemplateSlot slot)
	{
		foreach (TemplateHotSpot door in GetDoors(slot))
		{
			Vector3 hotSpotPosition = GetHotSpotPosition(slot, door);
			if (templateSlotsByHotSpotPosition.TryGetValue(hotSpotPosition, out List<TemplateSlot> value))
			{
				value.Remove(slot);
			}
		}
	}

	private IEnumerator RegisterTemplates(string containerPath)
	{
		GameObject templateContainer = Resources.Load<GameObject>(containerPath);
		if (templateContainer == null)
		{
			Diagnostics.LogError("Couldn't find any template container at path {0}!", containerPath);
			yield break;
		}
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		List<Template> templates = new List<Template>();
		templates.AddRange(templateContainer.GetComponentsInChildren<Template>(includeInactive: true));
		if (NeedToWaitForNextFrame())
		{
			yield return null;
		}
		foreach (Template template in templates)
		{
			if (!templatesByType.ContainsKey(template.Type))
			{
				templatesByType.Add(template.Type, new List<Template>());
			}
			templatesByType[template.Type].Add(template);
			if (NeedToWaitForNextFrame())
			{
				yield return null;
			}
		}
	}

	private IEnumerator FreeMemory()
	{
		if (templatesByType != null)
		{
			IEnumerator typeEnum = templatesByType.Keys.GetEnumerator();
			while (typeEnum.MoveNext())
			{
				List<Template> templates = templatesByType[typeEnum.Current as StaticString];
				for (int j = 0; j < templates.Count; j++)
				{
					templates[j] = null;
				}
				templates.Clear();
			}
			templatesByType.Clear();
			templatesByType = null;
		}
		if (dungeonRooms != null)
		{
			for (int i = 0; i < dungeonRooms.Count; i++)
			{
				dungeonRooms[i] = null;
			}
			dungeonRooms.Clear();
			dungeonRooms = null;
		}
		dungeon = null;
		dungeonStartRoom = null;
		yield return DungeonsApplication.FreeMemory();
	}

	private IEnumerator ShowLoadingScreen()
	{
		SingletonManager.Get<GameSelectionPanel>().Hide(instant: true);
		if (SingletonManager.Get<GameNetworkManager>().IsMultiplayerSession())
		{
			Services.GetService<IAudioEventService>().Play2DEvent("Master/GUI/Lobby/ItsTheFinalCountdown");
		}
		IViewService viewService = Services.GetService<IViewService>();
		Diagnostics.Assert(viewService != null);
		viewService.PostViewChange(typeof(GameLoadingView));
		GameLoadingScreen gameLoadingScreen = SingletonManager.Get<GameLoadingScreen>();
		gameLoadingScreen.Load();
		while (!gameLoadingScreen.IsLoaded)
		{
			Diagnostics.Log("Waiting for GameLoadingScreen to be loaded...");
			yield return null;
		}
		gameLoadingScreen.Show();
		while (!gameLoadingScreen.IsVisible)
		{
			Diagnostics.Log("Waiting for GameLoadingScreen to be visible...");
			yield return null;
		}
		loadingPanel = SingletonManager.Get<LoadingPanel>();
		loadingPanel.Load();
		while (!loadingPanel.IsLoaded)
		{
			Diagnostics.Log("Waiting for LoadingPanel to be loaded...");
			yield return null;
		}
		loadingPanel.Hide();
		while (loadingPanel.IsVisible)
		{
			Diagnostics.Log("Waiting for LoadingPanel to be hidden...");
			yield return null;
		}
		loadingPanel.SetLoadingProgress(0f);
		loadingPanel.Show();
		while (!loadingPanel.IsVisible)
		{
			Diagnostics.Log("Waiting for LoadingPanel to be visible...");
			yield return null;
		}
	}

	private void GenerateDungeonPostPathfindingScan(AstarPath script)
	{
		AstarPath.OnLatePostScan = (OnScanDelegate)Delegate.Remove(AstarPath.OnLatePostScan, new OnScanDelegate(GenerateDungeonPostPathfindingScan));
		pathFindingScanComplete = true;
	}

	private void AddDynamicElementForScaling(Transform tfm)
	{
		if (IsGeneratingForRuntime)
		{
			dungeon.AddDynamicElementForScaling(tfm);
		}
		else
		{
			tfm.parent = testGenerationContainerTfm;
		}
	}

	private Dictionary<float, List<Vector2>> GetMergedLightBlockers(Dictionary<float, List<Vector2>> lightBlockerSections)
	{
		Dictionary<float, List<Vector2>> dictionary = new Dictionary<float, List<Vector2>>();
		foreach (KeyValuePair<float, List<Vector2>> lightBlockerSection in lightBlockerSections)
		{
			dictionary.Add(lightBlockerSection.Key, new List<Vector2>());
			List<Vector2> list = new List<Vector2>(lightBlockerSection.Value);
			list.Sort((Vector2 first, Vector2 next) => Math.Sign(first.x - next.x));
			Vector2 vector = list[0];
			float x = vector.x;
			Vector2 vector2 = list[0];
			Vector2 item = new Vector2(x, vector2.x);
			foreach (Vector2 item2 in list)
			{
				if (item2.x <= item.y)
				{
					if (item.y < item2.y)
					{
						item.y = item2.y;
					}
				}
				else
				{
					dictionary[lightBlockerSection.Key].Add(item);
					item = item2;
				}
			}
			dictionary[lightBlockerSection.Key].Add(item);
		}
		return dictionary;
	}

	private float GetGeneratorTime()
	{
		return (float)stopWatch.ElapsedMilliseconds / 1000f;
	}

	private void UpdateProgress(string msg)
	{
		currentProgressStep += 1f;
		float num = currentProgressStep / progressStepsCount;
		if (num < 0f || num > 1f)
		{
			Diagnostics.LogError("Invalid dungeon generation progress: {0} ({1}/{2})", num, currentProgressStep, progressStepsCount);
		}
		Diagnostics.Log("{0} (step {1}/{2} ({3}%), seed={4}, mem={5})", msg, currentProgressStep, progressStepsCount, num * 100f, RandomGenerator.Seed, GC.GetTotalMemory(forceFullCollection: true));
		if (IsGeneratingForRuntime)
		{
			if (loadingPanel == null)
			{
				loadingPanel = SingletonManager.Get<LoadingPanel>();
			}
			if (loadingPanel != null && loadingPanel.IsLoaded && loadingPanel.IsVisible)
			{
				loadingPanel.SetLoadingProgress(num);
			}
		}
	}

	private bool NeedToWaitForNextFrame()
	{
		if (!IsGeneratingForRuntime)
		{
			return false;
		}
		float generatorTime = GetGeneratorTime();
		float num = generatorTime - previousFrameTime;
		if (num > maxFreezeDuration)
		{
			Diagnostics.Log("Previous step took {0} sec., will wait for next frame to continue...", num);
			previousFrameTime = generatorTime;
			return true;
		}
		return false;
	}
}
internal static class DungeonStaticBatchingUtility
{
	private class BatchingObjectsList
	{
		public BatchingObjectInfo BatchingObjectInfo;

		public List<MeshFilter> MeshFilters;

		public BatchingObjectsList(BatchingObjectInfo batchingObjectInfo)
		{
			BatchingObjectInfo = batchingObjectInfo;
			MeshFilters = new List<MeshFilter>();
		}

		public static BatchingObjectsList CreateBatchingObjectListFrom(Material sharedMaterial, int subMeshIndex, MeshFilter meshFilter, MeshRenderer meshRenderer)
		{
			BatchingObjectsList batchingObjectsList = new BatchingObjectsList(new BatchingObjectInfo(sharedMaterial, subMeshIndex, meshRenderer.IsCastingShadows(), meshRenderer.receiveShadows, meshRenderer.gameObject.layer));
			bool condition = batchingObjectsList.AddIFN(sharedMaterial, subMeshIndex, meshFilter, meshRenderer);
			Diagnostics.Assert(condition);
			return batchingObjectsList;
		}

		public bool AddIFN(Material sharedMaterial, int subMeshIndex, MeshFilter meshFilter, MeshRenderer meshRenderer)
		{
			if (sharedMaterial != BatchingObjectInfo.SharedMaterial || subMeshIndex != BatchingObjectInfo.SubMeshIndex || meshRenderer.IsCastingShadows() != BatchingObjectInfo.CastShadows || meshRenderer.receiveShadows != BatchingObjectInfo.ReceiveShadows || meshFilter.gameObject.layer != BatchingObjectInfo.Layer)
			{
				return false;
			}
			MeshFilters.Add(meshFilter);
			return true;
		}

		public GameObject CreateGameObjectWithCombinedMeshAndClearPreviousContent(GameObject rootObject, Matrix4x4 rootObjectWorldToLocalMatrix)
		{
			Mesh mesh = new Mesh();
			CombineInstance[] array = new CombineInstance[MeshFilters.Count];
			for (int i = 0; i < MeshFilters.Count; i++)
			{
				CombineInstance combineInstance = default(CombineInstance);
				combineInstance.mesh = MeshFilters[i].sharedMesh;
				combineInstance.transform = rootObjectWorldToLocalMatrix * MeshFilters[i].transform.localToWorldMatrix;
				combineInstance.subMeshIndex = BatchingObjectInfo.SubMeshIndex;
				array[i] = combineInstance;
			}
			mesh.CombineMeshes(array);
			GameObject gameObject = new GameObject($"Combine{BatchingObjectInfo.SharedMaterial.name}");
			gameObject.transform.parent = rootObject.transform;
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localRotation = Quaternion.identity;
			gameObject.transform.localScale = new Vector3(1f, 1f, 1f);
			gameObject.layer = BatchingObjectInfo.Layer;
			MeshFilter meshFilter = gameObject.AddComponent<MeshFilter>();
			MeshRenderer meshRenderer = gameObject.AddComponent<MeshRenderer>();
			mesh.RecalculateBounds();
			meshFilter.sharedMesh = mesh;
			meshRenderer.sharedMaterial = BatchingObjectInfo.SharedMaterial;
			meshRenderer.SetShadowCasting(BatchingObjectInfo.CastShadows);
			meshRenderer.receiveShadows = BatchingObjectInfo.ReceiveShadows;
			for (int j = 0; j < MeshFilters.Count; j++)
			{
				MeshFilter meshFilter2 = MeshFilters[j];
				meshFilter2.sharedMesh = null;
			}
			gameObject.SetActive(value: true);
			return gameObject;
		}
	}

	private struct BatchingObjectInfo
	{
		public Material SharedMaterial;

		public int SubMeshIndex;

		public bool CastShadows;

		public bool ReceiveShadows;

		public int Layer;

		public BatchingObjectInfo(Material sharedMaterial, int subMeshIndex, bool castShadows, bool receiveShadows, int layer)
		{
			SharedMaterial = sharedMaterial;
			SubMeshIndex = subMeshIndex;
			CastShadows = castShadows;
			ReceiveShadows = receiveShadows;
			Layer = layer;
		}
	}

	private delegate bool IsSuitableToBatchingDelegate(GameObject gameObject);

	private delegate bool IsABatchingSourceDelegate(GameObject gameObject);

	public static void Combine(GameObject gameObject)
	{
		List<GameObject> list = new List<GameObject>();
		FillBatchingSource(list, gameObject, ReturnTrue);
		UnityEngine.Debug.Log($"Found {list.Count} rooms.");
		List<MeshFilter> list2 = new List<MeshFilter>();
		for (int i = 0; i < list.Count; i++)
		{
			FillBatchingCandidate(list2, list[i], IsSuitableToBatching);
			ApplyBatchingStrategy(list[i], list2);
			list2.Clear();
		}
	}

	private static void FillBatchingSource(List<GameObject> batchingCandidate, GameObject gameObject, IsABatchingSourceDelegate isABatchingSourceDelegate)
	{
		if (isABatchingSourceDelegate(gameObject))
		{
			batchingCandidate.Add(gameObject);
			return;
		}
		Transform[] children = gameObject.transform.GetChildren();
		for (int i = 0; i < children.Length; i++)
		{
			FillBatchingSource(batchingCandidate, children[i].gameObject, isABatchingSourceDelegate);
		}
	}

	private static void ApplyBatchingStrategy(GameObject rootObject, List<MeshFilter> batchingCandidate)
	{
		List<BatchingObjectsList> list = new List<BatchingObjectsList>();
		for (int i = 0; i < batchingCandidate.Count; i++)
		{
			MeshFilter meshFilter = batchingCandidate[i];
			MeshRenderer component = meshFilter.GetComponent<MeshRenderer>();
			int subMeshCount = meshFilter.mesh.subMeshCount;
			if (!(component != null))
			{
				continue;
			}
			for (int j = 0; j < component.sharedMaterials.Length; j++)
			{
				Material sharedMaterial = component.sharedMaterials[j];
				bool flag = false;
				int subMeshIndex = (subMeshCount != 1) ? j : 0;
				for (int k = 0; k < list.Count; k++)
				{
					BatchingObjectsList batchingObjectsList = list[k];
					if (batchingObjectsList.AddIFN(sharedMaterial, subMeshIndex, meshFilter, component))
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					list.Add(BatchingObjectsList.CreateBatchingObjectListFrom(sharedMaterial, subMeshIndex, meshFilter, component));
				}
			}
		}
		UnityEngine.Debug.Log($"Found {list.Count} batch source");
		Matrix4x4 worldToLocalMatrix = rootObject.transform.worldToLocalMatrix;
		for (int l = 0; l < list.Count; l++)
		{
			list[l].CreateGameObjectWithCombinedMeshAndClearPreviousContent(rootObject, worldToLocalMatrix);
		}
	}

	private static void FillBatchingCandidate(List<MeshFilter> batchingCandidate, GameObject gameObject, IsSuitableToBatchingDelegate isSuitableToBatchingDelegate)
	{
		if (isSuitableToBatchingDelegate(gameObject))
		{
			MeshFilter component = gameObject.GetComponent<MeshFilter>();
			if (component != null)
			{
				batchingCandidate.Add(component);
			}
		}
		Transform[] children = gameObject.transform.GetChildren();
		for (int i = 0; i < children.Length; i++)
		{
			FillBatchingCandidate(batchingCandidate, children[i].gameObject, isSuitableToBatchingDelegate);
		}
	}

	private static bool ReturnTrue(GameObject gameObject)
	{
		return true;
	}

	private static bool IsARoom(GameObject gameObject)
	{
		return gameObject.GetComponent<Room>() != null;
	}

	private static bool IsSuitableToBatching(GameObject gameObject)
	{
		if (gameObject.name == "Wall" || gameObject.name == "LeftWall" || gameObject.name == "RightWall" || gameObject.name == "Floor" || gameObject.name == "FloorTexture" || gameObject.name == "LightBlocker" || gameObject.name == "Hider" || gameObject.name == "Quad" || gameObject.name == "Roof")
		{
			return true;
		}
		return false;
	}

	private static bool IsSuitableToBatchingUnlitObject(GameObject gameObject)
	{
		if (gameObject.name == "LightBlocker" || gameObject.name == "Hider" || gameObject.name == "Quad" || gameObject.name == "Roof")
		{
			return true;
		}
		return false;
	}

	private static bool IsSuitableToBatchingLitObject(GameObject gameObject)
	{
		if (gameObject.name == "Wall" || gameObject.name == "LeftWall" || gameObject.name == "RightWall" || gameObject.name == "Floor" || gameObject.name == "FloorTexture")
		{
			return true;
		}
		return false;
	}
}
public class DungeonStaticBatchingUtilityComponent : MonoBehaviour
{
}
public class SelectContentByShipConfig : MonoBehaviour
{
	[SerializeField]
	private string specialShipConfigName;

	[SerializeField]
	private GameObject normalContent;

	[SerializeField]
	private GameObject specialContent;

	private void Awake()
	{
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		if (dungeon != null)
		{
			if (dungeon.ShipConfig.Name == specialShipConfigName)
			{
				UnityEngine.Object.DestroyImmediate(normalContent);
				specialContent.SetActive(value: true);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(specialContent);
				normalContent.SetActive(value: true);
			}
		}
	}
}
public class Template : TemplateCommon
{
	public GameObject GetContent()
	{
		return base.transform.parent.FindChild("Content").gameObject;
	}
}
public enum TemplateCategory
{
	Dungeon,
	RoomPack,
	Room,
	Props,
	Door,
	DoorStep,
	ModuleSlot,
	RoomDefenseSpot
}
[Serializable]
public struct TemplateCategoryData
{
	public TemplateCategory Category;

	public GameObject SpecificPfb;

	public Material SizeMaterial;

	public TemplateTag[] TemplateDefaultTags;

	public TemplateTag[] SlotDefaultMandatoryTags;
}
public class TemplateCommon : MonoBehaviour
{
	[SerializeField]
	protected string type;

	[SerializeField]
	protected TemplateTag[] tags;

	[SerializeField]
	protected GameObject shapePfb;

	protected TemplateCommonShape shape;

	public string Type
	{
		get
		{
			return type;
		}
		set
		{
			type = value;
		}
	}

	public TemplateTag[] Tags
	{
		get
		{
			return tags;
		}
		set
		{
			tags = value;
		}
	}

	public virtual void UpdateDisplay()
	{
		string text = GetType().ToString() + "_" + type.ToString();
		if (!base.name.StartsWith(text))
		{
			base.name = text;
		}
		if (shape == null)
		{
			shape = GetComponentInChildren<TemplateCommonShape>();
		}
		if (shape == null)
		{
			GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(shapePfb, base.transform.position, base.transform.rotation);
			gameObject.name = base.name + "_shape";
			shape = gameObject.GetComponent<TemplateCommonShape>();
			gameObject.transform.parent = base.transform;
		}
		shape.TxtMesh.text = type.ToString();
		TemplateTypeData templateTypeData = SingletonManager.Get<TemplateManager>().GetTemplateTypeData(type);
		if (shape.transform.localScale != templateTypeData.Size)
		{
			shape.transform.localScale = templateTypeData.Size;
		}
		for (int i = 0; i < shape.HotSpotTfms.Length; i++)
		{
			if (templateTypeData.HotSpots.Length >= i + 1)
			{
				shape.HotSpotTfms[i].gameObject.SetActive(value: true);
				Transform obj = shape.HotSpotTfms[i];
				float x = templateTypeData.HotSpots[i].RelPosition.x;
				Vector3 localScale = shape.transform.localScale;
				float x2 = x / localScale.x;
				float y = templateTypeData.HotSpots[i].RelPosition.y;
				Vector3 localScale2 = shape.transform.localScale;
				float y2 = y / localScale2.y;
				float z = templateTypeData.HotSpots[i].RelPosition.z;
				Vector3 localScale3 = shape.transform.localScale;
				obj.localPosition = new Vector3(x2, y2, z / localScale3.z);
				Transform obj2 = shape.HotSpotTfms[i];
				Vector3 localScale4 = shape.transform.localScale;
				float x3 = 1f / localScale4.x;
				Vector3 localScale5 = shape.transform.localScale;
				float y3 = 1f / localScale5.y;
				Vector3 localScale6 = shape.transform.localScale;
				obj2.localScale = new Vector3(x3, y3, 1f / localScale6.z);
			}
			else
			{
				shape.HotSpotTfms[i].gameObject.SetActive(value: false);
			}
		}
	}

	public virtual void ChangeType(string type)
	{
		this.type = type;
	}
}
public class TemplateCommonShape : MonoBehaviour
{
	[SerializeField]
	protected TextMesh txtMesh;

	[SerializeField]
	protected Transform[] hotSpotTfms;

	public TextMesh TxtMesh => txtMesh;

	public Transform[] HotSpotTfms => hotSpotTfms;
}
[Serializable]
public struct TemplateHotSpot
{
	public Vector3 RelPosition;

	public string AutoTag;
}
public class TemplateManager : MonoBehaviour
{
	[SerializeField]
	private TemplateCategoryData[] templateCategories;

	[SerializeField]
	private TemplateTypeData[] templateTypes;

	[SerializeField]
	private GameObject[] wallProps;

	private List<WallPropData> wallPropsData;

	public List<WallPropData> WallPropsData
	{
		get
		{
			if (wallPropsData == null)
			{
				wallPropsData = new List<WallPropData>();
				char[] separator = new char[2]
				{
					'_',
					' '
				};
				for (int i = 0; i < wallProps.Length; i++)
				{
					StaticString x = wallProps[i].name.Split(separator)[1];
					wallPropsData.Add(new WallPropData
					{
						Length = int.Parse(x),
						Prefab = wallProps[i]
					});
				}
			}
			return wallPropsData;
		}
	}

	public string[] GetTemplateTypeNames()
	{
		string[] array = new string[templateTypes.Length];
		for (int i = 0; i < templateTypes.Length; i++)
		{
			array[i] = templateTypes[i].Name;
		}
		return array;
	}

	public TemplateTypeData GetTemplateTypeData(string type)
	{
		for (int i = 0; i < templateTypes.Length; i++)
		{
			if (templateTypes[i].Name == type)
			{
				return templateTypes[i];
			}
		}
		Diagnostics.LogError("Unable to find template type data for \"" + type + "\" type");
		return default(TemplateTypeData);
	}

	public TemplateCategoryData GetTemplateCategoryData(TemplateCategory category)
	{
		for (int i = 0; i < templateCategories.Length; i++)
		{
			if (templateCategories[i].Category == category)
			{
				return templateCategories[i];
			}
		}
		Diagnostics.LogError("Unable to find template category data for \"" + category + "\" category");
		return default(TemplateCategoryData);
	}

	public TemplateCategoryData GetTemplateCategoryDataForType(string type)
	{
		TemplateTypeData templateTypeData = GetTemplateTypeData(type);
		return GetTemplateCategoryData(templateTypeData.Category);
	}

	[ContextMenu("SortTemplateTypes")]
	private void SortTemplateTypes()
	{
		Array.Sort(templateTypes, (TemplateTypeData type1, TemplateTypeData type2) => type1.Name.CompareTo(type2.Name));
	}
}
[Serializable]
public struct WallPropData
{
	public int Length;

	public GameObject Prefab;
}
public class TemplatePack : MonoBehaviour
{
	[SerializeField]
	private GameObject prefabTarget;
}
public class TemplateShape : TemplateCommonShape
{
}
public class TemplateShapeSelector : MonoBehaviour
{
}
public class TemplateSlot : TemplateCommon
{
	[SerializeField]
	private float probability = 1f;

	[SerializeField]
	private TemplateTag[] mandatoryTags;

	[SerializeField]
	private TemplateTag[] forbiddenTags;

	[SerializeField]
	private TemplateTag[] recursiveMandatoryTags;

	[SerializeField]
	private TemplateTag[] recursiveForbiddenTags;

	private bool? hasPassedProbabilityCheck;

	public float Probability => probability;

	public bool HasPassedProbabilityCheck
	{
		get
		{
			bool? flag = hasPassedProbabilityCheck;
			if (!flag.HasValue)
			{
				hasPassedProbabilityCheck = (RandomGenerator.Value() <= Probability);
			}
			bool? flag2 = hasPassedProbabilityCheck;
			return flag2.Value;
		}
	}

	public TemplateTag[] MandatoryTags
	{
		get
		{
			return mandatoryTags;
		}
		set
		{
			mandatoryTags = value;
		}
	}

	public TemplateTag[] ForbiddenTags
	{
		get
		{
			return forbiddenTags;
		}
		set
		{
			forbiddenTags = value;
		}
	}

	public TemplateTag[] RecursiveMandatoryTags
	{
		get
		{
			return recursiveMandatoryTags;
		}
		set
		{
			recursiveMandatoryTags = value;
		}
	}

	public TemplateTag[] RecursiveForbiddenTags
	{
		get
		{
			return recursiveForbiddenTags;
		}
		set
		{
			recursiveForbiddenTags = value;
		}
	}

	public override void ChangeType(string type)
	{
		base.ChangeType(type);
		TemplateManager templateManager = SingletonManager.Get<TemplateManager>();
		TemplateCategoryData templateCategoryDataForType = templateManager.GetTemplateCategoryDataForType(type);
		MandatoryTags = templateCategoryDataForType.SlotDefaultMandatoryTags;
	}

	public bool IsRoom()
	{
		TemplateTag[] array = MandatoryTags;
		foreach (TemplateTag templateTag in array)
		{
			if (templateTag.Category == TemplateTagCategory.Room)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsRoomOrRoomPack()
	{
		TemplateTag[] array = MandatoryTags;
		foreach (TemplateTag templateTag in array)
		{
			TemplateTagCategory category = templateTag.Category;
			if (category == TemplateTagCategory.Room || category == TemplateTagCategory.RoomPack)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsRoomPack()
	{
		TemplateTag[] array = MandatoryTags;
		foreach (TemplateTag templateTag in array)
		{
			if (templateTag.Category == TemplateTagCategory.RoomPack)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsStartRoomSlot()
	{
		TemplateTag[] array = MandatoryTags;
		foreach (TemplateTag templateTag in array)
		{
			TemplateTagCategory category = templateTag.Category;
			if (category == TemplateTagCategory.Room || category == TemplateTagCategory.RoomPack)
			{
				return templateTag.Value.StartsWith("StartRoom");
			}
		}
		return false;
	}
}
public class TemplateSlotShape : TemplateCommonShape
{
	[SerializeField]
	private Renderer sizeRnd;

	public Renderer SizeRnd => sizeRnd;
}
public enum TemplateTagCategory
{
	Default,
	Door,
	Level,
	Room,
	RoomPack,
	Tileset,
	Ship
}
[Serializable]
public class TemplateTag
{
	public static readonly char TagValueSeparator = '|';

	public TemplateTagCategory Category;

	public string Value;

	public TemplateTag(TemplateTagCategory categoryPrefix, string tag)
	{
		Category = categoryPrefix;
		Value = tag;
	}

	public TemplateTag(string tag)
	{
		Category = TemplateTagCategory.Default;
		Value = tag;
	}

	public static bool CheckTags(TemplateTag[] tags, TemplateTag[] controlTags, bool strictCheck)
	{
		if (controlTags.Length < 1)
		{
			return true;
		}
		if (controlTags.Length >= 1 && tags.Length < 1 && strictCheck)
		{
			return false;
		}
		Dictionary<TemplateTagCategory, List<string>> dictionary = new Dictionary<TemplateTagCategory, List<string>>();
		Regex regex = new Regex("^(?<start>[a-zA-Z]*)\\[(?<min>[0-9]+)\\-(?<max>[0-9]+)\\](?<end>[a-zA-Z]*)$");
		foreach (TemplateTag templateTag in tags)
		{
			if (!dictionary.ContainsKey(templateTag.Category))
			{
				dictionary.Add(templateTag.Category, new List<string>());
			}
			Match match = regex.Match(templateTag.Value);
			if (match.Success)
			{
				string value = match.Groups["start"].Value;
				string value2 = match.Groups["end"].Value;
				int num = int.Parse(match.Groups["min"].Value);
				int num2 = int.Parse(match.Groups["max"].Value);
				for (int j = num; j <= num2; j++)
				{
					dictionary[templateTag.Category].Add(value + j + value2);
				}
			}
			else
			{
				dictionary[templateTag.Category].Add(templateTag.Value);
			}
		}
		Dictionary<TemplateTagCategory, List<string>> dictionary2 = new Dictionary<TemplateTagCategory, List<string>>();
		foreach (TemplateTag templateTag2 in controlTags)
		{
			if (!dictionary2.ContainsKey(templateTag2.Category))
			{
				dictionary2.Add(templateTag2.Category, new List<string>());
			}
			dictionary2[templateTag2.Category].Add(templateTag2.Value);
		}
		foreach (TemplateTagCategory key in dictionary2.Keys)
		{
			if (!dictionary.ContainsKey(key))
			{
				if (strictCheck)
				{
					return false;
				}
			}
			else
			{
				foreach (string item2 in dictionary2[key])
				{
					string[] array = item2.Split(TagValueSeparator);
					bool flag = false;
					string[] array2 = array;
					foreach (string item in array2)
					{
						if (dictionary[key].Contains(item))
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						return false;
					}
				}
			}
		}
		return true;
	}
}
[Serializable]
public struct TemplateTypeData
{
	public string Name;

	public TemplateCategory Category;

	public float PositionSnapUnit;

	public Vector3 Size;

	public TemplateHotSpot[] HotSpots;
}
public enum AIInteraction
{
	Attack,
	Operate,
	Repair,
	Loot,
	Defend,
	Follow
}
public enum AIHeuristic
{
	Closest,
	ClosestUnpoisoned,
	MostPopularMob,
	MostPowerfulMob,
	MostPopulatedRoom,
	Random,
	ClosestFreeTarget,
	ClosestLowestMaxHealth,
	ClosestFollowable
}
public abstract class AI : MonoBehaviour
{
	public delegate void TargetChangedEventHandler(AITarget previousTarget, AITarget newTarget);

	[SerializeField]
	protected bool isActive;

	[SerializeField]
	protected bool debug;

	protected Health healthCpnt;

	protected Mover moverCpnt;

	protected Attacker attackerCpnt;

	protected SimMonoBehaviour simMB;

	protected Dungeon dungeon;

	protected RoomElement roomElement;

	protected IGameEventService gameEventManager;

	protected AIConfig aiConfig;

	[SerializeField]
	private float normalTickPeriod;

	[SerializeField]
	private float slowTickPeriod;

	private bool isMoveInterruptionAllowed;

	private Room moveInterruptionAllowedRoom;

	private bool isDungeonAttacker;

	private List<List<AITargetInteractionConfig>> sortedTargetInteractionConfigs;

	protected Dictionary<StaticString, AITargetInteractionConfig> targetInteractionConfigsByKey;

	private bool isIdle;

	private float tickPeriod;

	private string aiConfigName;

	private Room chosenPopulatedRoom;

	private float chosenPopulatedRoomWeight;

	private AITargetInteractionConfig mostPopulatedRoomConfig;

	private Room _currentRoom;

	private AITarget _bestTarget;

	private AITarget _target;

	protected List<AITarget> _targets = new List<AITarget>();

	private AITargetInteractionConfig _targetInteractionConfig;

	private Room _targetRoom;

	private List<AITargetInteractionConfig> _targetInteractionConfigs;

	private StaticString _interactionKey;

	private List<AITarget> _interactionTargets;

	private AITarget _interactionTarget;

	public bool IsActive
	{
		get
		{
			return isActive;
		}
		set
		{
			isActive = value;
		}
	}

	public SimMonoBehaviour SimMB => simMB;

	public AITarget CurrentTarget
	{
		get;
		private set;
	}

	public UniqueID UniqueID
	{
		get;
		private set;
	}

	public string AIConfigName
	{
		get
		{
			return aiConfigName;
		}
		private set
		{
			aiConfigName = value;
			AIConfigBaseName = aiConfigName.Replace("_Elite", string.Empty);
		}
	}

	public string AIConfigBaseName
	{
		get;
		private set;
	}

	public UniqueIDNetSyncElement NetSyncElement
	{
		get;
		private set;
	}

	public event TargetChangedEventHandler OnTargetChanged;

	public virtual void Init(string classDescName, bool autoStartAI = true)
	{
		if (!NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > AI.Init should only be called on owner side!");
			return;
		}
		isActive = true;
		isMoveInterruptionAllowed = true;
		SetNormalTickPeriod();
		gameEventManager.OnGameStopped += OnGameStopped;
		if (healthCpnt != null)
		{
			healthCpnt.OnDeath += OnDeath;
		}
		UpdateAIType(classDescName);
		if (targetInteractionConfigsByKey != null)
		{
			foreach (AITargetInteractionConfig value in targetInteractionConfigsByKey.Values)
			{
				if (value.Heuristic == AIHeuristic.MostPopulatedRoom)
				{
					mostPopulatedRoomConfig = value;
					UpdatePopulatedRoomTarget();
					break;
				}
			}
		}
		if (autoStartAI)
		{
			StartAI();
		}
	}

	public void SetNormalTickPeriod()
	{
		tickPeriod = normalTickPeriod;
	}

	public void SetSlowTickPeriod()
	{
		tickPeriod = slowTickPeriod;
	}

	public void UpdateAIType(string classDescName)
	{
		aiConfig = Databases.GetDatabase<AIConfig>().GetValue(classDescName);
		if (aiConfig == null)
		{
			Diagnostics.Log("{0} > No {1} AIConfig found: deactivated AI", base.name, classDescName);
			isActive = false;
			return;
		}
		sortedTargetInteractionConfigs = new List<List<AITargetInteractionConfig>>();
		targetInteractionConfigsByKey = new Dictionary<StaticString, AITargetInteractionConfig>();
		AITargetInteractionConfig[] array = aiConfig.AITargetInteractionConfigs.Clone() as AITargetInteractionConfig[];
		Array.Sort(array, (AITargetInteractionConfig cfg1, AITargetInteractionConfig cfg2) => -cfg1.Weight.CompareTo(cfg2.Weight));
		float num = float.PositiveInfinity;
		int num2 = array.Length;
		for (int i = 0; i < num2; i++)
		{
			AITargetInteractionConfig aITargetInteractionConfig = array[i];
			if (aITargetInteractionConfig.Weight == num)
			{
				sortedTargetInteractionConfigs[sortedTargetInteractionConfigs.Count - 1].Add(aITargetInteractionConfig);
			}
			else
			{
				sortedTargetInteractionConfigs.Add(new List<AITargetInteractionConfig>
				{
					aITargetInteractionConfig
				});
			}
			targetInteractionConfigsByKey.Add(aITargetInteractionConfig.GetTargetKey(), aITargetInteractionConfig);
			num = aITargetInteractionConfig.Weight;
		}
		AIConfigName = classDescName;
	}

	public void StartAI()
	{
		if (!NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > AI.TickAI should only be called on owner side!");
		}
		else
		{
			Invoke("TickAI", RandomGenerator.RangeFloat(0f, tickPeriod));
		}
	}

	public void AllowMoveInterruption(bool allowed, Room moveInterruptionAllowedRoom)
	{
		isMoveInterruptionAllowed = allowed;
		this.moveInterruptionAllowedRoom = moveInterruptionAllowedRoom;
	}

	public Room GetCurrentRoom()
	{
		return roomElement.ParentRoom;
	}

	protected virtual void Awake()
	{
		healthCpnt = GetComponent<Health>();
		moverCpnt = GetComponent<Mover>();
		attackerCpnt = GetComponent<Attacker>();
		simMB = GetComponent<SimMonoBehaviour>();
		roomElement = GetComponent<RoomElement>();
		NetSyncElement = GetComponent<UniqueIDNetSyncElement>();
		UniqueID = GetComponent<UniqueID>();
		dungeon = SingletonManager.Get<Dungeon>();
		gameEventManager = Services.GetService<IGameEventService>();
	}

	protected abstract void Attack(AITarget target, bool canAttack = true);

	protected abstract void Loot(AITarget target);

	protected abstract void Operate(AITarget target);

	protected abstract void Repair(AITarget target);

	protected abstract void Defend(AITarget target);

	private void StopCurrentInteraction()
	{
		if (CurrentTarget != null)
		{
			if (CurrentTarget.Actor == this)
			{
				CurrentTarget.UnsetActor();
			}
			if (this.OnTargetChanged != null)
			{
				this.OnTargetChanged(CurrentTarget, null);
			}
			CurrentTarget = null;
		}
	}

	protected virtual void OnDeath(ulong attackerOwnerPlayerID)
	{
		isActive = false;
		StopCurrentInteraction();
	}

	private void TickAI()
	{
		if (debug)
		{
			Diagnostics.Log(base.name + " > TickAI: this.isActive=" + isActive + " this.isMoveInterruptionAllowed=" + isMoveInterruptionAllowed + " this.currentTarget=" + ((!(CurrentTarget != null)) ? "nope" : CurrentTarget.name));
		}
		if (isActive && !NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > AI.TickAI should only be called on owner side!");
		}
		if (!healthCpnt.IsAlive())
		{
			return;
		}
		_currentRoom = GetCurrentRoom();
		if (!isActive || (moverCpnt != null && moverCpnt.IsMoving && !isMoveInterruptionAllowed && _currentRoom != moveInterruptionAllowedRoom))
		{
			StopCurrentInteraction();
		}
		else
		{
			float num = float.NegativeInfinity;
			_bestTarget = null;
			if (chosenPopulatedRoom != null && chosenPopulatedRoom.GetSimPropertyValue(SimulationProperties.PopulationWeight) != chosenPopulatedRoomWeight)
			{
				UpdatePopulatedRoomTarget();
			}
			AITarget aITarget = null;
			int count = sortedTargetInteractionConfigs.Count;
			for (int i = 0; i < count; i++)
			{
				_targetInteractionConfigs = sortedTargetInteractionConfigs[i];
				_targets.Clear();
				int count2 = _targetInteractionConfigs.Count;
				for (int j = 0; j < count2; j++)
				{
					_targetInteractionConfig = _targetInteractionConfigs[j];
					if ((_targetInteractionConfig.Interaction == AIInteraction.Operate && simMB.GetSimPropertyValue(SimulationProperties.OperateCapacity) < 1f) || (_targetInteractionConfig.Interaction == AIInteraction.Repair && simMB.GetSimPropertyValue(SimulationProperties.RepairCapacity) < 1f))
					{
						continue;
					}
					_interactionKey = _targetInteractionConfig.GetTargetKey();
					_interactionTargets = AITarget.GetActiveTargets(_interactionKey);
					for (int k = 0; k < _interactionTargets.Count; k++)
					{
						_interactionTarget = _interactionTargets[k];
						if (_interactionTarget != null && _interactionTarget.gameObject != null && _interactionTarget.gameObject != base.gameObject)
						{
							_targets.Add(_interactionTarget);
						}
					}
					if (debug)
					{
						Diagnostics.Log(base.name + " > TickAI: " + (string)_interactionKey + " > " + _targets.Count + " targets");
					}
				}
				int count3 = _targets.Count;
				for (int l = 0; l < count3; l++)
				{
					_target = _targets[l];
					if (_target == null)
					{
						continue;
					}
					if (debug)
					{
						Diagnostics.Log(base.name + " > TickAI: target=" + _target.name);
					}
					_targetInteractionConfig = targetInteractionConfigsByKey[_target.TargetKey];
					_targetRoom = _target.GetCurrentRoom();
					if (_targetRoom == null)
					{
						Diagnostics.LogError("AI.TickAI: {0} > Parent room is NULL!", _target);
					}
					else
					{
						if ((_targetInteractionConfig.SameRoomOnly && _targetRoom != _currentRoom) || (_targetInteractionConfig.DifferentRoomOnly && _targetRoom == _currentRoom) || (_targetInteractionConfig.LocalEntityOnly && _target.NetSyncElement != null && !_target.NetSyncElement.IsOwnedByLocalPlayer()))
						{
							continue;
						}
						float num2;
						switch (_targetInteractionConfig.Heuristic)
						{
						case AIHeuristic.Closest:
							num2 = 0f - dungeon.GetSqrDistance(base.transform.position, _target.Tfm.position);
							break;
						case AIHeuristic.ClosestUnpoisoned:
							num2 = 0f - dungeon.GetSqrDistance(base.transform.position, _target.Tfm.position);
							if (_target.SimMB.GetSimPropertyValue(SimulationProperties.Poison) > 0f)
							{
								num2 /= 1000f;
							}
							break;
						case AIHeuristic.MostPopularMob:
						{
							num2 = 0f;
							Mob mob = _target.Mob;
							foreach (Mob mob2 in _targetRoom.Mobs)
							{
								if (!(mob2 != null) || !(mob2 == mob))
								{
									num2 += 0f - dungeon.GetSqrDistance(_target.Tfm.position, mob2.transform.position);
								}
							}
							break;
						}
						case AIHeuristic.MostPowerfulMob:
							num2 = _target.Mob.Config.DifficultyValue;
							break;
						case AIHeuristic.MostPopulatedRoom:
							num2 = ((_target == chosenPopulatedRoom.AITarget) ? 1 : 0);
							break;
						case AIHeuristic.ClosestFreeTarget:
						{
							num2 = 0f - dungeon.GetSqrDistance(base.transform.position, _target.Tfm.position);
							if (!(_target.Actor != null) || _target.Actor.aiConfig == null)
							{
								break;
							}
							bool flag = false;
							for (int m = 0; m < _target.Actor.aiConfig.AITargetInteractionConfigs.Length; m++)
							{
								if (_target.Actor != this && _target.Actor.AIConfigBaseName == AIConfigBaseName)
								{
									flag = true;
									break;
								}
							}
							if (flag)
							{
								continue;
							}
							break;
						}
						case AIHeuristic.ClosestLowestMaxHealth:
							if (aITarget == null)
							{
								aITarget = _targets.OrderBy((AITarget tar) => (!(tar.SimMB != null)) ? (-1f) : tar.SimMB.GetSimPropertyValue(SimulationProperties.MaxHealth)).ElementAt(0);
							}
							num2 = ((!(_target == aITarget)) ? float.MinValue : (0f - dungeon.GetSqrDistance(base.transform.position, _target.Tfm.position)));
							break;
						case AIHeuristic.ClosestFollowable:
							if (_target.CanBeFollowedBy(this))
							{
								num2 = 0f - dungeon.GetSqrDistance(base.transform.position, _target.Tfm.position);
								break;
							}
							continue;
						case AIHeuristic.Random:
							num2 = ((!(_target == CurrentTarget)) ? RandomGenerator.RangeInt(0, 100) : int.MaxValue);
							break;
						default:
							Diagnostics.LogError("Invalid heuristic: " + _targetInteractionConfig.Heuristic);
							num2 = float.NegativeInfinity;
							break;
						}
						if (!_targetInteractionConfig.DontFavorSameRoom && _target == CurrentTarget && _target.Actor == this && _currentRoom == _targetRoom)
						{
							if (debug)
							{
								Diagnostics.Log(base.name + " > TickAI: stay on current target");
							}
							_bestTarget = _target;
							num = num2;
							break;
						}
						bool flag2 = simMB.GetSimPropertyValue(SimulationProperties.StayInRoom) > 0f;
						if (_targetInteractionConfig.OverrideStayInRoom >= 0)
						{
							flag2 = (_targetInteractionConfig.OverrideStayInRoom > 0);
						}
						if (flag2 && _targetRoom != _currentRoom)
						{
							if (debug)
							{
								Diagnostics.Log(base.name + " > TickAI: stay in room => skip");
							}
						}
						else if (_target.UniqueActor && _target.Actor != null && _target.Actor != this)
						{
							if (_target.Interaction == AIInteraction.Operate && simMB.GetSimPropertyValue(SimulationProperties.OperateWit) > _target.Actor.SimMB.GetSimPropertyValue(SimulationProperties.OperateWit))
							{
								_bestTarget = _target;
								num = num2;
							}
							else if (_target.Interaction == AIInteraction.Repair && simMB.GetSimPropertyValue(SimulationProperties.RepairWit) > _target.Actor.SimMB.GetSimPropertyValue(SimulationProperties.RepairWit))
							{
								_bestTarget = _target;
								num = num2;
							}
						}
						else if (_bestTarget == null)
						{
							if (debug)
							{
								Diagnostics.Log(base.name + " > TickAI: First target found");
							}
							_bestTarget = _target;
							num = num2;
						}
						else if (!_targetInteractionConfig.IgnoreSameRoomPriority && _bestTarget.GetCurrentRoom() != _currentRoom && _targetRoom == _currentRoom)
						{
							if (debug)
							{
								Diagnostics.Log(base.name + " > TickAI: Same room = best target");
							}
							_bestTarget = _target;
							num = num2;
						}
						else if (_targetRoom == _currentRoom && _bestTarget.Actor != null && _bestTarget.Actor != this && _target.Actor == null && !_targetInteractionConfig.IgnoreFreeTargetPriority)
						{
							if (debug)
							{
								Diagnostics.Log(base.name + " > TickAI: Free target = best target");
							}
							_bestTarget = _target;
							num = num2;
						}
						else if (num2 > num && (_targetInteractionConfig.IgnoreSameRoomPriority || _targetRoom == _currentRoom || _bestTarget.GetCurrentRoom() != _currentRoom))
						{
							if (debug)
							{
								Diagnostics.Log(base.name + " > TickAI: Highest weight target = best target");
							}
							_bestTarget = _target;
							num = num2;
						}
					}
				}
				if (_bestTarget != null && (_bestTarget.GetCurrentRoom() == _currentRoom || targetInteractionConfigsByKey[_bestTarget.TargetKey].IgnoreSameRoomPriority))
				{
					if (debug)
					{
						Diagnostics.Log(base.name + " > TickAI: Target found in current room, go for it!");
					}
					break;
				}
			}
			if (CurrentTarget != _bestTarget)
			{
				if (this.OnTargetChanged != null)
				{
					this.OnTargetChanged(CurrentTarget, _bestTarget);
				}
				if (CurrentTarget != null && CurrentTarget.Actor == this)
				{
					CurrentTarget.UnsetActor();
				}
			}
			CurrentTarget = _bestTarget;
			if ((CurrentTarget == null || CurrentTarget.Interaction != 0) && attackerCpnt != null && attackerCpnt.Target != null)
			{
				attackerCpnt.StopAttack();
			}
			if (CurrentTarget != null)
			{
				if (CurrentTarget.Actor != this)
				{
					if (CurrentTarget.UniqueActor && CurrentTarget.Actor != null)
					{
						if (CurrentTarget.Interaction == AIInteraction.Operate || CurrentTarget.Interaction == AIInteraction.Repair)
						{
							CurrentTarget.UnsetActor();
						}
						else
						{
							Diagnostics.LogError(base.name + " > AI.TickAI: " + CurrentTarget.name + " still has " + CurrentTarget.Actor.name + " as actor!");
						}
					}
					CurrentTarget.SetActor(this);
				}
				if (debug)
				{
					Diagnostics.LogWarning(base.name + " > " + CurrentTarget.Interaction.ToString() + " " + CurrentTarget.name);
				}
				isIdle = false;
				switch (CurrentTarget.Interaction)
				{
				case AIInteraction.Follow:
					Attack(CurrentTarget, canAttack: false);
					break;
				case AIInteraction.Attack:
					Attack(CurrentTarget);
					break;
				case AIInteraction.Loot:
					Loot(CurrentTarget);
					break;
				case AIInteraction.Operate:
					Operate(CurrentTarget);
					break;
				case AIInteraction.Repair:
					Repair(CurrentTarget);
					break;
				case AIInteraction.Defend:
					Defend(CurrentTarget);
					break;
				}
			}
			else if (!isIdle)
			{
				if (moverCpnt != null)
				{
					if (_currentRoom != null)
					{
						moverCpnt.MoveToPosition(_currentRoom.CenterPosition);
					}
					else
					{
						Diagnostics.LogError("NO CURRENT ROOM?!");
					}
				}
				isIdle = true;
			}
		}
		Invoke("TickAI", tickPeriod);
	}

	private void UpdatePopulatedRoomTarget()
	{
		List<Room> list = new List<Room>();
		List<Room> openedRooms = SingletonManager.Get<Dungeon>().OpenedRooms;
		for (int i = 0; i < openedRooms.Count; i++)
		{
			if (openedRooms[i].GetSimPropertyValue(SimulationProperties.PopulationWeight) > 0f)
			{
				list.Add(openedRooms[i]);
			}
		}
		list.Sort(delegate(Room r1, Room r2)
		{
			float simPropertyValue = r1.GetSimPropertyValue(SimulationProperties.PopulationWeight);
			float simPropertyValue2 = r2.GetSimPropertyValue(SimulationProperties.PopulationWeight);
			int num2 = -simPropertyValue.CompareTo(simPropertyValue2);
			return (num2 != 0) ? num2 : ((RandomGenerator.RangeFloat(0f, 1f) > 0.5f) ? 1 : (-1));
		});
		int num = (int)Mathf.Ceil((float)list.Count * mostPopulatedRoomConfig.MostPopulatedRoomSelectionRange);
		if (list.Count > num)
		{
			list.RemoveRange(num, list.Count - num);
		}
		if (chosenPopulatedRoom == null || !list.Contains(chosenPopulatedRoom))
		{
			chosenPopulatedRoom = list[RandomGenerator.RangeInt(0, num)];
			chosenPopulatedRoomWeight = chosenPopulatedRoom.GetSimPropertyValue(SimulationProperties.PopulationWeight);
			if (debug)
			{
				Diagnostics.Log(base.name + " > TickAI: selected room " + chosenPopulatedRoom + " for its kamikaze run (" + chosenPopulatedRoomWeight + ")");
			}
		}
	}

	private void OnGameStopped(bool killAutoSave)
	{
		if (this != null)
		{
			CancelInvoke("TickAI");
		}
	}

	private void OnDestroy()
	{
		if (gameEventManager != null)
		{
			gameEventManager.OnGameStopped -= OnGameStopped;
		}
	}
}
public enum AITargetType
{
	SpecialMob,
	AntiModuleMob,
	AntiHeroMob,
	BasicMob,
	Troubled,
	Item,
	Artifact,
	MajorModule,
	MinorModule,
	RoomDefenseSpot,
	MobsAggro,
	ShortRangeHero,
	LongRangeHero,
	HeroLure,
	HeroWithCrystal,
	Crystal,
	NPC,
	FreeHero,
	Room,
	Door,
	Stealth,
	SelfDestruct,
	Stele,
	Hero,
	Mob,
	DustFactory,
	Tamer
}
public enum AITargetRPC
{
	DoSetActor,
	DoUnsetActor,
	DoInflictTrouble,
	DoInflictPoison,
	DoInflictAttackBurn
}
public class AITarget : MonoBehaviour
{
	public delegate void SetActorHandler();

	[SerializeField]
	protected AITargetType type;

	[SerializeField]
	protected AIInteraction interaction;

	[SerializeField]
	protected bool uniqueActor;

	[SerializeField]
	protected bool autoInitOnStart;

	protected float actorSetTime;

	private static Dictionary<StaticString, List<AITarget>> activeTargetsByKey = new Dictionary<StaticString, List<AITarget>>();

	private GameNetworkManager gameNetManager;

	private ITimeSynchronizationService timeSyncManager;

	private Mob mob;

	private UnityEngine.Component _actorUniqueComp;

	private AI _actor;

	public Transform Tfm
	{
		get;
		private set;
	}

	public Health HealthCpnt
	{
		get;
		set;
	}

	public RoomElement RoomElement
	{
		get;
		private set;
	}

	public bool IsActive
	{
		get;
		private set;
	}

	public AITargetType Type => type;

	public AIInteraction Interaction => interaction;

	public StaticString TargetKey
	{
		get;
		private set;
	}

	public SimMonoBehaviour SimMB
	{
		get;
		private set;
	}

	public bool UniqueActor => uniqueActor;

	public UniqueIDNetSyncElement NetSyncElement
	{
		get;
		private set;
	}

	public AI Actor
	{
		get;
		private set;
	}

	public UniqueID UniqueID
	{
		get;
		private set;
	}

	public Mob Mob => mob;

	public event SetActorHandler OnActorChanged;

	public static StaticString GetTargetKey(AITarget target)
	{
		return GetTargetKey(target.Type, target.Interaction);
	}

	public static StaticString GetTargetKey(AITargetType type, AIInteraction interaction)
	{
		return $"{(int)type}_{(int)interaction}";
	}

	public static List<AITarget> GetActiveTargets(StaticString targetKey)
	{
		AssertTargetTypeIsDefined(targetKey);
		return activeTargetsByKey[targetKey];
	}

	public static void ClearActiveTargets()
	{
		activeTargetsByKey.Clear();
	}

	public void Init(bool isActive = true)
	{
		if (type == AITargetType.SelfDestruct)
		{
			Diagnostics.LogError(base.name + " > AI target type undefined!");
		}
		TargetKey = GetTargetKey(this);
		SetActive(isActive);
		if (HealthCpnt != null)
		{
			HealthCpnt.OnDeath += OnDeath;
		}
	}

	public void Init(bool isActive, AITargetType forcedType)
	{
		type = forcedType;
		Init(isActive);
	}

	public void Init(AITargetType type, AIInteraction interaction)
	{
		this.interaction = interaction;
		Init(isActive: true, type);
	}

	public void UpdateType(AITargetType newType)
	{
		if (type != newType)
		{
			bool isActive = IsActive;
			if (isActive)
			{
				SetActive(active: false);
			}
			type = newType;
			TargetKey = GetTargetKey(this);
			if (isActive)
			{
				SetActive(active: true);
			}
		}
	}

	public void SendRPCToAll(AITargetRPC rpc, params object[] args)
	{
		gameNetManager.SendRPCToAll(RPCProxyName.AITarget_RPC, UniqueID.GetCategory(), UniqueID.ID, TargetKey, (int)rpc, args);
	}

	public void SendRPCToOthers(AITargetRPC rpc, params object[] args)
	{
		gameNetManager.SendRPCToOthers(RPCProxyName.AITarget_RPC, UniqueID.GetCategory(), UniqueID.ID, TargetKey, (int)rpc, args);
	}

	public void SendRPCToServer(AITargetRPC rpc, params object[] args)
	{
		gameNetManager.SendRPCToServer(RPCProxyName.AITarget_RPC, UniqueID.GetCategory(), UniqueID.ID, TargetKey, (int)rpc, args);
	}

	public void SendRPCToPlayer(ulong playerID, AITargetRPC rpc, params object[] args)
	{
		gameNetManager.SendRPCToPlayer(playerID, RPCProxyName.AITarget_RPC, UniqueID.GetCategory(), UniqueID.ID, TargetKey, (int)rpc, args);
	}

	public void SetActor(AI actor)
	{
		if (Actor == actor)
		{
			Diagnostics.LogWarning(base.name + " > SetActor: current actor is already " + actor.name);
		}
		else if (uniqueActor || Actor == null)
		{
			SendRPCToAll(AITargetRPC.DoSetActor, actor.UniqueID.GetCategory(), actor.UniqueID.ID, timeSyncManager.Time.RoundWithDecimals(2));
		}
	}

	private void RPC_DoSetActor(StaticString actorCategory, int actorID, float netTime)
	{
		_actorUniqueComp = UniqueIDManager.Get(actorCategory, actorID, out UniqueIDGetError error, logError: false);
		if (_actorUniqueComp == null)
		{
			if (error == UniqueIDGetError.ObjectIsNull)
			{
				Diagnostics.Log("{0} > RPC_DoSetActor: Unable to find actor {1}#{2} (already dead&destroyed)", base.name, actorCategory, actorID);
			}
			else
			{
				Diagnostics.LogError("{0} > RPC_DoSetActor: Unable to find actor {1}#{2} (error={3})", base.name, actorCategory, actorID, error);
			}
			return;
		}
		_actor = _actorUniqueComp.GetComponent<AI>();
		if (_actor == null)
		{
			Diagnostics.LogError(base.name + " > RPC_DoSetActor: Unable to find actor's AI component");
			return;
		}
		if (Actor == _actor && uniqueActor)
		{
			Diagnostics.LogWarning(base.name + " > RPC_DoSetActor: current actor is already " + _actor.name);
			return;
		}
		if (uniqueActor && Actor != null && actorSetTime < netTime)
		{
			if (Actor.NetSyncElement.IsOwnedByLocalPlayer() && !_actor.NetSyncElement.IsOwnedByLocalPlayer())
			{
				Diagnostics.Log("{0} > AITarget({1}/{2}).RPC_DoSetActor({3}): another unique actor is already set! ({4} @ {5})", base.name, type.ToString(), interaction, _actor.name, Actor.name, actorSetTime);
			}
			else
			{
				Diagnostics.LogError("{0} > AITarget({1}/{2}).RPC_DoSetActor({3}): another unique actor is already set! ({4} @ {5})", base.name, type.ToString(), interaction, _actor.name, Actor.name, actorSetTime);
			}
			return;
		}
		Actor = _actor;
		actorSetTime = netTime;
		if (this.OnActorChanged != null)
		{
			this.OnActorChanged();
		}
	}

	public void UnsetActor()
	{
		if (!(Actor == null))
		{
			SendRPCToAll(AITargetRPC.DoUnsetActor);
		}
	}

	private void RPC_DoUnsetActor()
	{
		if (!(Actor == null))
		{
			Actor = null;
		}
	}

	public Room GetCurrentRoom()
	{
		return RoomElement.ParentRoom;
	}

	public virtual Vector3 GetPosition()
	{
		return Tfm.position;
	}

	public void SetActive(bool active)
	{
		if (!IsActive && active)
		{
			AssertTargetTypeIsDefined(TargetKey);
			activeTargetsByKey[TargetKey].Add(this);
			IsActive = true;
		}
		else if (IsActive && !active)
		{
			activeTargetsByKey[TargetKey].Remove(this);
			IsActive = false;
		}
	}

	public virtual bool CanBeAttacked()
	{
		return interaction == AIInteraction.Attack || interaction == AIInteraction.Follow;
	}

	public virtual bool CanBeFollowedBy(AI ai)
	{
		return false;
	}

	public bool IsHero()
	{
		return Type == AITargetType.ShortRangeHero || Type == AITargetType.LongRangeHero || Type == AITargetType.HeroWithCrystal;
	}

	public void InflictTrouble(int attackerLevel = 1)
	{
		SendRPCToAll(AITargetRPC.DoInflictTrouble, attackerLevel);
	}

	private void RPC_DoInflictTrouble(int attackerLevel)
	{
		SimMB.AddSimDescriptor("Mob_Troubled_LVL" + attackerLevel);
	}

	public void InflictPoison(int attackerLevel)
	{
		SendRPCToAll(AITargetRPC.DoInflictPoison, attackerLevel);
	}

	private void RPC_DoInflictPoison(int attackerLevel)
	{
		SimMB.AddSimDescriptor("Poison_LVL" + attackerLevel);
	}

	public void InflictAttackBurn(float damages, float duration, StaticString attackTypeName)
	{
		if (damages != 0f && duration != 0f)
		{
			SendRPCToAll(AITargetRPC.DoInflictAttackBurn, damages, duration, attackTypeName);
		}
	}

	private void RPC_DoInflictAttackBurn(float damages, float duration, StaticString attackTypeName)
	{
		SimulationDescriptor simulationDescriptor = new SimulationDescriptor();
		SimulationPropertyDescriptor[] properties = new SimulationPropertyDescriptor[1]
		{
			new SimulationPropertyDescriptor(SimulationProperties.Duration, duration)
		};
		SimulationModifierDescriptor[] modifiers = new SimulationModifierDescriptor[2]
		{
			new SingleSimulationModifierDescriptor(SimulationProperties.DamageOverTime, SimulationModifierDescriptor.ModifierOperation.Addition, damages),
			new SingleSimulationModifierDescriptor(string.Concat(attackTypeName, SimulationProperties.AttackBurnSuffix), SimulationModifierDescriptor.ModifierOperation.Addition, 1f)
		};
		simulationDescriptor.Load(attackTypeName, "AttackBurn", properties, modifiers);
		SimMB.AddSimDescriptor(simulationDescriptor);
	}

	protected virtual void Awake()
	{
		HealthCpnt = GetComponent<Health>();
		RoomElement = GetComponent<RoomElement>();
		UniqueID = GetComponent<UniqueID>();
		SimMB = GetComponent<SimMonoBehaviour>();
		mob = GetComponent<Mob>();
		NetSyncElement = GetComponent<UniqueIDNetSyncElement>();
		Tfm = base.transform;
		timeSyncManager = Services.GetService<ITimeSynchronizationService>();
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		if (!string.IsNullOrEmpty(dungeon.ShipConfig.ForbiddenAITarget) && dungeon.ShipConfig.ForbiddenAITarget == Interaction.ToString())
		{
			UnityEngine.Object.Destroy(this);
		}
	}

	protected virtual void Start()
	{
		if (autoInitOnStart)
		{
			Init(GetComponent<RoomElement>());
		}
	}

	private static void AssertTargetTypeIsDefined(StaticString targetKey)
	{
		if (!activeTargetsByKey.ContainsKey(targetKey))
		{
			activeTargetsByKey[targetKey] = new List<AITarget>();
		}
	}

	private void OnDeath(ulong attackerOwnerPlayerID)
	{
		SetActive(active: false);
	}
}
public class CombatExcluderDetector : MonoBehaviour
{
	[SerializeField]
	private LayerMask combatExcluderLM;

	public int CombatExcluderCount
	{
		get;
		private set;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (combatExcluderLM.ContainLayer(other.gameObject.layer))
		{
			CombatExcluderCount++;
			if (CombatExcluderCount <= 0)
			{
				Diagnostics.LogError(base.name + " > OnTriggerEnter: combatExcluderCount should be > 0!");
			}
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (combatExcluderLM.ContainLayer(other.gameObject.layer))
		{
			CombatExcluderCount--;
			if (CombatExcluderCount < 0)
			{
				Diagnostics.LogError(base.name + " > OnTriggerExit: combatExcluderCount should be >= 0!");
			}
		}
	}
}
public class HeroAI : MovableAI
{
	private Hero hero;

	protected override void Awake()
	{
		base.Awake();
		hero = GetComponent<Hero>();
	}

	protected override void Loot(AITarget target)
	{
		Item component = target.GetComponent<Item>();
		if (component == null)
		{
			Diagnostics.LogError("Invalid target for Loot interaction!");
		}
		else
		{
			hero.MoveToItem(component);
		}
	}

	protected override void Operate(AITarget target)
	{
		MajorModule component = target.GetComponent<MajorModule>();
		if (component == null)
		{
			Diagnostics.LogError("Invalid target for Operate interaction!");
		}
		else if (component.IsPowered)
		{
			if (target.GetCurrentRoom() == GetCurrentRoom() && dungeon.GetSqrDistance(base.transform.position, component.transform.position) <= component.OperatingDist * component.OperatingDist)
			{
				hero.OperateModule(component);
			}
			else
			{
				moverCpnt.MoveToPosition(component.transform.position, null, forceRePath: false, component.OperatingDist);
			}
		}
	}

	protected override void Repair(AITarget target)
	{
		Module component = target.GetComponent<Module>();
		if (component == null)
		{
			Diagnostics.LogError("Invalid target for Repair interaction!");
		}
		else if (target.GetCurrentRoom() == GetCurrentRoom() && dungeon.GetSqrDistance(base.transform.position, component.transform.position) <= component.RepairingDist * component.RepairingDist)
		{
			hero.RepairModule(component);
		}
		else
		{
			moverCpnt.MoveToPosition(component.transform.position, null, forceRePath: false, component.RepairingDist);
		}
	}
}
public class MobAI : MovableAI
{
	private Mob mob;

	protected override void Awake()
	{
		base.Awake();
		mob = GetComponent<Mob>();
	}

	public override void Init(string classDescName, bool autoStartAI = true)
	{
		base.Init(classDescName, autoStartAI);
		if (_targets != null && _targets.Count == 0 && attackerCpnt != null && targetInteractionConfigsByKey != null && targetInteractionConfigsByKey.Count == 0)
		{
			attackerCpnt.CheckSelfDestruct();
		}
	}

	protected override void Loot(AITarget target)
	{
		Diagnostics.LogError("A mob cannot loot!");
	}

	protected override void Operate(AITarget target)
	{
		Diagnostics.LogError("A mob cannot operate!");
	}

	protected override void Repair(AITarget target)
	{
		Diagnostics.LogError("A mob cannot repair!");
	}

	public override bool CanAttack(bool ignoreTamer = true)
	{
		if (!ignoreTamer && mob.Tamer != null && base.CurrentTarget.Interaction == AIInteraction.Follow)
		{
			return false;
		}
		return base.CanAttack();
	}
}
public class ModuleAI : AI
{
	private Module module;

	protected override void Awake()
	{
		base.Awake();
		module = GetComponent<Module>();
	}

	protected override void Attack(AITarget target, bool canAttack = true)
	{
		if (!module.CanAttack)
		{
			return;
		}
		if (debug)
		{
			Diagnostics.LogWarning(base.name + " Attack " + target.name);
		}
		float simPropertyValue = simMB.GetSimPropertyValue(SimulationProperties.AttackRange);
		Vector3 tileSize = SingletonManager.Get<Dungeon>().GetTileSize();
		float num = simPropertyValue * tileSize.x;
		if (debug)
		{
			Diagnostics.Log("attackRange=" + num);
			Diagnostics.Log("distance=" + Vector3.Distance(base.transform.position, target.Tfm.position));
			Diagnostics.Log("target.CanBeAttacked=" + target.CanBeAttacked());
			Diagnostics.Log("target.GetCurrentRoom=" + target.GetCurrentRoom());
			Diagnostics.Log("this.GetCurrentRoom=" + GetCurrentRoom());
		}
		if (target.CanBeAttacked() && target.GetCurrentRoom() == GetCurrentRoom() && dungeon.GetSqrDistance(base.transform.position, target.Tfm.position) <= num * num)
		{
			if (debug)
			{
				Diagnostics.Log("TARGET IN RANGE: ATTACK");
			}
			attackerCpnt.SetTarget(target);
		}
	}

	protected override void Loot(AITarget target)
	{
		Diagnostics.LogError("A module cannot loot! https://dl.dropboxusercontent.com/u/24322340/LOL/whatdidyouexpect.gif");
	}

	protected override void Operate(AITarget target)
	{
		Diagnostics.LogError("A module cannot operate! https://dl.dropboxusercontent.com/u/24322340/LOL/whatdidyouexpect.gif");
	}

	protected override void Repair(AITarget target)
	{
		Diagnostics.LogError("A module cannot repair! https://dl.dropboxusercontent.com/u/24322340/LOL/whatdidyouexpect.gif");
	}

	protected override void Defend(AITarget target)
	{
		Diagnostics.LogError("A module cannot defend! https://dl.dropboxusercontent.com/u/24322340/LOL/whatdidyouexpect.gif");
	}
}
public abstract class MovableAI : AI
{
	[SerializeField]
	protected float defenseDist;

	[SerializeField]
	protected bool useFlanking;

	[SerializeField]
	protected float flankMaxAngle = 60f;

	[SerializeField]
	protected float flankMaxDist = 30f;

	[SerializeField]
	protected bool waitForTargetToBeAttackable;

	[SerializeField]
	private CombatExcluderDetector combatExcluderDetector;

	private Transform tfm;

	private float flankAngle;

	private float flankDist = -1f;

	private Vector3 lastFlankRefPosition;

	private Vector3 lastFlankPosition;

	public virtual bool CanAttack(bool ignoreTame = true)
	{
		return attackerCpnt.CanAttack && combatExcluderDetector.CombatExcluderCount <= 0;
	}

	protected override void Awake()
	{
		base.Awake();
		tfm = base.transform;
	}

	protected override void Attack(AITarget target, bool canAttack = true)
	{
		Room currentRoom = GetCurrentRoom();
		Room currentRoom2 = target.GetCurrentRoom();
		if (!currentRoom2.IsFullyOpened)
		{
			if (debug)
			{
				Diagnostics.Log(base.name + " is waiting on target room " + currentRoom2.ToString() + " to be initialized");
			}
			return;
		}
		float simPropertyValue = simMB.GetSimPropertyValue(SimulationProperties.AttackRange);
		Vector3 tileSize = SingletonManager.Get<Dungeon>().GetTileSize();
		float num = simPropertyValue * tileSize.x;
		if (debug)
		{
			Diagnostics.Log("currentRoom=" + currentRoom);
			Diagnostics.Log("targetRoom=" + currentRoom2);
			Diagnostics.Log("distance=" + dungeon.GetDistance(tfm.position, target.Tfm.position));
		}
		Vector3 position = target.GetPosition();
		if (CanAttack() && target.CanBeAttacked() && currentRoom2 == currentRoom && dungeon.GetSqrDistance(tfm.position, position) <= num * num)
		{
			if (debug)
			{
				Diagnostics.Log("TARGET IN RANGE: ATTACK");
			}
			if (canAttack)
			{
				attackerCpnt.SetTarget(target);
			}
			return;
		}
		if (debug)
		{
			Diagnostics.Log("TARGET OUT OF RANGE: MOVE TO");
		}
		if (currentRoom2 == currentRoom)
		{
			if (!CanAttack(ignoreTame: false))
			{
				moverCpnt.MoveToPosition(currentRoom2.CenterPosition);
			}
			else if (!target.CanBeAttacked())
			{
				if (waitForTargetToBeAttackable)
				{
					if (moverCpnt.IsMoving)
					{
						moverCpnt.StopMove();
					}
				}
				else
				{
					moverCpnt.MoveToPosition(position);
				}
			}
			else if (useFlanking)
			{
				moverCpnt.MoveToPosition(GetFlankingPosition(position));
			}
			else
			{
				moverCpnt.MoveToPosition(position);
			}
		}
		else
		{
			moverCpnt.MoveToPosition(currentRoom2.CenterPosition);
		}
	}

	private Vector3 GetFlankingPosition(Vector3 targetPos)
	{
		Vector3 result = lastFlankPosition;
		if (targetPos != lastFlankRefPosition)
		{
			if (flankDist < 0f)
			{
				flankAngle = RandomGenerator.RangeFloat(0f - flankMaxAngle, flankMaxAngle);
				float simPropertyValue = simMB.GetSimPropertyValue(SimulationProperties.AttackRange);
				Vector3 tileSize = SingletonManager.Get<Dungeon>().GetTileSize();
				float num = simPropertyValue * tileSize.x;
				flankDist = RandomGenerator.RangeFloat(Mathf.Min(num / 2f, flankMaxDist), Mathf.Min(num, flankMaxDist));
			}
			Vector3 vector = tfm.position - targetPos;
			Vector3 b = flankDist * (Quaternion.Euler(0f, flankAngle, 0f) * vector.normalized);
			result = (Vector3)Mover.GetClosestWalkableNodeFromPosition(targetPos + b).position;
			lastFlankRefPosition = targetPos;
			lastFlankPosition = result;
		}
		return result;
	}

	protected override void Defend(AITarget target)
	{
		if (dungeon.GetSqrDistance(tfm.position, target.Tfm.position) > defenseDist * defenseDist)
		{
			moverCpnt.MoveToPosition(target.Tfm.position);
		}
	}

	protected override void OnDeath(ulong attackerOwnerPlayerID)
	{
		base.OnDeath(attackerOwnerPlayerID);
		combatExcluderDetector.GetComponent<Collider>().enabled = false;
	}
}
public class MovableAITarget : AITarget
{
	[SerializeField]
	private CombatExcluderDetector combatExcluderDetector;

	public GameObject AuthorizedFollower
	{
		get;
		set;
	}

	public override bool CanBeAttacked()
	{
		return base.CanBeAttacked() && (combatExcluderDetector == null || combatExcluderDetector.CombatExcluderCount <= 0);
	}

	public override bool CanBeFollowedBy(AI ai)
	{
		return ai.gameObject == AuthorizedFollower;
	}
}
public class RoomAITarget : AITarget
{
	public override Vector3 GetPosition()
	{
		return GetCurrentRoom().CenterPosition;
	}
}
public class AchievementManagerDOTE : MonoBehaviour
{
	private NetworkAchievementManager networkAchievementManager;

	private LocalAchievementManagerDOTE localAchievementManager;

	private bool needsToCommitNetwork;

	private XboxOneManager xboxEventService;

	private AchievementName[] shipWinnerAchievements;

	private UnityEngine.Component[] albumPictures;

	private void Awake()
	{
	}

	private void Start()
	{
		localAchievementManager = GetComponentInChildren<LocalAchievementManagerDOTE>();
		networkAchievementManager = GetComponentInChildren<NetworkAchievementManager>();
		needsToCommitNetwork = false;
		Diagnostics.Assert(localAchievementManager != null);
		localAchievementManager.OnAchievementAchieved += CheckNewUnlocks;
		if (networkAchievementManager == null)
		{
			Diagnostics.LogWarning("Network achievements disabled");
		}
		else
		{
			localAchievementManager.SetNetworkAchievementManager(networkAchievementManager);
			NetworkAchievementManager obj = networkAchievementManager;
			obj.OnStatisticSet = (EventHandler<EventArgs>)Delegate.Combine(obj.OnStatisticSet, new EventHandler<EventArgs>(OnNetworkStatChanged));
		}
		if (networkAchievementManager != null && networkAchievementManager is SteamAchievementManager)
		{
			(networkAchievementManager as SteamAchievementManager).OnLoadingFinished += AchievementManagerDOTE_OnSteamAchivementManagerLoadingFinished;
		}
		Room.OnHeroEnteredOrExitedExitRoom += Room_OnHeroEnteredOrExitedExitRoom;
	}

	public void Load()
	{
		localAchievementManager.Load();
	}

	private void AchievementManagerDOTE_OnSteamAchivementManagerLoadingFinished()
	{
		Load();
	}

	public void IncrementStatistic(StatisticName stat, bool commit = false)
	{
		if (!HashManager.IsHashDifferent)
		{
			if (localAchievementManager.HasStatistic(stat.ToString()))
			{
				localAchievementManager.IncrementStatistic(stat.ToString(), commit);
			}
			else if (networkAchievementManager != null)
			{
				networkAchievementManager.IncrementStatistic(stat.ToString(), commit);
			}
		}
	}

	public void AddToStatistic(StatisticName stat, float value, bool commit = false)
	{
		if (!HashManager.IsHashDifferent)
		{
			if (localAchievementManager.HasStatistic(stat.ToString()))
			{
				localAchievementManager.AddToStatistic(stat.ToString(), value, commit);
			}
			else if (networkAchievementManager != null)
			{
				networkAchievementManager.AddToStatistic(stat.ToString(), value, commit);
			}
		}
	}

	public void SetStatisticValue(StatisticName stat, float value, bool commit = false)
	{
		if (!HashManager.IsHashDifferent)
		{
			if (localAchievementManager.HasStatistic(stat.ToString()))
			{
				localAchievementManager.SetStatisticValue(stat.ToString(), value, commit);
			}
			else if (networkAchievementManager != null)
			{
				networkAchievementManager.SetStatisticValue(stat.ToString(), value, commit);
			}
		}
	}

	public float GetStatisticValue(StatisticName stat)
	{
		if (localAchievementManager.HasStatistic(stat.ToString()))
		{
			return localAchievementManager.GetStatisticValue(stat.ToString());
		}
		if (networkAchievementManager != null)
		{
			return networkAchievementManager.GetStatisticValue(stat.ToString());
		}
		return 0f;
	}

	public bool GetAchievement(AchievementName achievement, bool reCheckAchievement = false)
	{
		if (!HashManager.IsHashDifferent)
		{
			LocalAchievement localAchievementData = localAchievementManager.GetLocalAchievementData(achievement.ToString());
			LocalAchievementStatistic localAchievementStatistic = null;
			if (localAchievementData != null)
			{
				localAchievementStatistic = localAchievementManager.GetStatistic(localAchievementData.StatisticName);
			}
			if (localAchievementData != null && localAchievementData.Network && localAchievementStatistic != null && localAchievementStatistic.Volatile)
			{
				if (networkAchievementManager != null)
				{
					return networkAchievementManager.GetAchievement(achievement.ToString());
				}
				return false;
			}
			if (localAchievementManager.HasAchievement(achievement.ToString()))
			{
				return localAchievementManager.GetAchievement(achievement.ToString());
			}
			if (networkAchievementManager != null)
			{
				return networkAchievementManager.GetAchievement(achievement.ToString());
			}
			return false;
		}
		return false;
	}

	public void SetAchievement(AchievementName achievement)
	{
		if (!HashManager.IsHashDifferent)
		{
			if (localAchievementManager.HasAchievement(achievement.ToString()))
			{
				localAchievementManager.SetAchievement(achievement.ToString());
			}
			else
			{
				networkAchievementManager.SetAchievement(achievement.ToString());
			}
		}
	}

	public void Commit()
	{
		if (!HashManager.IsHashDifferent)
		{
			localAchievementManager.Commit();
			if (networkAchievementManager != null)
			{
				networkAchievementManager.Commit();
				needsToCommitNetwork = false;
			}
		}
	}

	private void CheckCommitNetworkUpdate()
	{
		if (needsToCommitNetwork)
		{
			Commit();
		}
	}

	private void OnNetworkStatChanged(object sender, EventArgs e)
	{
		needsToCommitNetwork = true;
	}

	public void PrintGlobalStats()
	{
		SteamAchievementManager steamAchievementManager = networkAchievementManager as SteamAchievementManager;
		if (steamAchievementManager != null)
		{
			StatisticName[] array = (StatisticName[])Enum.GetValues(typeof(StatisticName));
			Dictionary<StaticString, long> dictionary = new Dictionary<StaticString, long>();
			for (int i = 88; i < array.Length; i++)
			{
				long networkGlobalStatisticInteger = steamAchievementManager.GetNetworkGlobalStatisticInteger(array[i].ToString());
				if (networkGlobalStatisticInteger != 0L)
				{
					dictionary.Add(array[i].ToString(), networkGlobalStatisticInteger);
				}
			}
			Diagnostics.Log("Pulled " + dictionary.Count + " global stats from Steam");
			foreach (KeyValuePair<StaticString, long> item in dictionary)
			{
				Diagnostics.Log((string)item.Key + " = " + item.Value);
			}
		}
		else
		{
			Diagnostics.LogError("Global stats are only available when using Steam");
		}
	}

	public void PrintLocalStatistics()
	{
		localAchievementManager.PrintAllStatistics();
	}

	public void PrintNetworkStatistics()
	{
		if (networkAchievementManager != null)
		{
			networkAchievementManager.PrintAllStatistics();
		}
	}

	public void PrintLocalAchievements()
	{
		localAchievementManager.PrintAllAchievements();
	}

	public void PrintNetworkAchievements()
	{
		if (networkAchievementManager != null)
		{
			networkAchievementManager.PrintAllAchievements();
		}
	}

	public void ResetLocalStatistics()
	{
		localAchievementManager.ResetAllStatistics();
	}

	public void ResetLocalAchievements()
	{
		localAchievementManager.ResetAllAchievements();
	}

	public void ResetNetworkStatistics()
	{
		if (networkAchievementManager != null)
		{
			networkAchievementManager.ResetAllStatistics();
		}
	}

	public void ResetAllStatistics()
	{
		ResetLocalStatistics();
		ResetNetworkStatistics();
	}

	public void ResetVolatileStats(bool commit = true)
	{
		localAchievementManager.ResetVolatileStats();
	}

	public void AchievedEverything()
	{
		AchievementName[] array = (AchievementName[])Enum.GetValues(typeof(AchievementName));
		AchievementName[] array2 = array;
		foreach (AchievementName achievement in array2)
		{
			SetAchievement(achievement);
		}
		Commit();
	}

	public void CheckAchievement(AchievementName achievement)
	{
		localAchievementManager.CheckAchievement(localAchievementManager.GetAchievementData(achievement.ToString()));
	}

	public void CheckHeroUnlocks()
	{
		List<HeroGameStatsData> heroesGameStats = UserProfile.Data.HeroesGameStats;
		for (int i = 0; i < heroesGameStats.Count; i++)
		{
			HeroGameStatsData heroGameStatsData = heroesGameStats[i];
			if (heroGameStatsData.Status == HeroStatus.Unlocked)
			{
				AchievementName achievement = (heroGameStatsData.ConfigName.ToString().ToUpper() + "_UNLOCKER").ToEnum<AchievementName>();
				StatisticName stat = (heroGameStatsData.ConfigName.ToString().ToUpper() + "_UNLOCKS").ToEnum<StatisticName>();
				if (!GetAchievement(achievement))
				{
					IncrementStatistic(stat);
				}
			}
		}
	}

	private void CheckNewUnlocks(string newAchievementName)
	{
		Dungeon dungeon = SingletonManager.Get<Dungeon>(mandatory: false);
		ShipUnlockData[] shipUnlocks = SingletonManager.Get<PrivateGameConfigManager>().ShipUnlocks;
		string a = null;
		ShipUnlockData[] array = shipUnlocks;
		for (int i = 0; i < array.Length; i++)
		{
			ShipUnlockData shipUnlockData = array[i];
			int num = 0;
			for (int j = 0; j < shipUnlockData.UnlockingAchievement.Count; j++)
			{
				if (GetAchievement(shipUnlockData.UnlockingAchievement[j]))
				{
					num++;
					if (num > 1)
					{
						break;
					}
					a = shipUnlockData.UnlockingAchievement[j].ToString();
				}
			}
			if (dungeon != null && num == 1 && a == newAchievementName)
			{
				dungeon.EnqueueUnlockNotification(AgeLocalizer.Instance.LocalizeString("%Notification_ShipUnlocked").Replace("$ShipName", AgeLocalizer.Instance.LocalizeString("%ShipTitle_" + shipUnlockData.ShipName)), NotificationType.MiscUnlock, null, "Unlock");
			}
		}
		Album album = SingletonManager.Get<Album>(mandatory: false);
		if (!(album != null))
		{
			return;
		}
		if (albumPictures == null)
		{
			albumPictures = SingletonManager.Get<Album>().GetComponentsInChildren(typeof(PictureAchievementUnlock), includeInactive: true);
		}
		if (albumPictures != null)
		{
			bool flag = false;
			UnityEngine.Component[] array2 = albumPictures;
			for (int k = 0; k < array2.Length; k++)
			{
				PictureAchievementUnlock pictureAchievementUnlock = (PictureAchievementUnlock)array2[k];
				if (dungeon != null && pictureAchievementUnlock.UnlockingAchievement.ToString() == newAchievementName)
				{
					dungeon.EnqueueUnlockNotification(AgeLocalizer.Instance.LocalizeString("%Notification_AlbumPictureUnlocked"), NotificationType.AlbumPicture, OnPictureNotificationClick, "AlbumPicture", foreGround: false, pictureAchievementUnlock.name);
					flag = true;
				}
			}
			if (flag)
			{
				int unlockedPictureCount = album.GetUnlockedPictureCount();
				SetStatisticValue(StatisticName.PICTURES_UNLOCKED, unlockedPictureCount);
			}
		}
		else
		{
			Diagnostics.LogError("Unable to retrieve album pictures!");
		}
	}

	private void OnPictureNotificationClick()
	{
		NotificationPanel notificationPanel = SingletonManager.Get<NotificationPanel>();
		if (!(notificationPanel != null))
		{
			return;
		}
		NotificationData currentNotification = notificationPanel.CurrentNotification;
		if (currentNotification == null || currentNotification.MessageType != NotificationType.AlbumPicture || string.IsNullOrEmpty(currentNotification.NotificationInformation))
		{
			return;
		}
		Album album = SingletonManager.Get<Album>();
		if (album != null)
		{
			IGameControlService service = Services.GetService<IGameControlService>();
			if (service.CanPauseGame())
			{
				service.SetGamePause(paused: true);
			}
			album.OpenAndShow(currentNotification.NotificationInformation);
		}
	}

	private void Room_OnHeroEnteredOrExitedExitRoom(Hero hero, bool enter)
	{
		if (hero.HasCrystal)
		{
			if (enter)
			{
				Invoke("TriggerLastStandAchievement", 60f);
			}
			else
			{
				CancelInvoke("TriggerLastStandAchievement");
			}
		}
	}

	private void TriggerLastStandAchievement()
	{
		IncrementStatistic(StatisticName.LAST_STAND);
	}

	public void AddAlwaysReleventStatistic(StaticString statisticName)
	{
		if (!localAchievementManager.AlwaysReleventStatistics.Contains(statisticName))
		{
			localAchievementManager.AlwaysReleventStatistics.Add(statisticName);
		}
	}
}
public enum StatisticName
{
	POD_VICTORY = 2,
	ARMORY_VICTORY = 3,
	INFIRMARY_VICTORY = 4,
	LIBRARY_VICTORY = 50,
	REFREEZERATOR_VICTORY = 51,
	SANITARY_VICTORY = 52,
	ORGANIC_VICTORY = 452,
	DOORS_OPENED = 1,
	HERO_DEATH_NEGATIVE = 5,
	EVERY_DOOR_VICTORY = 6,
	HEAL_FOOD_USED = 7,
	CRYSTAL_HITS_NEGATIVE = 53,
	FULL_TEAM = 8,
	MAX_LEVEL_HEROES = 9,
	DRILL_LEVELS = 10,
	PAUSE_USES_NEGATIVE = 11,
	BEST_FLOOR = 12,
	MODULES_BUILT_CURRENT_FLOOR = 54,
	FIS_STOCK = 55,
	MULTIPLAYER_VICTORIES = 56,
	MULTIPLAYER_BEST_FLOOR = 58,
	RESEARCHED_ALL = 232,
	PICTURES_UNLOCKED = 233,
	HERO_H0001_VICTORY = 13,
	HERO_H0002_VICTORY = 14,
	HERO_H0003_VICTORY = 0xF,
	HERO_H0004_VICTORY = 0x10,
	HERO_H0005_VICTORY = 17,
	HERO_H0006_VICTORY = 18,
	HERO_H0007_VICTORY = 19,
	HERO_H0008_VICTORY = 20,
	HERO_H0009_VICTORY = 21,
	HERO_H0010_VICTORY = 22,
	HERO_H0011_VICTORY = 23,
	HERO_H0012_VICTORY = 24,
	HERO_H0013_VICTORY = 25,
	HERO_H0014_VICTORY = 26,
	HERO_H0015_VICTORY = 27,
	HERO_H0016_VICTORY = 28,
	HERO_H0017_VICTORY = 29,
	HERO_H0018_VICTORY = 30,
	HERO_H0019_VICTORY = 0x1F,
	HERO_H0020_VICTORY = 0x20,
	N_TRASHS_KILLED = 33,
	N_FLYINGS_KILLED = 34,
	N_CRYSTOPHILES_KILLED = 35,
	N_HUNTERS_KILLED = 36,
	N_KAMIKAZES_KILLED = 37,
	S_TRASHS_KILLED = 38,
	S_BULLDOZERS_KILLED = 39,
	S_SUPPORTERS_KILLED = 40,
	S_ZONERS_KILLED = 41,
	C_TRASHS_KILLED = 42,
	C_DEBUFFERS_KILLED = 43,
	C_KAMIKAZES_KILLED = 44,
	C_KEEPERS_KILLED = 45,
	H_HUNTERS_KILLED = 46,
	H_DOOROPENERS_KILLED = 47,
	H_DEBUFFERS_KILLED = 48,
	V_VULTUS_KILLED = 460,
	V_TRASHS_KILLED = 461,
	V_DEBUFFERS_KILLED = 462,
	H_ASSASSINS_KILLED = 491,
	H_ZONERS_KILLED = 492,
	HURNAS_FAMILY_KILLED = 463,
	HERO_H0001_UNLOCKS = 68,
	HERO_H0002_UNLOCKS = 69,
	HERO_H0003_UNLOCKS = 70,
	HERO_H0004_UNLOCKS = 71,
	HERO_H0005_UNLOCKS = 72,
	HERO_H0006_UNLOCKS = 73,
	HERO_H0007_UNLOCKS = 74,
	HERO_H0008_UNLOCKS = 75,
	HERO_H0009_UNLOCKS = 76,
	HERO_H0010_UNLOCKS = 67,
	HERO_H0011_UNLOCKS = 77,
	HERO_H0012_UNLOCKS = 78,
	HERO_H0013_UNLOCKS = 79,
	HERO_H0014_UNLOCKS = 80,
	HERO_H0015_UNLOCKS = 81,
	HERO_H0016_UNLOCKS = 82,
	HERO_H0017_UNLOCKS = 83,
	HERO_H0018_UNLOCKS = 84,
	HERO_H0019_UNLOCKS = 85,
	HERO_H0020_UNLOCKS = 86,
	ANY_HERO_UNLOCKS = 87,
	MAJORMODULE_MAJOR0001_LEVEL = 182,
	MAJORMODULE_MAJOR0002_LEVEL = 183,
	MAJORMODULE_MAJOR0003_LEVEL = 184,
	MAJORMODULE_MAJOR0004_LEVEL = 185,
	MAJORMODULE_MAJOR0005_LEVEL = 186,
	MAJORMODULE_MAJOR0006_LEVEL = 187,
	MAJORMODULE_MAJOR0007_LEVEL = 188,
	MAJORMODULE_MAJOR0008_LEVEL = 189,
	MAJORMODULE_MAJOR0009_LEVEL = 190,
	MAJORMODULE_MAJOR0010_LEVEL = 191,
	MINORMODULE_MINOR0001_LEVEL = 192,
	MINORMODULE_MINOR0002_LEVEL = 193,
	MINORMODULE_MINOR0003_LEVEL = 194,
	MINORMODULE_MINOR0004_LEVEL = 195,
	MINORMODULE_MINOR0005_LEVEL = 196,
	MINORMODULE_MINOR0006_LEVEL = 197,
	MINORMODULE_MINOR0007_LEVEL = 198,
	MINORMODULE_MINOR0008_LEVEL = 199,
	MINORMODULE_MINOR0009_LEVEL = 200,
	MINORMODULE_MINOR0010_LEVEL = 201,
	MINORMODULE_MINOR0011_LEVEL = 202,
	MINORMODULE_MINOR0012_LEVEL = 203,
	MINORMODULE_MINOR0013_LEVEL = 204,
	MINORMODULE_MINOR0014_LEVEL = 205,
	MINORMODULE_MINOR0015_LEVEL = 206,
	MINORMODULE_MINOR0016_LEVEL = 207,
	MINORMODULE_MINOR0017_LEVEL = 208,
	MINORMODULE_MINOR0018_LEVEL = 209,
	MINORMODULE_MINOR0019_LEVEL = 210,
	MINORMODULE_MINOR0020_LEVEL = 211,
	SAVIOR_PROGRESS = 220,
	KILLER_PROGRESS = 221,
	EXPERT_PROGRESS = 222,
	RESEARCHER_PROGRESS = 223,
	COLLECTOR_PROGRESS = 224,
	GAMES_ATTEMPTED_EASY = 225,
	GAMES_ATTEMPTED_NORMAL = 226,
	VICTORY_EASY = 227,
	VICTORY_NORMAL = 228,
	MOBS_KILLED = 229,
	HIRED_HEROES = 230,
	LOST_HEROES = 231,
	STORY_COMPLETED_WITH_HONOR = 239,
	STORY_COMPLETED_DOWNFALL = 240,
	STORY_COMPLETED_WHO_TALKED = 241,
	STORY_COMPLETED_HOTVENGEANCE = 242,
	STORY_COMPLETED_WHISKEY_TANGO_FOXTROT = 243,
	STORY_COMPLETED_THIEF_GUARD = 244,
	STORY_COMPLETED_MATTER_OF_TRUTHS = 245,
	STORY_COMPLETED_BUGEATER = 246,
	STORY_COMPLETED_HEAL_THE_LAME = 247,
	STORY_COMPLETED_FLAME_WARS = 248,
	STORY_COMPLETED_AUSTRALIUM = 249,
	RECRUITMENT_NEGATIVE = 250,
	EVERY_FACTION_VICTORY = 251,
	LAST_STAND = 252,
	HERO_H0001_SELECTED = 88,
	HERO_H0002_SELECTED = 89,
	HERO_H0003_SELECTED = 90,
	HERO_H0004_SELECTED = 91,
	HERO_H0005_SELECTED = 92,
	HERO_H0006_SELECTED = 93,
	HERO_H0007_SELECTED = 94,
	HERO_H0008_SELECTED = 95,
	HERO_H0009_SELECTED = 96,
	HERO_H0010_SELECTED = 100,
	HERO_H0011_SELECTED = 97,
	HERO_H0012_SELECTED = 98,
	HERO_H0013_SELECTED = 99,
	HERO_H0014_SELECTED = 101,
	HERO_H0015_SELECTED = 102,
	HERO_H0016_SELECTED = 103,
	HERO_H0017_SELECTED = 104,
	HERO_H0018_SELECTED = 105,
	HERO_H0019_SELECTED = 106,
	HERO_H0020_SELECTED = 107,
	HERO_RANDOM_SELECTED = 57,
	POD_SELECTED = 108,
	ARMORY_SELECTED = 109,
	INFIRMARY_SELECTED = 110,
	LIBRARY_SELECTED = 111,
	REFREEZERATOR_SELECTED = 112,
	SANITARY_SELECTED = 149,
	DRILL_SELECTED = 113,
	EASY_DIFFICULTY_SELECTED = 114,
	NORMAL_DIFFICULTY_SELECTED = 115,
	FLOOR_1_GAME_OVER = 116,
	FLOOR_2_GAME_OVER = 117,
	FLOOR_3_GAME_OVER = 118,
	FLOOR_4_GAME_OVER = 119,
	FLOOR_5_GAME_OVER = 120,
	FLOOR_6_GAME_OVER = 121,
	FLOOR_7_GAME_OVER = 122,
	FLOOR_8_GAME_OVER = 123,
	FLOOR_9_GAME_OVER = 124,
	FLOOR_10_GAME_OVER = 125,
	FLOOR_11_GAME_OVER = 126,
	FLOOR_12_GAME_OVER = 0x7F,
	ENDLESS_GAME_OVER = 0x80,
	FLOOR_1_HERO_DEATHS = 129,
	FLOOR_2_HERO_DEATHS = 130,
	FLOOR_3_HERO_DEATHS = 131,
	FLOOR_4_HERO_DEATHS = 132,
	FLOOR_5_HERO_DEATHS = 133,
	FLOOR_6_HERO_DEATHS = 134,
	FLOOR_7_HERO_DEATHS = 135,
	FLOOR_8_HERO_DEATHS = 136,
	FLOOR_9_HERO_DEATHS = 137,
	FLOOR_10_HERO_DEATHS = 138,
	FLOOR_11_HERO_DEATHS = 139,
	FLOOR_12_HERO_DEATHS = 140,
	ENDLESS_HERO_DEATHS = 141,
	MAJORMODULE_MAJOR0001_BUILT = 142,
	MAJORMODULE_MAJOR0002_BUILT = 143,
	MAJORMODULE_MAJOR0003_BUILT = 144,
	MAJORMODULE_MAJOR0004_BUILT = 145,
	MAJORMODULE_MAJOR0005_BUILT = 146,
	MAJORMODULE_MAJOR0006_BUILT = 147,
	MAJORMODULE_MAJOR0007_BUILT = 148,
	MAJORMODULE_MAJOR0008_BUILT = 149,
	MAJORMODULE_MAJOR0009_BUILT = 150,
	MAJORMODULE_MAJOR0010_BUILT = 151,
	MINORMODULE_MINOR0001_BUILT = 152,
	MINORMODULE_MINOR0002_BUILT = 153,
	MINORMODULE_MINOR0003_BUILT = 154,
	MINORMODULE_MINOR0004_BUILT = 155,
	MINORMODULE_MINOR0005_BUILT = 156,
	MINORMODULE_MINOR0006_BUILT = 157,
	MINORMODULE_MINOR0007_BUILT = 158,
	MINORMODULE_MINOR0008_BUILT = 159,
	MINORMODULE_MINOR0009_BUILT = 160,
	MINORMODULE_MINOR0010_BUILT = 161,
	MINORMODULE_MINOR0011_BUILT = 162,
	MINORMODULE_MINOR0012_BUILT = 163,
	MINORMODULE_MINOR0013_BUILT = 164,
	MINORMODULE_MINOR0014_BUILT = 165,
	MINORMODULE_MINOR0015_BUILT = 166,
	MINORMODULE_MINOR0016_BUILT = 167,
	MINORMODULE_MINOR0017_BUILT = 168,
	MINORMODULE_MINOR0018_BUILT = 169,
	MINORMODULE_MINOR0019_BUILT = 170,
	MINORMODULE_MINOR0020_BUILT = 171,
	ENDLESSDAY_SPECIALHERO_VICTORY = 300,
	HERO_H0021_VICTORY = 301,
	HERO_H0022_VICTORY = 302,
	HERO_H0023_VICTORY = 303,
	HERO_H0024_VICTORY = 304,
	HERO_H0025_VICTORY = 305,
	HERO_H0026_VICTORY = 306,
	HERO_H0027_VICTORY = 307,
	HERO_H0028_VICTORY = 308,
	HERO_H0029_VICTORY = 309,
	HERO_H0030_VICTORY = 310,
	HERO_H0031_VICTORY = 311,
	HERO_H0032_VICTORY = 312,
	HERO_H0033_VICTORY = 313,
	HERO_H0034_VICTORY = 314,
	HERO_H0035_VICTORY = 315,
	HERO_H0036_VICTORY = 316,
	HERO_H0037_VICTORY = 317,
	HERO_H0038_VICTORY = 318,
	HERO_H0039_VICTORY = 319,
	HERO_H0040_VICTORY = 320,
	HERO_H0041_VICTORY = 321,
	HERO_H0042_VICTORY = 322,
	HERO_H0043_VICTORY = 323,
	HERO_H0044_VICTORY = 324,
	HERO_H0045_VICTORY = 325,
	HERO_H0046_VICTORY = 326,
	HERO_H0047_VICTORY = 327,
	HERO_H0048_VICTORY = 328,
	HERO_H0049_VICTORY = 329,
	HERO_H0050_VICTORY = 330,
	HERO_H0021_UNLOCKS = 331,
	HERO_H0022_UNLOCKS = 332,
	HERO_H0023_UNLOCKS = 333,
	HERO_H0024_UNLOCKS = 334,
	HERO_H0025_UNLOCKS = 335,
	HERO_H0026_UNLOCKS = 336,
	HERO_H0027_UNLOCKS = 337,
	HERO_H0028_UNLOCKS = 338,
	HERO_H0029_UNLOCKS = 339,
	HERO_H0030_UNLOCKS = 340,
	HERO_H0031_UNLOCKS = 341,
	HERO_H0032_UNLOCKS = 342,
	HERO_H0033_UNLOCKS = 343,
	HERO_H0034_UNLOCKS = 344,
	HERO_H0035_UNLOCKS = 345,
	HERO_H0036_UNLOCKS = 346,
	HERO_H0037_UNLOCKS = 347,
	HERO_H0038_UNLOCKS = 348,
	HERO_H0039_UNLOCKS = 349,
	HERO_H0040_UNLOCKS = 350,
	HERO_H0041_UNLOCKS = 351,
	HERO_H0042_UNLOCKS = 352,
	HERO_H0043_UNLOCKS = 353,
	HERO_H0044_UNLOCKS = 354,
	HERO_H0045_UNLOCKS = 355,
	HERO_H0046_UNLOCKS = 356,
	HERO_H0047_UNLOCKS = 357,
	HERO_H0048_UNLOCKS = 358,
	HERO_H0049_UNLOCKS = 359,
	HERO_H0050_UNLOCKS = 360,
	HERO_H0021_SELECTED = 361,
	HERO_H0022_SELECTED = 362,
	HERO_H0023_SELECTED = 363,
	HERO_H0024_SELECTED = 364,
	HERO_H0025_SELECTED = 365,
	HERO_H0026_SELECTED = 366,
	HERO_H0027_SELECTED = 367,
	HERO_H0028_SELECTED = 368,
	HERO_H0029_SELECTED = 369,
	HERO_H0030_SELECTED = 370,
	HERO_H0031_SELECTED = 371,
	HERO_H0032_SELECTED = 372,
	HERO_H0033_SELECTED = 373,
	HERO_H0034_SELECTED = 374,
	HERO_H0035_SELECTED = 375,
	HERO_H0036_SELECTED = 376,
	HERO_H0037_SELECTED = 377,
	HERO_H0038_SELECTED = 378,
	HERO_H0039_SELECTED = 379,
	HERO_H0040_SELECTED = 380,
	HERO_H0041_SELECTED = 381,
	HERO_H0042_SELECTED = 382,
	HERO_H0043_SELECTED = 383,
	HERO_H0044_SELECTED = 384,
	HERO_H0045_SELECTED = 385,
	HERO_H0046_SELECTED = 386,
	HERO_H0047_SELECTED = 387,
	HERO_H0048_SELECTED = 388,
	HERO_H0049_SELECTED = 389,
	HERO_H0050_SELECTED = 390,
	ORGANIC_LEVELS = 400,
	ORGANIC_SELECTED = 401,
	VICTORY_ALL = 410,
	STORY_ALL = 411,
	MAJORMODULE_MAJOR0001_BEST_LEVEL = 422,
	MAJORMODULE_MAJOR0002_BEST_LEVEL = 423,
	MAJORMODULE_MAJOR0003_BEST_LEVEL = 424,
	MAJORMODULE_MAJOR0004_BEST_LEVEL = 425,
	MAJORMODULE_MAJOR0005_BEST_LEVEL = 426,
	MAJORMODULE_MAJOR0006_BEST_LEVEL = 427,
	MAJORMODULE_MAJOR0007_BEST_LEVEL = 428,
	MAJORMODULE_MAJOR0008_BEST_LEVEL = 429,
	MAJORMODULE_MAJOR0009_BEST_LEVEL = 430,
	MAJORMODULE_MAJOR0010_BEST_LEVEL = 431,
	MINORMODULE_MINOR0001_BEST_LEVEL = 432,
	MINORMODULE_MINOR0002_BEST_LEVEL = 433,
	MINORMODULE_MINOR0003_BEST_LEVEL = 434,
	MINORMODULE_MINOR0004_BEST_LEVEL = 435,
	MINORMODULE_MINOR0005_BEST_LEVEL = 436,
	MINORMODULE_MINOR0006_BEST_LEVEL = 437,
	MINORMODULE_MINOR0007_BEST_LEVEL = 438,
	MINORMODULE_MINOR0008_BEST_LEVEL = 439,
	MINORMODULE_MINOR0009_BEST_LEVEL = 440,
	MINORMODULE_MINOR0010_BEST_LEVEL = 441,
	MINORMODULE_MINOR0011_BEST_LEVEL = 442,
	MINORMODULE_MINOR0012_BEST_LEVEL = 443,
	MINORMODULE_MINOR0013_BEST_LEVEL = 444,
	MINORMODULE_MINOR0014_BEST_LEVEL = 445,
	MINORMODULE_MINOR0015_BEST_LEVEL = 446,
	MINORMODULE_MINOR0016_BEST_LEVEL = 447,
	MINORMODULE_MINOR0017_BEST_LEVEL = 448,
	MINORMODULE_MINOR0018_BEST_LEVEL = 449,
	MINORMODULE_MINOR0019_BEST_LEVEL = 450,
	MINORMODULE_MINOR0020_BEST_LEVEL = 451,
	N_TRASHS_TAMED = 470,
	N_FLYINGS_TAMED = 471,
	N_CRYSTOPHILES_TAMED = 472,
	N_HUNTERS_TAMED = 473,
	N_KAMIKAZES_TAMED = 474,
	S_TRASHS_TAMED = 475,
	S_BULLDOZERS_TAMED = 476,
	S_SUPPORTERS_TAMED = 477,
	S_ZONERS_TAMED = 478,
	C_TRASHS_TAMED = 479,
	C_DEBUFFERS_TAMED = 480,
	C_KAMIKAZES_TAMED = 481,
	C_KEEPERS_TAMED = 482,
	H_HUNTERS_TAMED = 483,
	H_DOOROPENERS_TAMED = 484,
	H_DEBUFFERS_TAMED = 485,
	V_VULTUS_TAMED = 486,
	V_TRASHS_TAMED = 487,
	V_DEBUFFERS_TAMED = 488,
	H_ASSASSINS_TAMED = 489,
	H_ZONERS_TAMED = 490,
	TAMER_PROGRESS = 493,
	RESCUE_TEAM_VICTORY = 494
}
public enum AchievementName
{
	POD_WINNER = 1,
	INFIRMARY_WINNER = 2,
	ARMORY_WINNER = 3,
	DRILL_WINNER = 4,
	LIBRARY_WINNER = 55,
	REFREEZERATOR_WINNER = 56,
	SANITARY_WINNER = 57,
	SURVIVOR = 5,
	HEALER = 6,
	OPENER = 7,
	RESEARCHER = 58,
	PROTECTOR = 59,
	N_TRASHS_KILLER = 27,
	N_FLYINGS_KILLER = 28,
	N_CRYSTOPHILES_KILLER = 29,
	N_HUNTERS_KILLER = 30,
	N_KAMIKAZES_KILLER = 0x1F,
	S_TRASHS_KILLER = 0x20,
	S_BULLDOZERS_KILLER = 33,
	S_SUPPORTERS_KILLER = 34,
	S_ZONERS_KILLER = 35,
	C_TRASHS_KILLER = 36,
	C_DEBUFFERS_KILLER = 37,
	C_KAMIKAZES_KILLER = 38,
	C_KEEPERS_KILLER = 39,
	H_HUNTERS_KILLER = 40,
	H_DOOROPENERS_KILLER = 41,
	H_DEBUFFERS_KILLER = 42,
	V_VULTUS_KILLER = 270,
	V_TRASHS_KILLER = 271,
	V_DEBUFFERS_KILLER = 272,
	H_ASSASSINS_KILLER = 273,
	H_ZONERS_KILLER = 274,
	HURNAS_FAMILY_KILLER = 275,
	FLOOR_1_REACHED = 43,
	FLOOR_2_REACHED = 44,
	FLOOR_3_REACHED = 45,
	FLOOR_4_REACHED = 46,
	FLOOR_5_REACHED = 47,
	FLOOR_6_REACHED = 48,
	FLOOR_7_REACHED = 49,
	FLOOR_8_REACHED = 50,
	FLOOR_9_REACHED = 51,
	FLOOR_10_REACHED = 52,
	FLOOR_11_REACHED = 53,
	FLOOR_12_REACHED = 54,
	SPRINTER = 0x3F,
	LEVELER = 0x40,
	RECRUITER = 65,
	OPENER_EXPERT = 66,
	FLOOR_1_REACHED_MULTI = 87,
	MULTIPLAYER_WINNER = 88,
	UNLOCKER = 89,
	STORER = 90,
	BUILDER = 91,
	SAVIOR = 92,
	KILLER = 93,
	EXPERT = 94,
	COLLECTOR = 95,
	HERO_H0001_UNLOCKER = 68,
	HERO_H0002_UNLOCKER = 69,
	HERO_H0003_UNLOCKER = 70,
	HERO_H0004_UNLOCKER = 71,
	HERO_H0005_UNLOCKER = 72,
	HERO_H0006_UNLOCKER = 73,
	HERO_H0007_UNLOCKER = 74,
	HERO_H0008_UNLOCKER = 75,
	HERO_H0009_UNLOCKER = 76,
	HERO_H0010_UNLOCKER = 67,
	HERO_H0011_UNLOCKER = 77,
	HERO_H0012_UNLOCKER = 78,
	HERO_H0013_UNLOCKER = 79,
	HERO_H0014_UNLOCKER = 80,
	HERO_H0015_UNLOCKER = 81,
	HERO_H0016_UNLOCKER = 82,
	HERO_H0017_UNLOCKER = 83,
	HERO_H0018_UNLOCKER = 84,
	HERO_H0019_UNLOCKER = 85,
	HERO_H0020_UNLOCKER = 86,
	HERO_H0001_WINNER = 8,
	HERO_H0002_WINNER = 9,
	HERO_H0003_WINNER = 10,
	HERO_H0004_WINNER = 11,
	HERO_H0005_WINNER = 12,
	HERO_H0006_WINNER = 13,
	HERO_H0007_WINNER = 14,
	HERO_H0008_WINNER = 0xF,
	HERO_H0009_WINNER = 0x10,
	HERO_H0011_WINNER = 17,
	HERO_H0012_WINNER = 18,
	HERO_H0013_WINNER = 19,
	HERO_H0014_WINNER = 20,
	HERO_H0015_WINNER = 21,
	HERO_H0016_WINNER = 22,
	HERO_H0017_WINNER = 23,
	HERO_H0018_WINNER = 24,
	HERO_H0019_WINNER = 25,
	HERO_H0020_WINNER = 26,
	MAJORMODULE_MAJOR0001_RESEARCHED_CURRENT_GAME = 102,
	MAJORMODULE_MAJOR0002_RESEARCHED_CURRENT_GAME = 103,
	MAJORMODULE_MAJOR0003_RESEARCHED_CURRENT_GAME = 104,
	MAJORMODULE_MAJOR0004_RESEARCHED_CURRENT_GAME = 105,
	MAJORMODULE_MAJOR0005_RESEARCHED_CURRENT_GAME = 106,
	MAJORMODULE_MAJOR0006_RESEARCHED_CURRENT_GAME = 107,
	MAJORMODULE_MAJOR0007_RESEARCHED_CURRENT_GAME = 108,
	MAJORMODULE_MAJOR0008_RESEARCHED_CURRENT_GAME = 109,
	MAJORMODULE_MAJOR0009_RESEARCHED_CURRENT_GAME = 110,
	MAJORMODULE_MAJOR0010_RESEARCHED_CURRENT_GAME = 111,
	MINORMODULE_MINOR0001_RESEARCHED_CURRENT_GAME = 112,
	MINORMODULE_MINOR0002_RESEARCHED_CURRENT_GAME = 113,
	MINORMODULE_MINOR0003_RESEARCHED_CURRENT_GAME = 114,
	MINORMODULE_MINOR0004_RESEARCHED_CURRENT_GAME = 115,
	MINORMODULE_MINOR0005_RESEARCHED_CURRENT_GAME = 116,
	MINORMODULE_MINOR0006_RESEARCHED_CURRENT_GAME = 117,
	MINORMODULE_MINOR0007_RESEARCHED_CURRENT_GAME = 118,
	MINORMODULE_MINOR0008_RESEARCHED_CURRENT_GAME = 119,
	MINORMODULE_MINOR0009_RESEARCHED_CURRENT_GAME = 120,
	MINORMODULE_MINOR0010_RESEARCHED_CURRENT_GAME = 121,
	MINORMODULE_MINOR0011_RESEARCHED_CURRENT_GAME = 122,
	MINORMODULE_MINOR0012_RESEARCHED_CURRENT_GAME = 123,
	MINORMODULE_MINOR0013_RESEARCHED_CURRENT_GAME = 124,
	MINORMODULE_MINOR0014_RESEARCHED_CURRENT_GAME = 125,
	MINORMODULE_MINOR0015_RESEARCHED_CURRENT_GAME = 126,
	MINORMODULE_MINOR0016_RESEARCHED_CURRENT_GAME = 0x7F,
	MINORMODULE_MINOR0017_RESEARCHED_CURRENT_GAME = 0x80,
	MINORMODULE_MINOR0018_RESEARCHED_CURRENT_GAME = 129,
	MINORMODULE_MINOR0019_RESEARCHED_CURRENT_GAME = 130,
	MINORMODULE_MINOR0020_RESEARCHED_CURRENT_GAME = 131,
	MAJORMODULE_MAJOR0001_FULLY_RESEARCHED = 142,
	MAJORMODULE_MAJOR0002_FULLY_RESEARCHED = 143,
	MAJORMODULE_MAJOR0003_FULLY_RESEARCHED = 144,
	MAJORMODULE_MAJOR0004_FULLY_RESEARCHED = 145,
	MAJORMODULE_MAJOR0005_FULLY_RESEARCHED = 146,
	MAJORMODULE_MAJOR0006_FULLY_RESEARCHED = 147,
	MAJORMODULE_MAJOR0007_FULLY_RESEARCHED = 148,
	MAJORMODULE_MAJOR0008_FULLY_RESEARCHED = 149,
	MAJORMODULE_MAJOR0009_FULLY_RESEARCHED = 150,
	MAJORMODULE_MAJOR0010_FULLY_RESEARCHED = 151,
	MINORMODULE_MINOR0001_FULLY_RESEARCHED = 152,
	MINORMODULE_MINOR0002_FULLY_RESEARCHED = 153,
	MINORMODULE_MINOR0003_FULLY_RESEARCHED = 154,
	MINORMODULE_MINOR0004_FULLY_RESEARCHED = 155,
	MINORMODULE_MINOR0005_FULLY_RESEARCHED = 156,
	MINORMODULE_MINOR0006_FULLY_RESEARCHED = 157,
	MINORMODULE_MINOR0007_FULLY_RESEARCHED = 158,
	MINORMODULE_MINOR0008_FULLY_RESEARCHED = 159,
	MINORMODULE_MINOR0009_FULLY_RESEARCHED = 160,
	MINORMODULE_MINOR0010_FULLY_RESEARCHED = 161,
	MINORMODULE_MINOR0011_FULLY_RESEARCHED = 162,
	MINORMODULE_MINOR0012_FULLY_RESEARCHED = 163,
	MINORMODULE_MINOR0013_FULLY_RESEARCHED = 164,
	MINORMODULE_MINOR0014_FULLY_RESEARCHED = 165,
	MINORMODULE_MINOR0015_FULLY_RESEARCHED = 166,
	MINORMODULE_MINOR0016_FULLY_RESEARCHED = 167,
	MINORMODULE_MINOR0017_FULLY_RESEARCHED = 168,
	MINORMODULE_MINOR0018_FULLY_RESEARCHED = 169,
	MINORMODULE_MINOR0019_FULLY_RESEARCHED = 170,
	MINORMODULE_MINOR0020_FULLY_RESEARCHED = 171,
	STORY_COMPLETER_AUSTRALIUM = 179,
	STORY_COMPLETER_DOWNFALL = 180,
	STORY_COMPLETER_WHO_TALKED = 181,
	STORY_COMPLETER_HOTVENGEANCE = 182,
	STORY_COMPLETER_WHISKEY_TANGO_FOXTROT = 183,
	STORY_COMPLETER_THIEF_GUARD = 184,
	STORY_COMPLETER_MATTER_OF_TRUTHS = 185,
	STORY_COMPLETER_BUGEATER = 186,
	STORY_COMPLETER_HEAL_THE_LAME = 187,
	STORY_COMPLETER_FLAME_WARS = 188,
	STORY_COMPLETER_WITH_HONOR = 189,
	NO_RECRUITMENT_WINNER = 190,
	EVERY_FACTION_WINNER = 191,
	FLY_YOU_FOOLS = 192,
	ENDLESSDAY_SPECIALHERO_WINNER = 200,
	HERO_H0021_UNLOCKER = 201,
	HERO_H0022_UNLOCKER = 202,
	HERO_H0023_UNLOCKER = 203,
	HERO_H0024_UNLOCKER = 204,
	HERO_H0025_UNLOCKER = 205,
	HERO_H0026_UNLOCKER = 206,
	HERO_H0027_UNLOCKER = 207,
	HERO_H0028_UNLOCKER = 208,
	HERO_H0029_UNLOCKER = 209,
	HERO_H0030_UNLOCKER = 210,
	HERO_H0031_UNLOCKER = 211,
	HERO_H0032_UNLOCKER = 212,
	HERO_H0033_UNLOCKER = 213,
	HERO_H0034_UNLOCKER = 214,
	HERO_H0035_UNLOCKER = 215,
	HERO_H0036_UNLOCKER = 216,
	HERO_H0037_UNLOCKER = 217,
	HERO_H0038_UNLOCKER = 218,
	HERO_H0039_UNLOCKER = 219,
	HERO_H0040_UNLOCKER = 220,
	HERO_H0041_UNLOCKER = 221,
	HERO_H0042_UNLOCKER = 222,
	HERO_H0043_UNLOCKER = 223,
	HERO_H0044_UNLOCKER = 224,
	HERO_H0045_UNLOCKER = 225,
	HERO_H0046_UNLOCKER = 226,
	HERO_H0047_UNLOCKER = 227,
	HERO_H0048_UNLOCKER = 228,
	HERO_H0049_UNLOCKER = 229,
	HERO_H0050_UNLOCKER = 230,
	HERO_H0021_WINNER = 231,
	HERO_H0022_WINNER = 232,
	HERO_H0023_WINNER = 233,
	HERO_H0024_WINNER = 234,
	HERO_H0025_WINNER = 235,
	HERO_H0026_WINNER = 236,
	HERO_H0027_WINNER = 237,
	HERO_H0028_WINNER = 238,
	HERO_H0029_WINNER = 239,
	HERO_H0030_WINNER = 240,
	HERO_H0031_WINNER = 241,
	HERO_H0032_WINNER = 242,
	HERO_H0033_WINNER = 243,
	HERO_H0034_WINNER = 244,
	HERO_H0035_WINNER = 245,
	HERO_H0036_WINNER = 246,
	HERO_H0037_WINNER = 247,
	HERO_H0038_WINNER = 248,
	HERO_H0039_WINNER = 249,
	HERO_H0040_WINNER = 250,
	HERO_H0041_WINNER = 251,
	HERO_H0042_WINNER = 252,
	HERO_H0043_WINNER = 253,
	HERO_H0044_WINNER = 254,
	HERO_H0045_WINNER = 0xFF,
	HERO_H0046_WINNER = 0x100,
	HERO_H0047_WINNER = 257,
	HERO_H0048_WINNER = 258,
	HERO_H0049_WINNER = 259,
	HERO_H0050_WINNER = 260,
	ORGANIC_WINNER = 262,
	TAMER = 263,
	RESCUE_TEAM_WINNER = 264,
	N_TRASHS_TAMER = 370,
	N_FLYINGS_TAMER = 371,
	N_CRYSTOPHILES_TAMER = 372,
	N_HUNTERS_TAMER = 373,
	N_KAMIKAZES_TAMER = 374,
	S_TRASHS_TAMER = 375,
	S_BULLDOZERS_TAMER = 376,
	S_SUPPORTERS_TAMER = 377,
	S_ZONERS_TAMER = 378,
	C_TRASHS_TAMER = 379,
	C_DEBUFFERS_TAMER = 380,
	C_KAMIKAZES_TAMER = 381,
	C_KEEPERS_TAMER = 382,
	H_HUNTERS_TAMER = 383,
	H_DOOROPENERS_TAMER = 384,
	H_DEBUFFERS_TAMER = 385,
	V_VULTUS_TAMER = 386,
	V_TRASHS_TAMER = 387,
	V_DEBUFFERS_TAMER = 388,
	H_ASSASSINS_TAMER = 389,
	H_ZONERS_TAMER = 390
}
public interface ILocalAchievementDOTEService : ILocalAchievementService, IService, IAchievementService
{
	void ResetVolatileStats(bool commit = true);
}
public class LocalAchievementManagerDOTE : LocalAchievementManager, ILocalAchievementDOTEService, ILocalAchievementService, IService, IAchievementService
{
	public void ResetVolatileStats(bool commit = true)
	{
		if (debug)
		{
			Diagnostics.Log("[Local Achievement] Reseting all volatile statistics");
		}
		if (statistics != null)
		{
			foreach (LocalAchievementStatistic statistic in statistics)
			{
				if (statistic.Volatile)
				{
					SetStatisticValue(statistic.Name, statistic.BaseValue);
				}
			}
		}
		if (achievements != null)
		{
			foreach (LocalAchievement achievement in achievements)
			{
				if (achievement.Volatile)
				{
					achievement.Achieved = false;
				}
			}
		}
		if (commit)
		{
			Commit();
		}
	}

	public override void Load()
	{
		base.Load();
		GameConfig gameConfig = GameConfig.GetGameConfig();
		string[] initUnlockedHeroes = gameConfig.InitUnlockedHeroes;
		foreach (string text in initUnlockedHeroes)
		{
			IncrementStatistic(text.ToUpper() + "_UNLOCKS");
		}
	}

	protected override void LoadStatisticValues()
	{
		if (UserProfile.Data == null || UserProfile.Data.LocalAchievementStats == null)
		{
			Diagnostics.LogError("Can't load achievement statistics because user profile hasn't been loaded");
			return;
		}
		List<LocalStatData> list = new List<LocalStatData>(UserProfile.Data.LocalAchievementStats);
		foreach (LocalStatData item in list)
		{
			LocalAchievementStatistic statistic = GetStatistic(item.Name);
			if (statistic != null)
			{
				statistic.SetValue(item.Value);
				if (debug)
				{
					Diagnostics.Log("[Local Achievement] Loading statistic value from profile: " + item.Name + " = " + statistic.Value);
				}
			}
			else
			{
				UserProfile.Data.LocalAchievementStats.Remove(item);
				Diagnostics.LogWarning("Deleting statistic " + item.Name + " from profile");
			}
		}
	}

	protected override void SaveStatistic(LocalAchievementStatistic stat, bool commit = false, bool forceValue = false)
	{
		if (UserProfile.Data == null || UserProfile.Data.LocalAchievementStats == null)
		{
			Diagnostics.LogError("Can't save local achievement statistics because user profile hasn't been loaded");
			return;
		}
		LocalStatData localStatData = default(LocalStatData);
		localStatData.Name = stat.Name;
		localStatData.Value = stat.Value;
		LocalStatData localStatData2 = localStatData;
		bool flag = false;
		int num = 0;
		while (num < UserProfile.Data.LocalAchievementStats.Count)
		{
			localStatData = UserProfile.Data.LocalAchievementStats[num];
			if (localStatData.Name == stat.Name)
			{
				if (stat.BestOnly)
				{
					float value = stat.Value;
					LocalStatData localStatData3 = UserProfile.Data.LocalAchievementStats[num];
					if (!(value > localStatData3.Value) && !forceValue)
					{
						goto IL_0115;
					}
				}
				UserProfile.Data.LocalAchievementStats[num] = localStatData2;
				if (stat.Network && networkAchievementManager != null && !networkAchievementManager.IsDisabled)
				{
					networkAchievementManager.SetStatisticValue(stat.Name, stat.Value, commit);
				}
				goto IL_0115;
			}
			num++;
			continue;
			IL_0115:
			flag = true;
			break;
		}
		if (!flag)
		{
			UserProfile.Data.LocalAchievementStats.Add(localStatData2);
			if (stat.Network && networkAchievementManager != null && !networkAchievementManager.IsDisabled)
			{
				networkAchievementManager.SetStatisticValue(stat.Name, stat.Value, commit);
			}
		}
		if (commit)
		{
			SaveStatisticsToDisk();
		}
	}

	protected override void SaveStatisticsToDisk()
	{
		UserProfile.SaveToFile();
	}

	public LocalAchievement GetAchievementData(StaticString achievementName)
	{
		for (int i = 0; i < achievements.Count; i++)
		{
			if (achievements[i].Name == achievementName)
			{
				return achievements[i];
			}
		}
		return null;
	}

	private void OnUserStorageDataLoaded()
	{
		Load();
	}
}
public class PictureAchievementUnlock : MonoBehaviour
{
	[SerializeField]
	private AchievementName unlockingAchievement;

	[SerializeField]
	private bool ignoreForCollectorAchivement;

	[SerializeField]
	private float fadeSpeed = 0.6f;

	[SerializeField]
	private Color lockedColor = new Color(0f, 0f, 0f, 0.4f);

	private SpriteRenderer[] pictures;

	private TextMesh[] texts;

	private float currentFade = -1f;

	public AchievementName UnlockingAchievement => unlockingAchievement;

	public bool IgnoreForCollectorAchivement => ignoreForCollectorAchivement;

	private void Awake()
	{
		pictures = GetComponentsInChildren<SpriteRenderer>();
		texts = GetComponentsInChildren<TextMesh>();
	}

	public bool Show(bool show)
	{
		bool flag = false;
		SpriteRenderer[] array = pictures;
		foreach (SpriteRenderer spriteRenderer in array)
		{
			spriteRenderer.color = ((!show) ? lockedColor : Color.white);
		}
		if (show && !UserProfile.Data.SeenAlbumPictures.Contains(base.name))
		{
			UserProfile.Data.SeenAlbumPictures.Add(base.name);
			currentFade = 0f;
			flag = true;
			SpriteRenderer[] array2 = pictures;
			foreach (SpriteRenderer spriteRenderer2 in array2)
			{
				spriteRenderer2.color = lockedColor;
			}
		}
		TextMesh[] array3 = texts;
		foreach (TextMesh textMesh in array3)
		{
			Color color = textMesh.color;
			float r = color.r;
			Color color2 = textMesh.color;
			float g = color2.g;
			Color color3 = textMesh.color;
			textMesh.color = new Color(r, g, color3.b, (!flag && show) ? 1f : 0f);
		}
		return flag;
	}

	private void Update()
	{
		if (currentFade >= 0f)
		{
			currentFade += DungeonsApplication.GetRealtimeDelta() * fadeSpeed;
			SpriteRenderer[] array = pictures;
			foreach (SpriteRenderer spriteRenderer in array)
			{
				spriteRenderer.color = Color.Lerp(lockedColor, Color.white, currentFade);
			}
			TextMesh[] array2 = texts;
			foreach (TextMesh textMesh in array2)
			{
				Color color = textMesh.color;
				float r = color.r;
				Color color2 = textMesh.color;
				float g = color2.g;
				Color color3 = textMesh.color;
				textMesh.color = new Color(r, g, color3.b, Mathf.Lerp(0f, 1f, currentFade));
			}
			if (currentFade > 1f)
			{
				currentFade = -1f;
			}
		}
	}

	private void OnDisable()
	{
		currentFade = -1f;
	}
}
public interface ILocalAchievementService : IService, IAchievementService
{
	bool HasAchievement(StaticString achievementName);

	bool HasStatistic(StaticString statName);

	void ResetAllAchievements();
}
public class LocalAchievement
{
	public StaticString Name;

	public bool Achieved;

	public string StatisticName;

	public float StatisticTriggerValue;

	public bool Hidden;

	public bool Volatile;

	public bool Network;

	public string[] SubAchievements;

	public LocalAchievement(LocalAchievementDefinition definition)
	{
		Name = definition.Name;
		Achieved = false;
		StatisticName = definition.StatisticName;
		StatisticTriggerValue = definition.StatisticTriggerValue;
		Hidden = definition.Hidden;
		Volatile = definition.Volatile;
		Network = definition.Network;
		SubAchievements = definition.SubAchievements;
	}
}
public class LocalAchievementDefinition : AchievementDefinition
{
	[XmlAttribute("StatisticName")]
	public string StatisticName
	{
		get;
		private set;
	}

	[XmlAttribute("StatisticTriggerValue")]
	public float StatisticTriggerValue
	{
		get;
		private set;
	}

	[XmlAttribute("Hidden")]
	public bool Hidden
	{
		get;
		private set;
	}

	[XmlAttribute("Volatile")]
	public bool Volatile
	{
		get;
		private set;
	}

	[XmlAttribute("Network")]
	public bool Network
	{
		get;
		private set;
	}

	[XmlArray("SubAchievements")]
	public string[] SubAchievements
	{
		get;
		private set;
	}
}
public abstract class LocalAchievementManager : Manager, ILocalAchievementService, IService, IAchievementService
{
	public delegate void AchievementAchievedHandler(string achievementName);

	[SerializeField]
	protected bool debug;

	protected List<LocalAchievementStatistic> statistics = new List<LocalAchievementStatistic>();

	protected List<LocalAchievement> achievements = new List<LocalAchievement>();

	protected NetworkAchievementManager networkAchievementManager;

	private Dictionary<StaticString, List<LocalAchievement>> statAchievementDependencies;

	private Dictionary<StaticString, List<LocalAchievement>> subAchievementDependencies;

	public List<StaticString> AlwaysReleventStatistics = new List<StaticString>();

	public event AchievementAchievedHandler OnAchievementAchieved;

	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		Services.AddService((ILocalAchievementService)this);
	}

	public virtual void Load()
	{
		LocalAchievementStatisticDefinition[] values = Databases.GetDatabase<LocalAchievementStatisticDefinition>().GetValues();
		statistics = new List<LocalAchievementStatistic>(values.Length);
		LocalAchievementStatisticDefinition[] array = values;
		foreach (LocalAchievementStatisticDefinition definition in array)
		{
			statistics.Add(new LocalAchievementStatistic(definition, 0f));
		}
		if (debug)
		{
			foreach (LocalAchievementStatistic statistic in statistics)
			{
				Diagnostics.Log("[Local Achievement] Loaded statistic: Name= " + (string)statistic.Name + ", Type= " + statistic.Type + ", IntValue= " + statistic.IntValue + ", FloatValue= " + statistic.FloatValue);
			}
		}
		LoadStatisticValues();
		LoadAchievements();
		statAchievementDependencies = new Dictionary<StaticString, List<LocalAchievement>>();
		foreach (LocalAchievementStatistic statistic2 in statistics)
		{
			statAchievementDependencies.Add(statistic2.Name, new List<LocalAchievement>());
			for (int j = 0; j < achievements.Count; j++)
			{
				if (achievements[j].StatisticName == statistic2.Name && achievements[j].SubAchievements == null)
				{
					statAchievementDependencies[statistic2.Name].Add(achievements[j]);
				}
			}
			if (debug && statAchievementDependencies[statistic2.Name].Count == 0 && !statistic2.Network)
			{
				Diagnostics.LogWarning("Statistic " + statistic2.Name + " is never used for any achivement");
			}
		}
		subAchievementDependencies = new Dictionary<StaticString, List<LocalAchievement>>();
		foreach (LocalAchievement achievement in achievements)
		{
			if (achievement.SubAchievements != null)
			{
				string[] subAchievements = achievement.SubAchievements;
				foreach (string x in subAchievements)
				{
					if (!subAchievementDependencies.TryGetValue(x, out List<LocalAchievement> value))
					{
						value = new List<LocalAchievement>();
						subAchievementDependencies.Add(x, value);
					}
					if (!value.Contains(achievement))
					{
						value.Add(achievement);
					}
				}
			}
		}
	}

	public void SetNetworkAchievementManager(NetworkAchievementManager networkAchievementManager)
	{
		this.networkAchievementManager = networkAchievementManager;
	}

	public void SetStatisticValue(StaticString statisticName, float value, bool commit = false)
	{
		LocalAchievementStatistic statistic = GetStatistic(statisticName);
		if (statistic != null && IsStatStillUsefull(statisticName))
		{
			statistic.SetValue(value);
			SaveStatistic(statistic, commit);
			CheckLinkedAchievement(statistic);
			if (debug)
			{
				Diagnostics.Log("[Local Achievement] Set stat: " + (string)statisticName + " to: " + value);
			}
		}
	}

	public void AddToStatistic(StaticString statisticName, float value, bool commit = false)
	{
		LocalAchievementStatistic statistic = GetStatistic(statisticName);
		if (statistic != null && IsStatStillUsefull(statisticName))
		{
			statistic.AddToStat(value);
			SaveStatistic(statistic, commit);
			CheckLinkedAchievement(statistic);
			if (debug)
			{
				Diagnostics.Log("[Achievement] Added " + value + " to stat: " + (string)statisticName);
			}
		}
	}

	public void IncrementStatistic(StaticString statisticName, bool commit = false)
	{
		LocalAchievementStatistic statistic = GetStatistic(statisticName);
		if (statistic != null && IsStatStillUsefull(statisticName))
		{
			statistic.Increment();
			SaveStatistic(statistic, commit);
			CheckLinkedAchievement(statistic);
			if (debug)
			{
				Diagnostics.Log("[Achievement] Incremented stat: " + statisticName);
			}
		}
	}

	public LocalAchievementStatistic GetStatistic(StaticString statName)
	{
		for (int i = 0; i < statistics.Count; i++)
		{
			if (statistics[i].Name == statName)
			{
				return statistics[i];
			}
		}
		Diagnostics.LogError("Can't get statistic: " + statName);
		return null;
	}

	public float GetStatisticValue(StaticString statName)
	{
		return GetStatistic(statName)?.Value ?? (-1f);
	}

	public bool HasStatistic(StaticString statName)
	{
		for (int i = 0; i < statistics.Count; i++)
		{
			if (statistics[i].Name == statName)
			{
				return true;
			}
		}
		return false;
	}

	protected void LoadAchievements()
	{
		LocalAchievementDefinition[] values = Databases.GetDatabase<LocalAchievementDefinition>().GetValues();
		achievements = new List<LocalAchievement>(values.Length);
		LocalAchievementDefinition[] array = values;
		foreach (LocalAchievementDefinition definition in array)
		{
			LocalAchievement localAchievement = new LocalAchievement(definition);
			achievements.Add(localAchievement);
			CheckAchievement(localAchievement);
			if (debug)
			{
				Diagnostics.Log("[Local Achievement] Loaded achievement: Name= " + (string)localAchievement.Name + ", Achieved= " + localAchievement.Achieved + ", StatisticName= " + localAchievement.StatisticName + ", StatisticTriggerValue= " + localAchievement.StatisticTriggerValue);
			}
		}
	}

	protected abstract void LoadStatisticValues();

	protected abstract void SaveStatistic(LocalAchievementStatistic stat, bool commit = false, bool forceValue = false);

	protected abstract void SaveStatisticsToDisk();

	public void Commit()
	{
		if (debug)
		{
			Diagnostics.Log("[Local Achievement] Commiting statistics:");
			for (int i = 0; i < statistics.Count; i++)
			{
				Diagnostics.Log("[Local Achievement Statistics] " + (string)statistics[i].Name + " = " + statistics[i].Value);
			}
		}
		SaveStatisticsToDisk();
	}

	public void PrintAllStatistics()
	{
		Diagnostics.LogWarning("LocalAchievementManager.PrintAllStatistics");
		for (int i = 0; i < statistics.Count; i++)
		{
			Diagnostics.Log("{0}={1}", statistics[i].Name, statistics[i].Value);
		}
	}

	public void PrintAllAchievements()
	{
		Diagnostics.LogWarning("LocalAchievementManager.PrintAllAchievements");
		for (int i = 0; i < achievements.Count; i++)
		{
			Diagnostics.Log("{0}={1}", achievements[i].Name, GetAchievement(achievements[i].Name));
		}
	}

	public void ResetAllAchievements()
	{
		Diagnostics.Log("[Local Achievement] Reseting all achievements");
		foreach (LocalAchievement achievement in achievements)
		{
			achievement.Achieved = false;
		}
	}

	public void ResetAllStatistics()
	{
		Diagnostics.Log("[Local Achievement] Reseting all statistics");
		LocalAchievementStatisticDefinition[] values = Databases.GetDatabase<LocalAchievementStatisticDefinition>().GetValues();
		foreach (LocalAchievementStatistic statistic in statistics)
		{
			LocalAchievementStatisticDefinition localAchievementStatisticDefinition = null;
			for (int i = 0; i < values.Length; i++)
			{
				if (values[i].Name == statistic.Name)
				{
					localAchievementStatisticDefinition = values[i];
					break;
				}
			}
			if (localAchievementStatisticDefinition != null)
			{
				statistic.SetValue(localAchievementStatisticDefinition.BaseValue);
				SaveStatistic(statistic, commit: false, forceValue: true);
			}
		}
		Commit();
	}

	public void ResetAll(bool commit = true)
	{
		ResetAllStatistics();
		ResetAllAchievements();
		if (commit)
		{
			Commit();
		}
	}

	public LocalAchievement GetLocalAchievementData(StaticString achievementName)
	{
		for (int i = 0; i < achievements.Count; i++)
		{
			if (achievements[i].Name == achievementName)
			{
				return achievements[i];
			}
		}
		Diagnostics.LogError("Can't get local achievement: " + achievementName);
		return null;
	}

	public bool GetAchievement(StaticString achievementName)
	{
		for (int i = 0; i < achievements.Count; i++)
		{
			if (achievements[i].Name == achievementName)
			{
				return achievements[i].Achieved;
			}
		}
		Diagnostics.LogError("Can't get local achievement: " + achievementName);
		return false;
	}

	public void SetAchievement(StaticString achievementName)
	{
		for (int i = 0; i < achievements.Count; i++)
		{
			if (achievements[i].Name == achievementName)
			{
				UnlockAchievement(achievements[i], commit: false);
			}
		}
		Diagnostics.LogError("Can't set local achievement: " + achievementName);
	}

	public bool HasAchievement(StaticString achievementName)
	{
		for (int i = 0; i < achievements.Count; i++)
		{
			if (achievements[i].Name == achievementName)
			{
				return true;
			}
		}
		return false;
	}

	public bool CheckAchievement(LocalAchievement achievement)
	{
		bool flag = false;
		if (achievement == null)
		{
			return flag;
		}
		if (!achievement.Achieved)
		{
			if (achievement.SubAchievements != null && achievement.SubAchievements.Length > 0)
			{
				int num = 0;
				for (int i = 0; i < achievement.SubAchievements.Length; i++)
				{
					if (GetAchievement(achievement.SubAchievements[i]))
					{
						num++;
					}
				}
				if (num == achievement.SubAchievements.Length)
				{
					flag = true;
				}
				if (statAchievementDependencies != null)
				{
					SetStatisticValue(achievement.StatisticName, num);
				}
			}
			else if (GetStatisticValue(achievement.StatisticName) >= achievement.StatisticTriggerValue)
			{
				flag = true;
			}
		}
		if (flag)
		{
			UnlockAchievement(achievement, commit: true);
		}
		return flag;
	}

	protected void CheckLinkedAchievement(LocalAchievementStatistic stat, bool commit = true)
	{
		List<LocalAchievement> list = new List<LocalAchievement>(statAchievementDependencies[stat.Name]);
		bool flag = false;
		foreach (LocalAchievement item in list)
		{
			if (CheckAchievement(item))
			{
				flag = true;
				statAchievementDependencies[stat.Name].Remove(item);
				if (this.OnAchievementAchieved != null)
				{
					this.OnAchievementAchieved(item.Name);
				}
			}
		}
		if (flag && commit)
		{
			Commit();
		}
	}

	protected void CheckLinkedSubAchievement(LocalAchievement achievement)
	{
		if (subAchievementDependencies == null || !subAchievementDependencies.TryGetValue(achievement.Name, out List<LocalAchievement> value))
		{
			return;
		}
		for (int i = 0; i < value.Count; i++)
		{
			CheckAchievement(value[i]);
			if (value[i].Achieved)
			{
				value.Remove(value[i]);
				i--;
			}
		}
	}

	protected virtual bool IsStatStillUsefull(StaticString statistic)
	{
		return true;
	}

	protected virtual void UnlockAchievement(LocalAchievement achievement, bool commit)
	{
		if (debug)
		{
			Diagnostics.Log("[Local Achievement] Achievement Unlocked: " + achievement.Name);
		}
		achievement.Achieved = true;
		CheckLinkedSubAchievement(achievement);
		if (achievement.Network && networkAchievementManager != null && !networkAchievementManager.IsDisabled)
		{
			networkAchievementManager.SetAchievement(achievement.Name);
			if (commit)
			{
				networkAchievementManager.Commit();
			}
		}
	}
}
public class LocalAchievementStatistic : AchievementStatistic
{
	public bool Volatile;

	public float BaseValue;

	public bool BestOnly;

	public bool Network;

	public LocalAchievementStatistic(LocalAchievementStatisticDefinition definition, float value = 0f)
		: base(definition, value)
	{
		Volatile = definition.Volatile;
		BaseValue = definition.BaseValue;
		BestOnly = definition.BestOnly;
		Network = definition.Network;
	}

	public void ResetValue()
	{
		SetValue(BaseValue);
	}
}
public class LocalAchievementStatisticDefinition : AchievementStatisticDefinition
{
	[XmlAttribute("BaseValue")]
	public float BaseValue
	{
		get;
		private set;
	}

	[XmlAttribute("Volatile")]
	public bool Volatile
	{
		get;
		private set;
	}

	[XmlAttribute("BestOnly")]
	public bool BestOnly
	{
		get;
		private set;
	}

	[XmlAttribute("Network")]
	public bool Network
	{
		get;
		private set;
	}
}
public class SteamAchivementManagerDOTE : SteamAchievementManager
{
	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		yield return BindService(delegate(IRuntimeService service)
		{
			service.RuntimeChange += RuntimeService_RuntimeChange;
		});
	}

	private void RuntimeService_RuntimeChange(object sender, RuntimeChangeEventArgs e)
	{
		Load();
	}
}
public class XboxOneAchievementManagerDOTE : XboxOneAchievementManager
{
	private static Events eventWrapper = new Events();

	protected override object GetEventWrapper()
	{
		return eventWrapper;
	}

	protected override StaticString[] GetStatisticNames()
	{
		List<StaticString> list = new List<StaticString>();
		Array values = Enum.GetValues(typeof(StatisticName));
		foreach (int item in values)
		{
			list.Add(((StatisticName)item).ToString());
		}
		return list.ToArray();
	}
}
public class Album : MonoBehaviour
{
	[SerializeField]
	private Transform pageContainer;

	[SerializeField]
	private Camera albumCamera;

	private List<GameObject> pages;

	private List<PictureAchievementUnlock[]> pictures;

	private int currentPageIndex;

	private AlbumPanel albumPanel;

	private AchievementManagerDOTE achievementManager;

	private bool textMeshModsInit;

	private IInputService inputManager;

	private SelectableManager selectableManager;

	public bool IsDisplayed
	{
		get;
		private set;
	}

	public void Focus(bool display, int pageNumber = 0)
	{
		if (display)
		{
			AssertTextMeshModsInit();
		}
		albumCamera.enabled = display;
		currentPageIndex = pageNumber;
		if (albumPanel == null)
		{
			albumPanel = SingletonManager.Get<AlbumPanel>(mandatory: false);
		}
		if (albumPanel != null)
		{
			if (display)
			{
				LoadPictures();
				if (achievementManager == null)
				{
					achievementManager = SingletonManager.Get<AchievementManagerDOTE>();
				}
				achievementManager.CheckHeroUnlocks();
				achievementManager.SetStatisticValue(StatisticName.PICTURES_UNLOCKED, GetUnlockedPictureCount());
			}
			albumPanel.AgeTransform.Visible = display;
			if (display)
			{
				RefreshContent();
			}
		}
		IsDisplayed = display;
		if (selectableManager == null)
		{
			selectableManager = SingletonManager.Get<SelectableManager>();
		}
		if (IsDisplayed)
		{
			selectableManager.SetCategory(SelectionCategory.Album);
			PopupMenuPanel.RegisterPopupMenuPanel(albumPanel);
		}
		else
		{
			selectableManager.UnsetCategory(SelectionCategory.Album);
			PopupMenuPanel.UnregisterPopupMenuPanel(albumPanel);
		}
	}

	private void LoadPictures()
	{
		pages = new List<GameObject>();
		pictures = new List<PictureAchievementUnlock[]>();
		for (int i = 0; i < pageContainer.childCount; i++)
		{
			GameObject gameObject = pageContainer.GetChild(i).gameObject;
			gameObject.SetActive(value: true);
			pages.Add(gameObject);
			pictures.Add(gameObject.GetComponentsInChildren<PictureAchievementUnlock>());
			gameObject.SetActive(value: false);
		}
	}

	public void PreviousPage()
	{
		if (currentPageIndex > 0)
		{
			pages[currentPageIndex--].SetActive(value: false);
			pages[currentPageIndex].SetActive(value: true);
			RefreshContent();
		}
	}

	public void NextPage()
	{
		if (currentPageIndex < pages.Count - 1)
		{
			pages[currentPageIndex++].SetActive(value: false);
			pages[currentPageIndex].SetActive(value: true);
			RefreshContent();
		}
	}

	private void AssertTextMeshModsInit()
	{
		if (!textMeshModsInit)
		{
			TextMeshModifier[] componentsInChildren = GetComponentsInChildren<TextMeshModifier>(includeInactive: true);
			int num = componentsInChildren.Length;
			for (int i = 0; i < num; i++)
			{
				componentsInChildren[i].FormatText();
			}
			textMeshModsInit = true;
		}
	}

	private void RefreshContent()
	{
		albumPanel.previousButton.Visible = (currentPageIndex > 0);
		albumPanel.nextButton.Visible = (currentPageIndex < pages.Count - 1);
		pages[currentPageIndex].SetActive(value: true);
		bool flag = false;
		if (achievementManager == null)
		{
			achievementManager = SingletonManager.Get<AchievementManagerDOTE>();
		}
		PictureAchievementUnlock[] array = pictures[currentPageIndex];
		foreach (PictureAchievementUnlock pictureAchievementUnlock in array)
		{
			flag |= pictureAchievementUnlock.Show(achievementManager.GetAchievement(pictureAchievementUnlock.UnlockingAchievement));
		}
		if (flag)
		{
			UserProfile.SaveToFile();
		}
	}

	private void Update()
	{
		if (IsDisplayed)
		{
			if (inputManager == null)
			{
				inputManager = Services.GetService<IInputService>();
			}
			if (inputManager.GetControlDown(Control.EscapeBehavior))
			{
				Focus(display: false);
			}
		}
	}

	public int GetUnlockedPictureCount()
	{
		if (pictures == null)
		{
			LoadPictures();
		}
		int num = 0;
		if (pictures != null)
		{
			AchievementManagerDOTE achievementManagerDOTE = SingletonManager.Get<AchievementManagerDOTE>();
			for (int i = 0; i < pictures.Count; i++)
			{
				PictureAchievementUnlock[] array = pictures[i];
				foreach (PictureAchievementUnlock pictureAchievementUnlock in array)
				{
					if (!pictureAchievementUnlock.IgnoreForCollectorAchivement && achievementManagerDOTE.GetAchievement(pictureAchievementUnlock.UnlockingAchievement))
					{
						num++;
					}
				}
			}
		}
		return num;
	}

	public void OpenAndShow(string pictureName)
	{
		if (pictures == null)
		{
			LoadPictures();
		}
		if (pictures == null)
		{
			return;
		}
		int num = -1;
		for (int i = 0; i < pictures.Count; i++)
		{
			for (int j = 0; j < pictures[i].Length; j++)
			{
				if (pictures[i][j].name == pictureName)
				{
					num = i;
					break;
				}
			}
			if (num >= 0)
			{
				break;
			}
		}
		if (num < 0)
		{
			Diagnostics.LogError("Could not find picture {0} in the album", pictureName);
		}
		else
		{
			Focus(display: true, num);
		}
	}
}
public interface IPlayerControllerRepositoryService : IEnumerable, IService, IRepositoryService<PlayerController>, IEnumerable<PlayerController>
{
	PlayerController ActivePlayerController
	{
		get;
		set;
	}
}
public interface IRepositoryService<T> : IEnumerable, IEnumerable<T>
{
	void Register(T instance);

	void Unregister(T instance);
}
public class CameraDragSupport : MonoBehaviour
{
	[SerializeField]
	private float minScreenPositionDelta;

	private IGameCameraService gameCameraManager;

	private IInputService inputManager;

	private bool isClicked;

	private Vector3 clickScreenPosition;

	private Vector3 dragPreviousMousePosition;

	public bool IsDragging
	{
		get;
		private set;
	}

	private void OnLeftClickDown(ClickDownInfo clickInfo)
	{
		isClicked = true;
		IsDragging = false;
		clickScreenPosition = Input.mousePosition;
	}

	private void OnLeftClickUp(ClickUpInfo clickInfo)
	{
		isClicked = false;
		IsDragging = false;
	}

	private void OnMouseWheelUp()
	{
		if (gameCameraManager == null)
		{
			gameCameraManager = Services.GetService<IGameCameraService>();
		}
		gameCameraManager.SwitchToGameCamera(goBackToPosBeforeZoomOut: true);
	}

	private void Update()
	{
		if (!isClicked)
		{
			return;
		}
		if (!IsDragging && (clickScreenPosition - Input.mousePosition).sqrMagnitude >= minScreenPositionDelta * minScreenPositionDelta)
		{
			IsDragging = true;
			dragPreviousMousePosition = Input.mousePosition;
		}
		if (IsDragging)
		{
			if (gameCameraManager == null)
			{
				gameCameraManager = Services.GetService<IGameCameraService>();
			}
			gameCameraManager.MoveByPixelDelta(dragPreviousMousePosition - Input.mousePosition);
			dragPreviousMousePosition = Input.mousePosition;
		}
	}
}
public class Cheats : MonoBehaviour
{
	public static bool OverrideNextRoomEvent;

	public static RoomEvent NextRoomEvent;

	public static bool ConstantRoomEvent;

	public static bool AutoPower;

	[SerializeField]
	private bool isActive;

	[SerializeField]
	private KeyCode keyboardShortcut;

	[SerializeField]
	private string padShortcut = "RightStickClick";

	[SerializeField]
	private int buttonHeight = 20;

	[SerializeField]
	private int buttonWidth = 200;

	[SerializeField]
	private int verticalPadding = 5;

	[SerializeField]
	private int horizontalPadding = 5;

	[SerializeField]
	private int x0 = 10;

	[SerializeField]
	private int y0 = 50;
}
public enum DLCObjectType
{
	Ship,
	Hero,
	Mob,
	BluePrint,
	Item,
	Event
}
[Serializable]
public struct DLCObject
{
	public DLCObjectType Type;

	public string Name;

	private StaticString _nameStaticString;

	public StaticString NameStaticString
	{
		get
		{
			if (_nameStaticString == null)
			{
				_nameStaticString = new StaticString(Name);
			}
			return _nameStaticString;
		}
	}
}
[Serializable]
public class DLC
{
	public string Name;

	public int[] AppIDs;

	public DLCObject[] Objects;

	public bool MainMenuIcon;

	private bool isAvailable;

	public bool IsAvailable()
	{
		return isAvailable;
	}

	public void SetAvailability(bool value)
	{
		isAvailable = value;
	}
}
public class DLCController : MonoBehaviour
{
	[SerializeField]
	private DLC[] dlcs;

	private bool isInitialized;

	private Dictionary<DLCObject, bool> objectsAvailabilityCache = new Dictionary<DLCObject, bool>();

	public void Init()
	{
		for (int i = 0; i < dlcs.Length; i++)
		{
			DLC dLC = dlcs[i];
			if (dLC.AppIDs.Length < 0)
			{
				Diagnostics.LogWarning("[Steam] No app ID defined for \"{0}\" DLC on {1} environment, considering DLC as available", dLC.Name, DungeonsApplication.Environment);
				dLC.SetAvailability(value: true);
				continue;
			}
			bool flag = false;
			for (int j = 0; j < dLC.AppIDs.Length; j++)
			{
				int num = dLC.AppIDs[j];
				flag = Steamworks.SteamAPI.SteamApps.BIsSubscribedApp((uint)num);
				if (flag)
				{
					Diagnostics.Log("[Steam] \"{0}\" DLC available thanks to #{1} app", dLC.Name, num);
					break;
				}
			}
			if (!flag)
			{
				Diagnostics.Log("[Steam] \"{0}\" DLC not available", dLC.Name);
			}
			dLC.SetAvailability(flag);
		}
		isInitialized = true;
	}

	public void AssertInit()
	{
		if (!isInitialized)
		{
			Init();
		}
	}

	public DLC[] GetCheckedDLCs()
	{
		AssertInit();
		return dlcs;
	}

	public bool IsObjectAvailable(DLCObjectType objectType, StaticString objectName)
	{
		foreach (KeyValuePair<DLCObject, bool> item in objectsAvailabilityCache)
		{
			DLCObject key = item.Key;
			if (key.Type == objectType && item.Key.NameStaticString == objectName)
			{
				return item.Value;
			}
		}
		bool flag = CheckObjectAvailable(objectType, objectName);
		DLCObject dLCObject = default(DLCObject);
		dLCObject.Type = objectType;
		dLCObject.Name = objectName;
		DLCObject key2 = dLCObject;
		objectsAvailabilityCache.Add(key2, flag);
		return flag;
	}

	private bool CheckObjectAvailable(DLCObjectType objectType, StaticString objectName)
	{
		AssertInit();
		bool flag = false;
		for (int i = 0; i < dlcs.Length; i++)
		{
			DLC dLC = dlcs[i];
			if (dLC.Objects.Any((DLCObject h) => h.Type == objectType && h.NameStaticString == objectName))
			{
				if (dLC.IsAvailable())
				{
					Diagnostics.Log("[Steam] {0} {1} is available via \"{2}\" DLC", objectType, objectName, dLC.Name);
					return true;
				}
				Diagnostics.Log("[Steam] {0} {1} is constrained by \"{2}\" DLC (unavailable)", objectType, objectName, dLC.Name);
				flag = true;
			}
		}
		if (flag)
		{
			return false;
		}
		return true;
	}
}
public abstract class DatatableElement : IDatatableElement
{
	[XmlIgnore]
	public virtual StaticString Name
	{
		get;
		protected set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}
}
public enum StatDialogCondition
{
	Generic,
	OneFloor,
	EarlyFloors,
	LateFloors,
	OneHero,
	SeveralHeroes,
	TwoThreeHeroes,
	NewHero,
	OneDeath,
	MultipleDeath
}
public class StoryDialogManager : MonoBehaviour
{
	private StoryDialogPanel dialogPanel;

	private List<KeyValuePair<StorySentenceConfig, Transform>> dialogSequence;

	private int currentDialogIndex;

	private List<Hero> heroesInLift;

	private Dungeon dungeon;

	private Lift lift;

	private Camera liftCamera;

	public string LastStoryPlayed
	{
		get;
		set;
	}

	public bool EnableDialog
	{
		get;
		set;
	}

	public Dictionary<Transform, GameObject> VFXsToPlay
	{
		get;
		private set;
	}

	public KeyValuePair<LiftHero, LiftHero> MurderToPlay
	{
		get;
		private set;
	}

	private void Awake()
	{
		liftCamera = GetComponentInChildren<Camera>();
	}

	private void OnEnable()
	{
		VFXsToPlay = new Dictionary<Transform, GameObject>();
		MurderToPlay = new KeyValuePair<LiftHero, LiftHero>(null, null);
		heroesInLift = new List<Hero>();
		for (int i = 0; i < Hero.LocalPlayerActiveRecruitedHeroes.Count; i++)
		{
			if (Hero.LocalPlayerActiveRecruitedHeroes[i].WasInExitRoomAtExitTime)
			{
				heroesInLift.Add(Hero.LocalPlayerActiveRecruitedHeroes[i]);
			}
		}
	}

	public IDatatableElement GetSelectedStory()
	{
		if (UserProfile.Data != null && UserProfile.Data.StoryStepStats != null)
		{
			if (lift == null)
			{
				lift = SingletonManager.Get<Lift>();
			}
			StoryDialogConfig[] array = (from story in Databases.GetDatabase<StoryDialogConfig>().GetValues()
				where CanTriggerStory(story)
				select story).ToArray();
			if (array.Length > 0)
			{
				if (array.Length > 1)
				{
					Dictionary<StoryDialogConfig, int> source = array.ToDictionary((StoryDialogConfig story) => story, delegate(StoryDialogConfig story)
					{
						StoryStepSaveData storyStepSaveData = UserProfile.Data.StoryStepStats.FirstOrDefault((StoryStepSaveData step) => step.StepName == story.Steps[story.CurrentStepIndex + 1].Name);
						return storyStepSaveData.OccurrenceCount;
					});
					int minPlayCount = source.Min((KeyValuePair<StoryDialogConfig, int> story) => story.Value);
					array = (from story in source
						where story.Value == minPlayCount
						select story.Key).ToArray();
					if (array.Length > 1 && !string.IsNullOrEmpty(LastStoryPlayed))
					{
						array = array.Where((StoryDialogConfig story) => story.Name != LastStoryPlayed).ToArray();
					}
				}
				return array[RandomGenerator.RangeInt(0, array.Length)];
			}
			StatDialogConfig[] array2 = (from dialog in Databases.GetDatabase<StatDialogConfig>().GetValues()
				where CanTriggerStatDialog(dialog)
				select dialog).ToArray();
			return array2[RandomGenerator.RangeInt(0, array2.Length)];
		}
		Diagnostics.LogError("StorySelection: user profile hasn't been loaded");
		return null;
	}

	public void TriggerStatDialog(StatDialogConfig chosenDialog)
	{
		Diagnostics.Log("Triggering stat dialog: " + chosenDialog.Name);
		List<Hero> list = new List<Hero>(heroesInLift);
		if (chosenDialog.Condition == StatDialogCondition.NewHero)
		{
			list = list.Where((Hero hero) => hero.FloorRecruited != dungeon.Level).ToList();
		}
		int num = RandomGenerator.RangeInt(0, list.Count);
		if (!heroesInLift[num].Config.IsHidden())
		{
			dialogSequence = new List<KeyValuePair<StorySentenceConfig, Transform>>();
			string[] sentences = chosenDialog.Sentences;
			foreach (string key in sentences)
			{
				StorySentenceConfig storySentenceConfig = new StorySentenceConfig();
				storySentenceConfig.Text = AgeLocalizer.Instance.LocalizeString(key);
				dialogSequence.Add(new KeyValuePair<StorySentenceConfig, Transform>(storySentenceConfig, lift.LiftHeroes[num].transform));
			}
			EnableDialog = true;
			currentDialogIndex = 0;
			DisplayDialog();
		}
	}

	private bool CanTriggerStatDialog(StatDialogConfig dialog)
	{
		switch (dialog.Condition)
		{
		case StatDialogCondition.Generic:
			return !HasRecruitedHeroThisFloor() && dungeon.Statistics.GetStat(DungeonStatistics.Stat_LostHeroesCurrentFloor) == 0f;
		case StatDialogCondition.OneFloor:
			return dungeon.Level == 1;
		case StatDialogCondition.EarlyFloors:
			return dungeon.Level < 5;
		case StatDialogCondition.LateFloors:
			return dungeon.Level > 10;
		case StatDialogCondition.OneHero:
			return heroesInLift.Count == 1;
		case StatDialogCondition.SeveralHeroes:
			return heroesInLift.Count > 1;
		case StatDialogCondition.TwoThreeHeroes:
			return heroesInLift.Count > 1 && heroesInLift.Count < 4;
		case StatDialogCondition.NewHero:
			return HasRecruitedHeroThisFloor();
		case StatDialogCondition.OneDeath:
			return dungeon.Statistics.GetStat(DungeonStatistics.Stat_LostHeroesCurrentFloor) == 1f;
		case StatDialogCondition.MultipleDeath:
			return dungeon.Statistics.GetStat(DungeonStatistics.Stat_LostHeroesCurrentFloor) > 1f;
		default:
			Diagnostics.LogError("Unknown dialog condition: " + dialog.Condition);
			return false;
		}
	}

	private bool HasRecruitedHeroThisFloor()
	{
		for (int i = 0; i < heroesInLift.Count; i++)
		{
			if (!heroesInLift[i].IsStartingHero && heroesInLift[i].FloorRecruited == dungeon.Level)
			{
				return true;
			}
		}
		return false;
	}

	public void TriggerStory(StoryDialogConfig story)
	{
		Diagnostics.Log("Triggering story: " + story.Name);
		EnableDialog = true;
		LastStoryPlayed = story.Name;
		PlayStoryStep(story);
	}

	private bool CanTriggerStory(StoryDialogConfig story)
	{
		if (dungeon == null)
		{
			dungeon = SingletonManager.Get<Dungeon>();
		}
		if (story.CurrentStepIndex < story.Steps.Length - 1)
		{
			List<string> storyHeroNames = story.Heroes.ToList();
			Hero[] array = heroesInLift.Where((Hero hero) => storyHeroNames.Contains(hero.Config.Name)).ToArray();
			if (storyHeroNames.Count == array.Length)
			{
				StoryDialogStepConfig storyDialogStepConfig = story.Steps[story.CurrentStepIndex + 1];
				int num = array.Select((Hero hero) => hero.FloorRecruited - 1).Max();
				return dungeon.Level - num >= storyDialogStepConfig.MinFloorTogether;
			}
		}
		return false;
	}

	private void PlayStoryStep(StoryDialogConfig story)
	{
		StoryDialogStepConfig step = story.Steps[++story.CurrentStepIndex];
		List<string> list = new List<string>(story.Heroes);
		Diagnostics.Log("Playing story step: " + step.Name);
		dialogSequence = new List<KeyValuePair<StorySentenceConfig, Transform>>();
		StorySentenceConfig[] sentences = step.Sentences;
		foreach (StorySentenceConfig storySentenceConfig in sentences)
		{
			int num = list.IndexOf(storySentenceConfig.Speaker);
			if (num == -1)
			{
				Diagnostics.LogError("StoryDialog: {0} is speaking but is not in the story {1}", storySentenceConfig.Speaker, story.Name);
			}
			else
			{
				dialogSequence.Add(new KeyValuePair<StorySentenceConfig, Transform>(storySentenceConfig, lift.LiftHeroes[num].transform));
			}
		}
		if (step.BackstoriesUnlocked != null && UserProfile.Data.BackstoriesUnlocked != null && story.Name != null)
		{
			BackstoryConfig[] backstoriesUnlocked = step.BackstoriesUnlocked;
			foreach (BackstoryConfig backstoryConfig in backstoriesUnlocked)
			{
				if (backstoryConfig != null)
				{
					BackstoryData item = UserProfile.Data.BackstoriesUnlocked.FirstOrDefault((BackstoryData backstoryData) => backstoryData.StoryName != null && backstoryData.StoryName == story.Name && backstoryData.StepIndex == story.CurrentStepIndex && backstoryData.HeroName == backstoryConfig.Hero);
					if (string.IsNullOrEmpty(item.StoryName))
					{
						item.StoryName = story.Name;
						item.StepIndex = story.CurrentStepIndex;
						item.HeroName = backstoryConfig.Hero;
						item.Text = backstoryConfig.Text;
						UserProfile.Data.BackstoriesUnlocked.Add(item);
						lift.UnlockedBackstories = true;
						Diagnostics.Log("{0} unlocked backstory {1} - {2}", item.HeroName, item.StoryName, item.StepIndex);
					}
				}
			}
		}
		if (step.Murder != null)
		{
			bool flag = step.Murder.Random && RandomGenerator.RangeInt(0, 2) == 0;
			string hero1Name = (!flag) ? step.Murder.Hero1 : step.Murder.Hero2;
			string hero2Name = (!flag) ? step.Murder.Hero2 : step.Murder.Hero1;
			LiftHero liftHero2 = lift.LiftHeroes.FirstOrDefault((LiftHero liftHero) => liftHero.HeroName == hero1Name);
			LiftHero liftHero3 = lift.LiftHeroes.FirstOrDefault((LiftHero liftHero) => liftHero.HeroName == hero2Name);
			Diagnostics.Assert(liftHero2 != null && liftHero3 != null);
			MurderToPlay = new KeyValuePair<LiftHero, LiftHero>(liftHero2, liftHero3);
		}
		if (step.NewDescriptors != null)
		{
			DialogGameplayAddDescriptorConfig[] newDescriptors = step.NewDescriptors;
			DialogGameplayAddDescriptorConfig newDescriptorConfig;
			for (int k = 0; k < newDescriptors.Length; k++)
			{
				newDescriptorConfig = newDescriptors[k];
				Hero hero = heroesInLift.FirstOrDefault((Hero h) => h.Config.Name == newDescriptorConfig.Hero);
				Diagnostics.Assert(hero != null);
				if (MurderToPlay.Value != null && MurderToPlay.Value.HeroName == hero.Config.Name)
				{
					continue;
				}
				hero.AddPermanentDescriptor(newDescriptorConfig.Descriptor);
				SkillConfig value = Databases.GetDatabase<SkillConfig>().GetValue(newDescriptorConfig.Descriptor);
				if (value != null && !string.IsNullOrEmpty(value.DialogVFXPath))
				{
					int num2 = list.IndexOf(newDescriptorConfig.Hero);
					Transform transform = lift.LiftHeroes[num2].transform;
					GameObject gameObject = Resources.Load<GameObject>(value.DialogVFXPath);
					if (gameObject != null)
					{
						VFXsToPlay.Add(transform, gameObject);
					}
					else
					{
						Diagnostics.LogError("Can't find VFX at:" + value.OwnerVFXPath);
					}
				}
			}
		}
		if (UserProfile.Data != null && UserProfile.Data.StoryStepStats != null)
		{
			StoryStepSaveData item2 = UserProfile.Data.StoryStepStats.FirstOrDefault((StoryStepSaveData stepData) => stepData.StepName == step.Name);
			if (!string.IsNullOrEmpty(item2.StepName))
			{
				UserProfile.Data.StoryStepStats.Remove(item2);
				item2.OccurrenceCount++;
			}
			else
			{
				item2.StepName = step.Name;
				item2.OccurrenceCount = 1;
			}
			UserProfile.Data.StoryStepStats.Add(item2);
		}
		else
		{
			Diagnostics.LogError("StoryStep: user profile hasn't been loaded");
		}
		lift.TriggerStoryCompletedAchievement = (story.CurrentStepIndex == story.Steps.Length - 1);
		currentDialogIndex = 0;
		DisplayDialog();
	}

	public void DisplayDialog()
	{
		if (dialogSequence != null && currentDialogIndex < dialogSequence.Count)
		{
			if (dialogPanel == null)
			{
				dialogPanel = SingletonManager.Get<StoryDialogPanel>();
			}
			KeyValuePair<StorySentenceConfig, Transform> keyValuePair = dialogSequence[currentDialogIndex++];
			dialogPanel.Display(AgeLocalizer.Instance.LocalizeString(keyValuePair.Key.Text), keyValuePair.Value, liftCamera, -1f);
			if (currentDialogIndex >= dialogSequence.Count)
			{
				Diagnostics.Log("End of dialog sequence");
				EnableDialog = false;
			}
		}
	}
}
public class DungeonStatistics : IEnumerable, IEnumerable<KeyValuePair<StaticString, float>>
{
	public static readonly StaticString Stat_LevelTime = "LevelTime";

	public static readonly StaticString Stat_GameTime = "GameTime";

	public static readonly StaticString Stat_OpenedDoors = "OpenedDoors";

	public static readonly StaticString Stat_GatheredFIS = "GatheredFIS";

	public static readonly StaticString Stat_KilledMobs = "KilledMobs";

	public static readonly StaticString Stat_LootedDust = "LootedDust";

	public static readonly StaticString Stat_LostHeroes = "LostHeroes";

	public static readonly StaticString Stat_LostHeroesCurrentFloor = "LostHeroesLostHeroesCurrentFloor";

	public static readonly StaticString Stat_ActionOpenedDoors = "ActionOpenedDoors";

	public Dictionary<StaticString, float> Statistics
	{
		get;
		private set;
	}

	public int Count => Statistics.Count;

	public DungeonStatistics()
	{
		Statistics = new Dictionary<StaticString, float>();
		Reset();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	public void Reset()
	{
		Statistics.Clear();
		IDatabase<GuiElement> database = Databases.GetDatabase<GuiElement>();
		GuiElement[] values = database.GetValues();
		foreach (GuiElement guiElement in values)
		{
			if (guiElement != null && guiElement.Name.ToString().StartsWith("DungeonStatistics_"))
			{
				SetStat(guiElement.Name);
				Diagnostics.Log("[DungeonStatistics] Reset '{0}' to default its default value.", guiElement.Name);
			}
		}
	}

	public void ImportStatistics(StaticString[] keys, float[] values)
	{
		Statistics.Clear();
		for (int i = 0; i < keys.Length; i++)
		{
			Statistics.Add(keys[i], values[i]);
		}
	}

	public void SetStat(StaticString statName, float value = 0f)
	{
		if (Statistics.ContainsKey(statName))
		{
			Statistics[statName] = value;
		}
		else
		{
			Statistics.Add(statName, value);
		}
	}

	public void IncrementStat(StaticString statName, float value = 1f)
	{
		if (Statistics.ContainsKey(statName))
		{
			Dictionary<StaticString, float> statistics;
			Dictionary<StaticString, float> dictionary = statistics = Statistics;
			StaticString key;
			StaticString key2 = key = statName;
			float num = statistics[key];
			dictionary[key2] = num + value;
		}
		else
		{
			Statistics.Add(statName, value);
		}
	}

	public float GetStat(StaticString statName)
	{
		if (Statistics.ContainsKey(statName))
		{
			return Statistics[statName];
		}
		return 0f;
	}

	public IEnumerator<KeyValuePair<StaticString, float>> GetEnumerator()
	{
		return Statistics.GetEnumerator();
	}

	public override string ToString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		foreach (KeyValuePair<StaticString, float> statistic in Statistics)
		{
			stringBuilder.AppendFormat("{0}={1}\n", statistic.Key, statistic.Value);
		}
		return stringBuilder.ToString();
	}
}
public class Ending : MonoBehaviour
{
	[SerializeField]
	private GameObject endingPrefab;

	private GameObject currentEnding;

	private Lift lift;

	private IAudioEventService audioEventManager;

	private FMOD.Event endingSFX;

	public void Show()
	{
		if (currentEnding != null)
		{
			UnityEngine.Object.Destroy(currentEnding);
		}
		if (lift == null)
		{
			lift = SingletonManager.Get<Lift>();
		}
		if (audioEventManager == null)
		{
			audioEventManager = Services.GetService<IAudioEventService>();
		}
		SingletonManager.Get<EndLevelPanel>().Hide();
		currentEnding = (UnityEngine.Object.Instantiate(endingPrefab, base.transform.position, base.transform.rotation) as GameObject);
		currentEnding.transform.parent = base.transform;
		EndingHero[] componentsInChildren = GetComponentsInChildren<EndingHero>();
		Camera componentInChildren = GetComponentInChildren<Camera>();
		lift.WinningHeroes.RemoveAll((Hero hero) => Hero.DeadHeroes.Contains(hero));
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (i < lift.WinningHeroes.Count)
			{
				componentsInChildren[i].BindAndShow(lift.WinningHeroes[i].Config.Name);
			}
			else
			{
				componentsInChildren[i].SpriteAnimation.Hide();
			}
		}
		SingletonManager.Get<EndingPanel>().Show();
		Services.GetService<IGameCameraService>().ActivateCamera(on: false);
		componentInChildren.enabled = true;
		if (lift.LastLiftSFX != null)
		{
			audioEventManager.StopEvent(lift.LastLiftSFX);
		}
		endingSFX = audioEventManager.Play2DEvent("Master/Events/Ending_Scene");
	}

	public void Hide()
	{
		if (endingSFX != null)
		{
			audioEventManager.StopEvent(endingSFX);
		}
		SingletonManager.Get<EndingPanel>().Hide();
		UnityEngine.Object.Destroy(currentEnding);
	}

	public void Terminate()
	{
		if (currentEnding != null)
		{
			Hide();
			SingletonManager.Get<VictoryPanel>().Show();
		}
	}
}
public class Game : Amplitude.Unity.Game.Game
{
	[SerializeField]
	private GameObject playerPfb;

	public IEnumerator Launch()
	{
		Diagnostics.Log("Launching game...");
		GameNetworkManager gameNetManager = SingletonManager.Get<GameNetworkManager>();
		ulong[] playerIDs = gameNetManager.GetLobbyPlayerIDs();
		for (int i = 0; i < playerIDs.Length; i++)
		{
			GameObject playerGO = UnityEngine.Object.Instantiate(playerPfb, Vector3.zero, Quaternion.identity) as GameObject;
			playerGO.transform.SetParent(base.transform);
			Player player = playerGO.GetComponent<Player>();
			player.Init(playerIDs[i]);
		}
		Diagnostics.Log("Game launched!");
		yield break;
	}

	protected override void OnRelease()
	{
		base.OnRelease();
		Diagnostics.Log("Releasing game...");
		SingletonManager.Get<AchievementManagerDOTE>().Commit();
		Hero.LocalPlayerActiveRecruitedHeroes.Clear();
		Hero.DeadHeroes.Clear();
		Hero.RemotePlayersActiveRecruitedHeroes.Clear();
		Hero.SelectedHeroes.Clear();
		Hero.RecentlyDeceasedHeroes.Clear();
		Mob.ActiveMobs.Clear();
		Door.OpenedDoorIDsHistory.Clear();
		Room.CleanedFromModuleSlotsIDs.Clear();
		Module.ClearOwnedActiveModules();
		MajorModule.UnlinkedShopModules.Clear();
		AITarget.ClearActiveTargets();
		SimMonoBehaviour.ClearSimMonoBhvsByName();
		SimMonoBehaviour.ClearTemporarySimDescriptors();
		DungeonGenerator2 dungeonGenerator = SingletonManager.Get<DungeonGenerator2>();
		if (dungeonGenerator != null)
		{
			dungeonGenerator.Clear();
		}
		UniqueIDManager.ResetIDs();
		Door.OpenableDoors.Clear();
		LogPanel logPanel = SingletonManager.Get<LogPanel>();
		if (logPanel != null)
		{
			logPanel.Reset();
		}
		ChatPanelInGame chatPanelInGame = SingletonManager.Get<ChatPanelInGame>();
		if (chatPanelInGame != null)
		{
			chatPanelInGame.InputTextField.ReplaceInputText(string.Empty);
		}
		IInputService service = Amplitude.Unity.Framework.Services.GetService<IInputService>();
		if (service.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			ConstructionPanel constructionPanel = SingletonManager.Get<ConstructionPanel>();
			if (constructionPanel != null)
			{
				constructionPanel.UnselectCurrentCategory();
				constructionPanel.SetModuleDestructionMode(on: false);
			}
		}
		SingletonManager.Get<DialogPanel>().Hide(instant: true);
		SingletonManager.Get<HeroRecruitmentPanel>().Hide(instant: true);
		SingletonManager.Get<DustFactoryPanel>().Hide(instant: true);
		SingletonManager.Get<CryoCapsulePanel>().Hide(instant: true);
		SingletonManager.Get<ResearchPanel>().Hide(instant: true);
		SingletonManager.Get<ResearchingPanel>().Hide(instant: true);
		SingletonManager.Get<NotificationPanel>().Hide(instant: true);
		SingletonManager.Get<StelePanel>().Hide(instant: true);
		SingletonManager.Get<CrystalLiftPanel>().Hide(instant: true);
		SingletonManager.Get<TutorialPanel>().StopTutorial();
		SingletonManager.Get<TutorialManager>().StopTutorial();
		SingletonManager.Get<ShortcutsPanel>().Hide(instant: true);
		SingletonManager.Get<InventoryPanel>().Hide(instant: true);
		SingletonManager.Get<SubInventoryPanel>().Hide(instant: true);
		if (SingletonManager.Get<MainGameScreen>().MerchantPanel != null)
		{
			SingletonManager.Get<MainGameScreen>().MerchantPanel.Hide(instant: true);
		}
		Diagnostics.Log("Game release!");
	}
}
public enum GameCameraZoom
{
	Default,
	ZoomedIn,
	ZoomedOut
}
public class GameCameraManager : Manager, IService, IGameCameraService
{
	private const string CameraStatusShaderParamName = "_CameraStatus";

	private readonly StaticString registryGameCameraMoveSpeed = "Settings/Controls/GameCameraMoveSpeed";

	private static int cameraStatusShaderParamId = -1;

	[SerializeField]
	private float controlsMoveSpeed;

	[SerializeField]
	private float defaultSmoothedFocusMoveSpeed;

	[SerializeField]
	private float defaultLinearFocusMoveSpeed;

	[SerializeField]
	private float visibilityMaxXDelta;

	[SerializeField]
	private float visibilityMaxZDelta;

	[SerializeField]
	private float positionTolerance;

	[SerializeField]
	private float defaultScale;

	[SerializeField]
	private float zoomInSpeed;

	[SerializeField]
	private float zoomInScale;

	private float zoomOutScale;

	[SerializeField]
	private float zoomOutDuration;

	[SerializeField]
	private float scaleTargetTolerance;

	[SerializeField]
	private float zoomMinDuration;

	[SerializeField]
	private Vector3 supportPositionOffset;

	[SerializeField]
	private Camera gameCamera;

	[SerializeField]
	private Transform gameCameraSupportTfm;

	[SerializeField]
	private Camera tacticalMapCamera;

	[SerializeField]
	private Transform tacticalMapCameraSupportTfm;

	[SerializeField]
	private float tacticalMapCameraSizeFactor;

	[SerializeField]
	private float tacticalMapCameraInitSize;

	private float startScale;

	private float startScaleTime;

	private float currentScale;

	private Vector3 supportStartPos;

	private float supportStartTime;

	private float supportTargetPosDist;

	private Vector3 supportTheoricalPos;

	private Vector3 supportTargetPos;

	private Vector3 targetZoom;

	private Vector3 moveDirection;

	private bool isLocked;

	private GameCameraZoom zoom;

	private IGameResolutionService gameResolutionManager;

	private float unzoomInMinTime;

	private bool needUnzoomIn;

	private Dungeon dungeon;

	private Transform originalSupportAnchor;

	private Rect visibilityZone;

	private float targetScale;

	private float zoomSpeed;

	private Camera activeCamera;

	private bool zoomEndReached;

	private ZoomEndHandler onZoomEnd;

	private float realFocusMoveSpeed;

	private LerpType focusLerpType;

	private LerpType zoomLerpType;

	private ICursorService cursorManager;

	private IAudioEventService audioManager;

	private Transform stickTfm;

	private Quaternion gameCameraSupportOriginalRotation;

	private Vector3 gameCameraSupportOriginalLocalScale;

	private Vector3 gameCamPosBeforeZoomOut;

	private FMOD.Event tacticalMapAmbianceSFX;

	private Type[] dialogPanelTypes = new Type[9]
	{
		typeof(DialogPanel),
		typeof(HeroRecruitmentPanel),
		typeof(MerchantPanel),
		typeof(ResearchPanel),
		typeof(ResearchingPanel),
		typeof(StelePanel),
		typeof(DustFactoryPanel),
		typeof(CryoCapsulePanel),
		typeof(CrystalPanel)
	};

	public Camera GameCamera => gameCamera;

	public bool IsSwitchingCamera
	{
		get;
		private set;
	}

	public event Action<bool> OnEndTacticalMapCameraToggle;

	public event Action<bool> OnBeginTacticalMapCameraToggle;

	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		SetLastError(0, "Waiting for service dependencies...");
		yield return BindService(delegate(IGameResolutionService service)
		{
			gameResolutionManager = service;
		});
		yield return BindService(delegate(ICursorService service)
		{
			cursorManager = service;
		});
		yield return BindService(delegate(IAudioEventService service)
		{
			audioManager = service;
		});
		SetGameCameraScale(defaultScale);
		currentScale = defaultScale;
		activeCamera = gameCamera;
		originalSupportAnchor = gameCameraSupportTfm.parent;
		gameCameraSupportOriginalRotation = gameCameraSupportTfm.rotation;
		gameCameraSupportOriginalLocalScale = gameCameraSupportTfm.localScale;
		Services.AddService((IGameCameraService)this);
		controlsMoveSpeed = Amplitude.Unity.Framework.Application.Registry.GetValue(registryGameCameraMoveSpeed, controlsMoveSpeed);
	}

	public Vector3 WorldToScreenPoint(Vector3 worldPos, Camera camera = null)
	{
		if (camera == null)
		{
			camera = activeCamera;
		}
		Vector2 v = camera.WorldToScreenPoint(worldPos);
		v -= gameResolutionManager.GetCurrentResolutionBorders();
		return v;
	}

	public Vector3 ScreenToWorldPoint(Vector3 screenPos)
	{
		Vector2 currentResolutionBorders = gameResolutionManager.GetCurrentResolutionBorders();
		screenPos.x += currentResolutionBorders.x;
		screenPos.y += currentResolutionBorders.y;
		return activeCamera.ScreenToWorldPoint(screenPos);
	}

	public Ray ScreenPointToRay(Vector3 screenPos)
	{
		return activeCamera.ScreenPointToRay(screenPos);
	}

	public Vector2 GetGameMousePosition()
	{
		Vector2 a = Input.mousePosition;
		return a - gameResolutionManager.GetCurrentResolutionBorders();
	}

	public Vector2 GetGameMouseNormalizedPosition()
	{
		Vector2 gameMousePosition = GetGameMousePosition();
		ScreenResolution currentDisplayResolution = gameResolutionManager.GetCurrentDisplayResolution();
		gameMousePosition.x /= currentDisplayResolution.Width;
		gameMousePosition.y /= currentDisplayResolution.Height;
		return gameMousePosition;
	}

	public void ActivateCamera(bool on)
	{
		gameCamera.enabled = on;
		if (!on)
		{
			tacticalMapCamera.enabled = false;
			onZoomEnd = null;
			IsSwitchingCamera = false;
			cursorManager.IsActive = true;
		}
	}

	public Vector3 GetCamPosition()
	{
		return gameCamera.transform.position;
	}

	public Vector3 GetCamSupportPosition()
	{
		return gameCameraSupportTfm.position;
	}

	public void Focus(Vector3 targetPos, LerpType lerpType = LerpType.Smoothed, float focusMoveSpeed = -1f)
	{
		if (!isLocked)
		{
			supportTargetPos = targetPos;
			if (focusMoveSpeed > 0f)
			{
				realFocusMoveSpeed = focusMoveSpeed;
			}
			else
			{
				realFocusMoveSpeed = ((lerpType != 0) ? defaultLinearFocusMoveSpeed : defaultSmoothedFocusMoveSpeed);
			}
			supportStartPos = supportTheoricalPos;
			supportTargetPosDist = Vector3.Distance(supportStartPos, supportTargetPos);
			supportStartTime = Time.realtimeSinceStartup;
			focusLerpType = lerpType;
			OnMove();
		}
	}

	public void ZoomIn(LerpType lerpType = LerpType.Smoothed, ZoomEndHandler onZoomEnd = null)
	{
		zoom = GameCameraZoom.ZoomedIn;
		startScale = currentScale;
		startScaleTime = Time.realtimeSinceStartup;
		targetScale = zoomInScale;
		zoomSpeed = zoomInSpeed;
		zoomLerpType = lerpType;
		this.onZoomEnd = onZoomEnd;
		zoomEndReached = false;
		unzoomInMinTime = Time.time + zoomMinDuration;
		needUnzoomIn = false;
	}

	public void ZoomOut(LerpType lerpType = LerpType.Smoothed, ZoomEndHandler onZoomEnd = null)
	{
		zoom = GameCameraZoom.ZoomedOut;
		tacticalMapCamera.enabled = true;
		tacticalMapCamera.clearFlags = CameraClearFlags.Depth;
		startScale = currentScale;
		startScaleTime = Time.realtimeSinceStartup;
		targetScale = zoomOutScale;
		zoomSpeed = Mathf.Abs(targetScale - startScale) / zoomOutDuration;
		zoomLerpType = lerpType;
		this.onZoomEnd = onZoomEnd;
		zoomEndReached = false;
	}

	public void Unzoom(ZoomEndHandler onZoomEnd = null)
	{
		zoom = GameCameraZoom.Default;
		startScale = currentScale;
		startScaleTime = Time.realtimeSinceStartup;
		targetScale = defaultScale;
		this.onZoomEnd = onZoomEnd;
		zoomEndReached = false;
	}

	public void SwitchToTacticalMapCamera()
	{
		if (activeCamera == tacticalMapCamera || IsSwitchingCamera)
		{
			return;
		}
		IsSwitchingCamera = true;
		gameCamPosBeforeZoomOut = gameCameraSupportTfm.position;
		Vector3 position = tacticalMapCameraSupportTfm.position;
		float focusMoveSpeed = Vector3.Distance(supportTheoricalPos, position) / zoomOutDuration;
		Focus(position, LerpType.Linear, focusMoveSpeed);
		ZoomOut(LerpType.Linear, OnZoomOutToTacticalMapEnd);
		for (int i = 0; i < dialogPanelTypes.Length; i++)
		{
			GuiPanel guiPanel = SingletonManager.Get(dialogPanelTypes[i]) as GuiPanel;
			if (guiPanel != null && guiPanel.IsVisible)
			{
				guiPanel.Hide(instant: true);
			}
		}
		if (this.OnBeginTacticalMapCameraToggle != null)
		{
			this.OnBeginTacticalMapCameraToggle(obj: false);
		}
	}

	private void OnZoomOutToTacticalMapEnd()
	{
		gameCamera.enabled = false;
		tacticalMapCamera.enabled = true;
		tacticalMapCamera.clearFlags = CameraClearFlags.Color;
		activeCamera = tacticalMapCamera;
		IsSwitchingCamera = false;
		cursorManager.IsActive = false;
		if (this.OnEndTacticalMapCameraToggle != null)
		{
			this.OnEndTacticalMapCameraToggle(obj: true);
		}
		tacticalMapAmbianceSFX = audioManager.Play2DEvent("Master/Ambiances/Ambiance_Map");
	}

	public void SwitchToGameCamera(bool goBackToPosBeforeZoomOut = false)
	{
		if (!(activeCamera == gameCamera) && !IsSwitchingCamera)
		{
			IsSwitchingCamera = true;
			gameCamera.enabled = true;
			tacticalMapCamera.clearFlags = CameraClearFlags.Depth;
			activeCamera = gameCamera;
			if (this.OnBeginTacticalMapCameraToggle != null)
			{
				this.OnBeginTacticalMapCameraToggle(obj: false);
			}
			if (goBackToPosBeforeZoomOut)
			{
				float focusMoveSpeed = Vector3.Distance(supportTheoricalPos, gameCamPosBeforeZoomOut) / zoomOutDuration;
				Focus(gameCamPosBeforeZoomOut, LerpType.Linear, focusMoveSpeed);
			}
			Unzoom(OnUnzoomToGameCameraEnd);
			cursorManager.IsActive = true;
			if (this.OnEndTacticalMapCameraToggle != null)
			{
				this.OnEndTacticalMapCameraToggle(obj: false);
			}
			if (tacticalMapAmbianceSFX != null)
			{
				tacticalMapAmbianceSFX.stop();
			}
		}
	}

	public void SwitchToGameCamera(Vector3 focusPos)
	{
		if (!(activeCamera == gameCamera) && !IsSwitchingCamera)
		{
			float focusMoveSpeed = Vector3.Distance(supportTheoricalPos, focusPos) / zoomOutDuration;
			Focus(focusPos, LerpType.Linear, focusMoveSpeed);
			SwitchToGameCamera();
		}
	}

	private void OnUnzoomToGameCameraEnd()
	{
		IsSwitchingCamera = false;
		tacticalMapCamera.enabled = false;
	}

	public bool IsTacticalMapActive()
	{
		return activeCamera == tacticalMapCamera;
	}

	public void ToggleTacticalMapCamera()
	{
		if (IsTacticalMapActive())
		{
			SwitchToGameCamera(goBackToPosBeforeZoomOut: true);
		}
		else
		{
			SwitchToTacticalMapCamera();
		}
	}

	public void Lock()
	{
		isLocked = true;
	}

	public void Unlock()
	{
		isLocked = false;
	}

	public void MoveToward(Vector3 direction)
	{
		if (!isLocked)
		{
			moveDirection += direction;
			OnMove();
			stickTfm = null;
		}
	}

	public void MoveByWorldDelta(Vector3 delta)
	{
		if (!isLocked)
		{
			supportTheoricalPos += delta;
			supportTargetPos = supportTheoricalPos;
			OnMove();
			stickTfm = null;
		}
	}

	public void MoveByPixelDelta(Vector3 delta)
	{
		if (dungeon == null)
		{
			dungeon = SingletonManager.Get<Dungeon>(mandatory: false);
		}
		if (!(dungeon == null))
		{
			ScreenResolution currentDisplayResolution = gameResolutionManager.GetCurrentDisplayResolution();
			float num = 0f - delta.x;
			ScreenResolution gameplayResolution = gameResolutionManager.GameplayResolution;
			float num2 = num * ((float)gameplayResolution.Width / (float)currentDisplayResolution.Width);
			Vector3 containerScale = dungeon.ContainerScale;
			float x = num2 * containerScale.x / currentScale;
			float num3 = 0f - delta.y;
			ScreenResolution gameplayResolution2 = gameResolutionManager.GameplayResolution;
			float num4 = num3 * ((float)gameplayResolution2.Height / (float)currentDisplayResolution.Height);
			Vector3 containerScale2 = dungeon.ContainerScale;
			MoveByWorldDelta(new Vector3(x, 0f, num4 * containerScale2.z / currentScale));
			stickTfm = null;
		}
	}

	public void MoveTo(Vector3 position, bool cancelStick = true)
	{
		if (!isLocked)
		{
			supportTheoricalPos = position;
			supportTargetPos = supportTheoricalPos;
			UpdateGameCameraSupportPosition();
			OnMove();
			if (cancelStick)
			{
				stickTfm = null;
			}
		}
	}

	public void StickTo(Transform tfm)
	{
		stickTfm = tfm;
	}

	public void AssertVisibility(Vector3 targetPos)
	{
		if (!isLocked)
		{
			float num = supportTargetPos.x;
			Vector3 vector = targetPos - supportTargetPos;
			float x = vector.x;
			float num2 = Mathf.Abs(x);
			if (num2 > visibilityMaxXDelta)
			{
				num += Mathf.Sign(x) * (num2 - visibilityMaxXDelta);
			}
			float num3 = supportTargetPos.z;
			Vector3 vector2 = targetPos - supportTargetPos;
			float z = vector2.z;
			float num4 = Mathf.Abs(z);
			if (num4 > visibilityMaxZDelta)
			{
				num3 += Mathf.Sign(z) * (num4 - visibilityMaxZDelta);
			}
			Focus(new Vector3(num, 0f, num3), LerpType.Linear, -1f);
		}
	}

	private void OnMove()
	{
		if (zoom == GameCameraZoom.ZoomedIn)
		{
			if (Time.time >= unzoomInMinTime)
			{
				Unzoom();
			}
			else
			{
				needUnzoomIn = true;
			}
		}
	}

	private void Update()
	{
		UpdateGameCameraSupportPosition();
		if (stickTfm != null)
		{
			MoveTo(stickTfm.position, cancelStick: false);
		}
		if (Mathf.Abs(currentScale - targetScale) > scaleTargetTolerance)
		{
			switch (zoomLerpType)
			{
			case LerpType.Linear:
				currentScale = Mathf.Lerp(startScale, targetScale, (Time.realtimeSinceStartup - startScaleTime) * zoomSpeed / Mathf.Abs(targetScale - startScale));
				break;
			case LerpType.Smoothed:
				currentScale = Mathf.Lerp(currentScale, targetScale, DungeonsApplication.GetRealtimeDelta() * zoomSpeed);
				break;
			}
		}
		else
		{
			if (currentScale != targetScale)
			{
				currentScale = targetScale;
			}
			if (!zoomEndReached && onZoomEnd != null)
			{
				onZoomEnd();
				zoomEndReached = true;
			}
		}
		if (needUnzoomIn && Time.time >= unzoomInMinTime)
		{
			if (!IsTacticalMapActive() && !IsSwitchingCamera)
			{
				Unzoom();
			}
			needUnzoomIn = false;
		}
		SetGameCameraScale(currentScale);
		if (cameraStatusShaderParamId == -1)
		{
			cameraStatusShaderParamId = Shader.PropertyToID("_CameraStatus");
		}
		Diagnostics.Assert(defaultScale < zoomInScale);
		Diagnostics.Assert(zoomOutScale < defaultScale);
		float num = 1f - Math.Max(0f, Math.Min(1f, (currentScale - zoomInScale) / (defaultScale - zoomInScale)));
		float num2 = 1f - Math.Max(0f, Math.Min(1f, (currentScale - zoomOutScale) / (defaultScale - zoomOutScale)));
		float x = Math.Max(0f, Math.Min(1f, 1f - num - num2));
		Shader.SetGlobalVector(vec: new Vector4(x, num2, num, 0f), nameID: cameraStatusShaderParamId);
	}

	private void SetGameCameraScale(float scale)
	{
		Camera camera = gameCamera;
		ScreenResolution gameplayResolution = gameResolutionManager.GameplayResolution;
		camera.orthographicSize = (float)gameplayResolution.Height / (2f * scale);
	}

	private void UpdateGameCameraSupportPosition()
	{
		if (moveDirection.sqrMagnitude > 0f)
		{
			supportTheoricalPos += moveDirection.normalized * DungeonsApplication.GetRealtimeDelta() * controlsMoveSpeed;
			supportTargetPos = supportTheoricalPos;
			moveDirection = Vector3.zero;
		}
		else if ((supportTheoricalPos - supportTargetPos).sqrMagnitude > positionTolerance * positionTolerance)
		{
			switch (focusLerpType)
			{
			case LerpType.Linear:
				supportTheoricalPos = Vector3.Lerp(supportStartPos, supportTargetPos, (Time.realtimeSinceStartup - supportStartTime) * realFocusMoveSpeed / supportTargetPosDist);
				break;
			case LerpType.Smoothed:
				supportTheoricalPos = Vector3.Lerp(supportTheoricalPos, supportTargetPos, DungeonsApplication.GetRealtimeDelta() * realFocusMoveSpeed);
				break;
			}
		}
		else if (supportTheoricalPos != supportTargetPos)
		{
			supportTheoricalPos = supportTargetPos;
		}
		if (supportTheoricalPos.x < visibilityZone.xMin)
		{
			supportTheoricalPos.x = visibilityZone.xMin;
		}
		if (supportTheoricalPos.x > visibilityZone.xMax)
		{
			supportTheoricalPos.x = visibilityZone.xMax;
		}
		if (supportTheoricalPos.z < visibilityZone.yMin)
		{
			supportTheoricalPos.z = visibilityZone.yMin;
		}
		if (supportTheoricalPos.z > visibilityZone.yMax)
		{
			supportTheoricalPos.z = visibilityZone.yMax;
		}
		gameCameraSupportTfm.position = supportTheoricalPos;
		gameCameraSupportTfm.localPosition = gameCameraSupportTfm.localPosition.RoundHalfAwayFromZero() + supportPositionOffset;
	}

	public void AnchorSupport(Transform parentTfm)
	{
		gameCameraSupportTfm.parent = parentTfm;
	}

	public void UnAnchorSupport()
	{
		gameCameraSupportTfm.parent = originalSupportAnchor;
		gameCameraSupportTfm.rotation = gameCameraSupportOriginalRotation;
		gameCameraSupportTfm.localScale = gameCameraSupportOriginalLocalScale;
	}

	public void AddVisibleZone(Rect visibleZone)
	{
		if (visibilityZone.width * visibilityZone.height == 0f)
		{
			visibilityZone = visibleZone;
		}
		else
		{
			if (visibleZone.xMin < visibilityZone.xMin)
			{
				visibilityZone.xMin = visibleZone.xMin;
			}
			if (visibleZone.xMax > visibilityZone.xMax)
			{
				visibilityZone.xMax = visibleZone.xMax;
			}
			if (visibleZone.yMin < visibilityZone.yMin)
			{
				visibilityZone.yMin = visibleZone.yMin;
			}
			if (visibleZone.yMax > visibilityZone.yMax)
			{
				visibilityZone.yMax = visibleZone.yMax;
			}
		}
		Transform transform = tacticalMapCameraSupportTfm;
		Vector2 center = visibilityZone.center;
		float x = center.x;
		Vector2 center2 = visibilityZone.center;
		transform.position = new Vector3(x, 0f, center2.y);
		float num = tacticalMapCameraSizeFactor * Mathf.Max(visibilityZone.width, visibilityZone.height) / 2f;
		if (tacticalMapCamera.orthographicSize < num)
		{
			tacticalMapCamera.orthographicSize = num;
			UpdateZoomOutScale();
		}
	}

	public void ResetVisibleZone()
	{
		visibilityZone.width = 0f;
		visibilityZone.height = 0f;
		tacticalMapCamera.orthographicSize = tacticalMapCameraInitSize;
		UpdateZoomOutScale();
	}

	private void UpdateZoomOutScale()
	{
		ScreenResolution gameplayResolution = gameResolutionManager.GameplayResolution;
		zoomOutScale = (float)gameplayResolution.Height / (2f * tacticalMapCamera.orthographicSize);
	}
}
public class GameDebug : MonoBehaviour
{
	[SerializeField]
	private bool isActive;

	[SerializeField]
	private KeyCode shortcut;

	[SerializeField]
	private string padShortcut = "RightStickClick";

	[SerializeField]
	private float fpsUpdateInterval;
}
public struct AttackInfo
{
	public float Damages;

	public StaticString AttackerCategory;

	public int AttackerID;

	public Vector3 AttackerPos;

	public bool DisplayHit;
}
public class AttackProjectile : MonoBehaviour
{
	public delegate void OnHitHandler(AITarget target, Vector3 targetPosition);

	public OnHitHandler OnHit;

	[SerializeField]
	private float hitDistance;

	private bool isLaunched;

	private AITarget target;

	private Vector3 targetPosition;

	private Dungeon dungeon;

	private string attackType;

	private Transform tfm;

	private AttackTypeConfig attackTypeConfig;

	private GameObjectPoolManager goPoolManager;

	private GameObject projectileVFXGO;

	public float MoveSpeed
	{
		get;
		set;
	}

	private void Awake()
	{
		goPoolManager = SingletonManager.Get<GameObjectPoolManager>();
	}

	public void Init(AITarget target, Vector3 targetPosition, string attackType)
	{
		tfm = base.transform;
		attackTypeConfig = Databases.GetDatabase<AttackTypeConfig>().GetValue(attackType);
		this.attackType = attackType;
		isLaunched = true;
		this.target = target;
		MoveSpeed = attackTypeConfig.ProjectileSpeed;
		dungeon = SingletonManager.Get<Dungeon>();
		this.targetPosition = targetPosition;
		SimMonoBehaviour component = target.GetComponent<SimMonoBehaviour>();
		if (component != null)
		{
			float num = component.GetSimPropertyValue(SimulationProperties.HealthBarHeight) / 2f;
			if (num > 0f)
			{
				this.targetPosition = new Vector3(targetPosition.x, targetPosition.y + num, targetPosition.z);
			}
		}
		if (projectileVFXGO != null)
		{
			goPoolManager.Recycle(projectileVFXGO);
			projectileVFXGO = null;
		}
		string path = "VFX/Projectile/" + attackType;
		GameObject gameObject = (GameObject)Resources.Load(path, typeof(GameObject));
		if (!(gameObject == null))
		{
			projectileVFXGO = goPoolManager.Instantiate(gameObject, tfm.position, tfm.rotation, tfm);
		}
		RotateTowardTarget();
	}

	private void Update()
	{
		if (!isLaunched)
		{
			return;
		}
		if (target == null || dungeon.GetSqrDistance(tfm.position, targetPosition) <= hitDistance * hitDistance)
		{
			if (OnHit != null && target != null)
			{
				OnHit(target, targetPosition);
			}
			if (target != null)
			{
				string text = attackType;
				int num = text.LastIndexOf("_LVL");
				if (num != -1)
				{
					text = text.Substring(0, num);
				}
				string path = "VFX/Impact/" + text;
				GameObject gameObject = (GameObject)Resources.Load(path, typeof(GameObject));
				if (gameObject != null)
				{
					GameObject gameObject2 = goPoolManager.Instantiate(gameObject, tfm.position, tfm.rotation);
					ParticleSystem component = gameObject2.GetComponent<ParticleSystem>();
					if (component != null)
					{
						if (target != null)
						{
							component.transform.position = targetPosition;
							if (attackTypeConfig != null && attackTypeConfig.ImpactFollowTarget)
							{
								component.transform.parent = target.Tfm;
							}
						}
						component.Play(withChildren: true);
						goPoolManager.DelayRecycle(component.gameObject, component.duration);
					}
				}
			}
			if (projectileVFXGO != null)
			{
				goPoolManager.Recycle(projectileVFXGO);
				projectileVFXGO = null;
			}
			if (OnHit != null)
			{
				OnHit = null;
			}
			goPoolManager.Recycle(base.gameObject);
		}
		else
		{
			Vector3 a = targetPosition - tfm.position;
			float magnitude = a.magnitude;
			float b = Time.deltaTime * MoveSpeed;
			float num2 = Mathf.Min(magnitude, b);
			tfm.position += a * (num2 / magnitude);
		}
	}

	private void RotateTowardTarget()
	{
		Vector3 forward = targetPosition - tfm.position;
		if (forward.sqrMagnitude > Mathf.Epsilon)
		{
			tfm.forward = forward;
		}
	}
}
[RequireComponent(typeof(Health))]
[RequireComponent(typeof(SimMonoBehaviour))]
public class Attacker : MonoBehaviour
{
	public delegate void TargetFoundHandler();

	public delegate void TargetKilledHandler(Health targetHealth);

	[SerializeField]
	protected SpriteAnimationRuntime2 anim;

	[SerializeField]
	protected GameObject projectilePfb;

	[SerializeField]
	protected GameObject[] overheatingLevelVFXPfb;

	[SerializeField]
	protected string attackHitAnimEvent = "OnAttackHit";

	[SerializeField]
	protected bool debug;

	protected Mob mob;

	protected ParticleSystem overheatingVFX;

	private AITarget currentAttackTarget;

	private Vector3 currentAttackTargetPosition;

	private AudioEmitter audioEmitter;

	private string sfxPath;

	private ParticleSystem attackVFX;

	private ParticleSystem impactVFX;

	private AttackTypeConfig attackTypeConfig;

	private Mover moverCpnt;

	private float cooldownEndTime;

	private Dungeon dungeon;

	private RoomElement roomElement;

	private UniqueID uniqueID;

	private float selfDestructTimer;

	private float overheatingTimer;

	private string overheatingSFXName;

	private HeatBarDisplayer heatBar;

	private FMOD.Event attackLoopSFX;

	private IAudioService audioService;

	private Transform tfm;

	protected GameObjectPoolManager goPoolManager;

	private UnityEngine.Component _targetComp;

	private Health _targetHealth;

	public bool RunForestRun;

	private UnityEngine.Component _uniqueComp;

	private AITarget _target;

	private AITarget[] _aiTargets;

	public AITarget Target
	{
		get;
		private set;
	}

	public AttackTypeConfig ActiveAttackType
	{
		get;
		set;
	}

	public bool CanAttack
	{
		get;
		set;
	}

	public string AnimSuffix
	{
		get;
		set;
	}

	public int Level
	{
		get;
		set;
	}

	public Health HealthCpnt
	{
		get;
		set;
	}

	public float HeatPCt
	{
		get;
		private set;
	}

	public float OverheatPCt
	{
		get;
		private set;
	}

	public bool CanOverheat
	{
		get;
		private set;
	}

	public bool IsOverheating
	{
		get;
		private set;
	}

	public float Heat
	{
		get;
		private set;
	}

	public float SelfDestructTimer
	{
		get
		{
			return selfDestructTimer;
		}
		set
		{
			selfDestructTimer = value;
		}
	}

	public SimMonoBehaviour SimMB
	{
		get;
		private set;
	}

	public UniqueIDNetSyncElement NetSyncElement
	{
		get;
		private set;
	}

	public event TargetKilledHandler OnTargetKilled;

	public event Action<AITarget> OnHitTarget;

	public virtual void Init(string attackType)
	{
		cooldownEndTime = -1f;
		CanOverheat = (SimMB.GetSimPropertyValue(SimulationProperties.HeatMaximum) > 0f);
		overheatingSFXName = "Master/Modules/ModuleMachineGun_OverHeat";
		Heat = 0f;
		IsOverheating = false;
		audioService = Services.GetService<IAudioService>();
		Diagnostics.Assert(audioService != null);
		if (!string.IsNullOrEmpty(attackType))
		{
			attackTypeConfig = Databases.GetDatabase<AttackTypeConfig>().GetValue(attackType);
			if (attackTypeConfig == null)
			{
				Diagnostics.LogError(base.name + " > Attacker.Init: Unable to find \"" + attackType + "\" attack type");
				return;
			}
			SwitchAttackType(attackTypeConfig);
		}
		if (_aiTargets != null && _aiTargets.Length == 0)
		{
			CheckSelfDestruct();
		}
		if (anim != null)
		{
			anim.MonitorAnimEvent(attackHitAnimEvent, OnAttackHitAnimEvent);
		}
	}

	public void ResetAttackType()
	{
		SwitchAttackType(attackTypeConfig);
	}

	public void SwitchAttackType(AttackTypeConfig attackType)
	{
		if (attackType == ActiveAttackType || attackType == null)
		{
			return;
		}
		string path = "VFX/Attack/" + attackType.Name;
		GameObject gameObject = (GameObject)Resources.Load(path, typeof(GameObject));
		if (!(gameObject == null))
		{
			if (attackVFX != null)
			{
				goPoolManager.Recycle(attackVFX.gameObject);
			}
			attackVFX = InstantiatePfb(gameObject).GetComponent<ParticleSystem>();
		}
		if (!attackType.UseProjectile)
		{
			string path2 = "VFX/Impact/" + attackType.Name;
			GameObject gameObject2 = (GameObject)Resources.Load(path2, typeof(GameObject));
			if (!(gameObject2 == null))
			{
				if (impactVFX != null)
				{
					goPoolManager.Recycle(impactVFX.gameObject);
				}
				GameObject gameObject3 = goPoolManager.Instantiate(gameObject2, tfm.position, tfm.rotation, tfm);
				impactVFX = gameObject3.GetComponent<ParticleSystem>();
				impactVFX.Stop();
			}
		}
		sfxPath = attackType.SFXPath;
		ActiveAttackType = attackType;
	}

	public void SetTarget(AITarget target)
	{
		if (!CanAttack)
		{
			Diagnostics.LogError(base.name + " > SetTarget: CANNOT ATTACK!");
		}
		else if (!(Target == target))
		{
			NetSyncElement.SendRPCToAll(UniqueIDRPC.Attacker_DoSetTarget, target.UniqueID.GetCategory(), target.UniqueID.ID);
		}
	}

	private void RPC_DoSetTarget(StaticString targetCategory, int targetID)
	{
		if (!CanAttack)
		{
			Diagnostics.LogError(base.name + " > RPC_DoSetTarget: CANNOT ATTACK!");
			return;
		}
		UniqueIDGetError error;
		UnityEngine.Component component = UniqueIDManager.Get(targetCategory, targetID, out error, logError: false);
		if (component == null)
		{
			if (error == UniqueIDGetError.ObjectIsNull)
			{
				Diagnostics.Log("{0} > RPC_DoSetTarget: Unable to find target {1}#{2} (already dead&destroyed)", base.name, targetCategory, targetID);
			}
			else
			{
				Diagnostics.LogError("{0} > RPC_DoSetTarget: Unable to find target {1}#{2} (error={3})", base.name, targetCategory, targetID, error);
			}
			return;
		}
		AITarget[] components = component.GetComponents<AITarget>();
		if (components.Length == 0)
		{
			Diagnostics.LogError(base.name + " > RPC_DoSetTarget: Unable to find any AI target on " + component.name);
			return;
		}
		AITarget aITarget = null;
		for (int i = 0; i < components.Length; i++)
		{
			if (components[i].Interaction == AIInteraction.Attack)
			{
				aITarget = components[i];
				break;
			}
		}
		if (aITarget == null)
		{
			Diagnostics.LogError(base.name + " > RPC_DoSetTarget: Unable to find attackable AI target on " + component.name);
		}
		else if (!(Target == aITarget))
		{
			if (debug)
			{
				Diagnostics.Log(base.name + " > RPC_DoSetTarget: " + aITarget.gameObject + " of type " + aITarget.Type);
			}
			OnTargetChanged(Target, aITarget);
			Target = aITarget;
			if (NetSyncElement.IsOwnedByLocalPlayer())
			{
				StartAttack();
			}
		}
	}

	public void StartAttack()
	{
		if (!NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Attacker.StartAttack should only be called on owner side!");
			return;
		}
		if (debug)
		{
			Diagnostics.Log(base.name + " > StartAttack");
		}
		if (cooldownEndTime < 0f || Time.time >= cooldownEndTime)
		{
			cooldownEndTime = Time.time;
			AttackTarget();
		}
	}

	public void StopAttack()
	{
		OnTargetChanged(Target, null);
		Target = null;
		SetIsAttacking(isAttacking: false);
	}

	public virtual GameObject InstantiatePfb(GameObject pfb)
	{
		return goPoolManager.Instantiate(pfb, tfm.position, tfm.rotation, tfm);
	}

	protected virtual void OnTargetChanged(AITarget previousTarget, AITarget newTarget)
	{
	}

	public void ApplyZoneDamagesInRoom(AITarget mainTarget, bool directHit, Room targetRoom, float bonusZoneAttackRadius = 0f, float bonusDamageOnMobs = 0f)
	{
		float num = SimMB.GetSimPropertyValue(SimulationProperties.ZoneAttackRadius) + bonusZoneAttackRadius;
		if (num != 0f)
		{
			ApplyZoneDamagesOnTargets(mainTarget, directHit, targetRoom.Mobs, num, SimMB.GetSimPropertyValue(SimulationProperties.ZoneAttackPowerOnMobs) + bonusDamageOnMobs);
			ApplyZoneDamagesOnTargets(mainTarget, directHit, targetRoom.Heroes, num, SimMB.GetSimPropertyValue(SimulationProperties.ZoneAttackPowerOnHeroes));
			if (targetRoom.MajorModule != null)
			{
				ApplyZoneDamagesOnTargets(mainTarget, directHit, new List<MajorModule>
				{
					targetRoom.MajorModule
				}, num, SimMB.GetSimPropertyValue(SimulationProperties.ZoneAttackPowerOnModules));
			}
			ApplyZoneDamagesOnTargets(mainTarget, directHit, targetRoom.MinorModules, num, SimMB.GetSimPropertyValue(SimulationProperties.ZoneAttackPowerOnModules));
			ApplyZoneDamagesOnTargets(mainTarget, directHit, targetRoom.NPCs, num, SimMB.GetSimPropertyValue(SimulationProperties.ZoneAttackPowerOnNPCs));
		}
	}

	public void RegisterTargetKill(Health targetHealth)
	{
		NetSyncElement.SendRPCToPlayer(NetSyncElement.OwnerPlayerID, UniqueIDRPC.Attacker_DoRegisterTargetKill, targetHealth.UniqueID.GetCategory(), targetHealth.UniqueID.ID);
	}

	private void RPC_DoRegisterTargetKill(StaticString targetCategory, int targetID)
	{
		_targetComp = UniqueIDManager.Get(targetCategory, targetID);
		if (_targetComp != null)
		{
			if (!NetSyncElement.IsOwnedByLocalPlayer())
			{
				Diagnostics.LogError(base.name + " > Attacker.AttackTarget should only be called on owner side!");
			}
			else if (this.OnTargetKilled != null)
			{
				_targetHealth = _targetComp.GetComponent<Health>();
				this.OnTargetKilled(_targetHealth);
			}
		}
	}

	private float GetAttackAnimDuration()
	{
		float num = -1f;
		string animName = "Attack";
		num = anim.GetAnimLength(animName);
		if (num <= 0f)
		{
			animName = $"Attack{anim.GetCurrentAnimDirectionSuffix()}";
			num = anim.GetAnimLength(animName);
		}
		if (num <= 0f)
		{
			animName = "Attack_AllDirs";
			num = anim.GetAnimLength(animName);
		}
		return num;
	}

	protected float GetAttackPower()
	{
		Player ownerPlayer = NetSyncElement.GetOwnerPlayer();
		float scienceStock = ownerPlayer.ScienceStock;
		return Mathf.Min(SimMB.GetSimPropertyValue(SimulationProperties.AttackPower) + scienceStock * SimMB.GetSimPropertyValue(SimulationProperties.ScienceAttackPowerBonus), SimMB.GetSimPropertyValue(SimulationProperties.MaximumAttackPower));
	}

	protected virtual void Awake()
	{
		tfm = GetComponent<Transform>();
		SimMB = GetComponent<SimMonoBehaviour>();
		HealthCpnt = GetComponent<Health>();
		heatBar = GetComponent<HeatBarDisplayer>();
		moverCpnt = GetComponent<Mover>();
		audioEmitter = GetComponent<AudioEmitter>();
		roomElement = GetComponent<RoomElement>();
		NetSyncElement = GetComponent<UniqueIDNetSyncElement>();
		uniqueID = GetComponent<UniqueID>();
		mob = GetComponent<Mob>();
		goPoolManager = SingletonManager.Get<GameObjectPoolManager>();
		HealthCpnt.OnDeath += OnDeath;
		CanAttack = true;
	}

	private void Start()
	{
		dungeon = SingletonManager.Get<Dungeon>();
	}

	protected virtual void Update()
	{
		if (cooldownEndTime >= 0f && Time.time >= cooldownEndTime && NetSyncElement.IsOwnedByLocalPlayer())
		{
			AttackTarget();
		}
		if (selfDestructTimer > 0f)
		{
			selfDestructTimer -= Time.deltaTime;
			if (selfDestructTimer <= 0f && HealthCpnt.IsAlive())
			{
				if (mob != null)
				{
					mob.SelfDestruct = true;
				}
				if (NetSyncElement.IsOwnedByLocalPlayer())
				{
					LaunchAttackOnTarget();
					HealthCpnt.Kill();
				}
			}
		}
		if (CanOverheat)
		{
			if (Heat > 0f)
			{
				Heat = Mathf.Max(0f, Heat - SimMB.GetSimPropertyValue(SimulationProperties.HeatCooling) * Time.deltaTime);
			}
			if (IsOverheating)
			{
				overheatingTimer -= Time.deltaTime;
				if (overheatingTimer <= 0f)
				{
					IsOverheating = false;
					Heat = 0f;
					if (overheatingVFX != null)
					{
						overheatingVFX.Stop(withChildren: true);
					}
					if (NetSyncElement.IsOwnedByLocalPlayer())
					{
						StartAttack();
					}
				}
			}
			OverheatPCt = overheatingTimer / SimMB.GetSimPropertyValue(SimulationProperties.OverheatingDuration);
			HeatPCt = Heat / SimMB.GetSimPropertyValue(SimulationProperties.HeatMaximum);
			if (HealthCpnt.IsAlive())
			{
				heatBar.UpdateBarDisplay();
			}
		}
		if (HealthCpnt != null && HealthCpnt.HealthBar != null)
		{
			HealthCpnt.HealthBar.UpdateBarDisplay();
		}
	}

	private void AttackTarget()
	{
		if (Time.time < cooldownEndTime)
		{
			Diagnostics.LogError(base.name + " > Attacker.AttackTarget cooldown not over yet! (" + Time.time + " < " + cooldownEndTime + ")");
		}
		else if (!NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Attacker.AttackTarget should only be called on owner side!");
		}
		else if (!CanAttack)
		{
			StopAttack();
		}
		else if (Target == null)
		{
			StopAttack();
		}
		else if (Target.HealthCpnt != null && !Target.HealthCpnt.IsAlive())
		{
			StopAttack();
		}
		else if (Target.GetCurrentRoom() != roomElement.ParentRoom)
		{
			StopAttack();
		}
		else if (!IsOverheating)
		{
			if (debug)
			{
				Diagnostics.Log(base.name + " > AttackTarget");
			}
			if (moverCpnt != null && moverCpnt.IsMoving)
			{
				moverCpnt.StopMove();
			}
			CheckSelfDestruct();
			NetSyncElement.SendUnreliableRPCToAll(UniqueIDRPC.Attacker_DisplayAttack, Target.UniqueID.GetCategory(), Target.UniqueID.ID, (Int2Position)Target.GetPosition(), (Int2Position)tfm.position);
			cooldownEndTime += SimMB.GetSimPropertyValue(SimulationProperties.AttackCooldown);
			if (Time.time >= cooldownEndTime)
			{
				Diagnostics.LogError("Next attack should already be triggered, check the start/stop attack process!");
			}
			SetIsAttacking(isAttacking: true);
		}
	}

	private void RPC_DisplayAttack(StaticString targetCategory, int targetID, Int2Position targetPosition, Int2Position attackPosition)
	{
		if (HealthCpnt != null && !HealthCpnt.IsAlive())
		{
			return;
		}
		tfm.position = (Vector3)attackPosition;
		Vector3 vector = (Vector3)targetPosition;
		_uniqueComp = UniqueIDManager.Get(targetCategory, targetID, out UniqueIDGetError error, logError: false);
		if (_uniqueComp == null)
		{
			if (error == UniqueIDGetError.ObjectIsNull)
			{
				Diagnostics.Log("RPC_DisplayAttack: Unable to find {0}#{1} unique component (already dead&destroyed)", targetCategory, targetID);
			}
			else
			{
				Diagnostics.LogError("RPC_DisplayAttack: Unable to find {0}#{1} unique component (error={2})", targetCategory, targetID, error);
			}
			currentAttackTarget = null;
			return;
		}
		_aiTargets = _uniqueComp.GetComponents<AITarget>();
		if (_aiTargets.Length > 0)
		{
			_target = null;
			for (int i = 0; i < _aiTargets.Length; i++)
			{
				if (_aiTargets[i].Interaction == AIInteraction.Attack)
				{
					_target = _aiTargets[i];
					break;
				}
			}
			if (_target == null)
			{
				Diagnostics.LogError("RPC_DisplayAttack: Unable to find attackable AI target on " + _uniqueComp.name);
				currentAttackTarget = null;
				return;
			}
			vector = _target.GetPosition();
			if (debug)
			{
				Diagnostics.Log(base.name + " > RPC_DisplayAttack");
			}
			currentAttackTarget = _target;
			currentAttackTargetPosition = vector;
			float attackAnimDuration = GetAttackAnimDuration();
			if (anim == null || attackAnimDuration <= 0f)
			{
				LaunchAttackOnTarget();
				return;
			}
			anim.SetAnimDirection(vector - tfm.position);
			float simPropertyValue = SimMB.GetSimPropertyValue(SimulationProperties.AttackCooldown);
			if (attackAnimDuration >= 0f && attackAnimDuration > simPropertyValue)
			{
				anim.SetSpeed(attackAnimDuration / simPropertyValue, "AttackBT");
			}
			anim.Trigger(SpriteAnimationTrigger.OnAttack, autoPlayIfStopped: true, forceShow: false);
		}
		else
		{
			Diagnostics.LogError("RPC_DisplayAttack: Unable to find any AI target on " + _uniqueComp.name);
			currentAttackTarget = null;
		}
	}

	private Room GetCurrentRoom()
	{
		return roomElement.ParentRoom;
	}

	private void OnAttackHitAnimEvent()
	{
		LaunchAttackOnTarget();
	}

	private void LaunchAttackOnTarget()
	{
		if (currentAttackTarget == null)
		{
			return;
		}
		if (debug)
		{
			Diagnostics.Log(base.name + " > LaunchAttackOnTarget");
		}
		if (attackVFX != null)
		{
			attackVFX.Play(withChildren: true);
		}
		if (audioEmitter != null && !string.IsNullOrEmpty(sfxPath))
		{
			audioEmitter.PlayEvent(sfxPath);
		}
		if (ActiveAttackType != null && ActiveAttackType.UseProjectile)
		{
			GameObject gameObject = goPoolManager.Instantiate(projectilePfb, GetProjectileLaunchPosition(), tfm.rotation);
			AttackProjectile component = gameObject.GetComponent<AttackProjectile>();
			if (NetSyncElement.IsOwnedByLocalPlayer())
			{
				component.OnHit = (AttackProjectile.OnHitHandler)Delegate.Combine(component.OnHit, new AttackProjectile.OnHitHandler(OnProjectileHitTarget));
			}
			component.Init(currentAttackTarget, currentAttackTargetPosition, ActiveAttackType.Name);
		}
		else
		{
			HitTarget(currentAttackTarget, currentAttackTargetPosition);
		}
		if (!CanOverheat)
		{
			return;
		}
		Heat += 1f;
		if (Heat >= SimMB.GetSimPropertyValue(SimulationProperties.HeatMaximum))
		{
			IsOverheating = true;
			audioEmitter.PlayEvent(overheatingSFXName);
			overheatingTimer = SimMB.GetSimPropertyValue(SimulationProperties.OverheatingDuration);
			if (overheatingVFX != null)
			{
				overheatingVFX.Play(withChildren: true);
			}
			SetIsAttacking(isAttacking: false);
		}
	}

	protected virtual Vector3 GetProjectileLaunchPosition()
	{
		return tfm.position;
	}

	private void OnProjectileHitTarget(AITarget target, Vector3 targetPosition)
	{
		if (!NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Attacker.OnProjectileHitTarget should only be called on owner side!");
		}
		else
		{
			HitTarget(target, targetPosition, directHit: false);
		}
	}

	private void HitTarget(AITarget mainTarget, Vector3 targetPosition, bool directHit = true, bool isZoneDamage = false, float zoneDamages = 0f)
	{
		if (this == null)
		{
			return;
		}
		if (directHit && impactVFX != null)
		{
			impactVFX.transform.position = targetPosition;
			impactVFX.Play(withChildren: true);
		}
		if (!NetSyncElement.IsOwnedByLocalPlayer())
		{
			return;
		}
		if (debug)
		{
			Diagnostics.LogWarning(base.name + " > HitTarget: mainTarget=" + mainTarget.name + " isZoneDamage=" + isZoneDamage + " zoneDamages=" + zoneDamages);
		}
		if (!(mainTarget != null))
		{
			return;
		}
		targetPosition = mainTarget.Tfm.position;
		if (this.OnHitTarget != null)
		{
			this.OnHitTarget(mainTarget);
		}
		float damages = ((!isZoneDamage) ? GetAttackPower() : zoneDamages) / SimMB.GetSimPropertyValue(SimulationProperties.AttackHitCount);
		if (mainTarget.HealthCpnt != null && mainTarget.HealthCpnt.IsAlive())
		{
			mainTarget.HealthCpnt.Hit(new AttackInfo
			{
				Damages = damages,
				AttackerCategory = uniqueID.GetCategory(),
				AttackerID = uniqueID.ID,
				AttackerPos = tfm.position,
				DisplayHit = true
			});
		}
		float simPropertyValue = SimMB.GetSimPropertyValue(SimulationProperties.SelfDamage);
		if (simPropertyValue > 0f && HealthCpnt != null && HealthCpnt.IsAlive())
		{
			HealthCpnt.Hit(new AttackInfo
			{
				Damages = simPropertyValue,
				AttackerCategory = uniqueID.GetCategory(),
				AttackerID = uniqueID.ID,
				AttackerPos = tfm.position,
				DisplayHit = true
			});
		}
		if (ActiveAttackType != null)
		{
			if (ActiveAttackType.InflictTrouble)
			{
				mainTarget.InflictTrouble(Level);
			}
			else
			{
				float simPropertyValue2 = SimMB.GetSimPropertyValue(SimulationProperties.InflictTroubledChance);
				if (simPropertyValue2 > 0f && (float)UnityEngine.Random.Range(0, 100) < simPropertyValue2)
				{
					mainTarget.InflictTrouble(4);
				}
			}
			if (ActiveAttackType.InflictPoison)
			{
				mainTarget.InflictPoison(Level);
			}
			else
			{
				float simPropertyValue3 = SimMB.GetSimPropertyValue(SimulationProperties.InflictPoisonChance);
				if (simPropertyValue3 > 0f && (float)UnityEngine.Random.Range(0, 100) < simPropertyValue3)
				{
					mainTarget.InflictPoison(4);
				}
			}
			if (!string.IsNullOrEmpty(ActiveAttackType.SimulationModifierName) && mainTarget.SimMB != null && !mainTarget.SimMB.GetSimObj().Tags.Contains(ActiveAttackType.SimulationModifierName))
			{
				if (ActiveAttackType.SimulationModifier == null)
				{
					ActiveAttackType.SimulationModifier = SimMonoBehaviour.GetDBDescriptorByName(ActiveAttackType.SimulationModifierName);
				}
				mainTarget.SimMB.AddSimDescriptor(ActiveAttackType.SimulationModifier);
			}
		}
		float simPropertyValue4 = SimMB.GetSimPropertyValue(SimulationProperties.AttackBurnDamage);
		float simPropertyValue5 = SimMB.GetSimPropertyValue(SimulationProperties.AttackBurnDuration);
		if (simPropertyValue4 > 0f && simPropertyValue5 > 0f)
		{
			mainTarget.InflictAttackBurn(simPropertyValue4, simPropertyValue5, attackTypeConfig.Name);
		}
		if (!isZoneDamage)
		{
			ApplyZoneDamagesInRoom(mainTarget, directHit, mainTarget.GetCurrentRoom(), 0f, 0f);
		}
	}

	private void ApplyZoneDamagesOnTargets<T>(AITarget mainTarget, bool directHit, List<T> zoneTargets, float zoneRadius, float zoneAttackPower) where T : SimMonoBehaviour
	{
		if (zoneAttackPower <= 0f)
		{
			return;
		}
		for (int i = 0; i < zoneTargets.Count; i++)
		{
			int count = zoneTargets.Count;
			T x = zoneTargets[i];
			if ((UnityEngine.Object)x == (UnityEngine.Object)null || x == mainTarget)
			{
				continue;
			}
			if (zoneRadius < 0f || dungeon.GetSqrDistance(mainTarget.Tfm.position, x.transform.position) <= zoneRadius * zoneRadius)
			{
				AITarget[] components = x.GetComponents<AITarget>();
				if (components.Length > 0)
				{
					AITarget aITarget = components[0];
					HitTarget(aITarget, aITarget.Tfm.position, directHit, isZoneDamage: true, zoneAttackPower);
				}
			}
			if (zoneTargets.Count != count)
			{
				i--;
			}
		}
	}

	private void OnDeath(ulong attackerOwnerPlayerID)
	{
		CanAttack = false;
		StopAttack();
		if (heatBar != null)
		{
			heatBar.HideBar();
		}
		if (overheatingVFX != null)
		{
			goPoolManager.Recycle(overheatingVFX.gameObject);
		}
		if (impactVFX != null)
		{
			goPoolManager.Recycle(impactVFX.gameObject);
		}
		if (attackVFX != null)
		{
			goPoolManager.Recycle(attackVFX.gameObject);
		}
	}

	private void SetIsAttacking(bool isAttacking)
	{
		if (attackTypeConfig == null || string.IsNullOrEmpty(attackTypeConfig.AttackLoopSFXPath))
		{
			return;
		}
		if (isAttacking)
		{
			if (attackLoopSFX == null || !audioService.IsEventPlaying(attackLoopSFX))
			{
				attackLoopSFX = audioEmitter.PlayEvent(attackTypeConfig.AttackLoopSFXPath);
			}
		}
		else if (attackLoopSFX != null && audioService.IsEventPlaying(attackLoopSFX))
		{
			audioEmitter.StopEvent(attackLoopSFX);
		}
	}

	public void CheckSelfDestruct()
	{
		if (attackTypeConfig.SelfDestruct && selfDestructTimer <= 0f)
		{
			selfDestructTimer = RandomGenerator.RangeFloat(SimMB.GetSimPropertyValue(SimulationProperties.SelfDestructDelayMin), SimMB.GetSimPropertyValue(SimulationProperties.SelfDestructDelayMax));
		}
	}
}
public abstract class BarDisplayer : MonoBehaviour
{
	[SerializeField]
	protected Transform barContainer;

	[SerializeField]
	protected Transform barScaler;

	[HideInInspector]
	public bool IsHolderHidden;

	private RoomElement roomElement;

	public Transform BarContainer => barContainer;

	public Transform BarScaler => barScaler;

	protected virtual void Awake()
	{
		roomElement = GetComponent<RoomElement>();
		if (roomElement != null)
		{
			roomElement.OnParentRoomChanged += OnParentRoomChanged;
			if (roomElement.ParentRoom != null)
			{
				roomElement.ParentRoom.OnRoomContentChanged += OnParentRoomContentChanged;
			}
		}
	}

	private void OnParentRoomChanged(Room previousParentRoom, Room newParentRoom)
	{
		if (previousParentRoom != null)
		{
			previousParentRoom.OnRoomContentChanged -= OnParentRoomContentChanged;
		}
		if (newParentRoom != null)
		{
			newParentRoom.OnRoomContentChanged += OnParentRoomContentChanged;
		}
		OnParentRoomContentChanged();
	}

	private void OnParentRoomContentChanged()
	{
		if (!(roomElement == null) && !(roomElement.ParentRoom == null))
		{
			IsHolderHidden = (!roomElement.ParentRoom.IsStartRoom && !roomElement.ParentRoom.IsPowered && !roomElement.ParentRoom.IsOccupied());
			UpdateBarDisplay();
		}
	}

	public virtual void HideBar()
	{
		if (barContainer != null && barContainer.gameObject.activeSelf)
		{
			barContainer.gameObject.SetActive(value: false);
		}
	}

	public abstract void ShowBar();

	public abstract void UpdateBarDisplay();

	private void OnDestroy()
	{
		if (roomElement != null && roomElement.ParentRoom != null)
		{
			roomElement.ParentRoom.OnRoomContentChanged -= OnParentRoomContentChanged;
		}
	}
}
public class EnergyBarDisplayer : HealthBarDisplayer
{
	public override void UpdateHealthBarHeight()
	{
	}

	protected override void Awake()
	{
		base.Awake();
		healthCpt = GetComponent<Energy>();
	}
}
public class HealthBarDisplayer : BarDisplayer
{
	[SerializeField]
	protected bool debug;

	public bool ShowEvenWhenHolderIsHidden;

	public bool ShowEvenWhenFullLife;

	protected Health healthCpt;

	public override void ShowBar()
	{
		if (barContainer != null)
		{
			barContainer.gameObject.SetActive(value: true);
		}
	}

	public override void UpdateBarDisplay()
	{
		if ((IsHolderHidden && !ShowEvenWhenHolderIsHidden) || !healthCpt.IsAlive() || (!ShowEvenWhenFullLife && healthCpt.IsFullLive()))
		{
			HideBar();
		}
		else
		{
			ShowBar();
		}
	}

	public virtual void UpdateHealthBarHeight()
	{
		if (base.barContainer != null && healthCpt.SimMB != null)
		{
			float simPropertyValue = healthCpt.SimMB.GetSimPropertyValue(SimulationProperties.HealthBarHeight);
			if (simPropertyValue > 0f)
			{
				Transform barContainer = base.barContainer;
				Vector3 localPosition = base.barContainer.localPosition;
				float x = localPosition.x;
				Vector3 localPosition2 = base.barContainer.localPosition;
				barContainer.localPosition = new Vector3(x, simPropertyValue, localPosition2.z);
			}
		}
	}

	protected override void Awake()
	{
		base.Awake();
		healthCpt = GetComponent<Health>();
		HideBar();
	}

	private void Update()
	{
		float maxHealth = healthCpt.GetMaxHealth();
		if (maxHealth != 0f && barScaler != null)
		{
			barScaler.localScale = new Vector3(healthCpt.GetHealth() / maxHealth, 1f, 1f);
		}
	}
}
public class HealthValue : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class HeatBarDisplayer : BarDisplayer
{
	[SerializeField]
	private Transform overheatBarScaler;

	private Attacker attackerCpt;

	protected override void Awake()
	{
		base.Awake();
		attackerCpt = GetComponent<Attacker>();
	}

	public override void ShowBar()
	{
		if (barContainer != null && !barContainer.gameObject.activeSelf)
		{
			barContainer.gameObject.SetActive(value: true);
			barScaler.gameObject.SetActive(value: true);
			if (overheatBarScaler != null)
			{
				overheatBarScaler.gameObject.SetActive(value: false);
			}
		}
	}

	public void ShowOverheatBar()
	{
		if (overheatBarScaler != null)
		{
			barContainer.gameObject.SetActive(value: true);
			overheatBarScaler.gameObject.SetActive(value: true);
			if (barScaler != null)
			{
				barScaler.gameObject.SetActive(value: false);
			}
		}
	}

	public override void UpdateBarDisplay()
	{
		if (!attackerCpt.CanOverheat)
		{
			return;
		}
		if (attackerCpt.IsOverheating && !IsHolderHidden)
		{
			if (overheatBarScaler != null)
			{
				overheatBarScaler.localScale = new Vector3(attackerCpt.OverheatPCt, 1f, 1f);
			}
			ShowOverheatBar();
		}
		else if (attackerCpt.Heat > 0f && !IsHolderHidden)
		{
			if (barScaler != null)
			{
				barScaler.localScale = new Vector3(attackerCpt.HeatPCt, 1f, 1f);
			}
			ShowBar();
		}
		else
		{
			HideBar();
		}
	}
}
public class CleanLight : RoomLight
{
	private Color organicColorShift = new Color(1f, 0f, 0f, 0f);

	private float organicColorShiftFactor = 0.3f;

	private bool useAdditive;

	private Color organicColorAdditive = Color.black;

	private Light[] lights;

	public void Init()
	{
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		if (dungeon != null && dungeon.ShipConfig.UseLightColorShift)
		{
			ApplyColor(organicColorShift, organicColorShiftFactor, useAdditive, organicColorAdditive);
		}
	}

	public void ApplyColor(Color colorShift, float shiftFactor, bool useAdditive, Color colorAdditive)
	{
		if (lights == null)
		{
			lights = GetComponentsInChildren<Light>();
		}
		for (int i = 0; i < lights.Length; i++)
		{
			if (useAdditive)
			{
				lights[i].color += colorAdditive;
			}
			else
			{
				lights[i].color = Color.Lerp(lights[i].color, colorShift, shiftFactor);
			}
		}
	}
}
public class CrystalRoomInteractiveElement : RoomInteractiveElement
{
	private Dungeon dungeon;

	protected override bool ShouldGUIBeDisplayed()
	{
		if (dungeon == null)
		{
			dungeon = SingletonManager.Get<Dungeon>();
		}
		return base.ShouldGUIBeDisplayed() && dungeon.ExitRoom != null && base.ParentRoom == dungeon.StartRoom;
	}
}
public class CrystalSlotRoomInteractiveElement : RoomInteractiveElement
{
	private Dungeon dungeon;

	public override void SetParentRoom(Room parentRoom)
	{
		base.SetParentRoom(parentRoom);
		Room.OnHeroEnteredOrExitedExitRoom += OnHeroEnteredOrExitedParentRoom;
		IGameEventService service = Services.GetService<IGameEventService>();
		service.OnHeroSelectionChanged += base.RefreshGUIVisibility;
		dungeon = SingletonManager.Get<Dungeon>();
		dungeon.OnCrystalStateChanged += OnCrystalStateChanged;
	}

	private void OnCrystalStateChanged(CrystalState state)
	{
		RefreshGUIVisibility();
	}

	private void OnHeroEnteredOrExitedParentRoom(Hero hero, bool enter)
	{
		RefreshGUIVisibility();
	}

	protected override bool ShouldGUIBeDisplayed()
	{
		if (!base.ShouldGUIBeDisplayed() || !base.ParentRoom.IsExitRoom || dungeon.CurrentCrystalState != CrystalState.Unplugged)
		{
			return false;
		}
		for (int i = 0; i < Hero.SelectedHeroes.Count; i++)
		{
			Hero hero = Hero.SelectedHeroes[i];
			if (hero.HasCrystal && hero.RoomElement.ParentRoom == base.ParentRoom)
			{
				return true;
			}
		}
		return false;
	}
}
public class DirtyLight : RoomLight
{
	[SerializeField]
	private Light lightCpnt;

	[SerializeField]
	private Renderer[] renderers;

	[SerializeField]
	private float lightOnIntensity;

	[SerializeField]
	private float lightOnRange;

	[SerializeField]
	private float lightOffIntensity;

	[SerializeField]
	private float lightOffRange;

	[SerializeField]
	private ParticleSystem smokeParticles;

	[SerializeField]
	private GameObject flareGO;

	private void Awake()
	{
		lightCpnt = GetComponentInChildren<Light>();
		if (lightCpnt == null)
		{
			Diagnostics.LogError("{0} > DirtyLight.Awake: no light component found!", this.GetScenePath());
		}
	}

	public void ToggleLightIntensity(bool on)
	{
		if (lightCpnt == null)
		{
			return;
		}
		lightCpnt.intensity = ((!on) ? lightOffIntensity : lightOnIntensity);
		lightCpnt.range = ((!on) ? lightOffRange : lightOnRange);
		Renderer[] array = renderers;
		foreach (Renderer renderer in array)
		{
			if (renderer != null)
			{
				renderer.enabled = on;
			}
		}
		if (smokeParticles != null)
		{
			if (on)
			{
				smokeParticles.Play(withChildren: true);
			}
			else
			{
				smokeParticles.Stop(withChildren: true);
			}
		}
		if (flareGO != null)
		{
			flareGO.SetActive(on);
		}
	}
}
public class Door : MonoBehaviour
{
	public delegate void DoorOpenedHandler();

	public DoorOpenedHandler OnDoorOpened;

	private static List<DoorOpeningData> openedDoorIDsHistory = new List<DoorOpeningData>();

	private static List<Door> openableDoors = new List<Door>();

	[SerializeField]
	private DoorCursorTarget roof;

	[SerializeField]
	private OffscreenMarker.OffscreenMarkerData doorOpenerIconData;

	[SerializeField]
	private float openingTime;

	[SerializeField]
	private GameObject hitVFXPfb;

	[SerializeField]
	private GameObject brokenVFXPfb;

	[SerializeField]
	private SpriteAnimationRuntime2 bonusAnim;

	[SerializeField]
	private Transform roomSelectableContainerTfm;

	private HeroMobCommon opener;

	private List<Hero> waitingForOpeningHeroes = new List<Hero>();

	private Bounds bounds;

	private Vector3 openingVelocity;

	private Dungeon dungeon;

	private AudioEmitter audioEmitter;

	private Room openingRoom;

	private bool triggerEvents;

	private bool instantOpen;

	private UniqueID uniqueID;

	private RoomElement roomElement;

	private AITarget aiTarget;

	private bool shouldInitTarget = true;

	private List<Mob> attackers;

	private OffscreenMarker offscreenMarker;

	private Vector3 hpBarInitialPos;

	private Vector3 hpBarInitialScale;

	private GameNetworkManager gameNetManager;

	private ParticleSystem hitVFX;

	private Room nextRoom;

	private Mob mobOpener;

	private SpriteAnimDir attackerDirection;

	private DoorSelectable doorSelectable;

	public static int MultiDoorCount = 0;

	public static List<DoorOpeningData> OpenedDoorIDsHistory => openedDoorIDsHistory;

	public static List<Door> OpenableDoors
	{
		get
		{
			return openableDoors;
		}
		set
		{
			openableDoors = value;
		}
	}

	public float RoomAngle
	{
		get;
		set;
	}

	public Vector3 OpeningDir
	{
		get;
		set;
	}

	public Room Room1
	{
		get;
		private set;
	}

	public Room Room2
	{
		get;
		private set;
	}

	public Health HealthCpnt
	{
		get;
		private set;
	}

	public bool IsOpening
	{
		get;
		private set;
	}

	public DoorStep DoorStep
	{
		get;
		private set;
	}

	public UniqueIDNetSyncElement NetSyncElement
	{
		get;
		private set;
	}

	public void Init(Room room1, Room room2, Vector3 openingDir, DoorStep doorStep)
	{
		uniqueID.RequestUniqueID();
		Room1 = room1;
		Room2 = room2;
		OpeningDir = openingDir;
		DoorStep = doorStep;
		attackers = new List<Mob>();
		HealthCpnt.OnHit += OnHit;
		Room1.AddDoor(this);
		Room2.AddDoor(this);
		roomSelectableContainerTfm.rotation = Quaternion.Euler(270f * Vector3.right);
	}

	private void InitAITarget(Room revealedRoom)
	{
		if (roomElement != null)
		{
			roomElement.SetParentRoom(revealedRoom);
		}
		if (aiTarget != null)
		{
			aiTarget.Init();
			aiTarget.OnActorChanged += OnAITargetActorChange;
		}
		if (HealthCpnt != null)
		{
			HealthCpnt.InitHealth();
			HealthCpnt.OnDeath += OnDeath;
			hpBarInitialPos = HealthCpnt.HealthBar.BarContainer.transform.localPosition;
			hpBarInitialScale = HealthCpnt.HealthBar.BarContainer.transform.localScale;
			HealthCpnt.HitRenderers = GetComponentsInChildren<Renderer>();
		}
		shouldInitTarget = false;
	}

	public void Hide()
	{
		base.gameObject.SetActive(value: false);
		DoorStep.gameObject.SetActive(value: false);
	}

	public void Show(Room callingRoom = null)
	{
		if (!base.gameObject.activeSelf)
		{
			base.gameObject.SetActive(value: true);
			DoorStep.gameObject.SetActive(value: true);
			doorSelectable.Register();
			if (shouldInitTarget)
			{
				InitAITarget(callingRoom);
			}
			openableDoors.Add(this);
		}
	}

	public Transform GetOpeningSpot(Vector3 openerPos)
	{
		Transform destSpot = DoorStep.DestSpot1;
		Transform destSpot2 = DoorStep.DestSpot2;
		Room uniqueAlreadyOpenRoom = GetUniqueAlreadyOpenRoom();
		if (uniqueAlreadyOpenRoom != null)
		{
			if (Vector3.Dot(destSpot.forward, DoorStep.transform.position - uniqueAlreadyOpenRoom.transform.position) < 0f)
			{
				return destSpot;
			}
			return destSpot2;
		}
		if (Vector3.Dot(destSpot.forward, DoorStep.transform.position - openerPos) < 0f)
		{
			return destSpot;
		}
		return destSpot2;
	}

	public Room GetUniqueAlreadyOpenRoom()
	{
		if (Room1.IsVisible && !Room2.IsVisible)
		{
			return Room1;
		}
		if (Room2.IsVisible && !Room1.IsVisible)
		{
			return Room2;
		}
		return null;
	}

	public Room GetRoomToOpen(Vector3 openerPosition)
	{
		if (Room1.IsVisible && !Room2.IsVisible)
		{
			return Room2;
		}
		if (Room2.IsVisible && !Room1.IsVisible)
		{
			return Room1;
		}
		Transform openingSpot = GetOpeningSpot(openerPosition);
		if (Vector3.Dot(openingSpot.forward, DoorStep.transform.position - Room1.transform.position) > 0f)
		{
			return Room1;
		}
		return Room2;
	}

	private bool CanBeOpened(bool checkIsOpening = true)
	{
		if (checkIsOpening && IsOpening)
		{
			Diagnostics.LogError(base.name + " > Cannot be opened: door already opening!");
			return false;
		}
		return true;
	}

	public void OpenByHeroOrMob(Room openingRoom, HeroMobCommon opener, bool instantOpen = false, bool checkIsOpening = true)
	{
		if (CanBeOpened(checkIsOpening))
		{
			NetSyncElement.SendRPCToServer(UniqueIDRPC.Door_RequestOpenByHeroOrMob, (!(openingRoom != null)) ? (-1) : openingRoom.UniqueID.ID, opener.UniqueID.GetCategory(), opener.UniqueID.ID, instantOpen, checkIsOpening);
		}
	}

	private void RPC_RequestOpenByHeroOrMob(int openingRoomID, StaticString openerCategory, int openerID, bool instantOpen, bool checkIsOpening)
	{
		if (!gameNetManager.IsServer())
		{
			Diagnostics.LogError("Door.RPC_RequestOpenByHeroOrMob should only be called on server side!");
		}
		else if (!CanBeOpened(checkIsOpening))
		{
			Diagnostics.LogWarning(base.name + " > Door.RPC_RequestOpenByHeroOrMob: NOPE!");
		}
		else
		{
			NetSyncElement.SendRPCToAll(UniqueIDRPC.Door_DoOpenByHeroOrMob, openingRoomID, openerCategory, openerID, instantOpen, checkIsOpening);
		}
	}

	private void RPC_DoOpenByHeroOrMob(int openingRoomID, StaticString openerCategory, int openerID, bool instantOpen, bool checkIsOpening)
	{
		if (!CanBeOpened(checkIsOpening))
		{
			Diagnostics.LogError(base.name + " > Door.RPC_DoOpenByHeroOrMob: CANNOT BE OPENED!");
			return;
		}
		Room room = null;
		if (openingRoomID > 0)
		{
			room = UniqueIDManager.Get<Room>(openingRoomID);
		}
		if (room == null)
		{
			Diagnostics.LogError("RPC_DoOpenByHeroOrMob: openingRoom is null!");
		}
		HeroMobCommon heroMobCommon = (HeroMobCommon)UniqueIDManager.Get(openerCategory, openerID);
		if (heroMobCommon == null)
		{
			Diagnostics.LogError("RPC_DoOpenByHeroOrMob: Can't find opener {0} of category {1}", openerID, openerCategory);
			return;
		}
		Open(room, heroMobCommon, applyFIDSIncome: true, instantOpen, incrementOpenedDoorsStat: true, room != null && !room.IsFullyOpened && heroMobCommon.NetSyncElement.IsOwnedByLocalPlayer(), checkIsOpening);
		Hero hero = heroMobCommon as Hero;
		if (hero != null)
		{
			dungeon.CheckSituationDialog(SituationDialogType.OpenDoor, hero);
			if (TutorialManager.IsEnable)
			{
				Services.GetService<IGameEventService>()?.TriggerDoorOpenedByHeroTutorialEvent();
			}
		}
	}

	public void OpenForSaveRestore(Room openingRoom)
	{
		Open(openingRoom, null, applyFIDSIncome: false, instantOpen: true, incrementOpenedDoorsStat: false, triggerEvents: false);
	}

	public void OpenForCrystalPhase(Room orderingRoom)
	{
		if (!IsOpening)
		{
			if (dungeon.CurrentCrystalState != CrystalState.Unplugged)
			{
				Diagnostics.LogError("{0} > Door.OpenForCrystalPhase: shouldn't be called when crystal is not unplugged ({1})!", base.name, dungeon.CurrentCrystalState);
				return;
			}
			Room roomToOpen = GetRoomToOpen(orderingRoom.transform.position);
			NetSyncElement.SendRPCToAll(UniqueIDRPC.Door_DoOpenForCrystalPhase, roomToOpen.UniqueID.ID);
		}
	}

	private void RPC_DoOpenForCrystalPhase(int openingRoomID)
	{
		if (dungeon.CurrentCrystalState != CrystalState.Unplugged)
		{
			Diagnostics.LogError("{0} > Door.RPC_DoOpenForCrystalPhase: shouldn't be called when crystal is not unplugged ({1})!", base.name, dungeon.CurrentCrystalState);
		}
		else
		{
			StartCoroutine(DoOpenForCrystalPhaseCoroutine(openingRoomID));
		}
	}

	private IEnumerator DoOpenForCrystalPhaseCoroutine(int openingRoomID)
	{
		if (dungeon.CurrentCrystalState != CrystalState.Unplugged)
		{
			Diagnostics.LogError("{0} > Door.DoOpenForCrystalPhaseCoroutine: shouldn't be called when crystal is not unplugged ({1})!", base.name, dungeon.CurrentCrystalState);
			yield break;
		}
		GameConfig gameCfg = GameConfig.GetGameConfig();
		yield return new WaitForSeconds(RandomGenerator.RangeFloat(gameCfg.CrystalPhaseDoorOpeningDelayMin.GetValue(), gameCfg.CrystalPhaseDoorOpeningDelayMax.GetValue()));
		Room openingRoom = UniqueIDManager.Get<Room>(openingRoomID);
		Open(openingRoom, null, applyFIDSIncome: false, instantOpen: false, incrementOpenedDoorsStat: false, !openingRoom.IsFullyOpened && gameNetManager.IsServerOrSinglePlayer());
	}

	private void Open(Room openingRoom = null, HeroMobCommon opener = null, bool applyFIDSIncome = true, bool instantOpen = false, bool incrementOpenedDoorsStat = true, bool triggerEvents = true, bool checkIsOpening = true)
	{
		if (checkIsOpening && IsOpening)
		{
			Diagnostics.LogError("Unable to open door, door already opening!");
			return;
		}
		if (dungeon.CurrentCrystalState == CrystalState.PluggedOnExitSlot)
		{
			Diagnostics.LogError("{0} > Door.Open: shouldn't be called when crystal has been plugged on exit slot!", base.name, dungeon.CurrentCrystalState);
			return;
		}
		if (dungeon.CurrentCrystalState == CrystalState.Plugged)
		{
			MultiDoorCount++;
		}
		this.opener = opener;
		if (dungeon == null)
		{
			dungeon = SingletonManager.Get<Dungeon>();
		}
		GamePhase currentGamePhase = dungeon.CurrentGamePhase;
		this.instantOpen = instantOpen;
		if (applyFIDSIncome)
		{
			applyFIDSIncome = (!gameNetManager.IsMultiplayerSession() || (MultiplayerConfig.SplitFISIncome && MultiplayerConfig.SplitFIS) || this.opener.NetSyncElement.IsOwnedByLocalPlayer());
			if (applyFIDSIncome)
			{
				dungeon.StartCoroutine(dungeon.ApplyFIDSIncome());
			}
		}
		Room1.OnRoomPowerChanged += Room2.OnAdjacentRoomPowerChanged;
		Room2.OnRoomPowerChanged += Room1.OnAdjacentRoomPowerChanged;
		this.openingRoom = openingRoom;
		this.triggerEvents = triggerEvents;
		if (this.openingRoom != null)
		{
			this.openingRoom.Open(this);
			if (dungeon.OpeningDoorCount == 0 && opener != null && opener is Hero && (opener as Hero).NetSyncElement.IsOwnedByLocalPlayer())
			{
				this.openingRoom.SelectableForMove.Select();
			}
		}
		bounds = GetComponent<Collider>().bounds;
		if (this.instantOpen)
		{
			OnDoorOpeningMoveFinished();
		}
		else
		{
			Invoke("OnDoorOpeningMoveFinished", openingTime);
			Vector3 tileSize = dungeon.GetTileSize();
			openingVelocity = tileSize.x * OpeningDir.MultiplyBy(dungeon.ContainerScale) / openingTime;
			base.transform.localScale *= 0.99f;
			audioEmitter.PlayEvent(GameConfig.GetGameConfig().GetTilesetConfig().DoorOpeningSFXPath);
		}
		if (aiTarget != null)
		{
			aiTarget.SetActive(active: false);
			if (offscreenMarker != null)
			{
				offscreenMarker.Hide();
			}
		}
		IsOpening = true;
		openableDoors.Remove(this);
		if (openableDoors.Count < 1)
		{
			Diagnostics.Log("Last door just opened");
			string key = "%Notification_LastDoorOpened";
			if (dungeon.CurrentCrystalState != 0)
			{
				key = "%Notification_LastDoorOpened_CrystalPhase";
			}
			dungeon.EnqueueNotification(AgeLocalizer.Instance.LocalizeString(key), null, "LastDoor");
			IGameEventService service = Services.GetService<IGameEventService>();
			Diagnostics.Assert(service != null);
			service.TriggerLastDoorOpenedEvent();
		}
		dungeon.OpeningDoorCount++;
		dungeon.UpdateGamePhase();
		DoorOpeningData item = default(DoorOpeningData);
		item.DoorID = uniqueID.ID;
		item.OpeningRoomID = ((!(openingRoom != null)) ? (-1) : openingRoom.UniqueID.ID);
		openedDoorIDsHistory.Add(item);
		if (incrementOpenedDoorsStat)
		{
			dungeon.Statistics.IncrementStat((currentGamePhase != GamePhase.Action) ? DungeonStatistics.Stat_OpenedDoors : DungeonStatistics.Stat_ActionOpenedDoors);
			AchievementManagerDOTE achievementManagerDOTE = SingletonManager.Get<AchievementManagerDOTE>();
			achievementManagerDOTE.IncrementStatistic(StatisticName.DOORS_OPENED);
			if (Analytics.Instance != null)
			{
				(Analytics.Instance as GoogleAnalyticsManager).SendNewUserMetrics(achievementManagerDOTE.GetStatisticValue(StatisticName.DOORS_OPENED) == 1f);
			}
		}
		bonusAnim.transform.eulerAngles = Vector3.up * 180f;
		bonusAnim.transform.position = roof.transform.position + bonusAnim.transform.localPosition;
		bonusAnim.transform.parent = base.transform.parent;
		bonusAnim.SetFloat(SpriteAnimationFloat.DoorBonus, 0f);
		bonusAnim.Trigger(SpriteAnimationTrigger.OnMultiDoor);
		if (currentGamePhase == GamePhase.Action && dungeon.CurrentCrystalState == CrystalState.Plugged)
		{
			float value = GameConfig.GetGameConfig().ActionDoorFISBonus.GetValue();
			value *= (float)(MultiDoorCount - 1);
			switch (RandomGenerator.RangeInt(1, 4))
			{
			case 1:
				Player.LocalPlayer.AddFood(value);
				break;
			case 2:
				Player.LocalPlayer.AddIndustry(value);
				break;
			case 3:
				Player.LocalPlayer.AddScience(value);
				break;
			}
		}
		Services.GetService<IGameCameraService>().Unlock();
		doorSelectable.Unregister();
	}

	public void RegisterOpener(Hero hero)
	{
		if (!waitingForOpeningHeroes.Contains(hero))
		{
			waitingForOpeningHeroes.Add(hero);
		}
	}

	public void RemoveOpener(Hero hero)
	{
		waitingForOpeningHeroes.Remove(hero);
	}

	public void OnDeath(ulong attackerOwnerPlayerID)
	{
		if (attackers == null || attackers.Count == 0)
		{
			Diagnostics.LogError("Door died but no attacker was ever registered.");
		}
		else if (mobOpener == null)
		{
			mobOpener = attackers[0];
			nextRoom = GetRoomToOpen(mobOpener.transform.position);
			float d = 0f;
			switch (attackerDirection)
			{
			case SpriteAnimDir.Down:
				d = 180f;
				break;
			case SpriteAnimDir.Up:
				d = 0f;
				break;
			case SpriteAnimDir.Right:
				d = 90f;
				break;
			case SpriteAnimDir.Left:
				d = 270f;
				break;
			}
			UnityEngine.Object.Instantiate(brokenVFXPfb, base.transform.position + brokenVFXPfb.transform.position, Quaternion.Euler(brokenVFXPfb.transform.eulerAngles + Vector3.up * d));
			instantOpen = true;
			OpenByHeroOrMob(nextRoom, mobOpener, instantOpen: true, checkIsOpening: false);
			dungeon.IncrementTurn();
		}
	}

	protected void Awake()
	{
		audioEmitter = GetComponent<AudioEmitter>();
		uniqueID = GetComponent<UniqueID>();
		HealthCpnt = GetComponent<Health>();
		NetSyncElement = GetComponent<UniqueIDNetSyncElement>();
		roomElement = GetComponent<RoomElement>();
		aiTarget = GetComponent<AITarget>();
		doorSelectable = GetComponent<DoorSelectable>();
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
	}

	private void Start()
	{
		dungeon = SingletonManager.Get<Dungeon>();
	}

	private void Update()
	{
		if (IsOpening)
		{
			base.transform.position += openingVelocity * Time.deltaTime;
		}
		if (HealthCpnt != null && HealthCpnt.HealthBar.BarContainer.gameObject.activeInHierarchy && attackers.Count == 0)
		{
			HealthCpnt.HealthBar.HideBar();
		}
	}

	private void OnDoorOpeningMoveFinished(AstarPath script)
	{
		OnDoorOpeningMoveFinished();
	}

	private void OnDoorOpeningMoveFinished()
	{
		AstarPath.OnGraphsUpdated = (OnScanDelegate)Delegate.Remove(AstarPath.OnGraphsUpdated, new OnScanDelegate(OnDoorOpeningMoveFinished));
		if (!instantOpen)
		{
		}
		if (!instantOpen)
		{
			if (AstarPath.active.IsAnyGraphUpdatesQueued)
			{
				Diagnostics.LogWarning(base.name + " > Waiting for pathfinding update to remove door bounds");
				AstarPath.OnGraphsUpdated = (OnScanDelegate)Delegate.Combine(AstarPath.OnGraphsUpdated, new OnScanDelegate(OnDoorOpeningMoveFinished));
				return;
			}
			base.gameObject.layer = LayerMask.NameToLayer("Default");
			AstarPath.OnGraphsUpdated = (OnScanDelegate)Delegate.Combine(AstarPath.OnGraphsUpdated, new OnScanDelegate(OnPathfindingGraphUpdated));
			AstarPath.active.UpdateGraphs(bounds);
		}
		else
		{
			base.gameObject.layer = LayerMask.NameToLayer("Default");
			AstarPath.active.UpdateGraphs(bounds);
			OnPathfindingGraphUpdated();
		}
		if (!instantOpen)
		{
			dungeon.IncrementTurn();
		}
	}

	private void OnPathfindingGraphUpdated(AstarPath script)
	{
		AstarPath.OnGraphsUpdated = (OnScanDelegate)Delegate.Remove(AstarPath.OnGraphsUpdated, new OnScanDelegate(OnPathfindingGraphUpdated));
		OnPathfindingGraphUpdated();
	}

	private void OnPathfindingGraphUpdated()
	{
		if (openingRoom != null && !openingRoom.IsFullyOpened)
		{
			openingRoom.InitAgents();
		}
		foreach (Hero waitingForOpeningHero in waitingForOpeningHeroes)
		{
			if (waitingForOpeningHero != null && waitingForOpeningHero.HealthCpnt.IsAlive() && !waitingForOpeningHero.IsDismissing && !waitingForOpeningHero.IsRespawning)
			{
				waitingForOpeningHero.UnlockInteractions();
				waitingForOpeningHero.OnBlockingDoorOpened();
			}
		}
		if (triggerEvents && dungeon.CurrentCrystalState != CrystalState.PluggedOnExitSlot)
		{
			dungeon.StartCoroutine(dungeon.TriggerEvents(openingRoom, opener, opener != null));
		}
		if (OnDoorOpened != null)
		{
			OnDoorOpened();
		}
		dungeon.OpeningDoorCount--;
		dungeon.UpdateGamePhase();
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void OnHit(AttackInfo hit)
	{
		if (hitVFX == null)
		{
			hitVFX = (UnityEngine.Object.Instantiate(hitVFXPfb, Vector3.zero, base.transform.rotation) as GameObject).GetComponent<ParticleSystem>();
		}
		attackerDirection = UniqueIDManager.Get(hit.AttackerCategory, hit.AttackerID).GetComponent<Mob>().GetAnimDirection();
		Vector3 vector = Vector3.zero;
		float d = 1.5f;
		switch (attackerDirection)
		{
		case SpriteAnimDir.Down:
			vector = Vector3.back * d;
			break;
		case SpriteAnimDir.Up:
			vector = Vector3.forward * d;
			break;
		case SpriteAnimDir.Right:
			vector = Vector3.right;
			break;
		case SpriteAnimDir.Left:
			vector = Vector3.left;
			break;
		}
		Transform transform = hitVFX.transform;
		Vector3 a = base.transform.position + hitVFXPfb.transform.position;
		Vector3 a2 = vector;
		Vector3 extents = GetComponent<Collider>().bounds.extents;
		transform.position = a + a2 * extents.x;
		hitVFX.Play(withChildren: true);
	}

	private void OnRightClickDown(ClickDownInfo clickInfo)
	{
		if (Hero.SelectedHeroes.Count > 0)
		{
			foreach (Hero selectedHero in Hero.SelectedHeroes)
			{
				selectedHero.MoveToDoor(this);
			}
			Services.GetService<IInputService>().StopClickEventPropagation();
		}
	}

	private void OnDestroy()
	{
		HealthCpnt.OnHit -= OnHit;
		if (offscreenMarker != null)
		{
			UnityEngine.Object.Destroy(offscreenMarker.gameObject);
		}
		if (hitVFX != null)
		{
			UnityEngine.Object.Destroy(hitVFX.gameObject);
		}
		if (bonusAnim != null)
		{
			UnityEngine.Object.Destroy(bonusAnim.gameObject);
		}
		if (gameNetManager == null)
		{
			gameNetManager = SingletonManager.Get<GameNetworkManager>();
		}
		if (gameNetManager != null)
		{
			gameNetManager.ClearCachedAITargets(this);
		}
	}

	private void OnAITargetActorChange()
	{
		if (!IsOpening && offscreenMarker == null)
		{
			Mob component = aiTarget.Actor.SimMB.GetComponent<Mob>();
			if (!attackers.Contains(component))
			{
				attackers.Add(component);
				component.OnMobDeath += DoOnAttackerDied;
			}
			offscreenMarker = dungeon.DisplayOffscreenMarker(roof.transform, doorOpenerIconData);
			if (HealthCpnt.HealthBar.BarContainer != null)
			{
				HealthCpnt.HealthBar.BarContainer.transform.parent = offscreenMarker.transform;
				HealthCpnt.HealthBar.BarContainer.transform.localPosition = hpBarInitialPos;
				HealthCpnt.HealthBar.BarContainer.transform.localScale = hpBarInitialScale;
				HealthCpnt.HealthBar.BarContainer.transform.localEulerAngles = Vector3.zero;
				HealthCpnt.HealthBar.ShowBar();
			}
		}
	}

	private void RPC_OnAttackerDied(StaticString category, int id)
	{
		Mob component = UniqueIDManager.Get(category, id).GetComponent<Mob>();
		if (component != null)
		{
			DoOnAttackerDied(component);
		}
	}

	public void DoOnAttackerDied(Mob attacker)
	{
		attackers.Remove(attacker);
		if (offscreenMarker != null && attackers.Count == 0)
		{
			HealthCpnt.HealthBar.BarContainer.transform.parent = base.transform;
			HealthCpnt.HealthBar.HideBar();
			offscreenMarker.Hide();
		}
	}
}
public class DoorStep : MonoBehaviour
{
	[SerializeField]
	private Transform destSpot1;

	[SerializeField]
	private Transform destSpot2;

	public Transform DestSpot1 => destSpot1;

	public Transform DestSpot2 => destSpot2;
}
public class Dungeon : SimMonoBehaviour
{
	public delegate void FIDSChangedEventHandler();

	public delegate void TurnChangedEventHandler();

	public delegate void RoomPoweredEventHandler(Room room, bool powered);

	public delegate void CrystalStateChangedEventHandler(CrystalState state);

	private Dictionary<ModuleCategory, BluePrintConfig> researchableBPByCategory = new Dictionary<ModuleCategory, BluePrintConfig>();

	private Dictionary<ModuleCategory, List<BluePrintConfig>> researchedBPsByCategory = new Dictionary<ModuleCategory, List<BluePrintConfig>>();

	private Dictionary<ModuleCategory, List<BluePrintConfig>> unlockedBPsByCategory = new Dictionary<ModuleCategory, List<BluePrintConfig>>();

	private List<string> lockedBluePrints = new List<string>();

	[SerializeField]
	private float mobSpawnInterval;

	private DynamicRoomEventConfig[] forcedPositiveEvents;

	private RoomDefenseSpot[] _defenseSpots;

	private List<Vector3> _spawnPositions;

	private Dictionary<StaticString, int> _spawnedMobCountPerClass;

	private IDatabase<MobClassConfig> _mobClassCfgDB;

	private List<SelectedMob> _elligibleMobsPool;

	private List<Vector3> _spawnPositionsPool;

	private Dictionary<StaticString, int> _mobClassCountInRoom;

	private MobClassConfig _mobClassConfig;

	private bool isSpawningMobs;

	public bool EnableGameMenuOrCloseTopMenuControl = true;

	public static readonly string ForbiddenFromClients = "Save_ForbiddenFromClients";

	public static readonly string ForbiddenDuringEvent = "Save_ForbiddenDuringEvent";

	private readonly StaticString registryTutorialAlreadyDisplayedKey = "Settings/Misc/TutorialAlreadyDisplayed";

	[SerializeField]
	private Transform staticContainer;

	[SerializeField]
	private Transform dynamicContainer;

	[SerializeField]
	private Vector3 containerScale;

	[SerializeField]
	private Vector3 tileSize;

	[SerializeField]
	private GameObject mobPfb;

	[SerializeField]
	private GameObject heroPfb;

	[SerializeField]
	private GameObject npcPfb;

	[SerializeField]
	private GameObject dustLootPfb;

	[SerializeField]
	private float fidsIncomeDelay;

	[SerializeField]
	private float dungeonEventDelay;

	[SerializeField]
	private float powerPulsePeriod;

	[SerializeField]
	private int maxPowerPulseVFXCount;

	[SerializeField]
	private GameObject powerPulseDefaultVFXPfb;

	[SerializeField]
	private GameObject powerPulseAlternativeVFXPfb;

	[SerializeField]
	private GameObject powerPulseMinorModuleAlternativeVFXPfb;

	[SerializeField]
	private GameObject powerPulseMajorModuleAlternativeVFXPfb;

	[SerializeField]
	private ItemConfig.ItemConfigPrefab[] itemsPfb;

	[SerializeField]
	private NPCConfig.NPCConfigPrefab[] npcsPfb;

	[SerializeField]
	private float gameOverToMainMenuDelay;

	[SerializeField]
	private GameObject offscreenMarkerPfb;

	[SerializeField]
	private OffscreenMarker.OffscreenMarkerData exitOffscreenMarkerData;

	[SerializeField]
	private Animation ambiantLightCrystalPhaseAnim;

	[SerializeField]
	private float vistoryScreenDisplayDelay;

	[SerializeField]
	private float gameOverScreenDisplayDelay;

	[SerializeField]
	private float gameStartTutorialDelay;

	[SerializeField]
	private float heroDialogueDuration;

	[SerializeField]
	private float mpHeartbeatPeriod;

	private bool isContainerScaled;

	private List<Room> dustPoweredRooms = new List<Room>();

	private List<Room> openedRooms = new List<Room>();

	private float totalDustLootAmount;

	private IGameEventService gameEventManager;

	private IAudioEventService audioEventManager;

	private LayeredEvent musicCrystalQuest;

	private FMOD.Event tilesetAmbianceSFX;

	private bool shouldPlayEndTurnSFX;

	private List<StaticString> discoverableHeroPool;

	private int eventTriggeringCount;

	private GameNetworkManager gameNetManager;

	private bool spawnExitWaves;

	private DLCController steamDLCController;

	private ulong hostPlayerID;

	private GuiElement cachedGUIElement;

	private IGuiService guiService;

	private IGameCameraService gameCameraManager;

	private IGameResolutionService gameResolutionManager;

	private IGameControlService gameControlManager;

	private IInputService inputManager;

	private SelectableManager selectableManager;

	private MainGameScreen mainGameScreen;

	private GameMenuPanel gameMenuPanel;

	private EndLevelPanel endLevelPanel;

	private GameOverPanel gameOverPanel;

	private VictoryPanel victoryPanel;

	private HeroPanel heroPanel;

	private ConstructionPanel constructionPanel;

	private CameraDragSupport cameraDragSupport;

	private RequesterPanel requesterPanel;

	private ChatPanelInGame chatPanelInGame;

	private AchievementManagerDOTE achievementManager;

	private GameConfig gameConfig;

	private Lift lift;

	private float nextHeartbeatTime;

	private Dictionary<int, Control> selectHeroControlByIndex = new Dictionary<int, Control>();

	private DungeonGenerationParams generationParams;

	private bool victory;

	private GameSaveData userSaveData;

	private DungeonGenerationSaveData autoSaveData;

	private GameObject powerPulseVFXPfb;

	private List<SpriteAnimationRuntime2> powerablePropsWaiting = new List<SpriteAnimationRuntime2>();

	private Vector3 previousPoweredPropPosition = Vector3.zero;

	private static DungeonGenerationParams nextDungeonGenerationParams;

	public int ResetResearchesCount
	{
		get;
		private set;
	}

	public Dictionary<RoomEvent, int> DynamicRoomEventCounts
	{
		get;
		private set;
	}

	public float DustStock
	{
		get;
		private set;
	}

	public SingletonNetSyncElement NetSyncElement
	{
		get;
		private set;
	}

	public Room ExitRoom
	{
		get;
		set;
	}

	public Inventory[] Inventories
	{
		get;
		private set;
	}

	public GamePhase CurrentGamePhase
	{
		get;
		private set;
	}

	public ShipConfig ShipConfig
	{
		get;
		private set;
	}

	public SimulationDescriptor ShipDesc
	{
		get;
		private set;
	}

	public string CrystalType
	{
		get;
		private set;
	}

	public Vector3 ContainerScale => containerScale;

	public List<Room> PoweredRooms => dustPoweredRooms;

	public GameObject PowerPulseMinorModuleAlternativeVFXPfb => powerPulseMinorModuleAlternativeVFXPfb;

	public GameObject PowerPulseMajorModuleAlternativeVFXPfb => powerPulseMajorModuleAlternativeVFXPfb;

	public bool IsLevelOver
	{
		get;
		private set;
	}

	public int Level
	{
		get;
		private set;
	}

	public GameDifficulty Difficulty
	{
		get;
		private set;
	}

	public int Turn
	{
		get;
		private set;
	}

	public int OpenRoomsCount => openedRooms.Count;

	public List<Room> OpenedRooms => openedRooms;

	public DungeonStatistics Statistics
	{
		get;
		private set;
	}

	public Transform StaticContainer => staticContainer;

	public float GameStartTime
	{
		get;
		private set;
	}

	public int ExitWaveNumber
	{
		get;
		private set;
	}

	public Room StartRoom
	{
		get;
		set;
	}

	public CrystalState CurrentCrystalState
	{
		get;
		set;
	}

	public int MajorModuleSlotCount
	{
		get;
		set;
	}

	public int MinorModuleSlotCount
	{
		get;
		set;
	}

	public int OpeningDoorCount
	{
		get;
		set;
	}

	public float CurrentLevelDifficulty
	{
		get;
		private set;
	}

	public bool ShouldDifficultyIncrease
	{
		get;
		private set;
	}

	public float EventProbBonus
	{
		get;
		private set;
	}

	public int ActivatingModuleCount
	{
		get;
		set;
	}

	public Transform CrystalTfm
	{
		get;
		private set;
	}

	public Inventory SharedInventory
	{
		get;
		private set;
	}

	public Inventory BackpackInventory
	{
		get;
		private set;
	}

	public int PluggedOnExitSlotCrystalCount
	{
		get;
		private set;
	}

	public int MaxDepth
	{
		get;
		set;
	}

	public int RoomCount
	{
		get;
		set;
	}

	public List<SelectedMob> LevelSelectedMobs
	{
		get;
		private set;
	}

	public int TotalMissedDoorCount
	{
		get;
		private set;
	}

	public int AliveMajorModuleCount
	{
		get;
		set;
	}

	public bool IsStarted
	{
		get;
		private set;
	}

	public bool IsDisplayed
	{
		get;
		private set;
	}

	public StaticString ShipName
	{
		get;
		private set;
	}

	public static DungeonGenerationParams NextDungeonGenerationParams => nextDungeonGenerationParams;

	public event RoomPoweredEventHandler OnRoomPowered;

	public event CrystalStateChangedEventHandler OnCrystalStateChanged;

	public List<BluePrintConfig> GetCategoryUnlockedBluePrints(ModuleCategory moduleCategory)
	{
		if (!unlockedBPsByCategory.ContainsKey(moduleCategory))
		{
			unlockedBPsByCategory.Add(moduleCategory, new List<BluePrintConfig>());
		}
		unlockedBPsByCategory[moduleCategory].Sort((BluePrintConfig bpConfig1, BluePrintConfig bpConfig2) => bpConfig1.Name.CompareTo(bpConfig2.Name));
		return unlockedBPsByCategory[moduleCategory];
	}

	public BluePrintConfig GetModuleUnlockedBluePrint(ModuleCategory moduleCategory, StaticString moduleName)
	{
		List<BluePrintConfig> categoryUnlockedBluePrints = GetCategoryUnlockedBluePrints(moduleCategory);
		for (int i = 0; i < categoryUnlockedBluePrints.Count; i++)
		{
			if (categoryUnlockedBluePrints[i].ModuleName == moduleName)
			{
				return categoryUnlockedBluePrints[i];
			}
		}
		return null;
	}

	public BluePrintConfig[] GetResearchableBPs()
	{
		List<BluePrintConfig> list = new List<BluePrintConfig>();
		ModuleCategory[] array = new ModuleCategory[researchableBPByCategory.Count];
		IEnumerator<ModuleCategory> enumerator = researchableBPByCategory.Keys.GetEnumerator();
		int num = 0;
		while (enumerator.MoveNext())
		{
			array[num++] = enumerator.Current;
		}
		Array.Sort(array, delegate(ModuleCategory cat1, ModuleCategory cat2)
		{
			int num2 = (int)cat1;
			return num2.CompareTo((int)cat2);
		});
		ModuleCategory[] array2 = array;
		foreach (ModuleCategory key in array2)
		{
			BluePrintConfig bluePrintConfig = researchableBPByCategory[key];
			if (bluePrintConfig != null)
			{
				list.Add(bluePrintConfig);
			}
		}
		return list.ToArray();
	}

	public bool CanResearchBluePrint(BluePrintConfig bpConfig, bool checkIsResearchable = true, bool consumeScience = true, bool displayErrors = false)
	{
		if (checkIsResearchable && (!researchableBPByCategory.ContainsKey(bpConfig.ModuleCategory) || researchableBPByCategory[bpConfig.ModuleCategory] != bpConfig))
		{
			Diagnostics.Log("Unable to research " + bpConfig.Name + " BP: it is not researchable!");
			return false;
		}
		if (checkIsResearchable && Door.OpenableDoors.Count < 1)
		{
			Diagnostics.Log("Unable to research " + bpConfig.Name + " BP: no more openable door!");
			if (displayErrors)
			{
				EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_BPResearchFailNoRemainingDoor"));
			}
			return false;
		}
		if (consumeScience && Player.LocalPlayer.ScienceStock < bpConfig.ResearchScienceCost)
		{
			Diagnostics.Log("Unable to research " + bpConfig.Name + " BP: not enough science!");
			if (displayErrors)
			{
				EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_BPResearchFailResources"));
			}
			return false;
		}
		return true;
	}

	public void ResearchBluePrint(BluePrintConfig bpConfig)
	{
		if (!researchedBPsByCategory.ContainsKey(bpConfig.ModuleCategory))
		{
			researchedBPsByCategory.Add(bpConfig.ModuleCategory, new List<BluePrintConfig>());
		}
		researchedBPsByCategory[bpConfig.ModuleCategory].Add(bpConfig);
	}

	public void UnlockStartBluePrint(StaticString bpName)
	{
		UnlockBluePrint(bpName, checkIfResearched: false, triggerNotification: false, pickNewResearchables: false);
	}

	public void UnlockBluePrintForSaveRestore(StaticString bpName)
	{
		UnlockBluePrint(bpName, checkIfResearched: false, triggerNotification: false, pickNewResearchables: false);
	}

	public void UnlockBluePrint(StaticString bpName, bool checkIfResearched = true, bool triggerNotification = true, bool pickNewResearchables = true)
	{
		BluePrintConfig value = Databases.GetDatabase<BluePrintConfig>().GetValue(bpName);
		if (value == null)
		{
			Diagnostics.LogError("Dungeon.UnlockBluePrint: " + bpName + " BP couldn't be found!");
		}
		UnlockBluePrint(value, checkIfResearched, triggerNotification, pickNewResearchables);
	}

	public void UnlockBluePrint(BluePrintConfig bpConfig, bool checkIfResearched = true, bool triggerNotification = true, bool pickNewResearchables = true)
	{
		if (checkIfResearched && (!researchedBPsByCategory.ContainsKey(bpConfig.ModuleCategory) || !researchedBPsByCategory[bpConfig.ModuleCategory].Contains(bpConfig)))
		{
			Diagnostics.LogError("Unable to unlock " + bpConfig.Name + " BP: it was not researched!");
			return;
		}
		if (!unlockedBPsByCategory.ContainsKey(bpConfig.ModuleCategory))
		{
			unlockedBPsByCategory.Add(bpConfig.ModuleCategory, new List<BluePrintConfig>());
		}
		for (int i = 0; i < unlockedBPsByCategory[bpConfig.ModuleCategory].Count; i++)
		{
			if (unlockedBPsByCategory[bpConfig.ModuleCategory][i].ModuleName == bpConfig.ModuleName)
			{
				unlockedBPsByCategory[bpConfig.ModuleCategory].RemoveAt(i--);
			}
		}
		if (checkIfResearched)
		{
			researchedBPsByCategory[bpConfig.ModuleCategory].Remove(bpConfig);
		}
		unlockedBPsByCategory[bpConfig.ModuleCategory].Add(bpConfig);
		if (bpConfig.ModuleLevel > 1)
		{
			Module.UpdateBPModulesLevel(bpConfig);
		}
		if (triggerNotification)
		{
			string newValue = bpConfig.Name;
			if (guiService.GuiPanelHelper.TryGetGuiElement(bpConfig.Name, out cachedGUIElement))
			{
				newValue = AgeLocalizer.Instance.LocalizeString(cachedGUIElement.Title);
			}
			if (bpConfig.ModuleLevel == 1)
			{
				EnqueueNotification(AgeLocalizer.Instance.LocalizeString("%Notification_NewModuleUnlocked").Replace("$BPName", newValue), null, bpConfig.Name, foreGround: false, bpConfig.Name);
			}
			else
			{
				EnqueueNotification(AgeLocalizer.Instance.LocalizeString("%Notification_ModuleUpgradeUnlocked").Replace("$BPName", newValue), null, bpConfig.Name, foreGround: false, bpConfig.Name);
			}
		}
		if (pickNewResearchables && gameNetManager.IsServerOrSinglePlayer() && (!researchableBPByCategory.ContainsKey(bpConfig.ModuleCategory) || researchableBPByCategory[bpConfig.ModuleCategory] == null))
		{
			PickResearchableBluePrintsForCategory(bpConfig.ModuleCategory);
		}
		if (bpConfig.ModuleCategory != ModuleCategory.SpecialModule)
		{
			try
			{
				achievementManager.SetStatisticValue((bpConfig.ModuleName.ToUpper() + "_LEVEL").ToEnum<StatisticName>(), bpConfig.ModuleLevel);
				achievementManager.SetStatisticValue((bpConfig.ModuleName.ToUpper() + "_BEST_LEVEL").ToEnum<StatisticName>(), bpConfig.ModuleLevel);
			}
			catch (ArgumentException ex)
			{
				Diagnostics.LogError("Missing module stat: " + ex.Message);
			}
		}
		if (lockedBluePrints != null)
		{
			lockedBluePrints.Remove(bpConfig.ModuleName);
		}
	}

	public void CancelBluePrintResearch(BluePrintConfig bpConfig)
	{
		if (!researchedBPsByCategory.ContainsKey(bpConfig.ModuleCategory) || !researchedBPsByCategory[bpConfig.ModuleCategory].Contains(bpConfig))
		{
			Diagnostics.LogError("Unable to cancel " + bpConfig.Name + " BP research: it is not currently researched!");
			return;
		}
		researchedBPsByCategory[bpConfig.ModuleCategory].Remove(bpConfig);
		if (gameNetManager.IsServerOrSinglePlayer())
		{
			PickResearchableBluePrintsForAllCategories();
		}
	}

	private void SetResearchableBluePrintsFromSave(BluePrintSaveData[] researchableBluePrints)
	{
		researchableBPByCategory = new Dictionary<ModuleCategory, BluePrintConfig>();
		IDatabase<BluePrintConfig> database = Databases.GetDatabase<BluePrintConfig>();
		for (int i = 0; i < researchableBluePrints.Length; i++)
		{
			BluePrintSaveData bluePrintSaveData = researchableBluePrints[i];
			BluePrintConfig value = database.GetValue(bluePrintSaveData.BluePrintName);
			researchableBPByCategory.Add(value.ModuleCategory, value);
		}
	}

	public void PickResearchableBluePrintsForAllCategories()
	{
		PickResearchableBluePrints(onlyOneCategory: false, ModuleCategory.MajorModule);
	}

	public void PickResearchableBluePrintsForCategory(ModuleCategory singleModuleCategory)
	{
		PickResearchableBluePrints(onlyOneCategory: true, singleModuleCategory);
	}

	private void PickResearchableBluePrints(bool onlyOneCategory, ModuleCategory specificCategory)
	{
		if (!gameNetManager.IsServerOrSinglePlayer())
		{
			Diagnostics.LogError("Dungeon.PickResearchableBluePrints should only be called on server!");
			return;
		}
		Dictionary<ModuleCategory, List<BluePrintConfig>> dictionary = new Dictionary<ModuleCategory, List<BluePrintConfig>>();
		BluePrintConfig[] values = Databases.GetDatabase<BluePrintConfig>().GetValues();
		foreach (BluePrintConfig bluePrintConfig in values)
		{
			if ((onlyOneCategory && bluePrintConfig.ModuleCategory != specificCategory) || bluePrintConfig.ModuleCategory == ModuleCategory.SpecialModule)
			{
				continue;
			}
			bool flag = false;
			for (int j = 0; j < ShipConfig.FilteredUnavailableBluePrints.Length; j++)
			{
				if (ShipConfig.FilteredUnavailableBluePrints[j] == bluePrintConfig.Name)
				{
					flag = true;
					break;
				}
			}
			if (flag || (unlockedBPsByCategory.ContainsKey(bluePrintConfig.ModuleCategory) && unlockedBPsByCategory[bluePrintConfig.ModuleCategory].Contains(bluePrintConfig)))
			{
				continue;
			}
			if (researchedBPsByCategory.ContainsKey(bluePrintConfig.ModuleCategory))
			{
				bool flag2 = false;
				for (int k = 0; k < researchedBPsByCategory[bluePrintConfig.ModuleCategory].Count; k++)
				{
					if (researchedBPsByCategory[bluePrintConfig.ModuleCategory][k].ModuleName == bluePrintConfig.ModuleName)
					{
						flag2 = true;
						break;
					}
				}
				if (flag2)
				{
					continue;
				}
			}
			int num;
			if (bluePrintConfig.ModuleLevel > 1)
			{
				if (!unlockedBPsByCategory.ContainsKey(bluePrintConfig.ModuleCategory))
				{
					continue;
				}
				bool flag3 = false;
				bool flag4 = false;
				for (int l = 0; l < unlockedBPsByCategory[bluePrintConfig.ModuleCategory].Count; l++)
				{
					if (unlockedBPsByCategory[bluePrintConfig.ModuleCategory][l].ModuleName == bluePrintConfig.ModuleName)
					{
						if (unlockedBPsByCategory[bluePrintConfig.ModuleCategory][l].ModuleLevel == bluePrintConfig.ModuleLevel - 1)
						{
							flag3 = true;
							break;
						}
						if (unlockedBPsByCategory[bluePrintConfig.ModuleCategory][l].ModuleLevel == bluePrintConfig.ModuleLevel - 2)
						{
							flag4 = true;
						}
					}
				}
				if (flag3)
				{
					num = gameConfig.LvlPlus1BluePrintWeight;
				}
				else
				{
					if (!flag4)
					{
						continue;
					}
					num = gameConfig.LvlPlus2BluePrintWeight;
				}
			}
			else
			{
				if (unlockedBPsByCategory.ContainsKey(bluePrintConfig.ModuleCategory))
				{
					bool flag5 = false;
					for (int m = 0; m < unlockedBPsByCategory[bluePrintConfig.ModuleCategory].Count; m++)
					{
						if (unlockedBPsByCategory[bluePrintConfig.ModuleCategory][m].ModuleName == bluePrintConfig.ModuleName && unlockedBPsByCategory[bluePrintConfig.ModuleCategory][m].ModuleLevel > 1)
						{
							flag5 = true;
							break;
						}
					}
					if (flag5)
					{
						continue;
					}
				}
				num = gameConfig.NewBluePrintWeight;
			}
			if (!dictionary.ContainsKey(bluePrintConfig.ModuleCategory))
			{
				dictionary.Add(bluePrintConfig.ModuleCategory, new List<BluePrintConfig>());
			}
			for (int n = 0; n < num; n++)
			{
				dictionary[bluePrintConfig.ModuleCategory].Add(bluePrintConfig);
			}
		}
		ModuleCategory[] enumValues = GenericUtilities.GetEnumValues<ModuleCategory>();
		foreach (ModuleCategory moduleCategory in enumValues)
		{
			if (!onlyOneCategory || moduleCategory == specificCategory)
			{
				StaticString staticString = (!dictionary.ContainsKey(moduleCategory)) ? null : dictionary[moduleCategory].GetRandom().Name;
				NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_SetResearchableBPByCategory, moduleCategory, staticString);
			}
		}
		UpdateResearchingBPSimDesc();
	}

	private void RPC_SetResearchableBPByCategory(ModuleCategory moduleCategory, StaticString bpConfigName)
	{
		BluePrintConfig bluePrintConfig = null;
		if (bpConfigName != null)
		{
			bluePrintConfig = Databases.GetDatabase<BluePrintConfig>().GetValue(bpConfigName);
			if (researchableBPByCategory.ContainsKey(moduleCategory))
			{
				researchableBPByCategory[moduleCategory] = bluePrintConfig;
			}
			else
			{
				researchableBPByCategory.Add(moduleCategory, bluePrintConfig);
			}
		}
		else if (researchableBPByCategory.ContainsKey(moduleCategory))
		{
			researchableBPByCategory.Remove(moduleCategory);
		}
	}

	public void ResetResearches()
	{
		NetSyncElement.SendRPCToServer(SingletonRPC.Dungeon_RequestResearchesReset);
	}

	private void RPC_RequestResearchesReset()
	{
		PickResearchableBluePrintsForAllCategories();
		NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_DoResearchesReset);
	}

	private void RPC_DoResearchesReset()
	{
		ResetResearchesCount++;
		ResearchPanel researchPanel = SingletonManager.Get<ResearchPanel>();
		if (researchPanel.IsVisible)
		{
			researchPanel.RefreshContent();
		}
	}

	public void UpdateResearchingBPSimDesc()
	{
		if (!(GetSimPropertyValue(SimulationProperties.ResearchingBP) > 0f))
		{
			return;
		}
		bool flag = false;
		for (int i = 0; i < openedRooms.Count; i++)
		{
			if (openedRooms[i].MajorModule != null && openedRooms[i].MajorModule is Artifact && (openedRooms[i].MajorModule as Artifact).ResearchedBP != null)
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			RemoveSimDescriptor(SimulationProperties.SimDescDungeonResearchingBP);
		}
	}

	public IEnumerator TriggerEvents(Room openingRoom, HeroMobCommon opener, bool canTriggerDungeonEvent = true)
	{
		if (CurrentCrystalState == CrystalState.PluggedOnExitSlot)
		{
			Diagnostics.LogError("{0} > Room.TriggerEvents: shouldn't be called when crystal has been plugged on exit slot)!", base.name);
			yield break;
		}
		eventTriggeringCount++;
		UpdateGamePhase();
		if (!openingRoom.WasAlreadyOpen)
		{
			int dustLootAmount = openingRoom.DustLootAmount;
			if (dustLootAmount > 0)
			{
				openingRoom.PlayDustLootVFX(dustLootAmount);
				SingletonManager.Get<MainGameScreen>().DisplayFIDSGameFeedback(dustLootAmount, SimulationProperties.Dust, openingRoom.transform);
				CurrentLevelDifficulty += gameConfig.RoomDustLootLevelDifficultyBaseValue;
				float heroRoomDustBonus = 0f;
				if (opener != null && opener is Hero)
				{
					heroRoomDustBonus = opener.GetSimPropertyValue(SimulationProperties.RoomDustBonus);
					if (heroRoomDustBonus > 0f)
					{
						SingletonManager.Get<MainGameScreen>().DisplayFIDSGameFeedback(heroRoomDustBonus, SimulationProperties.Dust, opener.transform);
					}
				}
				float totalDustLoot = (float)dustLootAmount + heroRoomDustBonus;
				AddDust(totalDustLoot);
				totalDustLootAmount += totalDustLoot;
			}
		}
		ShouldDifficultyIncrease = (CurrentLevelDifficulty < gameConfig.DifficultyTarget);
		EventProbBonus = Mathf.Abs(CurrentLevelDifficulty - gameConfig.DifficultyTarget) * gameConfig.EventProbWeightBonusMultiplier;
		RoomEvent roomEvent = openingRoom.StaticRoomEvent;
		bool forbidDungeonEvent = openingRoom.ForbidDungeonEvent;
		bool recruitableHero = true;
		Diagnostics.Log("Dungeon.TriggerEvents: StaticRoomEvent=" + roomEvent + " (ForbidDungeonEvent=" + forbidDungeonEvent + ")");
		Dictionary<DynamicEventCombinationConfig, float> eventCombinationCfgWeights = new Dictionary<DynamicEventCombinationConfig, float>();
		int eventCombinationCfgsCount = gameConfig.DynamicEventCombinationConfigs.Length;
		DynamicEventCombinationConfig eventCombinationCfg;
		for (int i = 0; i < eventCombinationCfgsCount; i++)
		{
			eventCombinationCfg = gameConfig.DynamicEventCombinationConfigs[i];
			eventCombinationCfgWeights.Add(eventCombinationCfg, eventCombinationCfg.ProbWeight.GetValue(openingRoom));
		}
		eventCombinationCfg = eventCombinationCfgWeights.GetWeightedRandom();
		if (eventCombinationCfg != null)
		{
			EventCombination eventCombination = eventCombinationCfg.Name.ToEnum<EventCombination>();
			Diagnostics.Log("Dungeon.TriggerEvents: eventCombination=" + eventCombination);
			if (!openingRoom.WasAlreadyOpen && (eventCombination == EventCombination.RoomEventOnly || eventCombination == EventCombination.DungeonAndRoomEvent || roomEvent != 0))
			{
				if (roomEvent == RoomEvent.None)
				{
					if (GetSimPropertyValue(SimulationProperties.UpcomingPositiveEvents) <= 0f)
					{
						Dictionary<DynamicRoomEventConfig, float> roomEventCfgWeights = new Dictionary<DynamicRoomEventConfig, float>();
						int roomEventCfgsCount = gameConfig.DynamicRoomEventConfigs.Length;
						DynamicRoomEventConfig roomEventCfg2;
						for (int k = 0; k < roomEventCfgsCount; k++)
						{
							roomEventCfg2 = gameConfig.DynamicRoomEventConfigs[k];
							if (steamDLCController.IsObjectAvailable(DLCObjectType.Event, roomEventCfg2.Name))
							{
								roomEventCfgWeights.Add(roomEventCfg2, roomEventCfg2.GetProbWeightValue(openingRoom));
							}
						}
						roomEventCfg2 = roomEventCfgWeights.GetWeightedRandom();
						if (roomEventCfg2 != null)
						{
							roomEvent = roomEventCfg2.Name.ToEnum<RoomEvent>();
							forbidDungeonEvent = roomEventCfg2.ForbidDungeonEvent;
						}
					}
					else
					{
						DynamicRoomEventConfig roomEventCfg2 = forcedPositiveEvents[UnityEngine.Random.Range(0, forcedPositiveEvents.Length)];
						roomEvent = roomEventCfg2.Name.ToEnum<RoomEvent>();
						forbidDungeonEvent = false;
						eventCombination = EventCombination.DungeonAndRoomEvent;
						recruitableHero = (ShipConfig.Name != "Armory" && ShipConfig.Name != "Refreezerator");
					}
				}
				Diagnostics.Log("Dungeon.TriggerEvents: roomEvent=" + roomEvent + " (forbidDungeonEvent=" + forbidDungeonEvent + ")");
				string roomEventStr = roomEvent.ToString();
				bool displayDialog = opener != null && !(opener is Mob);
				NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_IncrementDynamicRoomEventCount, roomEvent);
				switch (roomEvent)
				{
				case RoomEvent.Mobs:
				{
					float roomDifficultyValue = RandomGenerator.RangeFloat(gameConfig.RoomDifficultyMin.GetValue(openingRoom), gameConfig.RoomDifficultyMax.GetValue(openingRoom));
					yield return StartCoroutine(SpawnMobs(openingRoom, roomDifficultyValue, MobSpawnType.Room, roomEventStr, LevelSelectedMobs));
					break;
				}
				case RoomEvent.Item:
					SpawnItem(openingRoom, roomEventStr);
					break;
				case RoomEvent.Hero:
					SpawnHero(openingRoom, roomEventStr, displayDialog && recruitableHero, recruitableHero);
					break;
				case RoomEvent.Merchant:
				case RoomEvent.DeathMerchant:
					SpawnNPC(openingRoom, roomEventStr, displayDialog);
					break;
				case RoomEvent.Exit:
					SpawnExit(openingRoom);
					break;
				case RoomEvent.Artifact:
					SpawnArtifact(openingRoom, roomEventStr);
					break;
				case RoomEvent.Stele:
					SpawnStele(openingRoom, roomEventStr);
					break;
				case RoomEvent.DustFactory:
					SpawnDustFactory(openingRoom, roomEventStr);
					break;
				case RoomEvent.CryoCapsule:
					SpawnCryoCapsule(openingRoom, roomEventStr);
					break;
				case RoomEvent.ToxicCloud:
					SpawnToxicCloud(openingRoom, roomEventStr);
					break;
				case RoomEvent.AutoPower:
					openingRoom.AutoPower(power: true, isFromEvent: true, gameNetManager.GetLocalPlayerID());
					break;
				case RoomEvent.EMP:
					SpawnEMP(openingRoom);
					break;
				default:
					Diagnostics.LogError("Unknown room event: " + roomEvent);
					break;
				}
				EventConfig eventCfg = Databases.GetDatabase<EventConfig>().GetValue(roomEventStr);
				if (eventCfg != null && !string.IsNullOrEmpty(eventCfg.SFXJinglePath))
				{
					audioEventManager.Play2DEvent(eventCfg.SFXJinglePath);
				}
			}
			gameEventManager.TriggerRoomEventFinished();
			yield return new WaitForSeconds(dungeonEventDelay);
			if (canTriggerDungeonEvent && !openingRoom.WasAlreadyOpen && !forbidDungeonEvent && (eventCombination == EventCombination.DungeonEventOnly || eventCombination == EventCombination.DungeonAndRoomEvent))
			{
				Dictionary<DynamicDungeonEventConfig, float> dungeonEventCfgWeights = new Dictionary<DynamicDungeonEventConfig, float>();
				int dungeonEventCfgsCount = gameConfig.DynamicDungeonEventConfigs.Length;
				DynamicDungeonEventConfig dungeonEventCfg;
				for (int j = 0; j < dungeonEventCfgsCount; j++)
				{
					dungeonEventCfg = gameConfig.DynamicDungeonEventConfigs[j];
					dungeonEventCfgWeights.Add(dungeonEventCfg, dungeonEventCfg.GetProbWeightValue(openingRoom));
				}
				dungeonEventCfg = dungeonEventCfgWeights.GetWeightedRandom();
				if (dungeonEventCfg != null)
				{
					DungeonEvent dungeonEvent = dungeonEventCfg.Name.ToEnum<DungeonEvent>();
					Diagnostics.Log("Dungeon.TriggerEvents: dungeonEvent=" + dungeonEvent);
					DungeonEvent dungeonEvent2 = dungeonEventCfg.Name.ToEnum<DungeonEvent>();
					if (dungeonEvent2 == DungeonEvent.MobWaves)
					{
						yield return StartCoroutine(SpawnMobWaves(openingRoom, dungeonEventCfg.Name));
					}
				}
			}
		}
		eventTriggeringCount--;
		UpdateGamePhase();
	}

	public GameObject GetItemPrefab(ItemType itemType)
	{
		if (itemsPfb != null)
		{
			for (int i = 0; i < itemsPfb.Length; i++)
			{
				if (itemsPfb[i].Type == itemType)
				{
					return itemsPfb[i].Prefab;
				}
			}
		}
		Diagnostics.LogError("Unable to find item prefab for {0} type", itemType);
		return null;
	}

	private GameObject GetNPCPrefab(NPCConfig npcConfig)
	{
		if (npcsPfb != null && npcConfig != null)
		{
			for (int i = 0; i < npcsPfb.Length; i++)
			{
				if (npcsPfb[i].Type == npcConfig.NPCType)
				{
					return npcsPfb[i].Prefab;
				}
			}
		}
		return npcPfb;
	}

	private void RPC_IncrementDynamicRoomEventCount(RoomEvent roomEvent)
	{
		DynamicRoomEventCounts.AssertKeyDefined(roomEvent, 0);
		Dictionary<RoomEvent, int> dynamicRoomEventCounts;
		Dictionary<RoomEvent, int> dictionary = dynamicRoomEventCounts = DynamicRoomEventCounts;
		RoomEvent key;
		RoomEvent key2 = key = roomEvent;
		int num = dynamicRoomEventCounts[key];
		dictionary[key2] = num + 1;
	}

	private void SpawnItem(Room spawnRoom, StaticString eventType)
	{
		DLCController dlcManager = SingletonManager.Get<DLCController>();
		ItemConfig[] dbElements = (from item in Databases.GetDatabase<ItemConfig>().GetValues()
			where dlcManager.IsObjectAvailable(DLCObjectType.Item, item.Name) && !ShipConfig.UnavailableItems.Contains(item.Name.ToString())
			select item).ToArray();
		ItemConfig itemConfig = MaxedProbabilityConfig.PickLimitedRandomElement(spawnRoom.OpeningIndex, spawnRoom.FloorSurface, Level, dbElements);
		if (itemConfig == null)
		{
			Diagnostics.LogWarning("SpawnItem > All limited items already spawned");
			return;
		}
		RarityConfig rarityConfig = null;
		if (itemConfig is ItemHeroConfig)
		{
			ItemHeroConfig itemHeroConfig = itemConfig as ItemHeroConfig;
			rarityConfig = itemHeroConfig.PickRandomRarityParameters(spawnRoom.Depth, GenericUtilities.RoundHalfAwayFromZeroToInt(spawnRoom.FloorSurface), Level);
		}
		NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_DoSpawnItem, gameNetManager.GetLocalPlayerID(), itemConfig.Name, rarityConfig?.Name, spawnRoom.UniqueID.ID, eventType);
	}

	private void RPC_DoSpawnItem(ulong ownerPlayerID, StaticString itemConfigName, StaticString rarityConfigName, int spawnRoomID, StaticString eventType)
	{
		Room room = UniqueIDManager.Get<Room>(spawnRoomID);
		ItemConfig value = Databases.GetDatabase<ItemConfig>().GetValue(itemConfigName);
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(GetItemPrefab(value.Type), room.CenterPosition, Quaternion.identity);
		AddDynamicElementForScaling(gameObject.transform);
		Item component = gameObject.GetComponent<Item>();
		component.Init(ownerPlayerID, itemConfigName, rarityConfigName, room, value.Type);
		EnqueueEventNotification(eventType, component.GetSpawnNotificationDescription(value));
		switch (value.Type)
		{
		case ItemType.FIDS:
			audioEventManager.Play2DEvent("Master/Jingles/Ressource");
			break;
		case ItemType.ItemHero:
		case ItemType.Chest:
			audioEventManager.Play2DEvent("Master/Jingles/Treasure");
			break;
		}
		switch (value.Type)
		{
		case ItemType.FIDS:
		{
			CurrentLevelDifficulty += gameConfig.FIDSItemSpawnLevelDifficultyBaseValue * component.GetFIDSAmount(out StaticString _);
			break;
		}
		case ItemType.ItemHero:
		case ItemType.Chest:
		{
			ItemHero itemHero = (ItemHero)component;
			CurrentLevelDifficulty += gameConfig.HeroItemSpawnLevelDifficultyBaseValue * itemHero.GetCost(basicCost: true);
			break;
		}
		}
	}

	private void SpawnHero(Room spawnRoom, StaticString eventType, bool displayRecruitmentDialog = true, bool recruitable = true)
	{
		StaticString staticString = PickRandomHeroFromDiscoverablePool();
		if (staticString == null)
		{
			Diagnostics.LogWarning("SpawnHero > Empty hero config pool");
		}
		else
		{
			NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_DoSpawnHero, gameNetManager.GetLocalPlayerID(), staticString, spawnRoom.UniqueID.ID, spawnRoom.CenterPosition + Vector3.up, eventType, displayRecruitmentDialog, recruitable);
		}
	}

	private void RPC_DoSpawnHero(ulong ownerPlayerID, StaticString heroConfigName, int spawnRoomID, Vector3 spawnPosition, StaticString eventType, bool displayRecruitmentDialog, bool recruitable)
	{
		Room room = UniqueIDManager.Get<Room>(spawnRoomID);
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(heroPfb, spawnPosition, Quaternion.identity);
		AddDynamicElementForScaling(gameObject.transform);
		int level = RandomGenerator.RangeInt((int)gameConfig.FreeHeroMinLevel.GetValue(room), (int)gameConfig.FreeHeroMaxLevel.GetValue(room) + 1);
		Hero component = gameObject.GetComponent<Hero>();
		component.InitForEvent(ownerPlayerID, heroConfigName, room, displayRecruitmentDialog, level, recruitable);
		if (guiService.GuiPanelHelper.TryGetGuiElement(eventType, out GuiElement guiElement) && guiService.GuiPanelHelper.TryGetGuiElement(heroConfigName, out GuiElement guiElement2))
		{
			EnqueueEventNotification(eventType, AgeLocalizer.Instance.LocalizeString(guiElement.Title).Replace("$HeroName", AgeLocalizer.Instance.LocalizeString(guiElement2.Title)));
		}
		audioEventManager.Play2DEvent("Master/Jingles/Hero");
		CurrentLevelDifficulty += gameConfig.HeroSpawnLevelDifficultyValue;
	}

	private void SpawnNPC(Room spawnRoom, StaticString eventType, bool displayDialog = true)
	{
		NPCConfig value = Databases.GetDatabase<NPCConfig>().GetValue("NPC_" + eventType);
		IDatabase<CurrencyConfig> database = Databases.GetDatabase<CurrencyConfig>();
		CurrencyConfig[] values = database.GetValues();
		int num = values.Length;
		Dictionary<CurrencyConfig, float> dictionary = new Dictionary<CurrencyConfig, float>();
		for (int i = 0; i < num; i++)
		{
			CurrencyConfig currencyConfig = values[i];
			dictionary.Add(currencyConfig, currencyConfig.MerchantProbWeight.GetValue(spawnRoom));
		}
		CurrencyConfig weightedRandom = dictionary.GetWeightedRandom();
		NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_DoSpawnNPC, gameNetManager.GetLocalPlayerID(), value.Name, spawnRoom.UniqueID.ID, spawnRoom.CenterPosition + Vector3.up, eventType, displayDialog, weightedRandom.Name);
	}

	private void RPC_DoSpawnNPC(ulong ownerPlayerID, StaticString npcConfigName, int spawnRoomID, Vector3 spawnPosition, StaticString eventType, bool displayDialog, StaticString currencyName)
	{
		Room spawnRoom = UniqueIDManager.Get<Room>(spawnRoomID);
		NPCConfig value = Databases.GetDatabase<NPCConfig>().GetValue(npcConfigName);
		CurrencyConfig value2 = Databases.GetDatabase<CurrencyConfig>().GetValue(currencyName);
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(GetNPCPrefab(value), spawnPosition, Quaternion.identity);
		AddDynamicElementForScaling(gameObject.transform);
		NPCMerchant component = gameObject.GetComponent<NPCMerchant>();
		component.InitForEvent(ownerPlayerID, value, spawnRoom, value2, displayDialog);
		string newValue = string.Empty;
		if (guiService.GuiPanelHelper.TryGetGuiElement(value.Name, out cachedGUIElement))
		{
			newValue = AgeLocalizer.Instance.LocalizeString(cachedGUIElement.Title);
		}
		string key = string.Empty;
		if (guiService.GuiPanelHelper.TryGetGuiElement(eventType, out cachedGUIElement))
		{
			key = AgeLocalizer.Instance.LocalizeString(cachedGUIElement.Title);
		}
		EnqueueEventNotification(eventType, AgeLocalizer.Instance.LocalizeString(key).Replace("$NPCName", newValue));
		CurrentLevelDifficulty += gameConfig.MerchantSpawnLevelDifficultyValue;
	}

	private void SpawnExitMobWaves()
	{
		if (spawnExitWaves)
		{
			if (CurrentCrystalState == CrystalState.PluggedOnExitSlot)
			{
				Diagnostics.LogError("Dungeon.SpawnExitMobWaves: shouldn't be called when crystal has been plugged on exit slot!");
			}
			else
			{
				StartCoroutine(SpawnExitMobWavesCoroutine());
			}
		}
	}

	private IEnumerator SpawnExitMobWavesCoroutine()
	{
		if (!spawnExitWaves)
		{
			yield break;
		}
		if (CurrentCrystalState == CrystalState.PluggedOnExitSlot)
		{
			Diagnostics.LogError("Dungeon.SpawnExitMobWavesCoroutine: shouldn't be called when crystal has been plugged on exit slot!");
			yield break;
		}
		StaticString eventType = DungeonEvent.MobWaves.ToString();
		int totalWaveCount = GenericUtilities.RoundHalfAwayFromZeroToInt(RandomGenerator.RangeFloat(gameConfig.ExitWaveCountMin.GetValue(), gameConfig.ExitWaveCountMax.GetValue()));
		if (totalWaveCount >= 1)
		{
			int waveCount = 0;
			openedRooms.Shuffle();
			for (int roomIndex = 0; roomIndex < openedRooms.Count; roomIndex++)
			{
				Room room = openedRooms[roomIndex];
				if (!room.IsFullyOpened || room.IsOccupied() || room.IsPowered)
				{
					continue;
				}
				float exitWaveDifficultyValue = RandomGenerator.RangeFloat(gameConfig.ExitWaveDifficultyMin.GetValue(), gameConfig.ExitWaveDifficultyMax.GetValue());
				IDatabase<MobClassConfig> mobClassCfgDB = Databases.GetDatabase<MobClassConfig>();
				int spawnedMobCount = 0;
				List<SelectedMob> selectedMobs = new List<SelectedMob>();
				for (int i = 0; i < LevelSelectedMobs.Count; i++)
				{
					SelectedMob selectedMob = LevelSelectedMobs[i];
					if (mobClassCfgDB.GetValue(selectedMob.MobCfg.Name).IsElligibleForExitWave)
					{
						selectedMobs.Add(LevelSelectedMobs[i]);
					}
				}
				yield return StartCoroutine(SpawnMobs(room, exitWaveDifficultyValue, MobSpawnType.ExitWave, null, selectedMobs, delegate(int result)
				{
					spawnedMobCount = result;
				}));
				if (spawnedMobCount > 0)
				{
					room.DisplayWaveOffscreenMarker();
					waveCount++;
					if (waveCount >= totalWaveCount)
					{
						break;
					}
				}
			}
			if (waveCount > 0 && guiService.GuiPanelHelper.TryGetGuiElement(eventType, out cachedGUIElement))
			{
				NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_EnqueueEventNotification, eventType, cachedGUIElement.Title, new string[1]
				{
					"$WaveCount"
				}, new string[1]
				{
					waveCount.ToString()
				});
			}
		}
		ExitWaveNumber++;
		if (spawnExitWaves)
		{
			Invoke("SpawnExitMobWaves", GetNextExitWaveDelay());
		}
	}

	private IEnumerator SpawnMobWaves(Room openingRoom, StaticString eventType)
	{
		if (CurrentCrystalState == CrystalState.PluggedOnExitSlot)
		{
			Diagnostics.LogError("Dungeon.SpawnMobWaves: shouldn't be called when crystal has been plugged on exit slot!");
			yield break;
		}
		int totalWaveCount = GenericUtilities.RoundHalfAwayFromZeroToInt(RandomGenerator.RangeFloat(gameConfig.WaveCountMin.GetValue(openingRoom), gameConfig.WaveCountMax.GetValue(openingRoom)));
		if (totalWaveCount < 1)
		{
			yield break;
		}
		int waveCount = 0;
		openedRooms.Shuffle();
		Room[] spawnRooms = openedRooms.ToArray();
		Room[] array = spawnRooms;
		foreach (Room room in array)
		{
			if (room == openingRoom || !room.IsFullyOpened || room.IsOccupied() || room.IsPowered)
			{
				continue;
			}
			float waveDifficultyValue = RandomGenerator.RangeFloat(gameConfig.WaveDifficultyMin.GetValue(openingRoom), gameConfig.WaveDifficultyMax.GetValue(openingRoom));
			int spawnedMobCount = 0;
			yield return StartCoroutine(SpawnMobs(room, waveDifficultyValue, MobSpawnType.Wave, eventType, LevelSelectedMobs, delegate(int result)
			{
				spawnedMobCount = result;
			}));
			if (spawnedMobCount > 0)
			{
				room.DisplayWaveOffscreenMarker();
				waveCount++;
				if (waveCount >= totalWaveCount)
				{
					break;
				}
			}
		}
		if (waveCount > 0 && guiService.GuiPanelHelper.TryGetGuiElement(eventType, out cachedGUIElement))
		{
			NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_EnqueueEventNotification, eventType, cachedGUIElement.Title, new string[1]
			{
				"$WaveCount"
			}, new string[1]
			{
				waveCount.ToString()
			});
		}
	}

	public IEnumerator SpawnMobs(Room spawnRoom, float roomDifficultyValue, MobSpawnType spawnType = MobSpawnType.Room, StaticString eventType = null, List<SelectedMob> elligibleMobs = null, Action<int> spawnCountSetter = null)
	{
		if (CurrentCrystalState == CrystalState.PluggedOnExitSlot)
		{
			Diagnostics.LogError("Dungeon.SpawnMobs: shouldn't be called when crystal has been plugged on exit slot!");
			yield break;
		}
		while (isSpawningMobs)
		{
			yield return null;
		}
		isSpawningMobs = true;
		int spawnedMobCount = 0;
		int roomMaxMobCount = Mathf.Min(b: Mathf.Max(0, gameConfig.MaxTotalMobCount - Mob.ActiveMobs.Count), a: GenericUtilities.RoundHalfAwayFromZeroToInt(gameConfig.MaxMobPerTile * spawnRoom.FloorSurface));
		float remainingRoomDifficultyValue = roomDifficultyValue;
		int realRoomDifficultyValue = 0;
		_defenseSpots = spawnRoom.GetComponentsInChildren<RoomDefenseSpot>();
		_spawnPositions = new List<Vector3>();
		_spawnPositions.Add(spawnRoom.CenterPosition);
		for (int defenseSpotIndex = 0; defenseSpotIndex < _defenseSpots.Length; defenseSpotIndex++)
		{
			_spawnPositions.Add(_defenseSpots[defenseSpotIndex].transform.position);
		}
		_spawnedMobCountPerClass = new Dictionary<StaticString, int>();
		_mobClassCfgDB = Databases.GetDatabase<MobClassConfig>();
		_elligibleMobsPool = new List<SelectedMob>();
		for (int k = 0; k < elligibleMobs.Count; k++)
		{
			IDatabase<MobClassConfig> mobClassCfgDB = _mobClassCfgDB;
			SelectedMob selectedMob2 = elligibleMobs[k];
			MobClassConfig config = mobClassCfgDB.GetValue(selectedMob2.MobCfg.Name);
			SelectedMob selectedMob3 = elligibleMobs[k];
			int index = (!selectedMob3.IsNew) ? config.MinRoomOpeningIndex : config.MinRoomOpeningIndexIfNew;
			if (spawnRoom.OpeningIndex > index)
			{
				_elligibleMobsPool.Add(elligibleMobs[k]);
			}
		}
		_spawnPositionsPool = null;
		_mobClassCountInRoom = new Dictionary<StaticString, int>();
		for (int j = 0; j < _elligibleMobsPool.Count; j++)
		{
			SelectedMob selectedMob4 = _elligibleMobsPool[j];
			StaticString name = selectedMob4.MobCfg.Name;
			int count = 0;
			for (int i = 0; i < spawnRoom.Mobs.Count; i++)
			{
				if (spawnRoom.Mobs[i].ClassDescName == name)
				{
					count++;
				}
			}
			_mobClassCountInRoom.Add(name, count);
		}
		while (spawnedMobCount < roomMaxMobCount && remainingRoomDifficultyValue > 0f)
		{
			_elligibleMobsPool = _elligibleMobsPool.Where((SelectedMob m) => (float)_mobClassCfgDB.GetValue(m.MobCfg.Name).DifficultyValue <= remainingRoomDifficultyValue).ToList();
			if (_elligibleMobsPool.Count == 0)
			{
				break;
			}
			SelectedMob selectedMob = _elligibleMobsPool.GetWeightedRandom((SelectedMob m) => m.MobCfg.SpawnProbWeight.GetValue(base.spawnRoom));
			if (selectedMob.MobCfg == null)
			{
				break;
			}
			_mobClassConfig = _mobClassCfgDB.GetValue(selectedMob.MobCfg.Name);
			if (_mobClassCountInRoom[selectedMob.MobCfg.Name] >= _mobClassConfig.MaxPerRoom)
			{
				_elligibleMobsPool.Remove(selectedMob);
				Diagnostics.Log("Can't spawn more than " + _mobClassConfig.MaxPerRoom + " " + (string)selectedMob.MobCfg.Name + " in room " + spawnRoom.name);
				continue;
			}
			Dictionary<StaticString, int> mobClassCountInRoom;
			Dictionary<StaticString, int> dictionary = mobClassCountInRoom = _mobClassCountInRoom;
			StaticString name2;
			StaticString key = name2 = selectedMob.MobCfg.Name;
			int num = mobClassCountInRoom[name2];
			dictionary[key] = num + 1;
			if (!_spawnedMobCountPerClass.ContainsKey(_mobClassConfig.Name))
			{
				_spawnedMobCountPerClass.Add(_mobClassConfig.Name, 1);
			}
			else
			{
				Dictionary<StaticString, int> spawnedMobCountPerClass;
				Dictionary<StaticString, int> dictionary2 = spawnedMobCountPerClass = _spawnedMobCountPerClass;
				StaticString key2 = name2 = _mobClassConfig.Name;
				num = spawnedMobCountPerClass[name2];
				dictionary2[key2] = num + 1;
			}
			if (_mobClassConfig.MaxPerWave > 0 && _spawnedMobCountPerClass[_mobClassConfig.Name] >= _mobClassConfig.MaxPerWave)
			{
				_elligibleMobsPool.Remove(selectedMob);
			}
			Vector3 spawnPosition;
			if (_mobClassConfig.SpawnCenter)
			{
				spawnPosition = spawnRoom.CenterPosition;
			}
			else
			{
				if (_spawnPositionsPool == null || _spawnPositionsPool.Count < 1)
				{
					_spawnPositionsPool = new List<Vector3>(_spawnPositions);
				}
				spawnPosition = _spawnPositionsPool.PullRandom();
			}
			string mobAdditionalSimDescName = null;
			switch (spawnType)
			{
			case MobSpawnType.Wave:
				mobAdditionalSimDescName = SimulationProperties.SimDescMobWaveMod;
				break;
			case MobSpawnType.ExitWave:
				mobAdditionalSimDescName = SimulationProperties.SimDescMobExitWaveMod;
				break;
			}
			NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_InstantiateMob, gameNetManager.GetLocalPlayerID(), _mobClassConfig.Name, (Int2Position)spawnPosition, spawnRoom.UniqueID.ID, mobAdditionalSimDescName);
			remainingRoomDifficultyValue -= (float)_mobClassConfig.DifficultyValue;
			realRoomDifficultyValue += _mobClassConfig.DifficultyValue;
			spawnedMobCount++;
			yield return new WaitForSeconds(mobSpawnInterval);
		}
		RefreshSim();
		if (spawnType == MobSpawnType.Room && spawnedMobCount > 0 && guiService.GuiPanelHelper.TryGetGuiElement(eventType, out cachedGUIElement))
		{
			NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_EnqueueEventNotification, eventType, cachedGUIElement.Title, null, null);
		}
		spawnCountSetter?.Invoke(spawnedMobCount);
		isSpawningMobs = false;
	}

	private void RPC_InstantiateMob(ulong ownerPlayerID, StaticString mobClassName, Int2Position spawnPosition, int spawnRoomID, string additionalSimDescName)
	{
		DoInstantiateMob(ownerPlayerID, mobClassName, spawnPosition, spawnRoomID, additionalSimDescName);
	}

	private Mob DoInstantiateMob(ulong ownerPlayerID, StaticString mobClassName, Int2Position spawnPosition, int spawnRoomID, string additionalSimDescName)
	{
		if (CurrentCrystalState == CrystalState.PluggedOnExitSlot)
		{
			Diagnostics.LogError("Dungeon.RPC_InstantiateMob: shouldn't be called when crystal has been plugged on exit slot!");
			return null;
		}
		Room spawnRoom = UniqueIDManager.Get<Room>(spawnRoomID);
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(mobPfb, (Vector3)spawnPosition + Vector3.up, Quaternion.identity);
		AddDynamicElementForScaling(gameObject.transform);
		Mob component = gameObject.GetComponent<Mob>();
		component.Init(ownerPlayerID, mobClassName, spawnRoom, SimMonoBehaviour.GetDBDescriptorByName(additionalSimDescName));
		MobClassConfig value = Databases.GetDatabase<MobClassConfig>().GetValue(mobClassName);
		CurrentLevelDifficulty += gameConfig.MobSpawnLevelDifficultyBaseValue * (float)value.DifficultyValue;
		return component;
	}

	private void SpawnExit(Room spawnRoom)
	{
		if (ExitRoom != null)
		{
			Diagnostics.LogError("Cannot spawn an exit: exit already found in {0}!", ExitRoom.name);
		}
		else if (gameNetManager.IsMultiplayerSession())
		{
			if (MultiplayerConfig.OneCrystalPerPlayer)
			{
				NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_DoSpawnExit, spawnRoom.UniqueID.ID);
			}
			else
			{
				DoSpawnExit(spawnRoom);
			}
		}
		else
		{
			DoSpawnExit(spawnRoom);
		}
	}

	private void RPC_DoSpawnExit(int spawnRoomID)
	{
		Room spawnRoom = UniqueIDManager.Get<Room>(spawnRoomID);
		DoSpawnExit(spawnRoom);
	}

	private void DoSpawnExit(Room spawnRoom)
	{
		Diagnostics.Log("Spawning an exit in " + spawnRoom.name);
		spawnRoom.AddCrystalSlot(isExitSlot: true);
		EnqueueEventNotification(RoomEvent.Exit);
		audioEventManager.Play2DEvent("Master/Jingles/Exit");
	}

	private void SpawnSpecialModule(Room spawnRoom, StaticString eventType, StaticString bpName, float difficultyValue)
	{
		if (spawnRoom.MajorModuleSlot == null)
		{
			Diagnostics.LogWarning("SpawnSpecialModule > No major module slot to build on");
			return;
		}
		spawnRoom.BuildSpecialModule(bpName);
		NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_DoSpecialModuleSpawnFeedback, eventType, difficultyValue);
	}

	private void RPC_DoSpecialModuleSpawnFeedback(StaticString eventType, float difficultyValue)
	{
		EnqueueEventNotification(eventType);
		CurrentLevelDifficulty += difficultyValue;
		audioEventManager.Play2DEvent("Master/Jingles/Relic");
	}

	private void SpawnArtifact(Room spawnRoom, StaticString eventType)
	{
		SpawnSpecialModule(spawnRoom, eventType, SimulationProperties.SpecialModule_Artifact, gameConfig.ArtifactSpawnLevelDifficultyValue);
	}

	private void SpawnStele(Room spawnRoom, StaticString eventType)
	{
		SpawnSpecialModule(spawnRoom, eventType, SimulationProperties.SpecialModule_Stele, gameConfig.SteleSpawnLevelDifficultyValue);
	}

	private void SpawnDustFactory(Room spawnRoom, StaticString eventType)
	{
		SpawnSpecialModule(spawnRoom, eventType, SimulationProperties.SpecialModule_DustFactory, gameConfig.DustFactorySpawnLevelDifficultyValue);
	}

	private void SpawnCryoCapsule(Room spawnRoom, StaticString eventType)
	{
		SpawnSpecialModule(spawnRoom, eventType, SimulationProperties.SpecialModule_CryoCapsule, gameConfig.CryoCapsuleSpawnLevelDifficultyValue);
	}

	private void SpawnToxicCloud(Room spawnRoom, StaticString eventType)
	{
		NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_DoSpawnToxicCloud, spawnRoom.UniqueID.ID, eventType);
	}

	private void RPC_DoSpawnToxicCloud(int spawnRoomID, StaticString eventType)
	{
		Room room = UniqueIDManager.Get<Room>(spawnRoomID);
		room.AddTemporarySimDescriptor(SimulationProperties.SimDescRoomToxicCloud, Turn + gameConfig.CryoCapsuleToxicCloudTurnCount);
		EnqueueEventNotification(eventType);
		CurrentLevelDifficulty += gameConfig.ToxicCloudSpawnLevelDifficultyValue;
	}

	private void SpawnEMP(Room currentRoom)
	{
		for (int i = 0; i < OpenedRooms.Count; i++)
		{
			Room room = OpenedRooms[i];
			if (room.ModulesCount > 0)
			{
				GameConfig gameConfig = this.gameConfig;
				int num = (int)gameConfig.EMPRoomCount.GetValue(currentRoom);
				int remainingTurns = (int)gameConfig.EMPDuration.GetValue(currentRoom);
				List<Room> source = OpenedRooms;
				source = (from r in source
					where r.ModulesCount > 0
					orderby r.ModulesCount descending
					select r).ToList();
				source.Sort(delegate(Room r1, Room r2)
				{
					float num4 = r1.ModulesCount;
					float value = r2.ModulesCount;
					int num5 = -num4.CompareTo(value);
					return (num5 != 0) ? num5 : ((RandomGenerator.RangeFloat(0f, 1f) > 0.5f) ? 1 : (-1));
				});
				int num2 = (int)Mathf.Ceil((float)source.Count * gameConfig.EMPSelectionPct);
				if (source.Count > num2)
				{
					source.RemoveRange(num2, source.Count - num2);
				}
				int num3 = 0;
				while (source.Count > 0 && num3 < num)
				{
					int index = RandomGenerator.RangeInt(0, source.Count - 1);
					source[index].ApplyEMP(emp: true, remainingTurns);
					source.RemoveAt(index);
					num3++;
				}
				RefreshSim();
				gameEventManager.TriggerDungeonFIDSChangedEvent();
				audioEventManager.Play2DEvent("Master/Jingles/EMP");
				return;
			}
		}
		Diagnostics.Log("Did not trigger EMP because there is no module built");
	}

	public void AddDust(float dustAmount, bool displayFeedback = true, bool triggerDungeonFIDSChangedEvent = true)
	{
		if (dustAmount != 0f)
		{
			NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_DoAddDust, dustAmount, displayFeedback, triggerDungeonFIDSChangedEvent);
		}
	}

	private void RPC_DoAddDust(float dustAmount, bool displayFeedback = true, bool triggerDungeonFIDSChangedEvent = true)
	{
		DoAddDust(dustAmount, displayFeedback, triggerDungeonFIDSChangedEvent);
	}

	private void DoAddDust(float dustAmount, bool displayFeedback = true, bool triggerDungeonFIDSChangedEvent = true)
	{
		DustStock += dustAmount;
		if (displayFeedback)
		{
			MainGameScreen mainGameScreen = SingletonManager.Get<MainGameScreen>();
			if (mainGameScreen != null)
			{
				mainGameScreen.AddFIDSFeedback(dustAmount, FIDS.Dust);
			}
		}
		if (DustStock < 1f)
		{
			DustStock = 0f;
			TriggerCrystalDeath();
		}
		if (DustStock > GetMaxDustStock())
		{
			DustStock = GetMaxDustStock();
		}
		if (dustAmount < 0f && gameNetManager.IsServerOrSinglePlayer())
		{
			float roomPowerDustCost = GetRoomPowerDustCost();
			while (GetPoweredRoomCount() > 0 && DustStock < (float)GetPoweredRoomCount() * roomPowerDustCost)
			{
				GetRandomPoweredRoom().Unpower();
			}
		}
		if (triggerDungeonFIDSChangedEvent)
		{
			gameEventManager.TriggerDungeonFIDSChangedEvent();
		}
		if (dustAmount > 0f)
		{
			Statistics.IncrementStat(DungeonStatistics.Stat_LootedDust, dustAmount);
		}
	}

	public bool ConsumeDust(float dustCost)
	{
		if (dustCost == 0f)
		{
			return true;
		}
		if (dustCost > 0f && !CanConsumeDust(dustCost))
		{
			return false;
		}
		AddDust(0f - dustCost);
		return true;
	}

	public IEnumerator ApplyFIDSIncome()
	{
		float industryProd = GetIndustryProd();
		if (industryProd > 0f)
		{
			Player.LocalPlayer.AddIndustry(industryProd);
			yield return new WaitForSeconds(fidsIncomeDelay);
		}
		float scienceProd = GetScienceProd();
		if (scienceProd > 0f)
		{
			Player.LocalPlayer.AddScience(scienceProd);
			yield return new WaitForSeconds(fidsIncomeDelay);
		}
		float foodProd = GetFoodProd();
		if (foodProd > 0f)
		{
			Player.LocalPlayer.AddFood(foodProd);
			yield return new WaitForSeconds(fidsIncomeDelay);
		}
		if (gameNetManager.IsServerOrSinglePlayer() || MultiplayerConfig.SplitDust)
		{
			float dustProd = GetDustProd();
			if (dustProd > 0f)
			{
				AddDust(dustProd);
			}
		}
	}

	public float GetFoodProd()
	{
		float num = GetSimPropertyValue(SimulationProperties.FoodProd);
		if (gameNetManager.IsMultiplayerSession() && MultiplayerConfig.SplitFISIncome)
		{
			num /= (float)gameNetManager.GetPlayerCount();
		}
		Math.Round(num, MidpointRounding.AwayFromZero);
		return Mathf.Ceil(num);
	}

	public float GetIndustryProd()
	{
		float num = GetSimPropertyValue(SimulationProperties.IndustryProd);
		if (gameNetManager.IsMultiplayerSession() && MultiplayerConfig.SplitFISIncome)
		{
			num /= (float)gameNetManager.GetPlayerCount();
		}
		return Mathf.Ceil(num);
	}

	public float GetDustProd()
	{
		return Mathf.Ceil(GetSimPropertyValue(SimulationProperties.DustProd));
	}

	public float GetScienceProd()
	{
		float num = GetSimPropertyValue(SimulationProperties.ScienceProd);
		if (gameNetManager.IsMultiplayerSession() && MultiplayerConfig.SplitFISIncome)
		{
			num /= (float)gameNetManager.GetPlayerCount();
		}
		return Mathf.Ceil(num);
	}

	public float GetMaxDustStock()
	{
		return GetSimPropertyValue(SimulationProperties.MaxDustStock);
	}

	public float GetCrystalHealth()
	{
		return DustStock * GetSimPropertyValue(SimulationProperties.DustHealthValue);
	}

	public void AddCrystalHealth(float amount)
	{
		AddDust(amount / GetSimPropertyValue(SimulationProperties.DustHealthValue));
		if (amount < 0f)
		{
			achievementManager.AddToStatistic(StatisticName.CRYSTAL_HITS_NEGATIVE, -1f);
		}
	}

	public float GetRoomPowerDustCost()
	{
		return GetSimPropertyValue(SimulationProperties.RoomPowerDustCost);
	}

	public int GetPoweredRoomCount()
	{
		return dustPoweredRooms.Count;
	}

	private void SimMB_OnSimChildAdded(SimulationObject simObj)
	{
		float propertyValue = simObj.GetPropertyValue(SimulationProperties.Food);
		if (propertyValue != 0f)
		{
			Player.LocalPlayer.AddFood(propertyValue);
		}
		float propertyValue2 = simObj.GetPropertyValue(SimulationProperties.Industry);
		if (propertyValue2 != 0f)
		{
			Player.LocalPlayer.AddIndustry(propertyValue2);
		}
		float propertyValue3 = simObj.GetPropertyValue(SimulationProperties.Dust);
		if (propertyValue3 != 0f)
		{
			AddDust(propertyValue3);
		}
		float propertyValue4 = simObj.GetPropertyValue(SimulationProperties.Science);
		if (propertyValue4 != 0f)
		{
			Player.LocalPlayer.AddScience(propertyValue4);
		}
	}

	public void TriggerCrystalDeath()
	{
		CrystalModuleSlot component = CrystalTfm.GetComponent<CrystalModuleSlot>();
		if (component == null)
		{
			Diagnostics.LogError("Unable to find crystal slot on " + CrystalTfm.name);
		}
		else if (component.PluggedModule == null)
		{
			Diagnostics.LogError("Unable to find plugged module on crystal slot (" + CrystalTfm.name + ")");
		}
		else
		{
			component.PluggedModule.HealthCpnt.TriggerDeath();
		}
	}

	public Room GetRandomPoweredRoom()
	{
		return dustPoweredRooms.GetRandom();
	}

	public float GetAvailableDustAmount()
	{
		return DustStock - GetRoomPowerDustCost() * (float)GetPoweredRoomCount();
	}

	public int GetMaxPoweredRoomCount()
	{
		return Mathf.FloorToInt(DustStock / GetRoomPowerDustCost());
	}

	public bool CanAffordRoomPowering()
	{
		return GetPoweredRoomCount() < GetMaxPoweredRoomCount();
	}

	public bool CanConsumeDust(float dustAmount)
	{
		return DustStock - 1f >= dustAmount;
	}

	public bool IsDustAvailableWithoutRoomUnpower(float dustAmount)
	{
		return DustStock >= dustAmount + GetRoomPowerDustCost() * (float)GetPoweredRoomCount();
	}

	public bool CanPowerRoom(Room room)
	{
		if (room.IsStartRoom)
		{
			return true;
		}
		if (!CanAffordRoomPowering())
		{
			return false;
		}
		return true;
	}

	private void CheckInputs()
	{
		if (!Amplitude.Unity.Framework.Application.HasFocus)
		{
			return;
		}
		if (IsDisplayed && !gameMenuPanel.IsVisible && !endLevelPanel.IsVisible && !gameOverPanel.IsVisible && !victoryPanel.IsVisible && (!this.heroPanel.IsVisible || inputManager.CurrentControlScheme == ControlScheme.MouseAndKeyboard) && gameControlManager.CanPauseGame() && inputManager.GetControlDown(Control.GamePause))
		{
			gameControlManager.ToggleGamePause();
			if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController)
			{
				SingletonManager.Get<TurnPanel>().XboxIcon.StartAllModifiers();
			}
		}
		if (inputManager.KeyboardShortcutEnabled && EnableGameMenuOrCloseTopMenuControl && inputManager.GetControlDown(Control.EscapeBehavior))
		{
			if (PopupMenuPanel.GetTopPopupMenuPanel() != null)
			{
				PopupMenuPanel.CloseTopPopupMenuPanelForEscapeBehavior();
			}
			else if (IsDisplayed && !requesterPanel.IsVisible && inputManager.CurrentControlScheme != ControlScheme.XBoxOneController)
			{
				gameMenuPanel.ToggleVisibility(false);
			}
		}
		if (IsLevelOver || gameMenuPanel.IsVisible)
		{
			return;
		}
		SelectionCategoryConfig currentCategoryConfig = selectableManager.GetCurrentCategoryConfig();
		if (!currentCategoryConfig.EnableNonContextualControl)
		{
			return;
		}
		int num = (Hero.SelectedHeroes != null) ? Hero.SelectedHeroes.Count : 0;
		int num2 = (Hero.LocalPlayerActiveRecruitedHeroes != null) ? Hero.LocalPlayerActiveRecruitedHeroes.Count : 0;
		if (IsDisplayed && (inputManager.CurrentControlScheme != 0 || inputManager.KeyboardShortcutEnabled))
		{
			if (inputManager.GetControlDown(Control.Chat))
			{
				chatPanelInGame.Focus();
			}
			if (inputManager.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
			{
				if (inputManager.GetControlDown(Control.TacticalMapToggle))
				{
					gameCameraManager.ToggleTacticalMapCamera();
				}
				else if (inputManager.GetControlDown(Control.TacticalMapHold))
				{
					gameCameraManager.SwitchToTacticalMapCamera();
				}
				else if (inputManager.GetControlUp(Control.TacticalMapHold))
				{
					gameCameraManager.SwitchToGameCamera();
				}
			}
			else
			{
				SelectionCategoryData currentCategory = selectableManager.CurrentCategory;
				if (currentCategory.Category == SelectionCategory.RoomForMove && inputManager.GetControlDown(Control.TacticalMapToggle))
				{
					gameCameraManager.SwitchToTacticalMapCamera();
					if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController)
					{
						SingletonManager.Get<ConstructionModeInitialPane>().HeroesPanelIcon.StartAllModifiers();
					}
				}
				else if (inputManager.GetControlUp(Control.TacticalMapToggle))
				{
					gameCameraManager.SwitchToGameCamera();
				}
			}
			if (inputManager.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
			{
				if (inputManager.GetControl(Control.MoveCameraUp))
				{
					gameCameraManager.MoveToward(Vector3.back);
				}
				else if (inputManager.GetControl(Control.MoveCameraDown))
				{
					gameCameraManager.MoveToward(Vector3.forward);
				}
				if (inputManager.GetControl(Control.MoveCameraLeft))
				{
					gameCameraManager.MoveToward(Vector3.right);
				}
				else if (inputManager.GetControl(Control.MoveCameraRight))
				{
					gameCameraManager.MoveToward(Vector3.left);
				}
				if (inputManager.GetControlDown(Control.FocusCrystal) && !gameCameraManager.IsTacticalMapActive())
				{
					gameCameraManager.Focus(CrystalTfm.position, LerpType.Smoothed, -1f);
				}
			}
			if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController)
			{
				SelectionCategoryData currentCategory2 = selectableManager.CurrentCategory;
				if (currentCategory2.Category == SelectionCategory.BuildMenu)
				{
					goto IL_053a;
				}
			}
			if (num2 >= 1 && !this.heroPanel.IsVisible && inputManager.GetControlDown(Control.SelectAllHeroes))
			{
				Hero.SelectAllHeroes();
			}
			else
			{
				bool flag = false;
				for (int i = 0; i < GameControlManager.HeroGroupCount; i++)
				{
					Control control = selectHeroControlByIndex[i];
					if (inputManager.GetControlDown(control))
					{
						flag = true;
						if (gameControlManager.HeroGroupAssignationMode)
						{
							gameControlManager.AssignHeroGroup(i);
						}
						else
						{
							SelectHeroGroup(i);
						}
						break;
					}
				}
				if (!flag && !this.heroPanel.IsVisible)
				{
					bool controlDown = inputManager.GetControlDown(Control.SelectPreviousHero);
					bool controlDown2 = inputManager.GetControlDown(Control.SelectNextHero);
					if (num2 > 1 && (controlDown || controlDown2))
					{
						int num3 = -1;
						if (num > 0)
						{
							num3 = Hero.LocalPlayerActiveRecruitedHeroes.IndexOf(Hero.SelectedHeroes[0]);
						}
						int num4 = num3;
						num4 = ((!controlDown) ? (num4 + 1) : (num4 - 1));
						num4 = (num4 + num2) % num2;
						Hero.LocalPlayerActiveRecruitedHeroes[num4].Select(recordSelectTime: false);
					}
				}
			}
			goto IL_053a;
		}
		goto IL_081e;
		IL_053a:
		if (num == 1 && inputManager.GetControlDown(Control.StickToHero))
		{
			gameCameraManager.StickTo(Hero.SelectedHeroes[0].transform);
		}
		if (num == 1)
		{
			bool flag2 = true;
			if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController)
			{
				HeroPanel heroPanel = SingletonManager.Get<HeroPanel>();
				if (heroPanel != null && heroPanel.IsVisible)
				{
					flag2 = false;
				}
			}
			if (flag2)
			{
				if (inputManager.GetControlDown(Control.ActiveSkill1))
				{
					Hero.SelectedHeroes[0].ActivateActiveSkill(0);
				}
				else if (inputManager.GetControlDown(Control.ActiveSkill2))
				{
					Hero.SelectedHeroes[0].ActivateActiveSkill(1);
				}
			}
		}
		if (num == 1 && inputManager.GetControl(Control.FocusHero))
		{
			Hero.SelectedHeroes[0].Focus();
		}
		if (inputManager.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			if (constructionPanel != null)
			{
				if (inputManager.GetControlDown(Control.MajorModuleMenu))
				{
					constructionPanel.RotateCategoryModuleSelection(0);
				}
				else if (inputManager.GetControlDown(Control.MinorModuleSupportMenu))
				{
					constructionPanel.RotateCategoryModuleSelection(1);
				}
				else if (inputManager.GetControlDown(Control.MinorModuleOffenseMenu))
				{
					constructionPanel.RotateCategoryModuleSelection(2);
				}
				else if (inputManager.GetControlDown(Control.MinorModuleDebuffMenu))
				{
					constructionPanel.RotateCategoryModuleSelection(3);
				}
				else if (inputManager.GetControlDown(Control.DestructionToggle))
				{
					constructionPanel.ToggleModuleDestructionMode();
				}
			}
			if (inputManager.GetControlDown(Control.InventoryToggle))
			{
				mainGameScreen.ToggleSharedInventoryPanel();
			}
			if (inputManager.GetControlDown(Control.HeroStatsToggle))
			{
				gameControlManager.ToggleHeroStatsPanelDisplay();
			}
		}
		HeroPanel heroPanel2 = SingletonManager.Get<HeroPanel>();
		bool flag3 = false;
		if (heroPanel2 != null)
		{
			flag3 = heroPanel2.IsVisible;
		}
		if (num > 0 && ShipConfig != null && !ShipConfig.ForbidHeal && (inputManager.CurrentControlScheme != ControlScheme.XBoxOneController || !flag3))
		{
			if (inputManager.GetControlDown(Control.HeroHeal))
			{
				HeroListPanel heroListPanel = SingletonManager.Get<HeroListPanel>();
				for (int j = 0; j < num; j++)
				{
					Hero.SelectedHeroes[j].Heal();
					heroListPanel.GetHeroItem(Hero.SelectedHeroes[j]).OpenButton.StartAllModifiers(forward: true, recursive: true);
				}
			}
			if (inputManager.GetControlDown(Control.HeroRest))
			{
				for (int k = 0; k < num; k++)
				{
					Hero.SelectedHeroes[k].Rest();
				}
			}
		}
		goto IL_081e;
		IL_081e:
		CrystalLiftPanel crystalLiftPanel = SingletonManager.Get<CrystalLiftPanel>();
		if (crystalLiftPanel != null && !crystalLiftPanel.IsVisible)
		{
			if (inputManager.GetControlDown(Control.RoomPowerModeToggle))
			{
				gameControlManager.SetRoomPowerToggleMode(on: true);
			}
			else if (inputManager.GetControlUp(Control.RoomPowerModeToggle))
			{
				gameControlManager.SetRoomPowerToggleMode(on: false);
			}
		}
		if (inputManager.CurrentControlScheme != 0)
		{
			return;
		}
		if (inputManager.GetControlDown(Control.MultipleModuleConstructionsToggle))
		{
			gameControlManager.MultipleModuleConstructionsMode = true;
		}
		else if (inputManager.GetControlUp(Control.MultipleModuleConstructionsToggle))
		{
			gameControlManager.MultipleModuleConstructionsMode = false;
		}
		if (inputManager.GetControlDown(Control.MultipleHeroToggle))
		{
			gameControlManager.MultipleHeroSelectionMode = true;
		}
		else if (inputManager.GetControlUp(Control.MultipleHeroToggle))
		{
			gameControlManager.MultipleHeroSelectionMode = false;
		}
		if (inputManager.GetControlDown(Control.HeroGroupAssignationToggle))
		{
			gameControlManager.HeroGroupAssignationMode = true;
		}
		else if (inputManager.GetControlUp(Control.HeroGroupAssignationToggle))
		{
			gameControlManager.HeroGroupAssignationMode = false;
		}
		if (inputManager.EdgeScrollingEnabled && !cameraDragSupport.IsDragging)
		{
			Vector2 gameMousePosition = gameCameraManager.GetGameMousePosition();
			ScreenResolution currentDisplayResolution = gameResolutionManager.GetCurrentDisplayResolution();
			if (gameMousePosition.x <= inputManager.EdgeScrollingBordersWidth)
			{
				gameCameraManager.MoveToward(Vector3.right);
			}
			else if (gameMousePosition.x >= (float)currentDisplayResolution.Width - inputManager.EdgeScrollingBordersWidth)
			{
				gameCameraManager.MoveToward(Vector3.left);
			}
			if (gameMousePosition.y <= inputManager.EdgeScrollingBordersWidth)
			{
				gameCameraManager.MoveToward(Vector3.forward);
			}
			else if (gameMousePosition.y >= (float)currentDisplayResolution.Height - inputManager.EdgeScrollingBordersWidth)
			{
				gameCameraManager.MoveToward(Vector3.back);
			}
		}
		if (IsDisplayed && !AgeManager.IsMouseCovered && Input.GetAxis("MouseWheel") < 0f)
		{
			gameCameraManager.SwitchToTacticalMapCamera();
		}
	}

	private void SelectHeroGroup(int index)
	{
		if (gameControlManager.HeroGroups != null && index >= 0 && index < gameControlManager.HeroGroups.Length && gameControlManager.HeroGroups[index] != null)
		{
			StaticString[] array = gameControlManager.HeroGroups[index];
			for (int i = 0; i < array.Length; i++)
			{
				for (int j = 0; j < Hero.LocalPlayerActiveRecruitedHeroes.Count; j++)
				{
					if (Hero.LocalPlayerActiveRecruitedHeroes[j].Config.Name == array[i])
					{
						Hero.LocalPlayerActiveRecruitedHeroes[j].Select(recordSelectTime: true, i == 0);
						break;
					}
				}
			}
		}
		else if (index > 0 && index <= Hero.LocalPlayerActiveRecruitedHeroes.Count)
		{
			Hero.LocalPlayerActiveRecruitedHeroes[index - 1].Select();
		}
	}

	public bool RequestBuyItem(InventoryItem item)
	{
		if (item.CurrentInventory == null || item.CurrentInventory.ParentSimMB == null || !(item.CurrentInventory.ParentSimMB is NPCMerchant))
		{
			Diagnostics.LogError("Dungeon.BuyItem: item is not in merchant inventory! ({0})", (item.CurrentInventory == null) ? "none" : item.CurrentInventory.Name.ToString());
			if (item.CurrentInventory != null)
			{
				item.CurrentInventory.RemoveItem(item);
			}
			return false;
		}
		FIDS currency = (item.CurrentInventory.ParentSimMB as NPCMerchant).CurrencyCfg.Currency;
		bool flag = false;
		if (gameNetManager.IsMultiplayerSession())
		{
			flag = ((currency == FIDS.Dust && !MultiplayerConfig.SplitDust) || (currency != FIDS.Dust && !MultiplayerConfig.SplitFIS));
		}
		if (flag && !Player.LocalPlayer.ConsumeFIDS(item.GetCostForCurrency(currency), currency))
		{
			Diagnostics.LogError("Dungeon.BuyItem: not enough resources!");
			return false;
		}
		return true;
	}

	public bool RequestSellItem(InventoryItem item, FIDS merchantCurrency)
	{
		if (gameNetManager.IsMultiplayerSession() && !MultiplayerConfig.SplitInventory && (item.CurrentInventory == null || item.CurrentInventory.ParentSimMB == null || (item.CurrentInventory.Name != Inventory.SharedInventoryName && item.CurrentInventory.Name != Inventory.BackpackInventoryName)))
		{
			Diagnostics.LogError("Dungeon.SellItem: item is not in general or backpack inventory! ({0})", (item.CurrentInventory == null) ? "none" : item.CurrentInventory.Name.ToString());
			return false;
		}
		bool flag = true;
		if (gameNetManager.IsMultiplayerSession() && ((merchantCurrency == FIDS.Dust && MultiplayerConfig.SplitDust) || (merchantCurrency != FIDS.Dust && MultiplayerConfig.SplitFIS)))
		{
			flag = false;
		}
		if (flag && !Player.LocalPlayer.ConsumeFIDS(0f - item.GetSellingCostForCurrency(merchantCurrency), merchantCurrency))
		{
			Diagnostics.LogError("Dungeon.SellItem: couldn't refund item!");
			return false;
		}
		return true;
	}

	private void RPC_RequestMoveItemToSharedInventory(StaticString itemUniqueIDCategory, int itemUniqueID, ulong moverPlayerID)
	{
		InventoryItem item = InventoryItem.GetItem(itemUniqueIDCategory, itemUniqueID);
		if (item != null)
		{
			if (item.CurrentInventory != BackpackInventory && inputManager.CurrentControlScheme != ControlScheme.XBoxOneController)
			{
				Diagnostics.LogError("Trying to move {0} item to shared inventories but it's not in backpack inventory ({1})!", item.Name, (item.CurrentInventory == null) ? "<NULL>" : item.CurrentInventory.Name.ToString());
			}
			else if (item.OwnerPlayerID != moverPlayerID)
			{
				Diagnostics.LogError("Trying to move {0} item from backpack inventories but it's owned by another player ({1})!", item.Name, item.OwnerPlayerID);
			}
			else
			{
				NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_DoMoveItemToSharedInventory, itemUniqueIDCategory, itemUniqueID, moverPlayerID);
			}
		}
	}

	private void RPC_DoMoveItemToSharedInventory(StaticString itemUniqueIDCategory, int itemUniqueID, ulong moverPlayerID)
	{
		InventoryItem item = InventoryItem.GetItem(itemUniqueIDCategory, itemUniqueID);
		if (item != null)
		{
			if (item.CurrentInventory != BackpackInventory && inputManager.CurrentControlScheme != ControlScheme.XBoxOneController)
			{
				Diagnostics.LogError("Trying to move {0} item to shared inventories but it's not in backpack inventory ({1})!", item.Name, (item.CurrentInventory == null) ? "<NULL>" : item.CurrentInventory.Name.ToString());
				return;
			}
			if (item.OwnerPlayerID != moverPlayerID)
			{
				Diagnostics.LogError("Trying to move {0} item from backpack inventories but it's owned by another player ({1})!", item.Name, item.OwnerPlayerID);
				return;
			}
			item.OwnerPlayerID = gameNetManager.GetLocalPlayerID();
			item.MoveToInventory(SharedInventory);
		}
	}

	private void RPC_RequestMoveItemToBackpackInventory(StaticString itemUniqueIDCategory, int itemUniqueID, ulong moverPlayerID)
	{
		InventoryItem item = InventoryItem.GetItem(itemUniqueIDCategory, itemUniqueID);
		if (item != null)
		{
			if (item.CurrentInventory != SharedInventory && inputManager.CurrentControlScheme != ControlScheme.XBoxOneController)
			{
				Diagnostics.LogError("Trying to move {0} item to backpack inventories but it's not in shared inventory ({1})!", item.Name, (item.CurrentInventory == null) ? "<NULL>" : item.CurrentInventory.Name.ToString());
			}
			else
			{
				NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_DoMoveItemToBackpackInventory, itemUniqueIDCategory, itemUniqueID, moverPlayerID);
			}
		}
	}

	private void RPC_DoMoveItemToBackpackInventory(StaticString itemUniqueIDCategory, int itemUniqueID, ulong moverPlayerID)
	{
		InventoryItem item = InventoryItem.GetItem(itemUniqueIDCategory, itemUniqueID);
		if (item != null)
		{
			if (item.CurrentInventory != SharedInventory && inputManager.CurrentControlScheme != ControlScheme.XBoxOneController)
			{
				Diagnostics.LogError("Trying to move {0} item to backpack inventories but it's not in shared inventory ({1})!", item.Name, (item.CurrentInventory == null) ? "<NULL>" : item.CurrentInventory.Name.ToString());
				return;
			}
			item.OwnerPlayerID = moverPlayerID;
			item.MoveToInventory(BackpackInventory);
		}
	}

	private void RPC_DoRemoveItem(StaticString itemUniqueIDCategory, int itemUniqueID)
	{
		InventoryItem item = InventoryItem.GetItem(itemUniqueIDCategory, itemUniqueID);
		if (item != null && item.CurrentInventory != null)
		{
			item.CurrentInventory.RemoveItem(item);
		}
	}

	public bool CanSaveDungeon(List<GuiError> guiErrors = null)
	{
		if (!IsStarted || !IsDisplayed)
		{
			return false;
		}
		if (IsLevelOver)
		{
			return false;
		}
		if (!gameNetManager.IsServerOrSinglePlayer())
		{
			GuiError.Add(guiErrors, ForbiddenFromClients);
			return false;
		}
		if (CurrentGamePhase != 0 || ActivatingModuleCount >= 1)
		{
			GuiError.Add(guiErrors, ForbiddenDuringEvent);
			return false;
		}
		return true;
	}

	public void SaveAndQuit()
	{
		if (!CanSaveDungeon())
		{
			Diagnostics.LogError("Dungeon.SaveAndQuit: cannot save game!");
			return;
		}
		string text = GameSave.GenerateSaveKey();
		NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_DoSaveAndQuit, text);
	}

	private void RPC_DoSaveAndQuit(string saveKey)
	{
		if (!gameNetManager.IsServerOrSinglePlayer())
		{
			requesterPanel.Display(AgeLocalizer.Instance.LocalizeString("%SaveAndQuit_ClientMessage"));
		}
		try
		{
			SaveGameData(saveKey);
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Exception raised while saving game: {0}\n{1}", ex.Message, ex.StackTrace);
		}
		Services.GetService<IGameControlService>().GoBackToMainMenu();
	}

	public void SaveGameData(string saveKey)
	{
		Diagnostics.Log("Saving game...");
		GameSaveData gameSaveData = new GameSaveData();
		Diagnostics.Log("Saving dungeon generator seed");
		DungeonGenerator2 dungeonGenerator = SingletonManager.Get<DungeonGenerator2>();
		gameSaveData.DungeonGeneratorRandomSeed = dungeonGenerator.RandomSeed;
		gameSaveData.DungeonPostGenerationRandomSeed = dungeonGenerator.PostGenerationSeed;
		Diagnostics.Log("Saving level data");
		gameSaveData.Level = Level;
		gameSaveData.GameDifficulty = Difficulty;
		gameSaveData.Turn = Turn;
		gameSaveData.CurrentLevelDifficulty = CurrentLevelDifficulty;
		gameSaveData.ExitWaveNumber = ExitWaveNumber;
		gameSaveData.TotalMissedDoorCount = TotalMissedDoorCount;
		gameSaveData.ResetResearchesCount = ResetResearchesCount;
		gameSaveData.ShipName = ShipConfig.Name;
		Diagnostics.Log("Saving ship: " + ShipConfig.Name);
		Diagnostics.Log("Saving stats");
		gameSaveData.CurrentLevelTime = Time.time - GameStartTime;
		gameSaveData.StatisticsKeys = Statistics.Statistics.Keys.ToArray();
		gameSaveData.StatisticsValues = Statistics.Statistics.Values.ToArray();
		Diagnostics.Log("Saving FIDS");
		gameSaveData.DustStock = DustStock;
		ulong[] playerIDs = Player.GetPlayerIDs();
		gameSaveData.Players = new PlayerSaveData[playerIDs.Length];
		for (int i = 0; i < playerIDs.Length; i++)
		{
			ulong num = playerIDs[i];
			Player playerByID = Player.GetPlayerByID(num);
			gameSaveData.Players[i] = new PlayerSaveData
			{
				ID = num,
				FoodStock = playerByID.FoodStock,
				IndustryStock = playerByID.IndustryStock,
				ScienceStock = playerByID.ScienceStock,
				IsStillConnected = playerByID.IsStillConnected()
			};
		}
		Diagnostics.Log("Saving blueprints");
		List<BluePrintSaveData> list = new List<BluePrintSaveData>();
		foreach (List<BluePrintConfig> value in unlockedBPsByCategory.Values)
		{
			foreach (BluePrintConfig item12 in value)
			{
				BluePrintSaveData item = default(BluePrintSaveData);
				item.BluePrintName = item12.Name;
				list.Add(item);
			}
		}
		gameSaveData.UnlockedBluePrints = list.ToArray();
		gameSaveData.LockedBluePrints = lockedBluePrints.ToArray();
		gameSaveData.ResearchableBluePrints = new BluePrintSaveData[researchableBPByCategory.Keys.Count];
		int num2 = 0;
		foreach (BluePrintConfig value2 in researchableBPByCategory.Values)
		{
			BluePrintSaveData bluePrintSaveData = default(BluePrintSaveData);
			bluePrintSaveData.BluePrintName = value2.Name;
			gameSaveData.ResearchableBluePrints[num2++] = bluePrintSaveData;
		}
		Diagnostics.Log("Saving shared inventory");
		gameSaveData.GeneralInventoryItems = new InventoryItemData[SharedInventory.Items.Count];
		int num3 = 0;
		foreach (InventoryItem item13 in SharedInventory.Items)
		{
			InventoryItemData inventoryItemData = new InventoryItemData();
			inventoryItemData.ItemDescName = item13.ItemConfig.Name;
			inventoryItemData.RarityDescName = ((item13.RarityCfg == null) ? null : item13.RarityCfg.Name);
			InventoryItemData inventoryItemData2 = inventoryItemData;
			gameSaveData.GeneralInventoryItems[num3++] = inventoryItemData2;
		}
		Diagnostics.Log("Saving Backpack");
		gameSaveData.BackpackInventoryItems = new InventoryItemData[BackpackInventory.Items.Count];
		num3 = 0;
		foreach (InventoryItem item14 in BackpackInventory.Items)
		{
			InventoryItemData inventoryItemData = new InventoryItemData();
			inventoryItemData.ItemDescName = item14.ItemConfig.Name;
			inventoryItemData.RarityDescName = ((item14.RarityCfg == null) ? null : item14.RarityCfg.Name);
			inventoryItemData.OwnerPlayerID = item14.OwnerPlayerID;
			InventoryItemData inventoryItemData2 = inventoryItemData;
			gameSaveData.BackpackInventoryItems[num3++] = inventoryItemData2;
		}
		Diagnostics.Log("Saving camera position");
		gameSaveData.CameraSupportPosition = Services.GetService<IGameCameraService>().GetCamSupportPosition();
		Diagnostics.Log("Saving doors");
		gameSaveData.OpenedDoorsHistory = Door.OpenedDoorIDsHistory.ToArray();
		Diagnostics.Log("Saving rooms cleaned from module slots");
		gameSaveData.RoomsCleanedFromModuleSlotsIDs = Room.CleanedFromModuleSlotsIDs.ToArray();
		Diagnostics.Log("Saving rooms");
		Room[] componentsInChildren = staticContainer.GetComponentsInChildren<Room>();
		List<RoomPowerData> list2 = new List<RoomPowerData>();
		Room[] array = componentsInChildren;
		foreach (Room room in array)
		{
			if (!room.IsStartRoom)
			{
				RoomPowerData roomPowerData = new RoomPowerData();
				roomPowerData.RoomID = room.UniqueID.ID;
				roomPowerData.NEW_PowerPlayerID = room.LastPowerChangePlayerID;
				roomPowerData.IsPowered = room.IsPowered;
				roomPowerData.IsUnpoweringWithDelay = room.IsUnpoweringWithDelay;
				roomPowerData.IsPowerForced = room.IsAutoPowered;
				roomPowerData.IsPowerForcedFromEvent = room.IsAutoPoweredByEvent;
				roomPowerData.EmpTurnsRemaining = room.EmpTurnsRemaining;
				RoomPowerData item2 = roomPowerData;
				list2.Add(item2);
			}
		}
		gameSaveData.PoweredRooms = list2.ToArray();
		Diagnostics.Log("Saving heroes");
		gameSaveData.HeroGroups = gameControlManager.HeroGroups;
		Hero[] componentsInChildren2 = dynamicContainer.GetComponentsInChildren<Hero>();
		componentsInChildren2 = (from h in componentsInChildren2
			where !h.IsDismissing && h.HealthCpnt.IsAlive()
			orderby (!h.IsRecruited) ? 1000f : ((float)Hero.LocalPlayerActiveRecruitedHeroes.IndexOf(h))
			select h).ToArray();
		List<HeroSaveData> list3 = new List<HeroSaveData>();
		Hero[] array2 = componentsInChildren2;
		HeroSaveData item3 = default(HeroSaveData);
		foreach (Hero hero in array2)
		{
			item3.OwnerPlayerID = hero.NetSyncElement.OwnerPlayerID;
			item3.Position = hero.transform.position;
			item3.ParentRoomID = hero.RoomElement.ParentRoom.UniqueID.ID;
			item3.SimDescName = hero.Config.Name;
			item3.Level = hero.Level;
			item3.UnlockLevel = hero.UnlockLevel;
			item3.IsRecruited = hero.IsRecruited;
			item3.HasOperatingBonus = hero.HasOperatingBonus;
			item3.HealthValue = hero.HealthCpnt.GetHealth();
			item3.PermanantHealthMalus = hero.HealthCpnt.PermanantHealthMalus;
			item3.FloorRecruited = hero.FloorRecruited;
			item3.IsStartingHero = hero.IsStartingHero;
			item3.CurrentRespawnRoomCount = hero.CurrentRespawnRoomCount;
			item3.PermanentDescriptors = hero.PermanentDescriptors.Select((SimulationDescriptor descriptor) => descriptor.Name).ToArray();
			item3.IsUnrecruitable = !hero.IsRecruitable;
			List<HeroItemData> list4 = new List<HeroItemData>();
			EquipmentSlot[] equipmentSlots = hero.EquipmentSlots;
			foreach (EquipmentSlot equipmentSlot in equipmentSlots)
			{
				if (equipmentSlot.EquippedItem != null)
				{
					HeroItemData heroItemData = new HeroItemData();
					heroItemData.CategoryName = equipmentSlot.CategoryParameters.CategoryName;
					heroItemData.ItemDescName = equipmentSlot.EquippedItem.ItemConfig.Name;
					heroItemData.RarityDescName = ((equipmentSlot.EquippedItem.RarityCfg == null) ? null : equipmentSlot.EquippedItem.RarityCfg.Name);
					HeroItemData item4 = heroItemData;
					list4.Add(item4);
				}
			}
			item3.Items = list4.ToArray();
			List<HeroActiveSkillData> list5 = new List<HeroActiveSkillData>();
			foreach (ActiveSkill filteredActiveSkill in hero.FilteredActiveSkills)
			{
				HeroActiveSkillData heroActiveSkillData = new HeroActiveSkillData();
				heroActiveSkillData.SkillName = filteredActiveSkill.Config.Name;
				heroActiveSkillData.LastActivityTurn = filteredActiveSkill.LastActivityTurn;
				HeroActiveSkillData item5 = heroActiveSkillData;
				list5.Add(item5);
			}
			item3.ActiveSkills = list5.ToArray();
			MobSaveData mobSaveData = new MobSaveData();
			if (hero.TamedMob != null && hero.TamedMob.HealthCpnt.IsAlive())
			{
				mobSaveData.Position = hero.TamedMob.transform.position;
				mobSaveData.ParentRoomID = hero.TamedMob.RoomElement.ParentRoom.UniqueID.ID;
				mobSaveData.SimDescName = hero.TamedMob.Config.Name;
				mobSaveData.Level = hero.TamedMob.TameLevel;
				mobSaveData.HealthValue = hero.TamedMob.HealthCpnt.GetHealth();
				mobSaveData.TameKillCount = hero.TamedMob.TameKillCount;
			}
			item3.TamedMob = mobSaveData;
			list3.Add(item3);
		}
		gameSaveData.Heroes = list3.ToArray();
		AssertDiscoverableHeroPoolIsInitialized();
		gameSaveData.HeroConfigNamePool = discoverableHeroPool.ToArray();
		gameSaveData.SelectedHeroIndexes = new int[Hero.SelectedHeroes.Count];
		int num4 = 0;
		foreach (Hero selectedHero in Hero.SelectedHeroes)
		{
			gameSaveData.SelectedHeroIndexes[num4++] = Hero.LocalPlayerActiveRecruitedHeroes.IndexOf(selectedHero);
		}
		List<SelectedMobSaveData> list6 = new List<SelectedMobSaveData>();
		for (int m = 0; m < LevelSelectedMobs.Count; m++)
		{
			SelectedMobSaveData item6 = default(SelectedMobSaveData);
			SelectedMob selectedMob = LevelSelectedMobs[m];
			item6.MobClassName = selectedMob.MobCfg.Name;
			SelectedMob selectedMob2 = LevelSelectedMobs[m];
			item6.IsNew = selectedMob2.IsNew;
			list6.Add(item6);
		}
		gameSaveData.LevelSelectedMobs = list6.ToArray();
		Diagnostics.Log("Saving minor modules");
		MinorModule[] componentsInChildren3 = dynamicContainer.GetComponentsInChildren<MinorModule>();
		List<MinorModuleSaveData> list7 = new List<MinorModuleSaveData>();
		MinorModule[] array3 = componentsInChildren3;
		MinorModuleSaveData item7 = default(MinorModuleSaveData);
		foreach (MinorModule minorModule in array3)
		{
			if (minorModule.Slot != null)
			{
				item7.SlotID = minorModule.Slot.GetComponent<UniqueID>().ID;
				item7.BPName = minorModule.BPConfig.Name;
				item7.KillCount = minorModule.MobKillCount;
				item7.Health = ((!minorModule.IsBuilding) ? minorModule.HealthCpnt.GetHealth() : float.PositiveInfinity);
				item7.OwnerPlayerID = minorModule.NetSyncElement.OwnerPlayerID;
				list7.Add(item7);
			}
		}
		gameSaveData.MinorModules = list7.ToArray();
		Diagnostics.Log("Saving major modules");
		MajorModule[] componentsInChildren4 = dynamicContainer.GetComponentsInChildren<MajorModule>();
		List<MajorModule> list8 = new List<MajorModule>();
		foreach (MajorModule majorModule in componentsInChildren4)
		{
			if (!majorModule.IsCrystal && !(majorModule is Artifact) && !(majorModule is Stele))
			{
				list8.Add(majorModule);
			}
		}
		componentsInChildren4 = list8.ToArray();
		gameSaveData.MajorModules = new MajorModuleSaveData[componentsInChildren4.Length];
		int num6 = 0;
		MajorModule[] array4 = componentsInChildren4;
		MajorModuleSaveData majorModuleSaveData = default(MajorModuleSaveData);
		foreach (MajorModule majorModule2 in array4)
		{
			majorModuleSaveData.RoomID = majorModule2.RoomElement.ParentRoom.UniqueID.ID;
			majorModuleSaveData.BPName = majorModule2.BPConfig.Name;
			majorModuleSaveData.Health = ((!majorModule2.IsBuilding) ? majorModule2.HealthCpnt.GetHealth() : float.PositiveInfinity);
			majorModuleSaveData.OwnerPlayerID = majorModule2.NetSyncElement.OwnerPlayerID;
			gameSaveData.MajorModules[num6++] = majorModuleSaveData;
		}
		Diagnostics.Log("Saving module slots");
		ModuleSlot[] componentsInChildren5 = staticContainer.GetComponentsInChildren<ModuleSlot>();
		componentsInChildren5 = componentsInChildren5.Where((ModuleSlot s) => s.DestroyedModuleConfigName != null).ToArray();
		gameSaveData.ModuleSlots = new ModuleSlotSaveData[componentsInChildren5.Length];
		int num8 = 0;
		ModuleSlot[] array5 = componentsInChildren5;
		ModuleSlotSaveData moduleSlotSaveData = default(ModuleSlotSaveData);
		foreach (ModuleSlot moduleSlot in array5)
		{
			moduleSlotSaveData.SlotID = moduleSlot.UniqueID.ID;
			moduleSlotSaveData.SlotCategory = moduleSlot.UniqueID.GetCategory();
			moduleSlotSaveData.ModuleCategory = moduleSlot.DestroyedModuleCategory;
			moduleSlotSaveData.ModuleConfigName = moduleSlot.DestroyedModuleConfigName;
			moduleSlotSaveData.ModuleLevel = moduleSlot.DestroyedModuleLevel;
			Diagnostics.Log("Saving module slot #" + moduleSlotSaveData.SlotID + " bp=" + moduleSlotSaveData.ModuleCategory);
			gameSaveData.ModuleSlots[num8++] = moduleSlotSaveData;
		}
		Diagnostics.Log("Saving artifacts");
		Artifact[] componentsInChildren6 = dynamicContainer.GetComponentsInChildren<Artifact>();
		ArtifactSaveData artifactSaveData = default(ArtifactSaveData);
		gameSaveData.Artifacts = new ArtifactSaveData[componentsInChildren6.Length];
		int num10 = 0;
		Artifact[] array6 = componentsInChildren6;
		foreach (Artifact artifact in array6)
		{
			artifactSaveData.RoomID = artifact.RoomElement.ParentRoom.UniqueID.ID;
			artifactSaveData.Health = artifact.HealthCpnt.GetHealth();
			artifactSaveData.ResearchedBPName = ((artifact.ResearchedBP == null) ? null : artifact.ResearchedBP.Name);
			artifactSaveData.ResearchStartTurn = artifact.ResearchStartTurn;
			gameSaveData.Artifacts[num10++] = artifactSaveData;
		}
		Diagnostics.Log("Saving steles");
		Stele[] componentsInChildren7 = dynamicContainer.GetComponentsInChildren<Stele>();
		SteleSaveData steleSaveData = default(SteleSaveData);
		gameSaveData.Steles = new SteleSaveData[componentsInChildren7.Length];
		int num12 = 0;
		Stele[] array7 = componentsInChildren7;
		foreach (Stele stele in array7)
		{
			steleSaveData.RoomID = stele.RoomElement.ParentRoom.UniqueID.ID;
			steleSaveData.Health = stele.HealthCpnt.GetHealth();
			steleSaveData.SteleTypeName = stele.TypeEventConfig.Name;
			gameSaveData.Steles[num12++] = steleSaveData;
		}
		Diagnostics.Log("Saving merchants");
		NPCMerchant[] componentsInChildren8 = dynamicContainer.GetComponentsInChildren<NPCMerchant>();
		gameSaveData.Merchants = new MerchantSaveData[componentsInChildren8.Length];
		int num14 = 0;
		NPCMerchant[] array8 = componentsInChildren8;
		MerchantSaveData merchantSaveData = default(MerchantSaveData);
		foreach (NPCMerchant nPCMerchant in array8)
		{
			merchantSaveData.Position = nPCMerchant.transform.position;
			merchantSaveData.ParentRoomID = nPCMerchant.RoomElement.ParentRoom.UniqueID.ID;
			merchantSaveData.Health = nPCMerchant.HealthCpnt.GetHealth();
			merchantSaveData.CurrencyConfig = nPCMerchant.CurrencyCfg;
			merchantSaveData.IsInShop = (nPCMerchant.LinkedModule != null);
			merchantSaveData.ConfigName = nPCMerchant.Config.Name;
			merchantSaveData.GiftCost = nPCMerchant.GiftCost;
			merchantSaveData.Items = new InventoryItemData[nPCMerchant.CurrentInventory.Items.Count];
			int num16 = 0;
			foreach (InventoryItem item15 in nPCMerchant.CurrentInventory.Items)
			{
				InventoryItemData inventoryItemData2 = new InventoryItemData();
				inventoryItemData2.ItemDescName = item15.ItemConfig.Name;
				inventoryItemData2.RarityDescName = ((item15.RarityCfg == null) ? null : item15.RarityCfg.Name);
				inventoryItemData2.IsGift = item15.IsGift;
				merchantSaveData.Items[num16++] = inventoryItemData2;
			}
			gameSaveData.Merchants[num14++] = merchantSaveData;
		}
		Diagnostics.Log("Saving lootable items");
		Item[] componentsInChildren9 = dynamicContainer.GetComponentsInChildren<Item>();
		LootItemSaveData item8 = default(LootItemSaveData);
		List<LootItemSaveData> list9 = new List<LootItemSaveData>();
		Item[] array9 = componentsInChildren9;
		foreach (Item item9 in array9)
		{
			if (item9.IsAcquired)
			{
				continue;
			}
			item8.Position = item9.transform.position;
			item8.ItemName = item9.ItemName;
			item8.Type = item9.Type;
			item8.ParentRoomID = item9.RoomElement.ParentRoom.UniqueID.ID;
			if (item9.Type == ItemType.ItemHero || item9.Type == ItemType.Chest)
			{
				ItemHero itemHero = (ItemHero)item9;
				if (itemHero.ItemElements != null && itemHero.ItemElements.Count > 0)
				{
					item8.ChestItems = new InventoryItemData[itemHero.ItemElements.Count];
					int num18 = 0;
					foreach (ItemHeroElement itemElement in itemHero.ItemElements)
					{
						item8.ChestItems[num18] = new InventoryItemData();
						item8.ChestItems[num18].ItemDescName = itemElement.ItemHeroCfg.Name;
						item8.ChestItems[num18].RarityDescName = ((itemElement.RarityCfg == null) ? null : itemElement.RarityCfg.Name);
						num18++;
					}
				}
			}
			list9.Add(item8);
		}
		gameSaveData.LootItems = list9.ToArray();
		Diagnostics.Log("Saving dust loots");
		MobDustLoot[] componentsInChildren10 = dynamicContainer.GetComponentsInChildren<MobDustLoot>();
		gameSaveData.DustLoots = new DustLootSaveData[componentsInChildren10.Length];
		int num19 = 0;
		MobDustLoot[] array10 = componentsInChildren10;
		DustLootSaveData dustLootSaveData = default(DustLootSaveData);
		foreach (MobDustLoot mobDustLoot in array10)
		{
			dustLootSaveData.Position = mobDustLoot.transform.position;
			dustLootSaveData.Amount = mobDustLoot.DustAmount;
			dustLootSaveData.ParentRoomID = mobDustLoot.ParentRoom.UniqueID.ID;
			gameSaveData.DustLoots[num19++] = dustLootSaveData;
		}
		Diagnostics.Log("Saving exit crystal slots");
		CrystalModuleSlot[] componentsInChildren11 = dynamicContainer.GetComponentsInChildren<CrystalModuleSlot>();
		gameSaveData.Exits = new ExitSaveData[(componentsInChildren11.Length >= 1) ? (componentsInChildren11.Length - 1) : 0];
		int num21 = 0;
		CrystalModuleSlot[] array11 = componentsInChildren11;
		ExitSaveData exitSaveData = default(ExitSaveData);
		foreach (CrystalModuleSlot crystalModuleSlot in array11)
		{
			if (crystalModuleSlot.IsExitSlot)
			{
				exitSaveData.RoomID = crystalModuleSlot.ParentRoom.UniqueID.ID;
				gameSaveData.Exits[num21++] = exitSaveData;
			}
		}
		Diagnostics.Log("Saving probability config occurence counts");
		List<ProbabilityConfigOccurrenceCountData> list10 = new List<ProbabilityConfigOccurrenceCountData>();
		if (ProbabilityConfig.OccurrenceCounts != null)
		{
			foreach (KeyValuePair<StaticString, Dictionary<StaticString, int>> occurrenceCount in ProbabilityConfig.OccurrenceCounts)
			{
				foreach (KeyValuePair<StaticString, int> item16 in occurrenceCount.Value)
				{
					if (item16.Value != 0)
					{
						ProbabilityConfigOccurrenceCountData item10 = default(ProbabilityConfigOccurrenceCountData);
						item10.TypeName = occurrenceCount.Key;
						item10.Name = item16.Key;
						item10.Count = item16.Value;
						list10.Add(item10);
					}
				}
			}
		}
		gameSaveData.ProbabilityConfigOccurrenceCounts = list10.ToArray();
		List<MaxedProbabilityConfigPickedElementCountData> list11 = new List<MaxedProbabilityConfigPickedElementCountData>();
		if (MaxedProbabilityConfig.PickedElementCounts != null)
		{
			foreach (KeyValuePair<StaticString, Dictionary<StaticString, int>> pickedElementCount in MaxedProbabilityConfig.PickedElementCounts)
			{
				foreach (KeyValuePair<StaticString, int> item17 in pickedElementCount.Value)
				{
					if (item17.Value != 0)
					{
						MaxedProbabilityConfigPickedElementCountData item11 = default(MaxedProbabilityConfigPickedElementCountData);
						item11.TypeName = pickedElementCount.Key;
						item11.Name = item17.Key;
						item11.Count = item17.Value;
						list11.Add(item11);
					}
				}
			}
		}
		gameSaveData.MaxedProbabilityConfigPickedElementCounts = list11.ToArray();
		gameSaveData.DynamicRoomEventCounts = new DynamicRoomEventCountData[DynamicRoomEventCounts.Count];
		int num23 = 0;
		foreach (KeyValuePair<RoomEvent, int> dynamicRoomEventCount in DynamicRoomEventCounts)
		{
			gameSaveData.DynamicRoomEventCounts[num23].RoomEvent = dynamicRoomEventCount.Key;
			gameSaveData.DynamicRoomEventCounts[num23].Count = dynamicRoomEventCount.Value;
			num23++;
		}
		StoryDialogManager storyDialogManager = SingletonManager.Get<StoryDialogManager>();
		if (storyDialogManager != null)
		{
			gameSaveData.LastStoryPlayed = storyDialogManager.LastStoryPlayed;
		}
		StoryDialogConfig[] array12 = (from story in Databases.GetDatabase<StoryDialogConfig>().GetValues()
			where story.CurrentStepIndex >= 0
			select story).ToArray();
		gameSaveData.StoriesInProgress = new StorySaveData[array12.Length];
		for (int num24 = 0; num24 < array12.Length; num24++)
		{
			StorySaveData storySaveData = default(StorySaveData);
			storySaveData.StoryName = array12[num24].Name;
			storySaveData.StepIndex = array12[num24].CurrentStepIndex;
			gameSaveData.StoriesInProgress[num24] = storySaveData;
		}
		Diagnostics.Log("Saving temporary simulation descriptors");
		gameSaveData.TempSimDescs = ((SimMonoBehaviour.TempSimDescs == null) ? new TemporarySimDescriptor[0] : SimMonoBehaviour.TempSimDescs.ToArray());
		gameSaveData.ReducedLogPanel = SingletonManager.Get<LogPanel>().IsReduced;
		Diagnostics.Log("User save");
		GameSave.WriteUserSaveToFile(gameSaveData, Player.GetPlayerIDs(), gameNetManager.IsMultiplayerSession(), saveKey);
	}

	private bool LoadSavedGame(GameSaveData gameSaveData)
	{
		Diagnostics.Log("Loading user save");
		ulong localPlayerID = gameNetManager.GetLocalPlayerID();
		ulong serverPlayerID = gameNetManager.GetServerPlayerID();
		bool flag = gameNetManager.IsServerOrSinglePlayer();
		Diagnostics.Log("Restoring level data");
		Turn = gameSaveData.Turn;
		CurrentLevelDifficulty = gameSaveData.CurrentLevelDifficulty;
		ExitWaveNumber = gameSaveData.ExitWaveNumber;
		GameStartTime = Time.time - gameSaveData.CurrentLevelTime;
		Diagnostics.Log("Restoring stats");
		Statistics.ImportStatistics(gameSaveData.StatisticsKeys, gameSaveData.StatisticsValues);
		Diagnostics.Log("Restoring ship: " + gameSaveData.ShipName);
		SetShip(gameSaveData.ShipName);
		Diagnostics.Log("Restoring FIDS");
		if (flag)
		{
			AddDust(gameSaveData.DustStock);
		}
		for (int i = 0; i < gameSaveData.Players.Length; i++)
		{
			ulong iD = gameSaveData.Players[i].ID;
			if (iD == localPlayerID)
			{
				Player playerByID = Player.GetPlayerByID(iD);
				playerByID.AddFood(gameSaveData.Players[i].FoodStock, displayFeedback: false, triggerDungeonFIDSChangedEvent: true, checkPlayerIsLocal: false);
				playerByID.AddIndustry(gameSaveData.Players[i].IndustryStock, displayFeedback: false, triggerDungeonFIDSChangedEvent: true, checkPlayerIsLocal: false);
				playerByID.AddScience(gameSaveData.Players[i].ScienceStock, displayFeedback: false, triggerDungeonFIDSChangedEvent: true, checkPlayerIsLocal: false);
			}
		}
		if (gameSaveData.UnlockedBluePrints != null)
		{
			Diagnostics.Log("Restoring blueprints");
			BluePrintSaveData[] unlockedBluePrints = gameSaveData.UnlockedBluePrints;
			for (int j = 0; j < unlockedBluePrints.Length; j++)
			{
				BluePrintSaveData bluePrintSaveData = unlockedBluePrints[j];
				UnlockBluePrintForSaveRestore(bluePrintSaveData.BluePrintName);
			}
		}
		if (gameSaveData.ResearchableBluePrints != null)
		{
			SetResearchableBluePrintsFromSave(gameSaveData.ResearchableBluePrints);
		}
		if (gameSaveData.LockedBluePrints != null)
		{
			lockedBluePrints = gameSaveData.LockedBluePrints.ToList();
		}
		if (gameSaveData.GeneralInventoryItems != null)
		{
			Diagnostics.Log("Restoring shared inventory");
			InventoryItemData[] generalInventoryItems = gameSaveData.GeneralInventoryItems;
			foreach (InventoryItemData inventoryItemData in generalInventoryItems)
			{
				ulong creatorPlayerID = (inventoryItemData.OwnerPlayerID == 0) ? localPlayerID : inventoryItemData.OwnerPlayerID;
				InventoryItem.BuildInventoryItem(inventoryItemData.ItemDescName, inventoryItemData.RarityDescName, SharedInventory, creatorPlayerID);
			}
		}
		if (gameSaveData.BackpackInventoryItems != null)
		{
			Diagnostics.Log("Restoring backpack");
			InventoryItemData[] backpackInventoryItems = gameSaveData.BackpackInventoryItems;
			foreach (InventoryItemData inventoryItemData2 in backpackInventoryItems)
			{
				ulong creatorPlayerID2 = (inventoryItemData2.OwnerPlayerID == 0) ? localPlayerID : inventoryItemData2.OwnerPlayerID;
				InventoryItem.BuildInventoryItem(inventoryItemData2.ItemDescName, inventoryItemData2.RarityDescName, BackpackInventory, creatorPlayerID2);
			}
		}
		if (gameSaveData.OpenedDoorsHistory != null)
		{
			Diagnostics.Log("Restoring doors");
			DoorOpeningData[] openedDoorsHistory = gameSaveData.OpenedDoorsHistory;
			for (int m = 0; m < openedDoorsHistory.Length; m++)
			{
				DoorOpeningData doorOpeningData = openedDoorsHistory[m];
				Door door = UniqueIDManager.Get<Door>(doorOpeningData.DoorID);
				if (door == null)
				{
					Diagnostics.LogError("Could not restore {0} door in room {1} (door not found)!", doorOpeningData.DoorID, doorOpeningData.OpeningRoomID);
					return false;
				}
				Room room = null;
				if (doorOpeningData.OpeningRoomID >= 0)
				{
					room = UniqueIDManager.Get<Room>(doorOpeningData.OpeningRoomID);
					if (room == null)
					{
						Diagnostics.LogError("Could not restore {0} door in room {1} (room not found)!", doorOpeningData.DoorID, doorOpeningData.OpeningRoomID);
						return false;
					}
				}
				door.OpenForSaveRestore(room);
			}
		}
		if (gameSaveData.PoweredRooms != null)
		{
			Diagnostics.Log("Restoring rooms power");
			List<Room> list = new List<Room>();
			List<Room> list2 = new List<Room>();
			Dictionary<int, RoomPowerData> dictionary = new Dictionary<int, RoomPowerData>();
			RoomPowerData[] poweredRooms = gameSaveData.PoweredRooms;
			foreach (RoomPowerData roomPowerData in poweredRooms)
			{
				Room room2 = UniqueIDManager.Get<Room>(roomPowerData.RoomID);
				if (room2 == null)
				{
					Diagnostics.LogError("Could not restore {0} room power (not found)!", roomPowerData.RoomID);
					return false;
				}
				dictionary.Add(roomPowerData.RoomID, roomPowerData);
				if (roomPowerData.EmpTurnsRemaining > 0)
				{
					room2.DoApplyEMP(emp: true, roomPowerData.EmpTurnsRemaining, silent: true);
				}
				if (roomPowerData.IsPowered)
				{
					list.Add(room2);
					if (roomPowerData.IsUnpoweringWithDelay)
					{
						list2.Add(room2);
					}
				}
			}
			list = list.OrderBy((Room r) => r.Depth).ToList();
			int num = 0;
			while (list.Count > 0 && num < 100)
			{
				Room room2 = list.PullAt(0);
				RoomPowerData roomPowerData2 = dictionary[room2.UniqueID.ID];
				if (roomPowerData2.IsPowerForced)
				{
					room2.DoAutoPower(power: true, roomPowerData2.IsPowerForcedFromEvent, roomPowerData2.NEW_PowerPlayerID, playPowerVFX: false);
				}
				else
				{
					room2.DoPower(roomPowerData2.NEW_PowerPlayerID, playPowerVFX: false, checkCrystalState: false, consumeDust: true, checkIfCanBePowered: false);
				}
				if (!room2.IsPowered)
				{
					list.Add(room2);
					num++;
				}
			}
			if (list.Count > 0)
			{
				Diagnostics.LogError("Couldn't restore all rooms to power (" + list.Count + " remaining)");
			}
			foreach (Room item2 in list2)
			{
				item2.DoUnpower(localPlayerID);
			}
		}
		if (gameSaveData.Heroes != null)
		{
			Diagnostics.Log("Restoring {0} heroes", gameSaveData.Heroes.Length);
			HeroSaveData[] heroes = gameSaveData.Heroes;
			for (int num2 = 0; num2 < heroes.Length; num2++)
			{
				HeroSaveData heroSaveData = heroes[num2];
				if (gameSaveData.Version.Serial < 19 || heroSaveData.OwnerPlayerID == localPlayerID)
				{
					Room x = UniqueIDManager.Get<Room>(heroSaveData.ParentRoomID);
					if (x == null)
					{
						Diagnostics.LogError("Could not restore {0} hero in room {1} (room not found)! Restoring in start room...", heroSaveData.SimDescName, heroSaveData.ParentRoomID);
						return false;
					}
					ulong num3 = heroSaveData.OwnerPlayerID;
					if (gameSaveData.Version.Serial < 19)
					{
						num3 = localPlayerID;
					}
					Diagnostics.Log("Restoring {0}", heroSaveData.SimDescName);
					NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_InstantiateSavedHero, num3, heroSaveData.SimDescName, heroSaveData.Level, heroSaveData.UnlockLevel, heroSaveData.HasOperatingBonus, heroSaveData.ParentRoomID, heroSaveData.Position, heroSaveData.Items, heroSaveData.IsRecruited, heroSaveData.FloorRecruited, heroSaveData.PermanentDescriptors, heroSaveData.IsStartingHero, heroSaveData.ActiveSkills, heroSaveData.HealthValue, heroSaveData.PermanantHealthMalus, heroSaveData.TamedMob, heroSaveData.CurrentRespawnRoomCount, !heroSaveData.IsUnrecruitable);
				}
			}
		}
		if (gameSaveData.HeroConfigNamePool != null)
		{
			discoverableHeroPool = gameSaveData.HeroConfigNamePool.ToList();
		}
		if (flag && gameSaveData.SelectedHeroIndexes != null)
		{
			int[] selectedHeroIndexes = gameSaveData.SelectedHeroIndexes;
			foreach (int num5 in selectedHeroIndexes)
			{
				if (Hero.LocalPlayerActiveRecruitedHeroes.Count >= num5 + 1)
				{
					Hero.LocalPlayerActiveRecruitedHeroes[num5].Select(recordSelectTime: false, unselectOthers: false);
				}
			}
		}
		if (gameSaveData.LevelSelectedMobs != null)
		{
			Diagnostics.Log("Restoring {0} selected mobs", gameSaveData.LevelSelectedMobs.Length);
			LevelSelectedMobs = new List<SelectedMob>();
			for (int num6 = 0; num6 < gameSaveData.LevelSelectedMobs.Length; num6++)
			{
				SelectedMobSaveData selectedMobSaveData = gameSaveData.LevelSelectedMobs[num6];
				MobConfig mobConfig = null;
				for (int num7 = 0; num7 < gameConfig.FilteredMobConfigs.Length; num7++)
				{
					if (gameConfig.FilteredMobConfigs[num7].Name == selectedMobSaveData.MobClassName)
					{
						mobConfig = gameConfig.FilteredMobConfigs[num7];
						break;
					}
				}
				if (mobConfig == null)
				{
					Diagnostics.LogError("Enable to find {0} mob config!", selectedMobSaveData.MobClassName);
					continue;
				}
				SelectedMob selectedMob = default(SelectedMob);
				selectedMob.IsNew = selectedMobSaveData.IsNew;
				selectedMob.MobCfg = mobConfig;
				SelectedMob item = selectedMob;
				LevelSelectedMobs.Add(item);
			}
		}
		if (gameSaveData.MinorModules != null)
		{
			Diagnostics.Log("Restoring {0} minor modules", gameSaveData.MinorModules.Length);
			MinorModuleSaveData[] minorModules = gameSaveData.MinorModules;
			for (int num8 = 0; num8 < minorModules.Length; num8++)
			{
				MinorModuleSaveData minorModuleSaveData = minorModules[num8];
				MinorModuleSlot minorModuleSlot = UniqueIDManager.Get<MinorModuleSlot>(minorModuleSaveData.SlotID);
				if (minorModuleSlot == null)
				{
					Diagnostics.LogError("Could not restore {0} minor module on #{1} slot (slot not found)!", minorModuleSaveData.BPName, minorModuleSaveData.SlotID);
					return false;
				}
				ulong buyerPlayerID = minorModuleSaveData.OwnerPlayerID;
				if (gameSaveData.Version.Serial < 19)
				{
					buyerPlayerID = localPlayerID;
				}
				Diagnostics.Log("Restoring {0}", minorModuleSaveData.BPName);
				minorModuleSlot.ParentRoom.DoBuildMinorModule(buyerPlayerID, minorModuleSaveData.BPName, minorModuleSlot, instantBuild: true, restoration: true, consumeIndustryOnBuyer: false, minorModuleSaveData.Health, minorModuleSaveData.KillCount, checkOwnershipForBuildComplete: false);
			}
		}
		if (gameSaveData.MajorModules != null)
		{
			Diagnostics.Log("Restoring {0} major modules", gameSaveData.MajorModules.Length);
			MajorModuleSaveData[] majorModules = gameSaveData.MajorModules;
			for (int num9 = 0; num9 < majorModules.Length; num9++)
			{
				MajorModuleSaveData majorModuleSaveData = majorModules[num9];
				Room room3 = UniqueIDManager.Get<Room>(majorModuleSaveData.RoomID);
				if (room3 == null)
				{
					Diagnostics.LogError("Could not restore {0} major module in room {1} (room not found)!", majorModuleSaveData.BPName, majorModuleSaveData.RoomID);
					return false;
				}
				ulong buyerPlayerID2 = majorModuleSaveData.OwnerPlayerID;
				if (gameSaveData.Version.Serial < 19)
				{
					buyerPlayerID2 = localPlayerID;
				}
				Diagnostics.Log("Restoring {0}", majorModuleSaveData.BPName);
				room3.DoBuildMajorModule(buyerPlayerID2, majorModuleSaveData.BPName, instantBuild: true, restoration: true, consumeIndustryOnBuyer: false, majorModuleSaveData.Health, checkOwnershipForBuildComplete: false);
			}
		}
		if (gameSaveData.ModuleSlots != null)
		{
			Diagnostics.Log("Restoring module slots");
			ModuleSlotSaveData[] moduleSlots = gameSaveData.ModuleSlots;
			for (int num10 = 0; num10 < moduleSlots.Length; num10++)
			{
				ModuleSlotSaveData moduleSlotSaveData = moduleSlots[num10];
				StaticString staticString = moduleSlotSaveData.SlotCategory;
				if (staticString == "MinorModuleSlot")
				{
					Diagnostics.LogWarning("Converting old format slot category! ({0})", staticString);
					staticString = 14.ToString();
				}
				else if (staticString == "MajorModuleSlot")
				{
					Diagnostics.LogWarning("Converting old format slot category! ({0})", staticString);
					staticString = 12.ToString();
				}
				ModuleSlot moduleSlot = UniqueIDManager.Get(staticString, moduleSlotSaveData.SlotID) as ModuleSlot;
				if (moduleSlot == null)
				{
					Diagnostics.LogError("Could not restore {0}#{1} minor module slot (not found)!", staticString, moduleSlotSaveData.SlotID);
					return false;
				}
				moduleSlot.DisplayDestroyedModule(moduleSlotSaveData.ModuleCategory, moduleSlotSaveData.ModuleConfigName, moduleSlotSaveData.ModuleLevel);
			}
		}
		if (gameSaveData.Artifacts != null)
		{
			Diagnostics.Log("Restoring artifacts");
			ArtifactSaveData[] artifacts = gameSaveData.Artifacts;
			for (int num11 = 0; num11 < artifacts.Length; num11++)
			{
				ArtifactSaveData artifactSaveData = artifacts[num11];
				Room room4 = UniqueIDManager.Get<Room>(artifactSaveData.RoomID);
				if (room4 == null)
				{
					Diagnostics.LogError("Could not restore artifact in room {0} (room not found)!", artifactSaveData.RoomID);
					return false;
				}
				room4.DoBuildMajorModule(serverPlayerID, SimulationProperties.SpecialModule_Artifact, instantBuild: true, restoration: true, consumeIndustryOnBuyer: false, artifactSaveData.Health, checkOwnershipForBuildComplete: false);
				if (room4.MajorModule == null)
				{
					Diagnostics.LogError("Could not restore artifact in room {0} (build denied)!", artifactSaveData.RoomID);
					return false;
				}
				Artifact artifact = (Artifact)room4.MajorModule;
				if (!string.IsNullOrEmpty(artifactSaveData.ResearchedBPName))
				{
					artifact.DoResearchBluePrint(artifactSaveData.ResearchedBPName, serverPlayerID, artifactSaveData.ResearchStartTurn, consumeScienceOnBuyer: false);
				}
			}
		}
		if (gameSaveData.Steles != null)
		{
			Diagnostics.Log("Restoring stele");
			Dictionary<StaticString, SteleTypeEventConfig> dictionary2 = gameConfig.SteleTypeEventConfigs.ToDictionary((SteleTypeEventConfig s) => s.Name, (SteleTypeEventConfig s) => s);
			SteleSaveData[] steles = gameSaveData.Steles;
			for (int num12 = 0; num12 < steles.Length; num12++)
			{
				SteleSaveData steleSaveData = steles[num12];
				Room room5 = UniqueIDManager.Get<Room>(steleSaveData.RoomID);
				if (room5 == null)
				{
					Diagnostics.LogError("Could not restore stele in room {0} (room not found)!", steleSaveData.RoomID);
					return false;
				}
				room5.DoBuildMajorModule(serverPlayerID, SimulationProperties.SpecialModule_Stele, instantBuild: true, restoration: true, consumeIndustryOnBuyer: false, steleSaveData.Health, checkOwnershipForBuildComplete: false);
				if (room5.MajorModule == null)
				{
					Diagnostics.LogError("Could not restore stele in room {0} (build denied)!", steleSaveData.RoomID);
					return false;
				}
				Stele stele = (Stele)room5.MajorModule;
				if (!string.IsNullOrEmpty(steleSaveData.SteleTypeName))
				{
					if (!dictionary2.ContainsKey(steleSaveData.SteleTypeName))
					{
						Diagnostics.Log("Cannot load stele type " + steleSaveData.SteleTypeName);
						return false;
					}
					stele.SetType(dictionary2[steleSaveData.SteleTypeName], netSync: false);
					if (flag)
					{
						stele.HealthCpnt.SetHealth(steleSaveData.Health, ignoreInvincibility: false, ignoreAlive: true);
					}
				}
			}
		}
		if (gameSaveData.RoomsCleanedFromModuleSlotsIDs != null)
		{
			Diagnostics.Log("Restoring rooms cleaned from module slots");
			int[] roomsCleanedFromModuleSlotsIDs = gameSaveData.RoomsCleanedFromModuleSlotsIDs;
			foreach (int num14 in roomsCleanedFromModuleSlotsIDs)
			{
				Room room6 = UniqueIDManager.Get<Room>(num14);
				if (room6 == null)
				{
					Diagnostics.LogError("Could not restore module slots destruction on room {0} (room not found)!", num14);
					return false;
				}
				room6.DestroyAllModuleSlots();
			}
		}
		if (gameSaveData.Merchants != null)
		{
			Diagnostics.Log("Restoring merchants");
			MerchantSaveData[] merchants = gameSaveData.Merchants;
			for (int num15 = 0; num15 < merchants.Length; num15++)
			{
				MerchantSaveData merchantSaveData = merchants[num15];
				Room room7 = UniqueIDManager.Get<Room>(merchantSaveData.ParentRoomID);
				if (room7 == null)
				{
					Diagnostics.LogError("Could not restore merchant in room {0} (room not found)!", merchantSaveData.ParentRoomID);
					return false;
				}
				NPCConfig value = Databases.GetDatabase<NPCConfig>().GetValue(merchantSaveData.ConfigName ?? "NPC_Merchant");
				GameObject nPCPrefab = GetNPCPrefab(value);
				GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(nPCPrefab, merchantSaveData.Position, Quaternion.identity);
				AddDynamicElementForScaling(gameObject.transform);
				NPCMerchant component = gameObject.GetComponent<NPCMerchant>();
				component.GiftCost = merchantSaveData.GiftCost;
				component.InitForSaveRestore(serverPlayerID, value, room7, merchantSaveData.CurrencyConfig, merchantSaveData.IsInShop);
				component.HealthCpnt.SetHealth(merchantSaveData.Health);
				InventoryItemData[] items = merchantSaveData.Items;
				foreach (InventoryItemData inventoryItemData3 in items)
				{
					InventoryItem.BuildInventoryItem(inventoryItemData3.ItemDescName, inventoryItemData3.RarityDescName, component.CurrentInventory, serverPlayerID, serverPlayerID == inventoryItemData3.OwnerPlayerID, inventoryItemData3.IsGift);
				}
			}
		}
		if (gameSaveData.LootItems != null)
		{
			Diagnostics.Log("Restoring {0} lootable items", gameSaveData.LootItems.Length);
			IDatabase<ItemConfig> database = Databases.GetDatabase<ItemConfig>();
			LootItemSaveData[] lootItems = gameSaveData.LootItems;
			for (int num17 = 0; num17 < lootItems.Length; num17++)
			{
				LootItemSaveData lootItemSaveData = lootItems[num17];
				Room room8 = UniqueIDManager.Get<Room>(lootItemSaveData.ParentRoomID);
				if (room8 == null)
				{
					Diagnostics.LogError("Could not restore lootable item in room {0} (room not found)!", lootItemSaveData.ParentRoomID);
					return false;
				}
				GameObject gameObject2 = (GameObject)UnityEngine.Object.Instantiate(GetItemPrefab(lootItemSaveData.Type), lootItemSaveData.Position, Quaternion.identity);
				AddDynamicElementForScaling(gameObject2.transform);
				Item component2 = gameObject2.GetComponent<Item>();
				if ((lootItemSaveData.Type == ItemType.ItemHero || lootItemSaveData.Type == ItemType.Chest) && lootItemSaveData.ChestItems != null && lootItemSaveData.ChestItems.Length > 0)
				{
					ItemHero itemHero = (ItemHero)component2;
					itemHero.ItemElements = new List<ItemHeroElement>();
					InventoryItemData[] chestItems = lootItemSaveData.ChestItems;
					foreach (InventoryItemData inventoryItemData4 in chestItems)
					{
						ItemHeroConfig itemHeroConfig = (ItemHeroConfig)database.GetValue(inventoryItemData4.ItemDescName);
						RarityConfig rarity = (!(inventoryItemData4.RarityDescName != null)) ? null : itemHeroConfig.GetRandomRarityParametersByName(inventoryItemData4.RarityDescName);
						itemHero.ItemElements.Add(new ItemHeroElement(itemHeroConfig, rarity));
					}
				}
				component2.Init(localPlayerID, lootItemSaveData.ItemName, null, room8, lootItemSaveData.Type);
			}
		}
		if (gameSaveData.DustLoots != null)
		{
			Diagnostics.Log("Restoring dust loots");
			DustLootSaveData[] dustLoots = gameSaveData.DustLoots;
			for (int num19 = 0; num19 < dustLoots.Length; num19++)
			{
				DustLootSaveData dustLootSaveData = dustLoots[num19];
				Room room9 = UniqueIDManager.Get<Room>(dustLootSaveData.ParentRoomID);
				if (room9 == null)
				{
					Diagnostics.LogError("Could not restore dust loot in room {0} (room not found)!", dustLootSaveData.ParentRoomID);
					return false;
				}
				SpawnDustLoot(dustLootSaveData.Amount, room9, dustLootSaveData.Position);
			}
		}
		if (gameSaveData.Exits != null)
		{
			Diagnostics.Log("Restoring exits");
			ExitSaveData[] exits = gameSaveData.Exits;
			for (int num20 = 0; num20 < exits.Length; num20++)
			{
				ExitSaveData exitSaveData = exits[num20];
				Room room10 = UniqueIDManager.Get<Room>(exitSaveData.RoomID);
				if (room10 == null)
				{
					Diagnostics.LogError("Could not restore exit in room {0} (room not found)!", exitSaveData.RoomID);
					return false;
				}
				room10.DoAddCrystalSlot(serverPlayerID, isExitSlot: true);
			}
		}
		if (gameSaveData.ProbabilityConfigOccurrenceCounts != null)
		{
			Diagnostics.Log("Restoring probability config occurence counts");
			ProbabilityConfig.ResetAllOccurrenceCounts();
			ProbabilityConfigOccurrenceCountData[] probabilityConfigOccurrenceCounts = gameSaveData.ProbabilityConfigOccurrenceCounts;
			for (int num21 = 0; num21 < probabilityConfigOccurrenceCounts.Length; num21++)
			{
				ProbabilityConfigOccurrenceCountData probabilityConfigOccurrenceCountData = probabilityConfigOccurrenceCounts[num21];
				ProbabilityConfig.SetOccurrenceCount(probabilityConfigOccurrenceCountData.TypeName, probabilityConfigOccurrenceCountData.Name, probabilityConfigOccurrenceCountData.Count);
			}
		}
		if (gameSaveData.MaxedProbabilityConfigPickedElementCounts != null)
		{
			MaxedProbabilityConfig.ResetAllPickedElementCounts();
			MaxedProbabilityConfigPickedElementCountData[] maxedProbabilityConfigPickedElementCounts = gameSaveData.MaxedProbabilityConfigPickedElementCounts;
			for (int num22 = 0; num22 < maxedProbabilityConfigPickedElementCounts.Length; num22++)
			{
				MaxedProbabilityConfigPickedElementCountData maxedProbabilityConfigPickedElementCountData = maxedProbabilityConfigPickedElementCounts[num22];
				MaxedProbabilityConfig.SetPickedElementCount(maxedProbabilityConfigPickedElementCountData.TypeName, maxedProbabilityConfigPickedElementCountData.Name, maxedProbabilityConfigPickedElementCountData.Count);
			}
		}
		if (gameSaveData.DynamicRoomEventCounts != null)
		{
			DynamicRoomEventCounts = new Dictionary<RoomEvent, int>();
			DynamicRoomEventCountData[] dynamicRoomEventCounts = gameSaveData.DynamicRoomEventCounts;
			for (int num23 = 0; num23 < dynamicRoomEventCounts.Length; num23++)
			{
				DynamicRoomEventCountData dynamicRoomEventCountData = dynamicRoomEventCounts[num23];
				DynamicRoomEventCounts.Add(dynamicRoomEventCountData.RoomEvent, dynamicRoomEventCountData.Count);
			}
		}
		if (gameSaveData.StoriesInProgress != null)
		{
			StoryDialogConfig[] values = Databases.GetDatabase<StoryDialogConfig>().GetValues();
			StorySaveData[] storiesInProgress = gameSaveData.StoriesInProgress;
			StorySaveData savedStory;
			for (int num24 = 0; num24 < storiesInProgress.Length; num24++)
			{
				savedStory = storiesInProgress[num24];
				StoryDialogConfig storyDialogConfig = values.FirstOrDefault((StoryDialogConfig s) => s.Name == savedStory.StoryName);
				if (storyDialogConfig != null)
				{
					storyDialogConfig.CurrentStepIndex = savedStory.StepIndex;
				}
			}
		}
		StoryDialogManager storyDialogManager = SingletonManager.Get<StoryDialogManager>();
		if (storyDialogManager != null)
		{
			storyDialogManager.LastStoryPlayed = gameSaveData.LastStoryPlayed;
		}
		if (gameSaveData.TempSimDescs != null)
		{
			Diagnostics.Log("Restoring temporary simulation descriptors");
			SimMonoBehaviour.RestoreTempSimDescs(gameSaveData.TempSimDescs);
		}
		if (OpenedRooms != null)
		{
			foreach (Room openedRoom in OpenedRooms)
			{
				openedRoom.ShowFog(!openedRoom.IsPowered && !openedRoom.IsOccupied());
			}
		}
		foreach (Hero localPlayerActiveRecruitedHero in Hero.LocalPlayerActiveRecruitedHeroes)
		{
			if (localPlayerActiveRecruitedHero.HasOperatingBonus && localPlayerActiveRecruitedHero.RoomElement != null && localPlayerActiveRecruitedHero.RoomElement.ParentRoom != null)
			{
				localPlayerActiveRecruitedHero.PreviousOperatedModule = localPlayerActiveRecruitedHero.RoomElement.ParentRoom.MajorModule;
			}
		}
		foreach (Hero remotePlayersActiveRecruitedHero in Hero.RemotePlayersActiveRecruitedHeroes)
		{
			if (remotePlayersActiveRecruitedHero.HasOperatingBonus && remotePlayersActiveRecruitedHero.RoomElement != null && remotePlayersActiveRecruitedHero.RoomElement.ParentRoom != null)
			{
				remotePlayersActiveRecruitedHero.PreviousOperatedModule = remotePlayersActiveRecruitedHero.RoomElement.ParentRoom.MajorModule;
			}
		}
		if (gameSaveData.HeroGroups != null)
		{
			gameControlManager.HeroGroups = gameSaveData.HeroGroups;
		}
		if (flag)
		{
			SingletonManager.Get<LogPanel>().SwitchDisplay(gameSaveData.ReducedLogPanel);
		}
		if (flag)
		{
			Diagnostics.Log("Restoring camera position");
			Services.GetService<IGameCameraService>().MoveTo(gameSaveData.CameraSupportPosition);
		}
		TotalMissedDoorCount = gameSaveData.TotalMissedDoorCount;
		ResetResearchesCount = gameSaveData.ResetResearchesCount;
		Diagnostics.Log("User save load success!");
		return true;
	}

	public DungeonGenerationSaveData GetLevelPersistentData()
	{
		Diagnostics.Log("Saving level persistent data");
		DungeonGenerationSaveData dungeonGenerationSaveData = new DungeonGenerationSaveData();
		ulong[] playerIDs = Player.GetPlayerIDs();
		dungeonGenerationSaveData.Players = new PlayerSaveData[playerIDs.Length];
		dungeonGenerationSaveData.DustStock = Mathf.Min(DustStock * GetSimPropertyValue(SimulationProperties.InitDustStockPctBonus), GetSimPropertyValue(SimulationProperties.InitDustStockBonusMax));
		for (int i = 0; i < playerIDs.Length; i++)
		{
			ulong num = playerIDs[i];
			Player playerByID = Player.GetPlayerByID(num);
			dungeonGenerationSaveData.Players[i] = new PlayerSaveData
			{
				ID = num,
				FoodStock = playerByID.FoodStock,
				IndustryStock = playerByID.IndustryStock,
				ScienceStock = playerByID.ScienceStock,
				IsStillConnected = playerByID.IsStillConnected()
			};
		}
		dungeonGenerationSaveData.StatisticsKeys = Statistics.Statistics.Keys.ToArray();
		dungeonGenerationSaveData.StatisticsValues = Statistics.Statistics.Values.ToArray();
		dungeonGenerationSaveData.ResetResearchesCount = ResetResearchesCount;
		List<BluePrintSaveData> list = new List<BluePrintSaveData>();
		foreach (List<BluePrintConfig> value in unlockedBPsByCategory.Values)
		{
			foreach (BluePrintConfig item4 in value)
			{
				BluePrintSaveData item = default(BluePrintSaveData);
				item.BluePrintName = item4.Name;
				list.Add(item);
			}
		}
		dungeonGenerationSaveData.UnlockedBluePrints = list.ToArray();
		dungeonGenerationSaveData.LockedBluePrints = lockedBluePrints.ToArray();
		dungeonGenerationSaveData.ResearchableBluePrints = new BluePrintSaveData[researchableBPByCategory.Keys.Count];
		int num2 = 0;
		foreach (BluePrintConfig value2 in researchableBPByCategory.Values)
		{
			BluePrintSaveData bluePrintSaveData = default(BluePrintSaveData);
			bluePrintSaveData.BluePrintName = value2.Name;
			dungeonGenerationSaveData.ResearchableBluePrints[num2++] = bluePrintSaveData;
		}
		List<InventoryItemData> list2 = new List<InventoryItemData>();
		foreach (InventoryItem item5 in BackpackInventory.Items)
		{
			InventoryItemData inventoryItemData = new InventoryItemData();
			inventoryItemData.ItemDescName = item5.ItemConfig.Name;
			inventoryItemData.RarityDescName = ((item5.RarityCfg == null) ? null : item5.RarityCfg.Name);
			inventoryItemData.OwnerPlayerID = item5.OwnerPlayerID;
			InventoryItemData item2 = inventoryItemData;
			list2.Add(item2);
		}
		dungeonGenerationSaveData.BackpackInventoryItems = list2.ToArray();
		List<HeroPersistentData> list3 = new List<HeroPersistentData>();
		List<Hero> list4 = new List<Hero>();
		list4.AddRange(Hero.LocalPlayerActiveRecruitedHeroes);
		list4.AddRange(Hero.RemotePlayersActiveRecruitedHeroes);
		foreach (Hero item6 in list4)
		{
			if (item6.WasInExitRoomAtExitTime)
			{
				HeroPersistentData item3 = default(HeroPersistentData);
				item3.OwnerPlayerID = item6.NetSyncElement.OwnerPlayerID;
				item3.HeroDescName = item6.GetSimDescriptorByType(SimulationProperties.SimDescTypeHero).Name;
				item3.Level = item6.Level;
				item3.UnlockLevel = item6.UnlockLevel;
				item3.HasOperatingBonus = item6.HasOperatingBonus;
				item3.FloorRecruited = item6.FloorRecruited;
				item3.IsStartingHero = item6.IsStartingHero;
				item3.PermanentDescriptors = item6.PermanentDescriptors.Select((SimulationDescriptor descriptor) => descriptor.Name).ToArray();
				item3.CurrentRespawnRoomCount = item6.CurrentRespawnRoomCount;
				List<HeroItemData> list5 = new List<HeroItemData>();
				EquipmentSlot[] equipmentSlots = item6.EquipmentSlots;
				foreach (EquipmentSlot equipmentSlot in equipmentSlots)
				{
					if (equipmentSlot.EquippedItem != null)
					{
						HeroItemData heroItemData = new HeroItemData();
						heroItemData.CategoryName = equipmentSlot.CategoryParameters.CategoryName;
						heroItemData.ItemDescName = equipmentSlot.EquippedItem.ItemConfig.Name;
						heroItemData.RarityDescName = ((equipmentSlot.EquippedItem.RarityCfg == null) ? null : equipmentSlot.EquippedItem.RarityCfg.Name);
						list5.Add(heroItemData);
					}
				}
				item3.Items = list5.ToArray();
				MobSaveData mobSaveData = new MobSaveData();
				if (item6.TamedMob != null && !item6.TamedMob.Config.Immobile && item6.TamedMob.HealthCpnt.IsAlive())
				{
					mobSaveData.SimDescName = item6.TamedMob.Config.Name;
					mobSaveData.Level = item6.TamedMob.TameLevel;
					mobSaveData.HealthValue = item6.TamedMob.HealthCpnt.GetHealth();
					mobSaveData.TameKillCount = item6.TamedMob.TameKillCount;
				}
				item3.TamedMobData = mobSaveData;
				list3.Add(item3);
			}
		}
		dungeonGenerationSaveData.HeroesPersistent = list3.ToArray();
		AssertDiscoverableHeroPoolIsInitialized();
		dungeonGenerationSaveData.HeroConfigNamePool = discoverableHeroPool.ToArray();
		if (LevelSelectedMobs != null)
		{
			dungeonGenerationSaveData.PreviousLevelSelectedMobNames = new StaticString[LevelSelectedMobs.Count];
			for (int k = 0; k < LevelSelectedMobs.Count; k++)
			{
				StaticString[] previousLevelSelectedMobNames = dungeonGenerationSaveData.PreviousLevelSelectedMobNames;
				int num3 = k;
				SelectedMob selectedMob = LevelSelectedMobs[k];
				previousLevelSelectedMobNames[num3] = selectedMob.MobCfg.Name;
			}
		}
		dungeonGenerationSaveData.TotalMissedDoorCount = TotalMissedDoorCount + Door.OpenableDoors.Count;
		dungeonGenerationSaveData.HeroGroups = gameControlManager.HeroGroups;
		StoryDialogManager storyDialogManager = SingletonManager.Get<StoryDialogManager>();
		if (storyDialogManager != null)
		{
			dungeonGenerationSaveData.LastStoryPlayed = storyDialogManager.LastStoryPlayed;
		}
		StoryDialogConfig[] array = (from story in Databases.GetDatabase<StoryDialogConfig>().GetValues()
			where story.CurrentStepIndex >= 0
			select story).ToArray();
		dungeonGenerationSaveData.StoriesInProgress = new StorySaveData[array.Length];
		for (int l = 0; l < array.Length; l++)
		{
			StorySaveData storySaveData = default(StorySaveData);
			storySaveData.StoryName = array[l].Name;
			storySaveData.StepIndex = array[l].CurrentStepIndex;
			dungeonGenerationSaveData.StoriesInProgress[l] = storySaveData;
		}
		dungeonGenerationSaveData.Level = Level;
		dungeonGenerationSaveData.ShipName = ShipName;
		dungeonGenerationSaveData.GameDifficulty = Difficulty;
		dungeonGenerationSaveData.Version = Amplitude.Unity.Framework.Application.Version;
		dungeonGenerationSaveData.SteamUserID = Steamworks.SteamAPI.SteamUser.SteamID;
		return dungeonGenerationSaveData;
	}

	private bool LoadLevelPersistentData(DungeonGenerationSaveData levelPersistentData)
	{
		Diagnostics.Log("Loading level persistent data");
		ulong localPlayerID = gameNetManager.GetLocalPlayerID();
		if (!gameNetManager.IsMultiplayerSession() || MultiplayerConfig.SplitFIS || gameNetManager.IsServerOrSinglePlayer())
		{
			for (int i = 0; i < levelPersistentData.Players.Length; i++)
			{
				ulong iD = levelPersistentData.Players[i].ID;
				if (iD == localPlayerID)
				{
					Player playerByID = Player.GetPlayerByID(iD);
					playerByID.AddFood(levelPersistentData.Players[i].FoodStock, displayFeedback: false, triggerDungeonFIDSChangedEvent: true, checkPlayerIsLocal: false);
					playerByID.AddIndustry(levelPersistentData.Players[i].IndustryStock, displayFeedback: false, triggerDungeonFIDSChangedEvent: true, checkPlayerIsLocal: false);
					playerByID.AddScience(levelPersistentData.Players[i].ScienceStock, displayFeedback: false, triggerDungeonFIDSChangedEvent: true, checkPlayerIsLocal: false);
				}
			}
			if (levelPersistentData.DustStock > 0f && gameNetManager.IsServerOrSinglePlayer())
			{
				AddDust(levelPersistentData.DustStock, displayFeedback: false, triggerDungeonFIDSChangedEvent: false);
				Diagnostics.Log("InitDustStockBonus = " + levelPersistentData.DustStock);
			}
		}
		Statistics.ImportStatistics(levelPersistentData.StatisticsKeys, levelPersistentData.StatisticsValues);
		BluePrintSaveData[] unlockedBluePrints = levelPersistentData.UnlockedBluePrints;
		for (int j = 0; j < unlockedBluePrints.Length; j++)
		{
			BluePrintSaveData bluePrintSaveData = unlockedBluePrints[j];
			UnlockBluePrintForSaveRestore(bluePrintSaveData.BluePrintName);
		}
		lockedBluePrints = levelPersistentData.LockedBluePrints.ToList();
		SetResearchableBluePrintsFromSave(levelPersistentData.ResearchableBluePrints);
		ResetResearchesCount = levelPersistentData.ResetResearchesCount;
		InventoryItemData[] backpackInventoryItems = levelPersistentData.BackpackInventoryItems;
		foreach (InventoryItemData inventoryItemData in backpackInventoryItems)
		{
			if (inventoryItemData.OwnerPlayerID == localPlayerID)
			{
				NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_BuildBackpackInventoryItem, inventoryItemData.ItemDescName, inventoryItemData.RarityDescName, gameNetManager.GetLocalPlayerID());
			}
		}
		HeroPersistentData[] heroesPersistent = levelPersistentData.HeroesPersistent;
		for (int l = 0; l < heroesPersistent.Length; l++)
		{
			HeroPersistentData heroPersistentData = heroesPersistent[l];
			if (heroPersistentData.OwnerPlayerID == localPlayerID)
			{
				NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_InstantiateLevelPersistentHero, heroPersistentData.OwnerPlayerID, heroPersistentData.HeroDescName, heroPersistentData.Level, heroPersistentData.UnlockLevel, heroPersistentData.HasOperatingBonus, StartRoom.UniqueID.ID, StartRoom.CenterPosition, heroPersistentData.Items, heroPersistentData.FloorRecruited, heroPersistentData.PermanentDescriptors, heroPersistentData.IsStartingHero, heroPersistentData.TamedMobData, heroPersistentData.CurrentRespawnRoomCount);
			}
		}
		discoverableHeroPool = levelPersistentData.HeroConfigNamePool.ToList();
		TotalMissedDoorCount = levelPersistentData.TotalMissedDoorCount;
		if (levelPersistentData.StoriesInProgress != null)
		{
			StoryDialogConfig[] values = Databases.GetDatabase<StoryDialogConfig>().GetValues();
			StorySaveData[] storiesInProgress = levelPersistentData.StoriesInProgress;
			StorySaveData savedStory;
			for (int m = 0; m < storiesInProgress.Length; m++)
			{
				savedStory = storiesInProgress[m];
				StoryDialogConfig storyDialogConfig = values.FirstOrDefault((StoryDialogConfig s) => s.Name == savedStory.StoryName);
				if (storyDialogConfig != null)
				{
					storyDialogConfig.CurrentStepIndex = savedStory.StepIndex;
				}
			}
		}
		StoryDialogManager storyDialogManager = SingletonManager.Get<StoryDialogManager>();
		if (storyDialogManager != null)
		{
			storyDialogManager.LastStoryPlayed = levelPersistentData.LastStoryPlayed;
		}
		if (levelPersistentData.HeroGroups != null)
		{
			gameControlManager.HeroGroups = levelPersistentData.HeroGroups;
		}
		Diagnostics.Log("Level persistant data load success!");
		return true;
	}

	private void RPC_BuildBackpackInventoryItem(StaticString itemCfgName, StaticString rarityCfgName, ulong buyerPlayerID)
	{
		InventoryItem.BuildInventoryItem(itemCfgName, rarityCfgName, BackpackInventory, buyerPlayerID);
	}

	private void RPC_InstantiateLevelPersistentHero(ulong ownerPlayerID, StaticString heroConfigName, int level, int unlockLevel, bool hasOperatingBonus, int spawnRoomID, Vector3 spawnPosition, HeroItemData[] items, int floorRecruited, StaticString[] permanentDescriptors, bool isStartingHero, MobSaveData tamedMobData, int currentRespawnRoomCount)
	{
		DoInstantiateSavedHero(ownerPlayerID, heroConfigName, level, unlockLevel, hasOperatingBonus, spawnRoomID, spawnPosition, items, isRecruited: true, floorRecruited, permanentDescriptors, isStartingHero, tamedMobData, currentRespawnRoomCount, recruitable: true);
	}

	private void RPC_InstantiateSavedHero(ulong ownerPlayerID, StaticString heroConfigName, int level, int unlockLevel, bool hasOperatingBonus, int spawnRoomID, Vector3 spawnPosition, HeroItemData[] items, bool isRecruited, int floorRecruited, StaticString[] permanentDescriptors, bool isStartingHero, HeroActiveSkillData[] activeSkills, float healthValue, float permanantHealthMalus, MobSaveData tamedMobData, int currentRespawnRoomCount, bool recruitable)
	{
		try
		{
			Hero hero = DoInstantiateSavedHero(ownerPlayerID, heroConfigName, level, unlockLevel, hasOperatingBonus, spawnRoomID, spawnPosition, items, isRecruited, floorRecruited, permanentDescriptors, isStartingHero, tamedMobData, currentRespawnRoomCount, recruitable);
			if (ownerPlayerID == gameNetManager.GetLocalPlayerID())
			{
				hero.HealthCpnt.PermanantHealthMalus = permanantHealthMalus;
				hero.HealthCpnt.SetHealth(healthValue);
				HeroActiveSkillData activeSkillData;
				for (int i = 0; i < activeSkills.Length; i++)
				{
					activeSkillData = activeSkills[i];
					hero.FilteredActiveSkills.First((ActiveSkill s) => s.Config.Name == activeSkillData.SkillName).LastActivityTurn = activeSkillData.LastActivityTurn;
				}
			}
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Dungeon.RPC_InstantiateSavedHero: exception raised {0}\n{1}", ex.Message, ex.StackTrace);
		}
	}

	private void RPC_InstantiateTamedMob(ulong ownerPlayerID, int tamerID, StaticString tamerCategory, StaticString mobClassName, Int2Position spawnPosition, int spawnRoomID, float health, int level, int tameKillCount)
	{
		try
		{
			Hero hero = (Hero)UniqueIDManager.Get(tamerCategory, tamerID);
			if (hero == null)
			{
				Diagnostics.LogError("RPC_InstantiateTamedMob: Can't find hero {0} of category {1}", tamerID, tamerCategory);
			}
			else
			{
				if (spawnRoomID == 0 && spawnPosition.x == 0 && spawnPosition.y == 0)
				{
					spawnRoomID = hero.RoomElement.ParentRoom.UniqueID.ID;
					spawnPosition = (Int2Position)hero.RoomElement.ParentRoom.CenterPosition;
				}
				Mob mob = DoInstantiateMob(ownerPlayerID, mobClassName, spawnPosition, spawnRoomID, string.Empty);
				if (mob != null)
				{
					hero.DoTameMob(mob);
					for (int i = 1; i < level; i++)
					{
						mob.TameLevelUp(saveRestore: true);
					}
					mob.TameKillCount = tameKillCount;
					mob.HealthCpnt.SetHealth(health);
				}
			}
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Exception raised while executing Dungeon.RPC_InstantiateTamedMob: {0}\n{1}", ex.Message, ex.StackTrace);
		}
	}

	private Hero DoInstantiateSavedHero(ulong ownerPlayerID, StaticString heroConfigName, int level, int unlockLevel, bool hasOperatingBonus, int spawnRoomID, Vector3 spawnPosition, HeroItemData[] items, bool isRecruited, int floorRecruited, StaticString[] permanentDescriptors, bool isStartingHero, MobSaveData tamedMobData, int currentRespawnRoomCount, bool recruitable)
	{
		Room spawnRoom = UniqueIDManager.Get<Room>(spawnRoomID);
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(heroPfb, spawnPosition, Quaternion.identity);
		AddDynamicElementForScaling(gameObject.transform);
		Hero component = gameObject.GetComponent<Hero>();
		Dictionary<StaticString, List<ItemPersistentData>> dictionary = new Dictionary<StaticString, List<ItemPersistentData>>();
		ItemPersistentData item = default(ItemPersistentData);
		foreach (HeroItemData heroItemData in items)
		{
			item.ItemDescName = heroItemData.ItemDescName;
			item.RarityDescName = heroItemData.RarityDescName;
			if (!dictionary.ContainsKey(heroItemData.CategoryName))
			{
				dictionary[heroItemData.CategoryName] = new List<ItemPersistentData>();
			}
			dictionary[heroItemData.CategoryName].Add(item);
		}
		component.InitForSaveRestore(ownerPlayerID, heroConfigName, spawnRoom, isRecruited, level, unlockLevel, hasOperatingBonus, dictionary, floorRecruited, permanentDescriptors, isStartingHero, currentRespawnRoomCount, recruitable);
		if (!string.IsNullOrEmpty(tamedMobData.SimDescName) && component.NetSyncElement.IsOwnedByLocalPlayer())
		{
			NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_InstantiateTamedMob, ownerPlayerID, component.UniqueID.ID, component.UniqueID.GetCategory(), tamedMobData.SimDescName, (Int2Position)tamedMobData.Position, tamedMobData.ParentRoomID, tamedMobData.HealthValue, tamedMobData.Level, tamedMobData.TameKillCount);
		}
		return component;
	}

	public SaveInfo GetCurrentAutoSaveInfo()
	{
		return UserProfile.Data.GetSaveInfo(gameNetManager.GetLobbyPlayerIDs(), gameNetManager.IsMultiplayerSession(), autoSave: true);
	}

	private void Start()
	{
		NetSyncElement = GetComponent<SingletonNetSyncElement>();
		DynamicRoomEventCounts = new Dictionary<RoomEvent, int>();
		mainGameScreen = SingletonManager.Get<MainGameScreen>();
		gameMenuPanel = SingletonManager.Get<GameMenuPanel>();
		endLevelPanel = SingletonManager.Get<EndLevelPanel>();
		gameOverPanel = SingletonManager.Get<GameOverPanel>();
		victoryPanel = SingletonManager.Get<VictoryPanel>();
		cameraDragSupport = SingletonManager.Get<CameraDragSupport>();
		requesterPanel = SingletonManager.Get<RequesterPanel>();
		chatPanelInGame = SingletonManager.Get<ChatPanelInGame>();
		achievementManager = SingletonManager.Get<AchievementManagerDOTE>();
		heroPanel = SingletonManager.Get<HeroPanel>();
		gameEventManager = Services.GetService<IGameEventService>();
		gameEventManager.OnGameStopped += OnGameStopped;
		guiService = Services.GetService<IGuiService>();
		gameCameraManager = Services.GetService<IGameCameraService>();
		gameResolutionManager = Services.GetService<IGameResolutionService>();
		gameControlManager = Services.GetService<IGameControlService>();
		inputManager = Services.GetService<IInputService>();
		if (inputManager.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			constructionPanel = SingletonManager.Get<ConstructionPanel>();
		}
		audioEventManager = Services.GetService<IAudioEventService>();
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
		steamDLCController = SingletonManager.Get<DLCController>();
		lift = SingletonManager.Get<Lift>();
		selectableManager = SingletonManager.Get<SelectableManager>();
		base.OnSimChildAdded += SimMB_OnSimChildAdded;
		generationParams = nextDungeonGenerationParams;
		Level = generationParams.Level;
		gameConfig = GameConfig.GetGameConfig();
		for (int i = 0; i < GameControlManager.HeroGroupCount; i++)
		{
			Control value = $"SelectHero{i}".ToEnum<Control>();
			selectHeroControlByIndex.Add(i, value);
		}
		if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			mainGameScreen.XboxRoomPowerIcon.Visible = true;
		}
	}

	public Inventory GetBestAvailableInventoryForPlayer(ulong playerID)
	{
		return Inventory.GetBestAvailableInventory(Inventories, playerID);
	}

	public void AssertDiscoverableHeroPoolIsInitialized()
	{
		if (discoverableHeroPool == null)
		{
			discoverableHeroPool = new List<StaticString>();
			HeroConfig[] values = Databases.GetDatabase<HeroConfig>().GetValues();
			HeroConfig[] array = values;
			foreach (HeroConfig heroConfig in array)
			{
				AddToDiscoverableHeroPool(heroConfig);
			}
		}
	}

	public void RegisterHeroSpawn(Hero hero, bool updateDiscoverableHeroPool = true)
	{
		HeroConfig heroConfig = hero.Config;
		if (updateDiscoverableHeroPool)
		{
			AssertDiscoverableHeroPoolIsInitialized();
			if (!heroConfig.IsHidden() && !discoverableHeroPool.Contains(heroConfig.Name))
			{
				Diagnostics.LogError(heroConfig.Name + " not in hero pool!");
				return;
			}
			discoverableHeroPool.Remove(heroConfig.Name);
		}
		int num = UserProfile.Data.HeroesGameStats.FindIndex((HeroGameStatsData h) => h.ConfigName == heroConfig.Name);
		if (num < 0)
		{
			Diagnostics.LogError(heroConfig.Name + " not found in game stats!");
		}
		if (hero.NetSyncElement.IsOwnedByLocalPlayer())
		{
			HeroGameStatsData value = UserProfile.Data.HeroesGameStats[num];
			if (value.Status == HeroStatus.Unknown)
			{
				Diagnostics.Log(value.ConfigName + " discovered!");
				value.Status = HeroStatus.Discovered;
				UserProfile.Data.HeroesGameStats[num] = value;
				UserProfile.SaveToFile();
			}
			if (value.Status != HeroStatus.Unlocked && !heroConfig.IsHidden() && hero.UnlockLevel == 0)
			{
				hero.UnlockLevel = Level + heroConfig.UnlockLevelCount;
				Diagnostics.Log("Start unlock UnlockLevel=" + hero.UnlockLevel);
			}
		}
	}

	public void RegisterHeroRecruitment(Hero hero)
	{
		IncrementHeroStat(hero, 1);
	}

	public void RegisterHeroDeath(Hero hero)
	{
		IncrementHeroStat(hero, 0, 1);
	}

	public void RegisterHeroVictory(Hero hero)
	{
		IncrementHeroStat(hero, 0, 0, 1);
	}

	private void IncrementHeroStat(Hero hero, int recruitCountInc = 0, int deathCountInc = 0, int victoryCountInc = 0)
	{
		HeroConfig heroConfig = hero.Config;
		int num = UserProfile.Data.HeroesGameStats.FindIndex((HeroGameStatsData h) => h.ConfigName == heroConfig.Name);
		if (num < 0)
		{
			Diagnostics.LogError("No game stats for " + heroConfig.Name + "!");
			return;
		}
		HeroGameStatsData value = UserProfile.Data.HeroesGameStats[num];
		if (value.Status != HeroStatus.Discovered && value.Status != HeroStatus.Unlocked && !heroConfig.IsHidden())
		{
			Diagnostics.LogError((string)heroConfig.Name + " not discovered (" + value.Status + ")!");
			return;
		}
		value.RecruitCount += recruitCountInc;
		value.DeathCount += deathCountInc;
		value.VictoryCount += victoryCountInc;
		UserProfile.Data.HeroesGameStats[num] = value;
		UserProfile.SaveToFile();
	}

	public List<StaticString> GetUnlockedHeroes()
	{
		if (steamDLCController == null)
		{
			steamDLCController = SingletonManager.Get<DLCController>();
		}
		List<StaticString> list = new List<StaticString>();
		IDatabase<HeroConfig> database = Databases.GetDatabase<HeroConfig>();
		for (int i = 0; i < UserProfile.Data.HeroesGameStats.Count; i++)
		{
			HeroGameStatsData heroGameStatsData = UserProfile.Data.HeroesGameStats[i];
			HeroConfig value = database.GetValue(heroGameStatsData.ConfigName);
			if (value != null && (heroGameStatsData.Status == HeroStatus.Unlocked || value.IsHidden()) && steamDLCController.IsObjectAvailable(DLCObjectType.Hero, heroGameStatsData.ConfigName))
			{
				list.Add(heroGameStatsData.ConfigName);
			}
		}
		return list;
	}

	private void RPC_EnqueueEventNotification(StaticString eventType, string eventTitle, string[] replaceTargets, string[] replaceContents)
	{
		string text = AgeLocalizer.Instance.LocalizeString(eventTitle);
		if (replaceTargets != null && replaceContents != null)
		{
			for (int i = 0; i < replaceTargets.Length; i++)
			{
				text = text.Replace(replaceTargets[i], replaceContents[i]);
			}
		}
		EnqueueEventNotification(eventType, text);
	}

	public void EnqueueEventNotification(RoomEvent roomEvent)
	{
		EnqueueEventNotification(roomEvent.ToString());
	}

	public void EnqueueEventNotification(StaticString eventName)
	{
		if (guiService.GuiPanelHelper.TryGetGuiElement(eventName, out cachedGUIElement))
		{
			EnqueueEventNotification(eventName, AgeLocalizer.Instance.LocalizeString(cachedGUIElement.Title));
		}
	}

	public void EnqueueEventNotification(StaticString eventType, string message)
	{
		SingletonManager.Get<LogPanel>().AddLog(message, NotificationType.Event, eventType);
	}

	public void EnqueueNotification(string message, NotificationClickHandler onClick = null, StaticString eventType = null, bool foreGround = false, string notificationInformation = null)
	{
		SingletonManager.Get<NotificationPanel>().EnqueueNotification(message, NotificationType.Message, onClick, foreGround, notificationInformation);
		SingletonManager.Get<LogPanel>().AddLog(message, NotificationType.Message, eventType);
	}

	public void EnqueueUnlockNotification(string message, NotificationType notificationType, NotificationClickHandler onClick = null, StaticString eventType = null, bool foreGround = false, string notificationInformation = null)
	{
		SingletonManager.Get<NotificationPanel>().EnqueueNotification(message, notificationType, onClick, foreGround, notificationInformation);
		SingletonManager.Get<LogPanel>().AddLog(message, notificationType, eventType);
		audioEventManager.Play2DEvent("Master/Jingles/Unlock");
	}

	public void EnqueueErrorNotification(string message)
	{
		Diagnostics.Log("EnqueueErrorNotification: message={0}", message);
		SingletonManager.Get<NotificationPanel>().EnqueueNotification(message, NotificationType.Error);
		SingletonManager.Get<LogPanel>().AddLog(message, NotificationType.Error, "Error");
	}

	public void EnqueueAlertNotification(string message, StaticString eventType = null, bool addToLog = true, NotificationClickHandler onClick = null)
	{
		SingletonManager.Get<NotificationPanel>().EnqueueNotification(message, NotificationType.Alert, onClick);
		if (addToLog)
		{
			SingletonManager.Get<LogPanel>().AddLog(message, NotificationType.Alert, eventType);
		}
	}

	public void EnqueueDialogNotification(string message, StaticString from)
	{
		SingletonManager.Get<LogPanel>().AddLog(message, NotificationType.Dialogue, from);
	}

	public void OnCrystalAttackedNotificationClick()
	{
		gameCameraManager.Focus(StartRoom.transform.position, LerpType.Smoothed, -1f);
	}

	public void CheckSituationDialog(SituationDialogType situation, Hero speaker)
	{
		if (gameNetManager == null || !gameNetManager.IsMultiplayerSession())
		{
			string text = situation.ToString();
			DialogueSituationConfig value = Databases.GetDatabase<DialogueSituationConfig>().GetValue(text);
			if (value == null)
			{
				Diagnostics.LogError("Dialogue situation " + text + " is unknown.");
			}
			else
			{
				value.CheckSituationDialog(speaker, heroDialogueDuration);
			}
		}
	}

	public StaticString PickRandomHeroFromDiscoverablePool()
	{
		AssertDiscoverableHeroPoolIsInitialized();
		if (discoverableHeroPool.Count < 1)
		{
			Diagnostics.LogWarning("No more unlocked hero available in pool");
			return null;
		}
		return discoverableHeroPool.GetRandom();
	}

	public void AddToDiscoverableHeroPool(HeroConfig heroConfig)
	{
		if (discoverableHeroPool.Contains(heroConfig.Name) || heroConfig.IsHidden())
		{
			return;
		}
		if (heroConfig.IsCommunityEventHero() && !heroConfig.IsCommunityEventActive())
		{
			HeroGameStatsData[] selectableHeroes = UserProfile.GetSelectableHeroes();
			bool flag = false;
			for (int i = 0; i < selectableHeroes.Length; i++)
			{
				if (selectableHeroes[i].ConfigName == heroConfig.Name)
				{
					flag = true;
					if (selectableHeroes[i].Status != HeroStatus.Unlocked)
					{
						return;
					}
				}
			}
			if (!flag)
			{
				return;
			}
		}
		if (steamDLCController == null)
		{
			steamDLCController = SingletonManager.Get<DLCController>();
		}
		StaticString name = heroConfig.Name;
		if (steamDLCController.IsObjectAvailable(DLCObjectType.Hero, name))
		{
			AssertDiscoverableHeroPoolIsInitialized();
			discoverableHeroPool.Add(name);
		}
	}

	private float GetNextExitWaveDelay()
	{
		return RandomGenerator.RangeFloat(gameConfig.ExitWaveDelayMin.GetValue(), gameConfig.ExitWaveDelayMax.GetValue());
	}

	public void OnCrystalUnplugged(bool spawnExitWaves = true)
	{
		if (spawnExitWaves)
		{
			this.spawnExitWaves = true;
			Invoke("SpawnExitMobWaves", GetNextExitWaveDelay());
		}
		ambiantLightCrystalPhaseAnim.Play("CrystalPhase");
		audioEventManager.Play2DEvent("Master/Environment/UnplugCrystal");
		IAudioLayeredMusicService service = Services.GetService<IAudioLayeredMusicService>();
		musicCrystalQuest = service.PlayLayeredMusic("MusicCrystalQuest", "MusicCrystalQuest", 1);
		if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			mainGameScreen.XboxRoomPowerIcon.Visible = false;
		}
		NotifyCrystalStateChanged(CrystalState.Unplugged);
		SingletonManager.Get<CrystalPanel>().Hide();
	}

	public void OnCrystalPlugged()
	{
		StopExitWaves();
		SingletonManager.Get<CrystalLiftPanel>().Hide();
		ambiantLightCrystalPhaseAnim.Play("Default");
		if (musicCrystalQuest != null)
		{
			IAudioLayeredMusicService service = Services.GetService<IAudioLayeredMusicService>();
			Diagnostics.Assert(service != null);
			service.StopMusic(musicCrystalQuest.Name);
		}
		NotifyCrystalStateChanged(CrystalState.PluggedOnExitSlot);
		gameEventManager.TriggerDungeonFIDSChangedEvent();
		SingletonManager.Get<AchievementManagerDOTE>().CancelInvoke("TriggerLastStandAchievement");
		if (victory)
		{
			OnVictorySequenceEnd();
		}
	}

	public Vector3 GetTileSize()
	{
		return tileSize;
	}

	public void AddOpenedRoom(Room room)
	{
		openedRooms.Add(room);
		AddSimChild(room);
	}

	public void NotifyRoomPowered(Room room, bool powered)
	{
		if (powered)
		{
			if (!room.IsStartRoom)
			{
				if (dustPoweredRooms.Contains(room))
				{
					Diagnostics.LogError("{0} room already in powered rooms register!", room.name);
				}
				else
				{
					dustPoweredRooms.Add(room);
				}
			}
		}
		else if (!dustPoweredRooms.Contains(room))
		{
			Diagnostics.LogError("{0} room not in powered rooms register!", room.name);
		}
		else
		{
			dustPoweredRooms.Remove(room);
		}
		if (this.OnRoomPowered != null)
		{
			this.OnRoomPowered(room, powered);
		}
	}

	public void IncrementTurn()
	{
		Turn++;
		gameEventManager.TriggerDungeonTurnChangedEvent();
	}

	public IEnumerator CreateDungeonAsync()
	{
		Diagnostics.Log("CreateDungeonAsync");
		gameCameraManager.ResetVisibleZone();
		gameCameraManager.SwitchToGameCamera();
		gameNetManager.ResetRPCAndLagMonitoring();
		gameNetManager.ResetCachedComponents();
		gameNetManager.ResetCachedAITargets();
		Diagnostics.Log("Set game difficulty and dungeon level");
		Level = generationParams.Level;
		Difficulty = generationParams.GameDifficulty;
		ShipName = generationParams.ShipName;
		switch (generationParams.GameType)
		{
		case GameType.UserSavedGame:
			DataFileManager.TryDeserializeData(generationParams.SavedGame_SaveDataSerial, GameSave.UserSaveMinSerial, out userSaveData, checkUserID: false);
			break;
		case GameType.AutoSavedGame:
			DataFileManager.TryDeserializeData(generationParams.SavedGame_SaveDataSerial, GameSave.AutoSaveMinSerial, out autoSaveData, checkUserID: false);
			if (Level == 1)
			{
				generationParams.NewGame_SelectedHeroes = new StaticString[autoSaveData.HeroesPersistent.Length];
				for (int i = 0; i < autoSaveData.HeroesPersistent.Length; i++)
				{
					generationParams.NewGame_SelectedHeroes[i] = autoSaveData.HeroesPersistent[i].HeroDescName;
				}
			}
			else
			{
				generationParams.NextLevel_LevelPersistentData = autoSaveData;
			}
			break;
		default:
		{
			ulong[] playerIDs = Player.GetPlayerIDs();
			DungeonGenerationSaveData levelStartData = new DungeonGenerationSaveData
			{
				Level = 0,
				ShipName = ShipName,
				GameDifficulty = Difficulty
			};
			if (generationParams.NewGame_SelectedHeroes != null)
			{
				levelStartData.HeroesPersistent = new HeroPersistentData[generationParams.NewGame_SelectedHeroes.Length];
				for (int slotIndex = 0; slotIndex < generationParams.NewGame_SelectedHeroes.Length; slotIndex++)
				{
					levelStartData.HeroesPersistent[slotIndex].OwnerPlayerID = gameNetManager.GetSlotPlayerID(slotIndex);
					levelStartData.HeroesPersistent[slotIndex].HeroDescName = generationParams.NewGame_SelectedHeroes[slotIndex];
				}
			}
			levelStartData.Players = new PlayerSaveData[playerIDs.Length];
			for (int j = 0; j < playerIDs.Length; j++)
			{
				levelStartData.Players[j].ID = playerIDs[j];
			}
			Diagnostics.Log("First level auto save");
			GameSave.WriteAutoSaveToFile(levelStartData, gameNetManager.GetLobbyPlayerIDs(), gameNetManager.IsMultiplayerSession(), gameNetManager.IsServerOrSinglePlayer());
			break;
		}
		case GameType.NextLevel:
			break;
		}
		Hero.RecentlyDeceasedHeroes.Clear();
		ShipConfig = Databases.GetDatabase<ShipConfig>().GetValue(ShipName);
		CrystalType = ShipConfig.CrystalType;
		Diagnostics.Log("Set ship config: " + ShipConfig.Name);
		powerPulseVFXPfb = ((!ShipConfig.UseAlternativePulseFX) ? powerPulseDefaultVFXPfb : powerPulseAlternativeVFXPfb);
		NPCMerchant.BuildAvailableItemHeroList();
		Diagnostics.Log("Adds level specific description modifiers");
		base.UniqueID.RequestUniqueID();
		SimulationDescriptor levelDesc = SimMonoBehaviour.GetDBDescriptorByName("Dungeon_Level" + Level);
		AddSimDescriptor(levelDesc ?? SimMonoBehaviour.GetDBDescriptorByName(SimulationProperties.SimDescLevelEndless), refresh: false);
		AddSimDescriptor(SimMonoBehaviour.GetDBDescriptorByName("Dungeon_Difficulty_" + Difficulty), refresh: false);
		ShipDesc = SimMonoBehaviour.GetDBDescriptorByName("Dungeon_Ship_" + ShipConfig.Name);
		if (ShipDesc != null)
		{
			AddSimDescriptor(ShipDesc, refresh: false);
		}
		RefreshSim();
		SharedInventory = new Inventory(Inventory.SharedInventoryName, this);
		BackpackInventory = new Inventory(Inventory.BackpackInventoryName, this, gameConfig.BackPackCapacity);
		Inventories = new Inventory[2]
		{
			BackpackInventory,
			SharedInventory
		};
		if (forcedPositiveEvents == null)
		{
			List<StaticString> positiveEvents = (from eventCfg in Databases.GetDatabase<EventConfig>().GetValues()
				where eventCfg.ForcedPositiveEvent
				select eventCfg.Name).ToList();
			forcedPositiveEvents = gameConfig.DynamicRoomEventConfigs.Where((DynamicRoomEventConfig eventCfg) => positiveEvents.Contains(eventCfg.Name)).ToArray();
		}
		Diagnostics.Log("Reset game stats");
		Statistics = new DungeonStatistics();
		DungeonGenerator2 dungeonGenerator = SingletonManager.Get<DungeonGenerator2>();
		yield return dungeonGenerator.GenerateDungeonUsingSeedCoroutine(Level, generationParams.GenerationSeed, ShipName);
		if (generationParams.GameType == GameType.UserSavedGame)
		{
			if (generationParams.PostGenerationSeed != 0 && dungeonGenerator.PostGenerationSeed != generationParams.PostGenerationSeed)
			{
				Diagnostics.LogError("Post generation seed different from save! ({0} / {1})", dungeonGenerator.PostGenerationSeed, generationParams.PostGenerationSeed);
				OnUserSaveLoadingFailed();
				yield break;
			}
		}
		else
		{
			Diagnostics.Log("Select level mobs");
			LevelSelectedMobs = new List<SelectedMob>();
			bool isNextLevelContext = generationParams.GameType == GameType.NextLevel || (generationParams.GameType == GameType.AutoSavedGame && generationParams.Level > 1);
			List<MobConfig> selectableMobConfigsPool;
			if (isNextLevelContext)
			{
				selectableMobConfigsPool = new List<MobConfig>();
				if (generationParams.NextLevel_LevelPersistentData != null && generationParams.NextLevel_LevelPersistentData.PreviousLevelSelectedMobNames != null)
				{
					for (int k = 0; k < generationParams.NextLevel_LevelPersistentData.PreviousLevelSelectedMobNames.Length; k++)
					{
						selectableMobConfigsPool.Add(gameConfig.FilteredMobConfigs.FirstOrDefault((MobConfig m) => m.Name == generationParams.NextLevel_LevelPersistentData.PreviousLevelSelectedMobNames[k]));
					}
				}
				int previousLevelMobCountTarget = RandomGenerator.RangeFloat(gameConfig.PreviousLevelMobClassCountMin.GetValue(), gameConfig.PreviousLevelMobClassCountMax.GetValue()).RoundHalfAwayFromZeroToInt();
				Diagnostics.Log("previousLevelMobCountTarget=" + previousLevelMobCountTarget);
				Diagnostics.Log("selectableMobConfigsPool.Count=" + selectableMobConfigsPool.Count);
				while (LevelSelectedMobs.Count < previousLevelMobCountTarget && selectableMobConfigsPool.Count > 0)
				{
					MobConfig mobCfg2 = selectableMobConfigsPool.GetWeightedRandom((MobConfig m) => m.SelectProbWeight.GetValue());
					if (mobCfg2 == null)
					{
						Diagnostics.LogError("Unable to select a mob from previous level!");
						break;
					}
					Diagnostics.Log("Select " + mobCfg2.Name + " mob from previous level");
					selectableMobConfigsPool.Remove(mobCfg2);
					LevelSelectedMobs.Add(new SelectedMob
					{
						MobCfg = mobCfg2
					});
				}
				if (LevelSelectedMobs.Count != previousLevelMobCountTarget)
				{
					Diagnostics.LogError("Couldn't select enough mob from previous level (selected = " + LevelSelectedMobs.Count + ", target = " + previousLevelMobCountTarget + ")!");
				}
				Diagnostics.Log("this.LevelSelectedMobConfigs.Count=" + LevelSelectedMobs.Count);
			}
			Diagnostics.Log("Select new mobs");
			selectableMobConfigsPool = gameConfig.FilteredMobConfigs.ToList();
			if (isNextLevelContext && generationParams.NextLevel_LevelPersistentData != null && generationParams.NextLevel_LevelPersistentData.PreviousLevelSelectedMobNames != null)
			{
				selectableMobConfigsPool.RemoveAll((MobConfig m) => generationParams.NextLevel_LevelPersistentData.PreviousLevelSelectedMobNames.Contains(m.Name));
			}
			int mobCountTarget = RandomGenerator.RangeFloat(gameConfig.LevelMobClassCountMin.GetValue(), gameConfig.LevelMobClassCountMax.GetValue()).RoundHalfAwayFromZeroToInt();
			Diagnostics.Log("mobCountTarget=" + mobCountTarget);
			Diagnostics.Log("selectableMobConfigsPool.Count=" + selectableMobConfigsPool.Count);
			while (LevelSelectedMobs.Count < mobCountTarget && selectableMobConfigsPool.Count > 0)
			{
				MobConfig mobCfg2 = selectableMobConfigsPool.GetWeightedRandom((MobConfig m) => m.SelectProbWeight.GetValue());
				if (mobCfg2 == null)
				{
					Diagnostics.LogError("Unable to select a mob for current level!");
					break;
				}
				Diagnostics.Log("Select " + mobCfg2.Name + " mob for current level");
				selectableMobConfigsPool.Remove(mobCfg2);
				LevelSelectedMobs.Add(new SelectedMob
				{
					MobCfg = mobCfg2,
					IsNew = true
				});
			}
			if (LevelSelectedMobs.Count != mobCountTarget)
			{
				Diagnostics.LogError("Couldn't select enough mob for current level (selected = " + LevelSelectedMobs.Count + ", target = " + mobCountTarget + ")!");
			}
			Diagnostics.Log("this.LevelSelectedMobConfigs.Count=" + LevelSelectedMobs.Count);
			achievementManager.SetStatisticValue(StatisticName.MODULES_BUILT_CURRENT_FLOOR, 0f);
		}
		Player.LocalPlayer.NetSyncElement.SendRPCToAll(UniqueIDRPC.Player_DungeonCreated);
	}

	public IEnumerator PreFillDungeonAsync()
	{
		Diagnostics.Log("PreFillDungeonAsync");
		Diagnostics.Log("Build crystal in start room");
		bool buildCrystal = false;
		if (!gameNetManager.IsMultiplayerSession() || MultiplayerConfig.OneCrystalPerPlayer || gameNetManager.IsServer())
		{
			StartRoom.AddCrystalSlot();
			StartRoom.BuildCrystal(instantBuild: true);
		}
		Player.LocalPlayer.NetSyncElement.SendRPCToAll(UniqueIDRPC.Player_DungeonPreFilled);
		yield break;
	}

	public IEnumerator FillDungeonAsync()
	{
		Diagnostics.Log("FillDungeonAsync");
		ulong localPlayerID = gameNetManager.GetLocalPlayerID();
		ulong serverPlayerID = gameNetManager.GetServerPlayerID();
		ulong[] playerIDs = gameNetManager.GetLobbyPlayerIDs();
		Diagnostics.Log("local=" + localPlayerID);
		Diagnostics.Log("server=" + serverPlayerID);
		Diagnostics.Log("players=" + string.Join(", ", playerIDs.Select((ulong p) => p.ToString()).ToArray()));
		bool isMultiplayerSession = gameNetManager.IsMultiplayerSession();
		Steamworks.SteamAPI.SteamFriends.SetRichPresence("status", AgeLocalizer.Instance.LocalizeString((!isMultiplayerSession) ? "%RichPresenceInSinglePlayerGame" : "%RichPresenceInMultiplayerGame"));
		if (isMultiplayerSession)
		{
			hostPlayerID = serverPlayerID;
		}
		Door.MultiDoorCount = 0;
		AchievementManagerDOTE achievementManager = SingletonManager.Get<AchievementManagerDOTE>();
		Diagnostics.Log("Reset crystal plugged on exit slot count");
		PluggedOnExitSlotCrystalCount = 0;
		if (generationParams.GameType == GameType.UserSavedGame)
		{
			Diagnostics.Log("Loading a saved game...");
			bool saveLoadSuccess = false;
			try
			{
				saveLoadSuccess = LoadSavedGame(userSaveData);
			}
			catch (Exception ex)
			{
				Exception e = ex;
				Diagnostics.LogError("Exception raised while loading user save: {0}\n{1}", e.Message, e.StackTrace);
			}
			if (!saveLoadSuccess)
			{
				Diagnostics.LogError("User save could not be loaded!");
				OnUserSaveLoadingFailed();
				yield break;
			}
		}
		else
		{
			Turn = 1;
			CurrentLevelDifficulty = 0f;
			ExitWaveNumber = 1;
			if (gameNetManager.IsServerOrSinglePlayer())
			{
				AddDust(GetSimPropertyValue(SimulationProperties.InitDustStock), displayFeedback: false, triggerDungeonFIDSChangedEvent: false);
			}
			if (Level > 1)
			{
				Diagnostics.Log("Starting next level");
				bool nextLevelLoaded = false;
				try
				{
					nextLevelLoaded = LoadLevelPersistentData(generationParams.NextLevel_LevelPersistentData);
				}
				catch (Exception ex2)
				{
					Exception e2 = ex2;
					Diagnostics.LogError("Exception raised while loading next level persistent data: {0}\n{1}", e2.Message, e2.StackTrace);
				}
				if (!nextLevelLoaded)
				{
					Diagnostics.LogError("Next level loading failed!");
					requesterPanel.Display(AgeLocalizer.Instance.LocalizeString("%NextLevelLoadingFailed"));
					gameControlManager.GoBackToMainMenu();
					yield break;
				}
			}
			else
			{
				Diagnostics.Log("Starting a new game");
				achievementManager.ResetVolatileStats();
				achievementManager.IncrementStatistic(("GAMES_ATTEMPTED_" + generationParams.GameDifficulty.ToString()).ToUpper().ToEnum<StatisticName>());
				GoogleAnalyticsManager analytics = SingletonManager.Get<GoogleAnalyticsManager>();
				if (analytics != null)
				{
					analytics.SendGameMetrics("New Game");
					analytics.SendMiscAnalytics();
				}
				Diagnostics.Log("Reset all occurence counts");
				ProbabilityConfig.ResetAllOccurrenceCounts();
				MaxedProbabilityConfig.ResetAllPickedElementCounts();
				Diagnostics.Log("Init FIDS stocks");
				Player.LocalPlayer.AddFood(GetSimPropertyValue(SimulationProperties.InitFoodStock));
				Player.LocalPlayer.AddIndustry(GetSimPropertyValue(SimulationProperties.InitIndustryStock));
				Player.LocalPlayer.AddScience(GetSimPropertyValue(SimulationProperties.InitScienceStock));
				Diagnostics.Log("Fill shared inventory");
				ShipConfig.ItemDatatableReference[] initialItems = ShipConfig.InitialItems;
				foreach (ShipConfig.ItemDatatableReference item in initialItems)
				{
					InventoryItem.BuildInventoryItem(item.Name, item.RarityName, SharedInventory, gameNetManager.GetServerPlayerID(), isCreatorOwner: false);
				}
				Diagnostics.Log("Instantiate heroes");
				int slotIndex = 0;
				int initHeroCount = (int)gameConfig.PlayerInitHeroCount.GetValue();
				HeroConfig[] heroConfigs = Databases.GetDatabase<HeroConfig>().GetValues();
				Dictionary<StaticString, float> unlockedHeroesRandomSelectWeights = new Dictionary<StaticString, float>();
				List<StaticString> unlockedHeroNames = GetUnlockedHeroes();
				foreach (StaticString heroName in unlockedHeroNames)
				{
					HeroConfig heroConfig = heroConfigs.First((HeroConfig c) => c.Name == heroName);
					if (heroConfig.IsHidden())
					{
						unlockedHeroesRandomSelectWeights.Add(heroName, heroConfig.GetRandomSelectionWeight() * (float)unlockedHeroNames.Count);
					}
					else
					{
						unlockedHeroesRandomSelectWeights.Add(heroName, 1f);
					}
				}
				int localPlayerSlotIndex = gameNetManager.GetPlayerSlotIndex(localPlayerID);
				int instantiatedHeroCount = 0;
				while (instantiatedHeroCount < initHeroCount && unlockedHeroesRandomSelectWeights.Count > 0)
				{
					if (gameNetManager.IsMultiplayerSession() && slotIndex != localPlayerSlotIndex)
					{
						slotIndex++;
						continue;
					}
					StaticString heroConfigName = (generationParams.NewGame_SelectedHeroes == null || slotIndex >= generationParams.NewGame_SelectedHeroes.Length) ? GameSelectionPanel.RandomHeroName : generationParams.NewGame_SelectedHeroes[slotIndex];
					if (!string.IsNullOrEmpty(heroConfigName) && heroConfigName != GameSelectionPanel.RandomHeroName)
					{
						Diagnostics.Log("Spawn selected hero " + heroConfigName);
						if (!unlockedHeroesRandomSelectWeights.Keys.Contains(heroConfigName))
						{
							Diagnostics.LogError(heroConfigName + " has not been unlocked! (shouldn't be selected)");
						}
						else
						{
							unlockedHeroesRandomSelectWeights.Remove(heroConfigName);
						}
					}
					else
					{
						if (isMultiplayerSession)
						{
							RandomGenerator.SaveSeed();
							RandomGenerator.SetSeed(RandomGenerator.Seed * (int)localPlayerID);
						}
						heroConfigName = unlockedHeroesRandomSelectWeights.GetWeightedRandom();
						unlockedHeroesRandomSelectWeights.Remove(heroConfigName);
						Diagnostics.Log("Spawn random hero " + heroConfigName);
						if (isMultiplayerSession)
						{
							RandomGenerator.RestoreSeed();
						}
					}
					int spawnIndex = slotIndex;
					NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_InstantiateGameStartHero, localPlayerID, heroConfigName, spawnIndex);
					instantiatedHeroCount++;
					slotIndex++;
				}
				BluePrintConfig[] bpConfigs = Databases.GetDatabase<BluePrintConfig>().GetValues();
				List<string> unavailableBPs = ShipConfig.FilteredUnavailableBluePrints.ToList();
				for (int j = 0; j < bpConfigs.Length; j++)
				{
					if (bpConfigs[j].ModuleCategory != ModuleCategory.SpecialModule && !lockedBluePrints.Contains(bpConfigs[j].ModuleName) && !unavailableBPs.Contains(bpConfigs[j].Name.ToString()))
					{
						lockedBluePrints.Add(bpConfigs[j].ModuleName);
					}
				}
				Diagnostics.Log("Add initial blueprints");
				string[] initBluePrints = ShipConfig.InitBluePrints;
				foreach (string initBluePrint in initBluePrints)
				{
					UnlockStartBluePrint(initBluePrint);
				}
				if (gameNetManager.IsServerOrSinglePlayer())
				{
					PickResearchableBluePrintsForAllCategories();
				}
				StoryDialogConfig[] stories = Databases.GetDatabase<StoryDialogConfig>().GetValues();
				StoryDialogConfig[] array = stories;
				foreach (StoryDialogConfig story in array)
				{
					story.CurrentStepIndex = -1;
				}
				StoryDialogManager storyManager = SingletonManager.Get<StoryDialogManager>();
				if (storyManager != null)
				{
					storyManager.LastStoryPlayed = string.Empty;
				}
			}
			Statistics.SetStat(DungeonStatistics.Stat_LostHeroesCurrentFloor);
			GameStartTime = Time.time;
		}
		if (ShipConfig.Name == "Drill")
		{
			this.achievementManager.SetStatisticValue(StatisticName.DRILL_LEVELS, Level);
		}
		RandomGenerator.WarnOnSeedAlteration = false;
		Diagnostics.Log("Initialize GUI");
		HeroListPanel heroListPanel = SingletonManager.Get<HeroListPanel>();
		heroListPanel.Load();
		heroListPanel.RefreshContent();
		SingletonManager.Get<HeroActiveSkillsPanel>().Load();
		Diagnostics.Log("Select first hero");
		if (generationParams.GameType != GameType.UserSavedGame && generationParams.GameType != GameType.AutoSavedGame && Hero.LocalPlayerActiveRecruitedHeroes.Count > 0)
		{
			Hero.LocalPlayerActiveRecruitedHeroes[0].Select();
		}
		Diagnostics.Log("Reset game camera");
		gameCameraManager.Unlock();
		gameCameraManager.Unzoom();
		if (generationParams.GameType != GameType.UserSavedGame && generationParams.GameType != GameType.AutoSavedGame)
		{
			gameCameraManager.MoveTo(10000f * Vector3.forward);
		}
		if (generationParams.GameType == GameType.UserSavedGame)
		{
			for (int i = 0; i < powerablePropsWaiting.Count; i++)
			{
				powerablePropsWaiting[i].Play();
			}
		}
		powerablePropsWaiting.Clear();
		previousPoweredPropPosition = Vector3.zero;
		IsStarted = true;
		UserProfile.CurrentGameIsNewHighscore = false;
		if (gameNetManager.IsServerOrSinglePlayer())
		{
			SaveInfo autoSaveInfo = GetCurrentAutoSaveInfo();
			if (autoSaveInfo != null && !autoSaveInfo.IsInGame)
			{
				Diagnostics.LogWarning("Marking user as in game for current auto save");
				autoSaveInfo.IsInGame = true;
				UserProfile.SaveToFile();
			}
		}
		Player.LocalPlayer.NetSyncElement.SendRPCToAll(UniqueIDRPC.Player_DungeonFilled);
	}

	private void OnUserSaveLoadingFailed()
	{
		requesterPanel.Display(AgeLocalizer.Instance.LocalizeString("%UserSaveLoadingFailed_RequestAutoSaveFallback"), delegate(RequesterPanel.Result result)
		{
			if (result == RequesterPanel.Result.Yes)
			{
				Diagnostics.LogWarning("Convert user save to auto save and reload...");
				SaveInfo saveInfo = GameSave.WriteAutoSaveToFile(userSaveData.ConvertToAutoSave(), gameNetManager.GetLobbyPlayerIDs(), gameNetManager.IsMultiplayerSession(), gameNetManager.IsServerOrSinglePlayer());
				GameSave.DeleteUserSave(gameNetManager.GetLobbyPlayerIDs(), gameNetManager.IsMultiplayerSession(), keepBackup: true, ".usload.ko");
				gameControlManager.StartSavedSinglePlayerGame(saveInfo.Key);
			}
			else
			{
				Diagnostics.LogWarning("Go back to main menu...");
				gameControlManager.GoBackToMainMenu();
			}
		}, RequesterPanel.ButtonsMode.YesNo);
	}

	public void DisplayGame()
	{
		Diagnostics.Log("Display game");
		selectableManager.SetCategory(SelectionCategory.RoomForMove);
		if (Hero.SelectedHeroes.Count == 0 && Hero.LocalPlayerActiveRecruitedHeroes.Count > 0)
		{
			Hero.LocalPlayerActiveRecruitedHeroes[0].Select();
		}
		if (generationParams.GameType != GameType.UserSavedGame || (gameNetManager.IsMultiplayerSession() && !gameNetManager.IsServer()))
		{
			if (Hero.SelectedHeroes.Count > 0)
			{
				gameCameraManager.MoveTo(Hero.SelectedHeroes[0].transform.position);
			}
			else
			{
				gameCameraManager.MoveTo(StartRoom.transform.position);
			}
		}
		gameCameraManager.ActivateCamera(on: true);
		gameCameraManager.AnchorSupport(dynamicContainer);
		Diagnostics.Log("Display game view");
		IViewService service = Services.GetService<IViewService>();
		Diagnostics.Assert(service != null);
		service.PostViewChange(typeof(GameView));
		Diagnostics.Log("Set SFX volume to 1");
		IAudioService service2 = Services.GetService<IAudioService>();
		Diagnostics.Assert(service2 != null);
		service2?.SetCategoryVolume("InGameSFX", 1f);
		Diagnostics.Log("Start background music");
		IAudioLayeredMusicService service3 = Services.GetService<IAudioLayeredMusicService>();
		Diagnostics.Assert(service3 != null);
		if (service3 != null)
		{
			while (!StaticString.IsNullOrEmpty(service3.CurrentLayeredMusicName) && service3.CurrentLayeredMusicName != "MusicDungeon")
			{
				service3.StopMusic(service3.CurrentLayeredMusicName);
			}
			if (service3.CurrentLayeredMusicName != "MusicDungeon")
			{
				service3.PlayLayeredMusic("MusicDungeon", "MusicDungeon", 5);
			}
			else
			{
				service3.NextLayeredMusicTrack("MusicDungeon", immediate: true);
			}
		}
		Diagnostics.Log("Start ambiance music");
		tilesetAmbianceSFX = audioEventManager.Play2DEvent(gameConfig.GetTilesetConfig().AmbianceSFXPath);
		Diagnostics.Log("Start power pulse routine");
		InvokeRepeating("PlayPowerPulse", powerPulsePeriod, powerPulsePeriod);
		Diagnostics.Log("Listen to pathfinding graph updates for cache cleaning");
		Mover.ListenToGraphsUpdates();
		Diagnostics.Log("Unpause game");
		gameControlManager.SetGamePause(paused: false);
		if (Level == 1)
		{
			Diagnostics.Log("Start tutorial");
			if (DungeonsApplication.Environment == BuildEnvironment.EXPO)
			{
				SingletonManager.Get<TutorialManager>().TriggerTutorial();
			}
			else if (!(Amplitude.Unity.Framework.Application.Registry.GetValue(registryTutorialAlreadyDisplayedKey) == "Y"))
			{
				SingletonManager.Get<TutorialManager>().TriggerTutorial(gameStartTutorialDelay);
				Amplitude.Unity.Framework.Application.Registry.SetValue(registryTutorialAlreadyDisplayedKey, "Y");
			}
		}
		Diagnostics.Log("Destroy user save");
		GameSave.DeleteUserSave(gameNetManager.GetLobbyPlayerIDs(), gameNetManager.IsMultiplayerSession());
		gameEventManager.TriggerGameStartedEvent();
		IsDisplayed = true;
	}

	private void RPC_InstantiateGameStartHero(ulong ownerPlayerID, StaticString heroConfigName, int spawnIndex)
	{
		RoomDefenseSpot[] componentsInChildren = StartRoom.GetComponentsInChildren<RoomDefenseSpot>();
		Vector3 position = StartRoom.CenterPosition;
		if (componentsInChildren.Length > spawnIndex)
		{
			position = componentsInChildren[spawnIndex].transform.position;
		}
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(heroPfb, position, Quaternion.identity);
		AddDynamicElementForScaling(gameObject.transform);
		Hero component = gameObject.GetComponent<Hero>();
		component.InitForGameStart(ownerPlayerID, heroConfigName, StartRoom);
	}

	private void RPC_OnCrystalPluggedOnExitSlot()
	{
		PluggedOnExitSlotCrystalCount++;
		if (gameNetManager.IsServerOrSinglePlayer())
		{
			int num = 0;
			num = ((!gameNetManager.IsMultiplayerSession()) ? 1 : ((!MultiplayerConfig.OneCrystalPerPlayer) ? 1 : gameNetManager.GetPlayerCount()));
			if (PluggedOnExitSlotCrystalCount > num)
			{
				Diagnostics.LogError("CrystalPluggedOnExitSlotCount (" + PluggedOnExitSlotCrystalCount + ") shouldn't be > " + num + "!");
			}
			else if (PluggedOnExitSlotCrystalCount == num)
			{
				LevelOver(victory: true);
			}
		}
	}

	public void LevelOver(bool victory = false)
	{
		if (IsLevelOver)
		{
			Diagnostics.LogWarning("Level is already over!");
		}
		else
		{
			NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_DoLevelOver, victory);
		}
	}

	private void RPC_DoLevelOver(bool victory = false)
	{
		if (IsLevelOver)
		{
			Diagnostics.LogError("Level is already over!");
			return;
		}
		this.victory = victory;
		HeroRecruitmentPanel heroRecruitmentPanel = SingletonManager.Get<HeroRecruitmentPanel>();
		if (heroRecruitmentPanel != null)
		{
			heroRecruitmentPanel.Hide();
		}
		SingletonManager.Get<MerchantPanel>().Hide(instant: true);
		for (int i = 0; i < Hero.LocalPlayerActiveRecruitedHeroes.Count; i++)
		{
			Hero hero = Hero.LocalPlayerActiveRecruitedHeroes[i];
			hero.WasInExitRoomAtExitTime = hero.RoomElement.ParentRoom.IsExitRoom;
			if (hero.WasInExitRoomAtExitTime)
			{
				Diagnostics.Log("{0} made it to the exit room \\o/", hero.LocalizedName);
			}
			else
			{
				Diagnostics.Log("{0} didn't make it to the exit room T_T", hero.LocalizedName);
			}
		}
		for (int j = 0; j < Hero.RemotePlayersActiveRecruitedHeroes.Count; j++)
		{
			Hero hero2 = Hero.RemotePlayersActiveRecruitedHeroes[j];
			hero2.WasInExitRoomAtExitTime = hero2.RoomElement.ParentRoom.IsExitRoom;
			if (hero2.WasInExitRoomAtExitTime)
			{
				Diagnostics.Log("{0} made it to the exit room \\o/", hero2.LocalizedName);
			}
			else
			{
				Diagnostics.Log("{0} didn't make it to the exit room T_T", hero2.LocalizedName);
			}
		}
		if (victory)
		{
			if (IsLastLevel())
			{
				GameSave.DeleteAutoSave(gameNetManager.GetLobbyPlayerIDs(), gameNetManager.IsMultiplayerSession());
			}
			else
			{
				Diagnostics.Log("Level end auto save");
				GameSave.WriteAutoSaveToFile(GetLevelPersistentData(), gameNetManager.GetLobbyPlayerIDs(), gameNetManager.IsMultiplayerSession(), gameNetManager.IsServerOrSinglePlayer());
			}
		}
		else
		{
			GameSave.DeleteAutoSave(gameNetManager.GetLobbyPlayerIDs(), gameNetManager.IsMultiplayerSession(), keepBackup: true);
		}
		StartCoroutine(DoLevelOverCoroutine());
	}

	private IEnumerator DoLevelOverCoroutine()
	{
		if (IsLevelOver)
		{
			Diagnostics.LogError("Level is already over!");
			yield break;
		}
		IsLevelOver = true;
		float levelTime = Time.time - GameStartTime;
		Statistics.SetStat(DungeonStatistics.Stat_LevelTime, levelTime);
		Statistics.IncrementStat(DungeonStatistics.Stat_GameTime, levelTime);
		StopExitWaves();
		if (Time.timeScale == 0f)
		{
			gameControlManager.SetGamePause(paused: false);
		}
		IAudioService audioService = Services.GetService<IAudioService>();
		Diagnostics.Assert(audioService != null);
		audioService?.SetCategoryVolume("InGameSFX", 0f, 1f);
		if (tilesetAmbianceSFX != null)
		{
			tilesetAmbianceSFX.stop();
		}
		if (victory)
		{
			Diagnostics.Assert(musicCrystalQuest != null, "musicCrystalQuest is null");
			if (musicCrystalQuest != null)
			{
				musicCrystalQuest.KeyOff();
				musicCrystalQuest = null;
			}
			Hero[] activeRecruitedHeroesCopy = Hero.LocalPlayerActiveRecruitedHeroes.ToArray();
			Hero heroCarryingCrystal = null;
			int heroCount = activeRecruitedHeroesCopy.Length;
			for (int heroIndex = 0; heroIndex < heroCount; heroIndex++)
			{
				Hero hero = activeRecruitedHeroesCopy[heroIndex];
				if (!hero.WasInExitRoomAtExitTime)
				{
					Hero.DeadHeroes.Add(hero);
					achievementManager.AddToStatistic(StatisticName.HERO_DEATH_NEGATIVE, -1f);
				}
				hero.HealthCpnt.IsInvincible = true;
				hero.AICpnt.IsActive = false;
				hero.MoverCpnt.StopMove();
				if (hero.HasCrystal)
				{
					heroCarryingCrystal = hero;
				}
				else
				{
					hero.MoverCpnt.CanMove = false;
				}
			}
			if (gameCameraManager.IsTacticalMapActive())
			{
				gameCameraManager.SwitchToGameCamera();
			}
			gameCameraManager.Focus(ExitRoom.CenterPosition, LerpType.Smoothed, -1f);
			if (heroCarryingCrystal != null)
			{
				heroCarryingCrystal.MoveToCrystalSlot(ExitRoom.CrystalModuleSlots[0]);
			}
		}
		else
		{
			bool multiplayer = SingletonManager.Get<GameNetworkManager>().IsMultiplayerSession();
			yield return new WaitForSeconds(gameOverScreenDisplayDelay);
			OnLevelEndDisplay();
			gameOverPanel.Show();
			UserProfile.AddHighScore(victory: false, !multiplayer);
		}
		GoogleAnalyticsManager analytics = SingletonManager.Get<GoogleAnalyticsManager>();
		if (analytics != null)
		{
			analytics.SendEndLevelMetrics();
			if (!victory)
			{
				analytics.SendGameOverMetrics("Game Over");
			}
		}
	}

	public void OnVictorySequenceEnd()
	{
		StartCoroutine(OnVictorySequenceEndCoroutine());
	}

	public bool IsLastLevel()
	{
		int levelCount = ShipConfig.LevelCount;
		return levelCount != -1 && Level == levelCount;
	}

	private IEnumerator OnVictorySequenceEndCoroutine()
	{
		bool multiplayer = SingletonManager.Get<GameNetworkManager>().IsMultiplayerSession();
		if (gameNetManager.IsServerOrSinglePlayer())
		{
			while (Mob.ActiveMobs.Count > 0)
			{
				Mob.ActiveMobs[0].HealthCpnt.Kill(checkOwnership: false);
			}
		}
		CheckVictoryAchievements();
		if (!IsLastLevel())
		{
			yield return new WaitForSeconds(vistoryScreenDisplayDelay);
			OnLevelEndDisplay();
			lift.Show();
			yield break;
		}
		CheckWinningGameAchievements();
		gameEventManager.TriggerGameVictoryEvent();
		yield return new WaitForSeconds(vistoryScreenDisplayDelay);
		if (tilesetAmbianceSFX != null)
		{
			audioEventManager.StopEvent(tilesetAmbianceSFX);
		}
		OnLevelEndDisplay();
		lift.Show();
		UserProfile.AddHighScore(victory: true, !multiplayer);
		GoogleAnalyticsManager analytics = SingletonManager.Get<GoogleAnalyticsManager>();
		if (analytics != null)
		{
			analytics.SendGameOverMetrics("Victory");
		}
	}

	public void StopExitWaves()
	{
		spawnExitWaves = false;
		if (IsInvoking("SpawnExitMobWaves"))
		{
			CancelInvoke("SpawnExitMobWaves");
		}
	}

	public void UpdateGamePhase()
	{
		if (Mob.ActiveMobs.Count < 1 && OpeningDoorCount < 1 && eventTriggeringCount < 1 && CurrentCrystalState == CrystalState.Plugged)
		{
			if (CurrentGamePhase != 0)
			{
				Diagnostics.Log("UpdateGamePhase > Strategy");
				CurrentGamePhase = GamePhase.Strategy;
				gameEventManager.TriggerGamePhaseChangedEvent();
				Door.MultiDoorCount = 0;
				if (shouldPlayEndTurnSFX)
				{
					audioEventManager.Play2DEvent("Master/Jingles/EndTurn");
				}
				shouldPlayEndTurnSFX = false;
			}
		}
		else
		{
			if (CurrentGamePhase != GamePhase.Action)
			{
				Diagnostics.Log("UpdateGamePhase > Action");
				CurrentGamePhase = GamePhase.Action;
				gameEventManager.TriggerGamePhaseChangedEvent();
			}
			if (!shouldPlayEndTurnSFX && Mob.ActiveMobs.Count >= 1)
			{
				shouldPlayEndTurnSFX = true;
			}
		}
	}

	public float GetSqrDistance(Vector3 a, Vector3 b)
	{
		return Mathf.Pow((b.x - a.x) / containerScale.x, 2f) + Mathf.Pow((b.z - a.z) / containerScale.z, 2f);
	}

	public float GetDistance(Vector3 a, Vector3 b)
	{
		return Mathf.Sqrt(GetSqrDistance(a, b));
	}

	public OffscreenMarker DisplayCrystalAndExitOffscreenMarkers(Transform exitTfm)
	{
		return DisplayOffscreenMarker(exitTfm.position, exitOffscreenMarkerData);
	}

	public void AssertElementsAreScaled()
	{
		if (!isContainerScaled)
		{
			staticContainer.localScale = containerScale;
			dynamicContainer.localScale = containerScale;
			isContainerScaled = true;
		}
	}

	public void AddStaticElementForScaling(Transform tfm, Transform parentTfm = null)
	{
		Vector3 localScale = tfm.localScale;
		tfm.parent = ((!(parentTfm != null)) ? staticContainer : parentTfm);
		if (isContainerScaled)
		{
			tfm.localScale = localScale;
		}
	}

	public void AddDynamicElementForScaling(Transform tfm, Transform parentTfm = null)
	{
		Vector3 localScale = tfm.localScale;
		tfm.parent = ((!(parentTfm != null)) ? dynamicContainer : parentTfm);
		if (isContainerScaled)
		{
			tfm.localScale = localScale;
		}
	}

	public void NotifyCrystalStateChanged(CrystalState state)
	{
		CurrentCrystalState = state;
		if (this.OnCrystalStateChanged != null)
		{
			this.OnCrystalStateChanged(state);
		}
		UpdateGamePhase();
	}

	public OffscreenMarker DisplayOffscreenMarker(Vector3 trackedPos, OffscreenMarker.OffscreenMarkerData markerData)
	{
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(offscreenMarkerPfb, Vector3.zero, Quaternion.identity);
		AddDynamicElementForScaling(gameObject.transform);
		OffscreenMarker component = gameObject.GetComponent<OffscreenMarker>();
		component.Init(trackedPos, markerData);
		return component;
	}

	public OffscreenMarker DisplayOffscreenMarker(Transform trackedTfm, OffscreenMarker.OffscreenMarkerData markerData)
	{
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(offscreenMarkerPfb, Vector3.zero, Quaternion.identity);
		AddDynamicElementForScaling(gameObject.transform);
		OffscreenMarker component = gameObject.GetComponent<OffscreenMarker>();
		component.Init(trackedTfm, markerData);
		return component;
	}

	public void UpdateCrystalTfm(Transform crystalTfm)
	{
		CrystalTfm = crystalTfm;
	}

	public float GetScore()
	{
		float num = 0f;
		if (Statistics != null)
		{
			num += gameConfig.OpenedDoorScore * Statistics.GetStat(DungeonStatistics.Stat_OpenedDoors);
			num += gameConfig.ActionOpenedDoorScore * Statistics.GetStat(DungeonStatistics.Stat_ActionOpenedDoors);
			num += gameConfig.GatheredFISScore * Statistics.GetStat(DungeonStatistics.Stat_GatheredFIS);
			num += gameConfig.KilledMobScore * Statistics.GetStat(DungeonStatistics.Stat_KilledMobs);
			num += gameConfig.LootedDustScore * Statistics.GetStat(DungeonStatistics.Stat_LootedDust);
			num += gameConfig.LostHeroScore * Statistics.GetStat(DungeonStatistics.Stat_LostHeroes);
			num += gameConfig.LeftOverFISScore * (Player.LocalPlayer.FoodStock + Player.LocalPlayer.IndustryStock + Player.LocalPlayer.ScienceStock);
			num *= GetSimPropertyValue(SimulationProperties.ScoreModifier);
		}
		return num;
	}

	public void SpawnDustLoot(float dustAmount, Room spawnRoom, Vector3 position)
	{
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(dustLootPfb, position, Quaternion.identity);
		AddDynamicElementForScaling(gameObject.transform);
		gameObject.GetComponent<MobDustLoot>().Init(dustAmount, spawnRoom);
	}

	private void OnLevelEndDisplay()
	{
		gameCameraManager.ActivateCamera(on: false);
		gameCameraManager.UnAnchorSupport();
		gameCameraManager.Unzoom();
		Time.timeScale = 1f;
		IsDisplayed = false;
	}

	private void PlayPowerPulse()
	{
		if (CurrentCrystalState == CrystalState.Plugged && RoomPowerVFX.VFXCount < maxPowerPulseVFXCount)
		{
			List<Room> list = new List<Room>(dustPoweredRooms);
			int num = Mathf.Min(maxPowerPulseVFXCount - RoomPowerVFX.VFXCount, list.Count);
			for (int i = 0; i < num; i++)
			{
				GameObjectPoolManager gameObjectPoolManager = SingletonManager.Get<GameObjectPoolManager>();
				GameObject gameObject = gameObjectPoolManager.Instantiate(powerPulseVFXPfb, StartRoom.CrystalModuleSlots.GetRandom().transform.position, Quaternion.identity);
				AddDynamicElementForScaling(gameObject.transform);
				RoomPowerVFX component = gameObject.GetComponent<RoomPowerVFX>();
				Room room = list.PullRandom();
				Vector3 destPos = (!(room.MajorModuleSlot != null)) ? ((room.MinorModuleSlots.Count <= 0) ? room.CenterPosition : room.MinorModuleSlots.GetRandom().transform.position) : room.MajorModuleSlot.transform.position;
				component.Init(destPos);
			}
		}
	}

	private void OnGameStopped(bool killAutoSave)
	{
		if (killAutoSave && gameNetManager.IsServerOrSinglePlayer())
		{
			SaveInfo currentAutoSaveInfo = GetCurrentAutoSaveInfo();
			if (currentAutoSaveInfo != null && currentAutoSaveInfo.IsInGame && IsStarted)
			{
				currentAutoSaveInfo.IsInGame = false;
				UserProfile.SaveToFile();
			}
		}
		if (tilesetAmbianceSFX != null)
		{
			tilesetAmbianceSFX.stop();
		}
	}

	protected virtual void OnApplicationQuit()
	{
		SaveInfo currentAutoSaveInfo = GetCurrentAutoSaveInfo();
		if (currentAutoSaveInfo != null && currentAutoSaveInfo.IsInGame)
		{
			Diagnostics.Log("Marking user as not in game anymore (application quit)");
			currentAutoSaveInfo.IsInGame = false;
			UserProfile.SaveToFile();
		}
	}

	private void OnDestroy()
	{
		if (gameEventManager != null)
		{
			gameEventManager.OnGameStopped -= OnGameStopped;
		}
		base.OnSimChildAdded -= SimMB_OnSimChildAdded;
	}

	private void CheckVictoryAchievements()
	{
		achievementManager.SetStatisticValue(StatisticName.BEST_FLOOR, Level);
		if (SingletonManager.Get<GameNetworkManager>().IsMultiplayerSession())
		{
			achievementManager.SetStatisticValue(StatisticName.MULTIPLAYER_BEST_FLOOR, Level);
		}
	}

	private void CheckWinningGameAchievements()
	{
		if (SingletonManager.Get<GameNetworkManager>().IsMultiplayerSession())
		{
			achievementManager.IncrementStatistic(StatisticName.MULTIPLAYER_VICTORIES);
		}
		achievementManager.IncrementStatistic(("VICTORY_" + Difficulty.ToString()).ToUpper().ToEnum<StatisticName>());
		achievementManager.IncrementStatistic(StatisticName.HERO_DEATH_NEGATIVE);
		achievementManager.IncrementStatistic(StatisticName.PAUSE_USES_NEGATIVE);
		achievementManager.IncrementStatistic(StatisticName.CRYSTAL_HITS_NEGATIVE);
		if (ShipConfig.Name == "Pod")
		{
			achievementManager.IncrementStatistic(StatisticName.RECRUITMENT_NEGATIVE);
		}
		List<Hero> levelWinningHeroes = Hero.GetLevelWinningHeroes();
		if (levelWinningHeroes.Count >= 3)
		{
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			for (int i = 0; i < levelWinningHeroes.Count; i++)
			{
				HeroConfig.HeroFaction faction = levelWinningHeroes[i].Config.Faction;
				flag |= (faction == HeroConfig.HeroFaction.Native);
				flag2 |= (faction == HeroConfig.HeroFaction.Guard);
				flag3 |= (faction == HeroConfig.HeroFaction.Prisoner);
				if (flag && flag2 && flag3)
				{
					achievementManager.IncrementStatistic(StatisticName.EVERY_FACTION_VICTORY);
					break;
				}
			}
			List<StaticString> list = levelWinningHeroes.Select((Hero hero) => hero.Config.Name).ToList();
			if (list.Contains("Hero_H0025") && list.Contains("Hero_H0026") && list.Contains("Hero_H0027"))
			{
				achievementManager.IncrementStatistic(StatisticName.RESCUE_TEAM_VICTORY);
			}
		}
		if (TotalMissedDoorCount + Door.OpenableDoors.Count == 0)
		{
			achievementManager.IncrementStatistic(StatisticName.EVERY_DOOR_VICTORY);
		}
		if (lockedBluePrints.Count == 0)
		{
			achievementManager.IncrementStatistic(StatisticName.RESEARCHED_ALL);
		}
		try
		{
			achievementManager.IncrementStatistic((ShipConfig.Name.ToString().ToUpper() + "_VICTORY").ToEnum<StatisticName>());
			foreach (Hero localPlayerActiveRecruitedHero in Hero.LocalPlayerActiveRecruitedHeroes)
			{
				achievementManager.IncrementStatistic((localPlayerActiveRecruitedHero.Config.Name.ToString().ToUpper() + "_VICTORY").ToEnum<StatisticName>());
			}
		}
		catch (ArgumentException ex)
		{
			Diagnostics.LogError("Something went wrong while setting end level auto achievements: " + ex.Message);
		}
		PrivateGameConfigManager privateGameConfigManager = SingletonManager.Get<PrivateGameConfigManager>();
		if (!privateGameConfigManager.IsCommunityEventActive(CommunityEvent.EndlessDay))
		{
			return;
		}
		int num = 0;
		while (true)
		{
			if (num < levelWinningHeroes.Count)
			{
				if (levelWinningHeroes[num].Config.Name == "Hero_H0020")
				{
					break;
				}
				num++;
				continue;
			}
			return;
		}
		achievementManager.IncrementStatistic(StatisticName.ENDLESSDAY_SPECIALHERO_VICTORY);
	}

	protected override void Update()
	{
		base.Update();
		CheckInputs();
		bool flag = hostPlayerID != 0;
		if (IsStarted && flag)
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			while (realtimeSinceStartup > nextHeartbeatTime)
			{
				NetSyncElement.SendUnreliableRPCToOthers(SingletonRPC.Dungeon_HeartBeat);
				nextHeartbeatTime = realtimeSinceStartup + mpHeartbeatPeriod;
			}
		}
	}

	private void RPC_HeartBeat()
	{
	}

	private void RPC_ShowVictoryPanel()
	{
		SingletonManager.Get<Ending>().Show();
	}

	private void OnDisable()
	{
		if (gameCameraManager != null)
		{
			gameCameraManager.UnAnchorSupport();
			gameCameraManager.ActivateCamera(on: false);
		}
	}

	public void AddPowerableProps(SpriteAnimationRuntime2[] props, Vector3 position)
	{
		for (int i = 0; i < props.Length; i++)
		{
			if (!props[i].IsPlaying && !powerablePropsWaiting.Contains(props[i]))
			{
				powerablePropsWaiting.Add(props[i]);
			}
		}
		if (position != Vector3.zero && previousPoweredPropPosition == Vector3.zero)
		{
			previousPoweredPropPosition = position;
		}
		if (powerablePropsWaiting.Count == props.Length)
		{
			PlayPowerableProp();
		}
	}

	private void PlayPowerableProp()
	{
		if (powerablePropsWaiting.Count > 0)
		{
			if (previousPoweredPropPosition == Vector3.zero)
			{
				previousPoweredPropPosition = StartRoom.CenterPosition;
			}
			powerablePropsWaiting = powerablePropsWaiting.OrderBy((SpriteAnimationRuntime2 prop) => Mathf.Abs(Vector3.Distance(prop.transform.position, previousPoweredPropPosition))).ToList();
			powerablePropsWaiting[0].MonitorAnimEvent("AnimEnd", PlayPowerableProp);
			powerablePropsWaiting[0].Play();
			previousPoweredPropPosition = powerablePropsWaiting[0].transform.position;
			powerablePropsWaiting.RemoveAt(0);
		}
		else
		{
			previousPoweredPropPosition = Vector3.zero;
		}
	}

	public static void SetNewGenerationSeed()
	{
		nextDungeonGenerationParams.GenerationSeed = RandomGenerator.Seed;
	}

	public static void SetGameDifficulty(GameDifficulty gameDifficulty)
	{
		nextDungeonGenerationParams.GameDifficulty = gameDifficulty;
	}

	public static void SetSelectedHeroes(StaticString[] selectedHeroes)
	{
		nextDungeonGenerationParams.NewGame_SelectedHeroes = selectedHeroes;
	}

	public static void SetShip(StaticString shipName)
	{
		nextDungeonGenerationParams.ShipName = shipName;
	}

	public static void SetGenerationParams(DungeonGenerationParams genParams)
	{
		nextDungeonGenerationParams.GameType = genParams.GameType;
		nextDungeonGenerationParams.GameDifficulty = genParams.GameDifficulty;
		nextDungeonGenerationParams.Level = genParams.Level;
		nextDungeonGenerationParams.ShipName = genParams.ShipName;
		nextDungeonGenerationParams.GenerationSeed = genParams.GenerationSeed;
		nextDungeonGenerationParams.PostGenerationSeed = genParams.PostGenerationSeed;
		nextDungeonGenerationParams.SavedGame_SaveDataSerial = genParams.SavedGame_SaveDataSerial;
	}

	public static void PrepareForNewGame(bool multiplayer)
	{
		Diagnostics.Log("PrepareForNewGame");
		nextDungeonGenerationParams.GameType = GameType.NewGame;
		nextDungeonGenerationParams.Level = 1;
		SetNewGenerationSeed();
	}

	public static void PrepareForNextLevel()
	{
		Diagnostics.Log("PrepareForNextLevel");
		nextDungeonGenerationParams.GameType = GameType.NextLevel;
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		nextDungeonGenerationParams.Level = dungeon.Level + 1;
		nextDungeonGenerationParams.GameDifficulty = dungeon.Difficulty;
		nextDungeonGenerationParams.NextLevel_LevelPersistentData = dungeon.GetLevelPersistentData();
		SetNewGenerationSeed();
	}

	public static void PrepareForLevelX(int level)
	{
		Diagnostics.Log("PrepareForLevelX: level=" + level);
		nextDungeonGenerationParams.GameType = GameType.NextLevel;
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		nextDungeonGenerationParams.Level = level;
		nextDungeonGenerationParams.GameDifficulty = dungeon.Difficulty;
		nextDungeonGenerationParams.NextLevel_LevelPersistentData = dungeon.GetLevelPersistentData();
		SetNewGenerationSeed();
	}

	public static void PrepareForSavedGame(string saveKey, bool multiplayer)
	{
		Diagnostics.Log("PrepareForSavedGame");
		nextDungeonGenerationParams.GameType = GameType.UserSavedGame;
		if (saveKey != null)
		{
			DungeonGenerationSaveData bestSaveData = GameSave.GetBestSaveData(saveKey, multiplayer);
			nextDungeonGenerationParams.GameDifficulty = bestSaveData.GameDifficulty;
			nextDungeonGenerationParams.ShipName = bestSaveData.ShipName;
			if (bestSaveData is GameSaveData)
			{
				nextDungeonGenerationParams.GameType = GameType.UserSavedGame;
				nextDungeonGenerationParams.SavedGame_SaveDataSerial = DataFileManager.SerializeData(bestSaveData as GameSaveData);
				GameSaveData gameSaveData = bestSaveData as GameSaveData;
				nextDungeonGenerationParams.GenerationSeed = gameSaveData.DungeonGeneratorRandomSeed;
				nextDungeonGenerationParams.PostGenerationSeed = gameSaveData.DungeonPostGenerationRandomSeed;
				nextDungeonGenerationParams.Level = gameSaveData.Level;
			}
			else
			{
				nextDungeonGenerationParams.GameType = GameType.AutoSavedGame;
				nextDungeonGenerationParams.SavedGame_SaveDataSerial = DataFileManager.SerializeData(bestSaveData);
				nextDungeonGenerationParams.Level = bestSaveData.Level + 1;
				SetNewGenerationSeed();
			}
		}
	}

	private static void SetGameModePresenceString(bool multiplayer)
	{
		Services.GetService<IXboxEventService>().SetPresenceString((!multiplayer) ? "SPPresenceString" : "MPPresenceString", null);
	}
}
public enum MobSpawnType
{
	Room,
	Wave,
	ExitWave
}
public enum EventCombination
{
	None,
	DungeonEventOnly,
	RoomEventOnly,
	DungeonAndRoomEvent
}
public enum DungeonEvent
{
	None,
	MobWaves
}
public enum RoomEvent
{
	None,
	Mobs,
	Item,
	Hero,
	Merchant,
	Exit,
	Artifact,
	Stele,
	DustFactory,
	CryoCapsule,
	ToxicCloud,
	AutoPower,
	EMP,
	DeathMerchant,
	CheatsNone
}
public struct SelectedMob
{
	public MobConfig MobCfg;

	public bool IsNew;
}
public enum CrystalState
{
	Plugged,
	Unplugged,
	PluggedOnExitSlot
}
public enum GamePhase
{
	Strategy,
	Action
}
public enum GameDifficulty
{
	Easy,
	Normal
}
public enum GameType
{
	NewGame,
	NextLevel,
	UserSavedGame,
	AutoSavedGame
}
public enum SituationDialogType
{
	OpenDoor,
	RepairModule,
	RemoveCrystal,
	Wounded
}
public struct DungeonGenerationParams
{
	public GameType GameType;

	public GameDifficulty GameDifficulty;

	public int Level;

	public StaticString ShipName;

	public int GenerationSeed;

	public int PostGenerationSeed;

	public StaticString[] NewGame_SelectedHeroes;

	public DungeonGenerationSaveData NextLevel_LevelPersistentData;

	public string SavedGame_SaveDataSerial;
}
public class EndingCrystal : EndingEntity
{
	public override void BindAndShow(string entityName)
	{
		base.SpriteAnimation.OverrideClipsFromPath("SpriteAnimations/Modules/" + SimulationProperties.SpecialModule_Crystal + "_" + entityName + "/LVL1");
		base.BindAndShow(entityName);
	}
}
public class EndingEntity : MonoBehaviour
{
	[SerializeField]
	protected EndingEntityAnimData[] animDatas;

	[SerializeField]
	protected string forcedEntityName;

	protected SpriteRendererToLightManager spriteRendererToLightManager;

	protected bool doUpdate;

	protected int currentAnimIndex;

	protected float currentTimer;

	public SpriteAnimationRuntime2 SpriteAnimation
	{
		get;
		private set;
	}

	public string EntityName
	{
		get;
		private set;
	}

	private void Awake()
	{
		SpriteAnimation = GetComponent<SpriteAnimationRuntime2>();
		spriteRendererToLightManager = GetComponent<SpriteRendererToLightManager>();
	}

	public virtual void BindAndShow(string entityName)
	{
		EntityName = entityName;
		SpriteAnimation.Play();
		if (spriteRendererToLightManager != null)
		{
			spriteRendererToLightManager.enabled = true;
		}
		doUpdate = true;
		currentAnimIndex = -1;
		currentTimer = 0f;
	}

	private void Update()
	{
		if (!doUpdate)
		{
			return;
		}
		currentTimer -= Time.deltaTime;
		if (currentTimer <= 0f)
		{
			if (currentAnimIndex >= animDatas.Length - 1)
			{
				doUpdate = false;
				OnAnimSequenceOver();
				return;
			}
			currentAnimIndex++;
			EndingEntityAnimData endingEntityAnimData = animDatas[currentAnimIndex];
			SpriteAnimation.SetBool(SpriteAnimationBool.IsMoving, endingEntityAnimData.IsMoving);
			SpriteAnimation.SetAnimDirection(endingEntityAnimData.AnimDirection);
			SpriteAnimation.SetSpeed(endingEntityAnimData.AnimSpeed);
			currentTimer = endingEntityAnimData.Duration;
		}
		base.transform.position += animDatas[currentAnimIndex].Movement * Time.deltaTime;
	}

	protected virtual void OnAnimSequenceOver()
	{
	}
}
[Serializable]
public struct EndingEntityAnimData
{
	public bool IsMoving;

	public Vector3 AnimDirection;

	public float Duration;

	public Vector3 Movement;

	public float AnimSpeed;
}
public class EndingHero : EndingEntity
{
	public override void BindAndShow(string heroName)
	{
		base.SpriteAnimation.OverrideClipsFromPath("SpriteAnimations/Hero/" + heroName.Replace("Hero_", string.Empty));
		base.BindAndShow(heroName);
	}

	protected override void OnAnimSequenceOver()
	{
		base.OnAnimSequenceOver();
		SingletonManager.Get<Ending>().Terminate();
	}
}
public class Energy : Health
{
	private MinorModule minorModule;

	protected override void Awake()
	{
		base.Awake();
		minorModule = GetComponent<MinorModule>();
		healthBar = GetComponent<EnergyBarDisplayer>();
	}

	public override float GetMaxHealth()
	{
		return base.SimMB.GetSimPropertyValue(SimulationProperties.LureMaxEnergy);
	}

	protected override void Death(ulong attackerOwnerPlayerID = 0)
	{
		DoSetHealthValue(0f);
		minorModule.SwitchLureMode(activate: false);
	}

	protected override bool ShouldInstantRegen(float healthRegen)
	{
		return (dungeon.CurrentGamePhase == GamePhase.Strategy && (roomElement == null || roomElement.ParentRoom.IsPowered)) || base.ShouldInstantRegen(healthRegen);
	}
}
public class FloorTile : MonoBehaviour
{
	[SerializeField]
	private GameObject dustLootPfb;

	private Room parentRoom;

	public float Width
	{
		get;
		private set;
	}

	public float Height
	{
		get;
		private set;
	}

	public bool IsDoorFloor
	{
		get;
		set;
	}

	public bool IsVisible
	{
		get;
		set;
	}

	public void Init(Room parentRoom)
	{
		this.parentRoom = parentRoom;
		Vector3 tileSize = SingletonManager.Get<Dungeon>().GetTileSize();
		Vector3 forward = base.transform.forward;
		if (Mathf.Abs(forward.x) > 0.9f)
		{
			Vector3 localScale = base.transform.localScale;
			Width = Mathf.Abs(localScale.z) / tileSize.x;
		}
		else
		{
			Vector3 right = base.transform.right;
			if (Mathf.Abs(right.x) > 0.9f)
			{
				Vector3 localScale2 = base.transform.localScale;
				Width = Mathf.Abs(localScale2.x) / tileSize.x;
			}
			else
			{
				Vector3 localScale3 = base.transform.localScale;
				Width = Mathf.Abs(localScale3.y) / tileSize.x;
			}
		}
		Vector3 forward2 = base.transform.forward;
		if (Mathf.Abs(forward2.z) > 0.9f)
		{
			Vector3 localScale4 = base.transform.localScale;
			Height = Mathf.Abs(localScale4.z) / tileSize.z;
			return;
		}
		Vector3 right2 = base.transform.right;
		if (Mathf.Abs(right2.z) > 0.9f)
		{
			Vector3 localScale5 = base.transform.localScale;
			Height = Mathf.Abs(localScale5.x) / tileSize.z;
		}
		else
		{
			Vector3 localScale6 = base.transform.localScale;
			Height = Mathf.Abs(localScale6.y) / tileSize.z;
		}
	}

	public void PlayDustLootVFX(int dustLootAmount, Vector3 targetPosition)
	{
		Vector3 tileSize = SingletonManager.Get<Dungeon>().GetTileSize();
		for (float num = (0f - (Width - 1f)) / 2f; num <= (Width - 1f) / 2f; num += 1f)
		{
			for (float num2 = (0f - (Height - 1f)) / 2f; num2 <= (Height - 1f) / 2f; num2 += 1f)
			{
				GameObjectPoolManager gameObjectPoolManager = SingletonManager.Get<GameObjectPoolManager>();
				GameObject gameObject = gameObjectPoolManager.Instantiate(dustLootPfb, base.transform.position + num * Vector3.right * tileSize.z + num2 * Vector3.forward * tileSize.z, base.transform.rotation, base.transform);
				RoomDustLootVFX component = gameObject.GetComponent<RoomDustLootVFX>();
				component.Init(dustLootAmount, targetPosition);
			}
		}
	}

	private void Awake()
	{
		IsDoorFloor = false;
	}

	private void OnLeftClickUp(ClickUpInfo clickInfo)
	{
		if (!clickInfo.Dragged)
		{
			string constructionBPName = Services.GetService<IGameControlService>().ConstructionBPName;
			if (constructionBPName != null && !AgeManager.IsMouseCovered)
			{
				ulong localPlayerID = SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID();
				parentRoom.BuildModuleAtPosition(constructionBPName, clickInfo.ClickDownInfo.WorldPosition, localPlayerID, instantBuild: false, restoration: false, checkRoomPower: true, consumeIndustry: true, -1f);
			}
		}
	}
}
public class FogOfWarZone : MonoBehaviour
{
	[SerializeField]
	private GameObject fogParticulesPfb;

	[SerializeField]
	private Vector2 fogSizeCoefficient;

	[SerializeField]
	private Vector2 fogSizeMin;

	[SerializeField]
	private Vector2 fogSizeMax;

	[SerializeField]
	private float fogDensityCoefficient;

	private Room room;

	private ParticleSystem fogParticles;

	public bool DefaultSize;

	public void Start()
	{
		room = GetComponentInParent<Room>();
		fogParticles = (UnityEngine.Object.Instantiate(fogParticulesPfb, base.transform.position, Quaternion.identity) as GameObject).GetComponent<ParticleSystem>();
		if (fogParticles == null)
		{
			Diagnostics.LogError("Fog of war particles prefab of room " + room.name + " has no ParticleSystem component.");
			return;
		}
		BoxCollider boxCollider = GetComponent<Collider>() as BoxCollider;
		fogParticles.transform.parent = base.transform;
		fogParticles.transform.rotation = fogParticulesPfb.transform.rotation;
		fogParticles.transform.localPosition = boxCollider.center + fogParticulesPfb.transform.localPosition;
		Vector3 size = boxCollider.size;
		float num = size.x * size.x * fogSizeCoefficient.x / 1000f;
		float num2 = size.z * size.z * fogSizeCoefficient.y / 1000f;
		if (DefaultSize)
		{
			num = Mathf.Min(fogSizeMax.x, Mathf.Max(fogSizeMin.x, num));
			num2 = Mathf.Min(fogSizeMax.y, Mathf.Max(fogSizeMin.y, num2));
		}
		if (size.x >= 250f)
		{
			num *= 0.9f;
		}
		if (size.y >= 250f)
		{
			num2 *= 0.9f;
		}
		Transform transform = fogParticles.transform;
		float x = num;
		float y = num2;
		Vector3 localScale = fogParticles.transform.localScale;
		transform.localScale = new Vector3(x, y, localScale.z);
		fogParticles.emissionRate = size.x * size.z * fogDensityCoefficient / 1000f;
		UnityEngine.Object.Destroy(boxCollider);
	}

	public void StopParticules(bool withChildren = true)
	{
		fogParticles.Stop(withChildren);
	}

	public void PlayParticules(bool withChildren = true)
	{
		fogParticles.Play(withChildren);
	}
}
public class GoogleAnalyticsManager : Analytics
{
	public bool OnlyInPublicEnv;

	private Dictionary<StaticString, int> modulesBuiltThisFloor;

	public bool SentUnlockAnalytics
	{
		get;
		private set;
	}

	public bool SentMiscAnalytics
	{
		get;
		private set;
	}

	protected override void Awake()
	{
		try
		{
			base.Awake();
			GoogleUniversalAnalytics.Instance.setApplicationVersion($"{DungeonsApplication.Environment.ToString()} {Amplitude.Unity.Framework.Application.Version.ToString()}");
			base.appVersion = Amplitude.Unity.Framework.Application.Version.ToString();
			modulesBuiltThisFloor = new Dictionary<StaticString, int>();
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Error in Google Analytics: " + ex.Message);
		}
	}

	public void SendGameMetrics(string category)
	{
		try
		{
			GoogleUniversalAnalytics instance = GoogleUniversalAnalytics.Instance;
			if (instance != null && IsAnalyticsEnabled())
			{
				instance.beginHit(GoogleUniversalAnalytics.HitType.Event);
				instance.sendHit();
				DungeonGenerationParams nextDungeonGenerationParams = Dungeon.NextDungeonGenerationParams;
				instance.SendEventHit(category, "Ship", nextDungeonGenerationParams.ShipName);
				DungeonGenerationParams nextDungeonGenerationParams2 = Dungeon.NextDungeonGenerationParams;
				object eventLabel = nextDungeonGenerationParams2.GameDifficulty;
				DungeonGenerationParams nextDungeonGenerationParams3 = Dungeon.NextDungeonGenerationParams;
				instance.SendEventHit(category, "Difficulty", eventLabel, (int)nextDungeonGenerationParams3.GameDifficulty);
				GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
				bool flag = gameNetworkManager != null && gameNetworkManager.IsMultiplayerSession();
				instance.SendEventHit(category, "Type", (!flag) ? "Singleplayer" : "Multiplayer");
				if (flag)
				{
					instance.SendEventHit(category, "Player Count", gameNetworkManager.GetPlayerCount());
				}
				DungeonGenerationParams nextDungeonGenerationParams4 = Dungeon.NextDungeonGenerationParams;
				if (nextDungeonGenerationParams4.NewGame_SelectedHeroes != null)
				{
					DungeonGenerationParams nextDungeonGenerationParams5 = Dungeon.NextDungeonGenerationParams;
					int num = Mathf.Min(nextDungeonGenerationParams5.NewGame_SelectedHeroes.Length, (int)GameConfig.GetGameConfig().PlayerInitHeroCount.GetValue());
					for (int i = 0; i < num; i++)
					{
						DungeonGenerationParams nextDungeonGenerationParams6 = Dungeon.NextDungeonGenerationParams;
						instance.SendEventHit(category, "Hero selected", nextDungeonGenerationParams6.NewGame_SelectedHeroes[i]);
					}
				}
				foreach (Hero localPlayerActiveRecruitedHero in Hero.LocalPlayerActiveRecruitedHeroes)
				{
					instance.SendEventHit(category, "Hero active", localPlayerActiveRecruitedHero.Config.Name);
				}
				modulesBuiltThisFloor.Clear();
			}
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Error in Google Analytics: " + ex.Message);
		}
	}

	public void SendNewUserMetrics(bool newUser)
	{
		try
		{
			GoogleUniversalAnalytics instance = GoogleUniversalAnalytics.Instance;
			if (instance != null && IsAnalyticsEnabled())
			{
				instance.beginHit(GoogleUniversalAnalytics.HitType.Event);
				instance.sendHit();
				instance.SendEventHit("New Game", "First game ever", newUser);
			}
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Error in Google Analytics: " + ex.Message);
		}
	}

	private bool IsAnalyticsEnabled()
	{
		//Discarded unreachable code: IL_0049, IL_0071
		try
		{
			return GoogleUniversalAnalytics.Instance != null && !GoogleUniversalAnalytics.Instance.analyticsDisabled && (!OnlyInPublicEnv || (DungeonsApplication.Environment != BuildEnvironment.DEV && DungeonsApplication.Environment != BuildEnvironment.QA));
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Error in Google Analytics: " + ex.Message);
			return false;
		}
	}

	public void SendGameOverMetrics(string category)
	{
		try
		{
			GoogleUniversalAnalytics instance = GoogleUniversalAnalytics.Instance;
			if (instance != null && IsAnalyticsEnabled())
			{
				SendGameMetrics(category);
				Dungeon dungeon = SingletonManager.Get<Dungeon>();
				instance.beginHit(GoogleUniversalAnalytics.HitType.Event);
				instance.sendHit();
				instance.SendEventHit(category, "Score", GenericUtilities.RoundHalfAwayFromZeroToInt(dungeon.GetScore()));
				instance.SendEventHit(category, "Active Hero Count", Hero.LocalPlayerActiveRecruitedHeroes.Count);
				instance.SendEventHit(category, "Dead Hero Count", Hero.DeadHeroes.Count);
				instance.SendEventHit(category, "Floor", dungeon.Level);
				instance.SendEventHit(category, "Crystal Phase", dungeon.CurrentCrystalState == CrystalState.Unplugged);
				if (Hero.LocalPlayerActiveRecruitedHeroes.Count > 0)
				{
					int num = 0;
					for (int i = 0; i < Hero.LocalPlayerActiveRecruitedHeroes.Count; i++)
					{
						if (Hero.LocalPlayerActiveRecruitedHeroes[i].Level > num)
						{
							num = Hero.LocalPlayerActiveRecruitedHeroes[i].Level;
						}
					}
					instance.SendEventHit(category, "Max Active Hero Level", num);
				}
				if (dungeon != null)
				{
					instance.SendEventHit(category, "Food", Convert.ToInt32(Player.LocalPlayer.FoodStock));
					instance.SendEventHit(category, "Industry", Convert.ToInt32(Player.LocalPlayer.IndustryStock));
					instance.SendEventHit(category, "Science", Convert.ToInt32(Player.LocalPlayer.ScienceStock));
					float stat = dungeon.Statistics.GetStat(DungeonStatistics.Stat_GameTime);
					instance.SendEventHit(category, "Duration", stat);
				}
			}
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Error in Google Analytics: " + ex.Message);
		}
	}

	public void SendEndLevelMetrics()
	{
		try
		{
			GoogleUniversalAnalytics instance = GoogleUniversalAnalytics.Instance;
			if (instance != null && IsAnalyticsEnabled())
			{
				instance.beginHit(GoogleUniversalAnalytics.HitType.Event);
				string eventCategory = "End Level";
				instance.sendHit();
				foreach (Hero localPlayerActiveRecruitedHero in Hero.LocalPlayerActiveRecruitedHeroes)
				{
					EquipmentSlot[] equipmentSlots = localPlayerActiveRecruitedHero.EquipmentSlots;
					foreach (EquipmentSlot equipmentSlot in equipmentSlots)
					{
						if (equipmentSlot.EquippedItem != null)
						{
							instance.SendEventHit(eventCategory, "Equipped Item", equipmentSlot.EquippedItem.ItemConfig.Name);
						}
					}
				}
				int num = 0;
				for (int j = 0; j < Hero.LocalPlayerActiveRecruitedHeroes.Count; j++)
				{
					if (!Hero.LocalPlayerActiveRecruitedHeroes[j].WasInExitRoomAtExitTime)
					{
						num++;
					}
				}
				instance.SendEventHit(eventCategory, "Abandonned Heroes", num);
				foreach (KeyValuePair<StaticString, int> item in modulesBuiltThisFloor)
				{
					instance.SendEventHit(eventCategory, "Modules Built", item.Key, item.Value);
				}
				modulesBuiltThisFloor.Clear();
			}
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Error in Google Analytics: " + ex.Message);
		}
	}

	public void SendHeroDeathAnalytics(Hero hero)
	{
		try
		{
			GoogleUniversalAnalytics instance = GoogleUniversalAnalytics.Instance;
			if (instance != null && IsAnalyticsEnabled())
			{
				instance.beginHit(GoogleUniversalAnalytics.HitType.Event);
				instance.addScreenName("Main Game Screen");
				string eventCategory = "Hero Death";
				instance.sendHit();
				instance.SendEventHit(eventCategory, "Name", hero.Config.Name);
				instance.SendEventHit(eventCategory, "Level", hero.Level);
				instance.SendEventHit(eventCategory, "Floor Recruited", hero.FloorRecruited);
			}
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Error in Google Analytics: " + ex.Message);
		}
	}

	public void SendResearchedBPAnalytics(BluePrintConfig bpConfig)
	{
		try
		{
			GoogleUniversalAnalytics instance = GoogleUniversalAnalytics.Instance;
			if (instance != null && IsAnalyticsEnabled())
			{
				instance.beginHit(GoogleUniversalAnalytics.HitType.Event);
				string eventCategory = "Researched BP";
				instance.sendHit();
				instance.SendEventHit(eventCategory, "BP Name", bpConfig.Name);
				instance.SendEventHit(eventCategory, "Module Name", bpConfig.ModuleName);
				instance.SendEventHit(eventCategory, "Module Level", bpConfig.ModuleLevel);
				DungeonGenerationParams nextDungeonGenerationParams = Dungeon.NextDungeonGenerationParams;
				instance.SendEventHit(eventCategory, "Ship Number", nextDungeonGenerationParams.ShipName);
				instance.SendEventHit(eventCategory, "Floor Number", SingletonManager.Get<Dungeon>().Level);
			}
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Error in Google Analytics: " + ex.Message);
		}
	}

	public void SendBuiltModuleAnalytics(BluePrintConfig bpConfig)
	{
		try
		{
			GoogleUniversalAnalytics instance = GoogleUniversalAnalytics.Instance;
			if (instance != null && IsAnalyticsEnabled())
			{
				instance.beginHit(GoogleUniversalAnalytics.HitType.Event);
				string eventCategory = "Built Module";
				instance.sendHit();
				instance.SendEventHit(eventCategory, "BP Name", bpConfig.Name);
				instance.SendEventHit(eventCategory, "Module Name", bpConfig.ModuleName);
				instance.SendEventHit(eventCategory, "Module Level", bpConfig.ModuleLevel);
				DungeonGenerationParams nextDungeonGenerationParams = Dungeon.NextDungeonGenerationParams;
				instance.SendEventHit(eventCategory, "Ship Number", nextDungeonGenerationParams.ShipName);
				instance.SendEventHit(eventCategory, "Floor Number", SingletonManager.Get<Dungeon>().Level);
			}
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Error in Google Analytics: " + ex.Message);
		}
	}

	public void SendUnlockAnalytics(int shipCount, int heroCount)
	{
		try
		{
			GoogleUniversalAnalytics instance = GoogleUniversalAnalytics.Instance;
			if (instance != null && IsAnalyticsEnabled())
			{
				instance.beginHit(GoogleUniversalAnalytics.HitType.Event);
				string eventCategory = "Unlocks";
				instance.sendHit();
				instance.SendEventHit(eventCategory, "Ships", shipCount);
				instance.SendEventHit(eventCategory, "Heroes", heroCount);
				instance.SendEventHit(eventCategory, "Pictures", SingletonManager.Get<Album>().GetUnlockedPictureCount());
				instance.SendEventHit(eventCategory, "Backstories", UserProfile.Data.BackstoriesUnlocked.Count);
				SentUnlockAnalytics = true;
			}
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Error in Google Analytics: " + ex.Message);
		}
	}

	public void SendMiscAnalytics()
	{
		try
		{
			GoogleUniversalAnalytics instance = GoogleUniversalAnalytics.Instance;
			if (!SentMiscAnalytics && instance != null && IsAnalyticsEnabled())
			{
				instance.beginHit(GoogleUniversalAnalytics.HitType.Event);
				string eventCategory = "Misc.";
				instance.sendHit();
				instance.SendEventHit(eventCategory, "Master Volume", (int)Services.GetService<IAudioVolumeService>().GetMasterVolume());
				instance.SendEventHit(eventCategory, "Hash Match", !HashManager.IsHashDifferent);
				instance.SendEventHit(eventCategory, "Language", Services.GetService<ILocalizationService>().CurrentLanguage);
				instance.SendEventHit(eventCategory, "Founder Pack DotE", Steamworks.SteamAPI.SteamApps.BIsDlcInstalled(268080u));
				instance.SendEventHit(eventCategory, "Founder Pack Legend", Steamworks.SteamAPI.SteamApps.BIsDlcInstalled(297652u));
				instance.SendEventHit(eventCategory, "Big Screen UI", Services.GetService<IGuiSettingsService>().HighDefinitionUI);
				instance.SendEventHit(eventCategory, "Environment", DungeonsApplication.Environment);
				instance.SendEventHit(eventCategory, "Version", Amplitude.Unity.Framework.Application.Version.ToString());
				SentMiscAnalytics = true;
				bool value = Amplitude.Unity.Framework.Application.Registry.GetValue("Metrics/FirstTimePlaying", defaultValue: true);
				instance.SendEventHit(eventCategory, "First Time Playing", value);
				if (value)
				{
					Amplitude.Unity.Framework.Application.Registry.SetValue("Metrics/FirstTimePlaying", value: false);
				}
			}
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Error in Google Analytics: " + ex.Message);
		}
	}

	public void RegisterBuiltModule(StaticString moduleName)
	{
		try
		{
			GoogleUniversalAnalytics instance = GoogleUniversalAnalytics.Instance;
			if (instance != null && IsAnalyticsEnabled() && modulesBuiltThisFloor != null)
			{
				if (modulesBuiltThisFloor.ContainsKey(moduleName))
				{
					modulesBuiltThisFloor[moduleName] += 1;
				}
				else
				{
					modulesBuiltThisFloor.Add(moduleName, 1);
				}
			}
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Error in Google Analytics: " + ex.Message);
		}
	}
}
public class Health : MonoBehaviour
{
	public delegate void HealthChangedEventHandler();

	public delegate void HitHandler(AttackInfo hit);

	public delegate void DeathHandler(ulong attackerOwnerPlayerID);

	public delegate void HealStartHandler();

	public delegate void DangerHandler();

	[SerializeField]
	private float instantHealSpeed;

	[SerializeField]
	private Renderer[] hitRenderers;

	[SerializeField]
	private Material hitMaterial;

	[SerializeField]
	private float hitDisplayDuration;

	[SerializeField]
	private float hitPosOffset = 3f;

	[SerializeField]
	private float hitPosOffsetDuration = 0.05f;

	[SerializeField]
	private float healthRegenUpdateStartTime;

	[SerializeField]
	private float healthRegenUpdateRepeatPeriod;

	[SerializeField]
	private float healthDOTUpdateStartTime;

	[SerializeField]
	private float healthDOTUpdateRepeatPeriod;

	[SerializeField]
	private float healthSyncUpdateStartTime;

	[SerializeField]
	private float healthSyncUpdateRepeatPeriod;

	protected HealthBarDisplayer healthBar;

	protected UniqueIDNetSyncElement netSyncElement;

	protected Dungeon dungeon;

	protected RoomElement roomElement;

	private SimMonoBehaviour simMB;

	private bool isCrystal;

	private bool isDoor;

	private bool previousHealthRegen;

	private float healthValue;

	private Hero hero;

	private Module module;

	private bool displayHit;

	private bool displayHitPositionOffset;

	private Vector3 hitAttackerPosition;

	private float hitDisplayEndTime;

	private float hitPositionOffsetToggleTime;

	private Material[] hitRenderersOriginalMaterials;

	private Vector3[] hitRenderersOriginalLocalPositions;

	private bool isMultiplayerSession;

	private float previousHealthValue;

	private GamePhase previousDungeonGamePhase;

	private float lastHealthRegenUpdateTime;

	private float lastHealthDOTUpdateTime;

	public bool IsInvincible;

	public float PermanantHealthMalus
	{
		get;
		set;
	}

	public bool EligibleToInstaRegen
	{
		get;
		set;
	}

	public UniqueID UniqueID
	{
		get;
		private set;
	}

	public SimMonoBehaviour SimMB => simMB;

	public HealthBarDisplayer HealthBar => healthBar;

	public Renderer[] HitRenderers
	{
		get
		{
			return hitRenderers;
		}
		set
		{
			hitRenderers = value;
		}
	}

	public event HealthChangedEventHandler OnHealthChanged;

	public event HitHandler OnHit;

	public event DeathHandler OnDeath;

	public event HealStartHandler OnHealStart;

	public event DangerHandler OnDanger;

	private void Start()
	{
		isMultiplayerSession = SingletonManager.Get<GameNetworkManager>().IsMultiplayerSession();
		if (healthRegenUpdateStartTime >= 0f && healthRegenUpdateRepeatPeriod >= 0f)
		{
			InvokeRepeating("HealthRegenUpdate", healthRegenUpdateStartTime, healthRegenUpdateRepeatPeriod);
		}
		if (healthDOTUpdateStartTime >= 0f && healthDOTUpdateRepeatPeriod >= 0f)
		{
			InvokeRepeating("HealthDOTUpdate", healthDOTUpdateStartTime, healthDOTUpdateRepeatPeriod);
		}
		if (healthSyncUpdateStartTime >= 0f && healthSyncUpdateRepeatPeriod >= 0f)
		{
			InvokeRepeating("HealthSyncUpdate", healthSyncUpdateStartTime, healthSyncUpdateRepeatPeriod);
		}
	}

	public float GetHealth()
	{
		if (isCrystal)
		{
			return dungeon.GetCrystalHealth();
		}
		return healthValue;
	}

	public void ClampHealth()
	{
		if (!isCrystal)
		{
			float num = healthValue;
			healthValue = Mathf.Clamp(healthValue, 0f, GetMaxHealth());
			if (Mathf.Abs(num - healthValue) > float.Epsilon && this.OnHealthChanged != null)
			{
				this.OnHealthChanged();
			}
		}
	}

	public void SetHealth(float health, bool ignoreInvincibility = false, bool ignoreAlive = false)
	{
		AddHealth(health - healthValue, 0uL, checkOwnership: true, ignoreInvincibility, ignoreAlive);
	}

	public void TriggerDeath(ulong attackerOwnerPlayerID = 0)
	{
		netSyncElement.SendRPCToAll(GetType(), "DoTriggerDeath", attackerOwnerPlayerID);
	}

	private void RPC_DoTriggerDeath(ulong attackerOwnerPlayerID)
	{
		healthValue = 0f;
		if (healthBar != null)
		{
			healthBar.UpdateBarDisplay();
		}
		if (displayHit)
		{
			StopHitDisplay();
		}
		if (this.OnDeath != null)
		{
			this.OnDeath(attackerOwnerPlayerID);
		}
	}

	public void AddHealth(float amount, ulong attackerOwnerPlayerID = 0, bool checkOwnership = true, bool ignoreInvincibility = false, bool ignoreAlive = false)
	{
		if (amount == 0f)
		{
			return;
		}
		if (checkOwnership && !netSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Health.AddHealth should only be called on owner side!");
		}
		else
		{
			if (!ignoreInvincibility && IsInvincible && amount < 0f)
			{
				return;
			}
			if (!ignoreAlive && !IsAlive())
			{
				Diagnostics.LogError(base.name + " > Health.AddHealth: already dead!");
				return;
			}
			if (isCrystal)
			{
				dungeon.AddCrystalHealth(amount);
				return;
			}
			float healthRatio = GetHealthRatio();
			float num = healthValue + amount;
			if (num <= 0f)
			{
				Death(attackerOwnerPlayerID);
				return;
			}
			DoSetHealthValue(num);
			if (hero != null)
			{
				float woundedDialogTriggerHealthRatio = GameConfig.GetGameConfig().WoundedDialogTriggerHealthRatio;
				if (healthRatio > woundedDialogTriggerHealthRatio && GetHealthRatio() <= woundedDialogTriggerHealthRatio)
				{
					dungeon.CheckSituationDialog(SituationDialogType.Wounded, hero);
				}
			}
		}
	}

	protected void RPC_SetHealthValue(float healthValue)
	{
		DoSetHealthValue(healthValue);
	}

	protected void DoSetHealthValue(float healthValue)
	{
		this.healthValue = healthValue;
		float maxHealth = GetMaxHealth();
		if (this.healthValue > maxHealth)
		{
			this.healthValue = maxHealth;
		}
		if (this.OnHealthChanged != null)
		{
			this.OnHealthChanged();
		}
		if (healthBar != null)
		{
			healthBar.UpdateBarDisplay();
		}
	}

	public virtual float GetMaxHealth()
	{
		if (isCrystal)
		{
			return GetHealth();
		}
		if (isDoor)
		{
			return 100f;
		}
		Diagnostics.Assert(simMB != null);
		return simMB.GetSimPropertyValue(SimulationProperties.MaxHealth) - PermanantHealthMalus;
	}

	public void InitHealth(bool eligibleToInstaRegen = false)
	{
		MajorModule component = GetComponent<MajorModule>();
		isCrystal = (component != null && component.IsCrystal);
		EligibleToInstaRegen = eligibleToInstaRegen;
		if (!isCrystal)
		{
			healthValue = GetMaxHealth();
		}
		if (healthBar != null)
		{
			healthBar.UpdateHealthBarHeight();
		}
	}

	public void Hit(AttackInfo hit)
	{
		netSyncElement.SendRPCToAll(GetType(), "DoHit", hit.Damages, hit.AttackerCategory, hit.AttackerID, (Int2Position)hit.AttackerPos, hit.DisplayHit);
	}

	protected void RPC_DoHit(float damages, StaticString attackerCategory, int attackerID, Int2Position attackerPos, bool displayHit)
	{
		AttackInfo attackInfo = default(AttackInfo);
		attackInfo.Damages = damages;
		attackInfo.AttackerCategory = attackerCategory;
		attackInfo.AttackerID = attackerID;
		attackInfo.AttackerPos = (Vector3)attackerPos;
		attackInfo.DisplayHit = displayHit;
		AttackInfo hit = attackInfo;
		if (!IsAlive())
		{
			return;
		}
		if (this.OnHit != null)
		{
			this.OnHit(hit);
		}
		if (this.OnDanger != null)
		{
			this.OnDanger();
		}
		if (hit.DisplayHit)
		{
			DisplayHit((Vector3)attackerPos);
		}
		if (isCrystal)
		{
			dungeon.EnqueueAlertNotification(AgeLocalizer.Instance.LocalizeString("%Notification_CrystalAttacked"), null, addToLog: false, dungeon.OnCrystalAttackedNotificationClick);
			SingletonManager.Get<DustBarPanel>().PlayCrystalAttackAlert();
		}
		if (!netSyncElement.IsOwnedByLocalPlayer())
		{
			return;
		}
		float num = 0f;
		Attacker attacker = null;
		if (isDoor)
		{
			attacker = UniqueIDManager.Get(hit.AttackerCategory, hit.AttackerID).GetComponent<Attacker>();
			if (attacker != null)
			{
				num = attacker.SimMB.GetSimPropertyValue(SimulationProperties.AttackPowerOnDoors);
			}
		}
		else
		{
			num = hit.Damages * (1f - simMB.GetSimPropertyValue(SimulationProperties.Defense) / (simMB.GetSimPropertyValue(SimulationProperties.Defense) + 100f));
		}
		if (num > 0f)
		{
			if (attacker == null && !string.IsNullOrEmpty(hit.AttackerCategory) && hit.AttackerID > 0)
			{
				attacker = UniqueIDManager.Get(hit.AttackerCategory, hit.AttackerID).GetComponent<Attacker>();
			}
			AddHealth(0f - num, (!(attacker != null)) ? 0 : attacker.NetSyncElement.OwnerPlayerID);
			if (!IsAlive() && attacker != null)
			{
				attacker.RegisterTargetKill(this);
			}
		}
	}

	public bool IsAlive()
	{
		return IsInvincible || GetHealth() > 0f;
	}

	public bool IsFullLive()
	{
		if (isCrystal)
		{
			return true;
		}
		return GetHealth() == GetMaxHealth();
	}

	public float GetHealthRatio()
	{
		if (isCrystal)
		{
			return 1f;
		}
		return GetHealth() / GetMaxHealth();
	}

	public void SetHealthRatio(float ratio, bool checkOwnership = true, bool ignoreInvincibility = false, bool ignoreAlive = false)
	{
		float num = ratio * GetMaxHealth();
		AddHealth(num - GetHealth(), 0uL, checkOwnership, ignoreInvincibility, ignoreAlive);
	}

	public void Kill(bool checkOwnership = true)
	{
		IsInvincible = false;
		AddHealth(0f - GetHealth(), 0uL, checkOwnership);
	}

	protected virtual void Awake()
	{
		simMB = GetComponent<SimMonoBehaviour>();
		dungeon = SingletonManager.Get<Dungeon>();
		hero = GetComponent<Hero>();
		module = GetComponent<Module>();
		healthBar = GetComponent<HealthBarDisplayer>();
		UniqueID = GetComponent<UniqueID>();
		netSyncElement = GetComponent<UniqueIDNetSyncElement>();
		isDoor = (GetComponent<Door>() != null);
		roomElement = GetComponent<RoomElement>();
		PermanantHealthMalus = 0f;
	}

	protected virtual void Death(ulong attackerOwnerPlayerID = 0)
	{
		if (hero == null || !hero.RespawnStart())
		{
			TriggerDeath(attackerOwnerPlayerID);
		}
	}

	public void HealthRegenUpdate()
	{
		float time = Time.time;
		float num = time - lastHealthRegenUpdateTime;
		if (!IsAlive() || isCrystal || simMB == null || !netSyncElement.IsOwnedByLocalPlayer() || !IsAlive())
		{
			return;
		}
		float simPropertyValue = simMB.GetSimPropertyValue(SimulationProperties.HealthRegen);
		if (ShouldInstantRegen(simPropertyValue))
		{
			simPropertyValue = instantHealSpeed;
		}
		simPropertyValue += simMB.GetSimPropertyValue(SimulationProperties.HealthRegenGamePhaseIndependent);
		if (simPropertyValue > 0f && !IsFullLive())
		{
			AddHealth(simPropertyValue * num);
			if (!previousHealthRegen && this.OnHealStart != null)
			{
				this.OnHealStart();
			}
			previousHealthRegen = true;
		}
		else
		{
			previousHealthRegen = false;
		}
		lastHealthRegenUpdateTime = time;
	}

	public void HealthDOTUpdate()
	{
		float time = Time.time;
		float num = time - lastHealthDOTUpdateTime;
		if (!IsAlive() || isCrystal || simMB == null || !netSyncElement.IsOwnedByLocalPlayer())
		{
			return;
		}
		if (lastHealthDOTUpdateTime > 0f)
		{
			float num2 = simMB.GetSimPropertyValue(SimulationProperties.DamageOverTime) + simMB.GetSimPropertyValue(SimulationProperties.Poison);
			if (num2 > 0f)
			{
				Hit(new AttackInfo
				{
					Damages = num2 * num,
					AttackerPos = base.transform.position + Vector3.forward
				});
			}
		}
		lastHealthDOTUpdateTime = time;
	}

	public void HealthSyncUpdate()
	{
		if (!isMultiplayerSession || !netSyncElement.IsOwnedByLocalPlayer())
		{
			return;
		}
		if (healthValue != previousHealthValue)
		{
			if (dungeon.CurrentGamePhase == GamePhase.Strategy || IsFullLive() || (module != null && module.IsBuilding))
			{
				netSyncElement.SendRPCToOthers(GetType(), "SetHealthValue", healthValue.RoundWithDecimals(2));
			}
			else
			{
				netSyncElement.SendUnreliableRPCToOthers(GetType(), "SetHealthValue", healthValue.RoundWithDecimals(2));
			}
		}
		if (dungeon.CurrentGamePhase == GamePhase.Strategy && previousDungeonGamePhase != 0)
		{
			netSyncElement.SendRPCToOthers(GetType(), "SetHealthValue", healthValue.RoundWithDecimals(2));
		}
		previousHealthValue = healthValue;
		previousDungeonGamePhase = dungeon.CurrentGamePhase;
	}

	protected virtual bool ShouldInstantRegen(float healthRegen)
	{
		if (dungeon.CurrentGamePhase == GamePhase.Strategy)
		{
			return (!EligibleToInstaRegen && healthRegen > 0f) || (EligibleToInstaRegen && !dungeon.ShipConfig.ForbidStrategyHealthRegen);
		}
		return false;
	}

	private void DisplayHit(Vector3 attackerPos)
	{
		if (hitRenderers == null || hitRenderers.Length < 1)
		{
			return;
		}
		if (hitRenderersOriginalMaterials == null || hitRenderersOriginalLocalPositions == null)
		{
			hitRenderersOriginalMaterials = new Material[hitRenderers.Length];
			hitRenderersOriginalLocalPositions = new Vector3[hitRenderers.Length];
			for (int i = 0; i < hitRenderers.Length; i++)
			{
				hitRenderersOriginalMaterials[i] = hitRenderers[i].sharedMaterial;
				hitRenderersOriginalLocalPositions[i] = hitRenderers[i].transform.localPosition;
			}
		}
		displayHit = true;
		hitDisplayEndTime = Time.time + hitDisplayDuration;
		hitAttackerPosition = attackerPos;
		for (int j = 0; j < hitRenderers.Length; j++)
		{
			hitRenderers[j].transform.localPosition = hitRenderersOriginalLocalPositions[j];
			hitRenderers[j].transform.position += hitPosOffset * (hitRenderers[j].transform.position - hitAttackerPosition).normalized;
		}
		displayHitPositionOffset = false;
		hitPositionOffsetToggleTime = Time.time + hitPosOffsetDuration;
	}

	private void StopHitDisplay()
	{
		if (!displayHit)
		{
			Diagnostics.LogError("{0} > Health.StopHitDisplay: not currently displaying hit", base.name);
			return;
		}
		for (int i = 0; i < hitRenderers.Length; i++)
		{
			hitRenderers[i].material = hitRenderersOriginalMaterials[i];
			hitRenderers[i].transform.localPosition = hitRenderersOriginalLocalPositions[i];
		}
		for (int j = 0; j < hitRenderers.Length; j++)
		{
			hitRenderers[j].transform.localPosition = hitRenderersOriginalLocalPositions[j];
		}
		displayHit = false;
	}

	private void LateUpdate()
	{
		if (!displayHit)
		{
			return;
		}
		if (Time.time <= hitDisplayEndTime)
		{
			for (int i = 0; i < hitRenderers.Length; i++)
			{
				hitRenderers[i].material = hitMaterial;
			}
			if (!(Time.time >= hitPositionOffsetToggleTime))
			{
				return;
			}
			for (int j = 0; j < hitRenderers.Length; j++)
			{
				hitRenderers[j].transform.localPosition = hitRenderersOriginalLocalPositions[j];
				if (displayHitPositionOffset)
				{
					hitRenderers[j].transform.localPosition = hitRenderersOriginalLocalPositions[j];
					hitRenderers[j].transform.position += hitPosOffset * (hitRenderers[j].transform.position - hitAttackerPosition).normalized;
				}
			}
			displayHitPositionOffset = !displayHitPositionOffset;
			hitPositionOffsetToggleTime += hitPosOffsetDuration;
		}
		else
		{
			StopHitDisplay();
		}
	}
}
public class Hero : HeroMobCommon
{
	public delegate void HeroSelectEventHandler(Hero selectedHero);

	public delegate void HasCrystalChangedEventHandler(bool hasCrystal);

	public delegate void SkillsChangedEventHandler();

	public delegate void ActiveHeroDeathEventHandler();

	public delegate void HeroRecruitedEventHandler();

	public const string RepairFirstHeroAIType = "RepairFirstHero";

	public const string FreHeroAIType = "Free{0}";

	[SerializeField]
	protected OffscreenMarker.OffscreenMarkerData heroDangerIconData;

	private FMOD.Event operateSFXEvent;

	private FMOD.Event repairSFXEvent;

	private StaticString previousOperatingBonusModuleSimDescName;

	private MovableAITarget followTarget;

	private Mob tamedMob;

	[SerializeField]
	private float itemGatheringDuration;

	private Item gatheringItem;

	[SerializeField]
	private Vector3 heroMoveToOffset;

	[SerializeField]
	private Vector3 crystalMoveToOffset;

	[SerializeField]
	private Vector3 npcMoveToOffset;

	[SerializeField]
	private Vector3 doorDestMarkerOffset;

	[SerializeField]
	private Vector3 heroDestMarkerOffset;

	[SerializeField]
	private Vector3 npcDestMarkerOffset;

	[SerializeField]
	private Vector3 specialModuleDestMarkerOffset;

	[SerializeField]
	private Vector3 crystalDestMarkerOffset;

	[SerializeField]
	private float crystalSlotApproachDistance;

	private MajorModule crystalMoveTarget;

	private SpecialMajorModule specialMajorModuleMoveTarget;

	private NPC npcMoveTarget;

	private Hero heroMoveTarget;

	private Room roomMoveTarget;

	private Door doorMoveTarget;

	private Item itemMoveTarget;

	private Room nextMoveRoomMoveTarget;

	private Door nextMoveDoorMoveTarget;

	private List<ActiveSkill> activeSkills;

	private List<PassiveSkill> passiveSkills;

	private static List<Hero> localPlayerActiveRecruitedHeroes = new List<Hero>();

	private static List<Hero> remotePlayersActiveRecruitedHeroes = new List<Hero>();

	private static List<Hero> selectedHeroes = new List<Hero>();

	private static List<Hero> deadHeroes = new List<Hero>();

	private static SimulationDescriptor operatingBonusGenericSimDesc;

	private static Dictionary<StaticString, SimulationDescriptor> operatingBonusModuleSimDesc = new Dictionary<StaticString, SimulationDescriptor>();

	[SerializeField]
	protected SpriteAnimationRuntime2 actionAnim;

	[SerializeField]
	private ParticleSystem supportBoosterVFX;

	[SerializeField]
	private ParticleSystem supportHealingVFX;

	[SerializeField]
	private ParticleSystem supportSonarVFX;

	[SerializeField]
	private ParticleSystem dismissVFX;

	[SerializeField]
	private Renderer selectorRenderer;

	[SerializeField]
	private Transform destRoomMarkerTfm;

	[SerializeField]
	private Renderer destRoomMarkerRnd;

	[SerializeField]
	private float hideDelayOnDismiss;

	[SerializeField]
	private float destroyDelayOnDismiss;

	[SerializeField]
	private Light heroLight;

	[SerializeField]
	private Light crystalLight;

	[SerializeField]
	private bool debug;

	[SerializeField]
	private Transform crystalContainer;

	[SerializeField]
	private SpriteAnimationRuntime2 crystalSprite;

	[SerializeField]
	private float crystalDistanceToPlayer;

	[SerializeField]
	private float crystalHeight;

	[SerializeField]
	private float doubleSelectMaxTimeDelta;

	[SerializeField]
	private GameObject activeSkillPfb;

	[SerializeField]
	private GameObject passiveSkillPfb;

	[SerializeField]
	private AITarget heroAttackTargetCpnt;

	[SerializeField]
	private AITarget mobsAggroAttackTargetCpnt;

	[SerializeField]
	private GameObject situationDialogPanelPfb;

	[SerializeField]
	private float lowHealthBarScaleY;

	[SerializeField]
	private float lowHealthBarScaleX;

	[SerializeField]
	private float lowHealthValue;

	[SerializeField]
	private GameObject playerNamePanelPfb;

	[SerializeField]
	private Color recruitementTextColor;

	[SerializeField]
	private SpriteAnimationRuntime2 tacticalMapElementAnim;

	[SerializeField]
	private SpriteAnimationRuntime2 selectTacticalMapElementAnim;

	[SerializeField]
	private SpriteAnimationRuntime2 itemRespawnSprite;

	private Vector3 targetLastKnownPos;

	private Dungeon dungeon;

	private List<HeroLevelConfig> levelConfigs;

	private List<Dictionary<StaticString, float>> levelUpModifiersByLevel;

	private ParticleSystem levelUpVfxParticles;

	private IGameEventService gameEventManager;

	private float lastSelectRealTime;

	private int attackingMobCount;

	private float defenseBonusFromMobKills;

	private float attackBonusFromMobKills;

	private float foodBonusFromMobKills;

	private float industryBonusFromMobKills;

	private SituationDialogPanel situationDialogPanel;

	private IGameControlService gameControlManager;

	private float initalHealthBarScaleY;

	private float initalHealthBarScaleX;

	private IAudioEventService audioEventManager;

	private bool allowAnim = true;

	private HeroPlayerNamePanel playerNamePanel;

	private AchievementManagerDOTE achievementManager;

	private SelectableManager selectableManager;

	private GameObject SkillA0039VFXPfb;

	private int floorRecruited = 1;

	private float previousMobTaming;

	private float previousSkillA0039Value;

	private bool shipRespawn = true;

	private float respawnHealthRatio;

	public static List<Hero> RecentlyDeceasedHeroes = new List<Hero>();

	private float cachedSkill_A0039_ZoneAttackRadius;

	private float cachedSkill_A0039_AttackPower;

	public MajorModule OperatingModule
	{
		get;
		private set;
	}

	public bool HasOperatingBonus
	{
		get;
		private set;
	}

	public Module RepairingModule
	{
		get;
		private set;
	}

	public MajorModule PreviousOperatedModule
	{
		get;
		set;
	}

	public Mob TamedMob
	{
		get
		{
			return tamedMob;
		}
		private set
		{
			tamedMob = value;
			if (followTarget != null)
			{
				followTarget.AuthorizedFollower = TamedMob.gameObject;
			}
		}
	}

	public Mover MoverCpnt
	{
		get;
		private set;
	}

	public ModuleSlot CrystalSlotMoveTarget
	{
		get;
		private set;
	}

	public List<ActiveSkill> FilteredActiveSkills
	{
		get;
		private set;
	}

	public List<PassiveSkill> FilteredPassiveSkills
	{
		get;
		private set;
	}

	public static List<Hero> SelectedHeroes => selectedHeroes;

	public static List<Hero> LocalPlayerActiveRecruitedHeroes => localPlayerActiveRecruitedHeroes;

	public static List<Hero> DeadHeroes => deadHeroes;

	public static List<Hero> RemotePlayersActiveRecruitedHeroes => remotePlayersActiveRecruitedHeroes;

	public int UnlockLevel
	{
		get;
		set;
	}

	public bool IsUsable
	{
		get;
		set;
	}

	public HeroConfig Config
	{
		get;
		set;
	}

	public bool IsStartingHero
	{
		get;
		set;
	}

	public bool IsRecruitable
	{
		get;
		set;
	}

	public int CurrentRespawnRoomCount
	{
		get;
		private set;
	}

	public EquipmentSlot[] EquipmentSlots
	{
		get;
		private set;
	}

	public bool IsInteracting
	{
		get;
		private set;
	}

	public bool IsRespawning
	{
		get;
		private set;
	}

	public bool HasCrystal
	{
		get;
		private set;
	}

	public string LocalizedName
	{
		get;
		private set;
	}

	public bool IsRecruited
	{
		get;
		private set;
	}

	public int FloorRecruited
	{
		get
		{
			return floorRecruited;
		}
		private set
		{
			floorRecruited = value;
		}
	}

	public bool IsDismissing
	{
		get;
		private set;
	}

	public List<SimulationDescriptor> PermanentDescriptors
	{
		get;
		private set;
	}

	public HeroAI AICpnt
	{
		get;
		private set;
	}

	public float LowHealthValue => lowHealthValue;

	public event Action<Mob, Mob> OnMobTamed;

	public static event Action OnLocalActiveHeroesChange;

	public event HasCrystalChangedEventHandler OnHasCrystalChanged;

	public event SkillsChangedEventHandler OnSkillsChanged;

	public static event ActiveHeroDeathEventHandler OnActiveHeroDeath;

	public static event HeroRecruitedEventHandler OnHeroRecruited;

	public void OperateModule(MajorModule module)
	{
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Hero.OperateModule should only be called on owner side!");
		}
		else if (!(OperatingModule == module))
		{
			AICpnt.OnTargetChanged += OnOperateTargetChanged;
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_StartModuleOperating, module.UniqueID.GetCategory(), module.UniqueID.ID);
		}
	}

	private void RPC_StartModuleOperating(StaticString moduleCategory, int moduleID)
	{
		MajorModule majorModule = OperatingModule = UniqueIDManager.Get(moduleCategory, moduleID).GetComponent<MajorModule>();
		if (HasOperatingBonus)
		{
			RemoveOperatingDescriptors(PreviousOperatedModule);
			if (PreviousOperatedModule == null)
			{
				HasOperatingBonus = false;
			}
			else
			{
				AddOperatingDescriptors();
			}
		}
		OperatingModule.Operate(this);
		spriteAnim.SetAnimDirection(OperatingModule.transform.position - base.transform.position);
		spriteAnim.SetBool(SpriteAnimationBool.IsActionning, value: true);
		actionAnim.Trigger((!HasOperatingBonus) ? SpriteAnimationTrigger.OnOperate : SpriteAnimationTrigger.OnOperateBonus);
		operateSFXEvent = base.AudioEmitter.PlayEvent("Master/Environment/ModuleEntretien");
		gameEventManager.TriggerHeroListChangedEvent();
		if (!HasOperatingBonus)
		{
			gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChangedDuringAction;
			gameEventManager.OnDungeonTurnChanged += OnDungeonTurnChangedDuringAction;
		}
	}

	private void AddOperatingDescriptors()
	{
		AddSimDescriptor(operatingBonusGenericSimDesc);
		SimulationDescriptor moduleOperatingDescriptor = GetModuleOperatingDescriptor();
		if (moduleOperatingDescriptor != null)
		{
			AddSimDescriptor(moduleOperatingDescriptor);
			previousOperatingBonusModuleSimDescName = moduleOperatingDescriptor.Name;
		}
	}

	private void RemoveOperatingDescriptors(MajorModule module = null)
	{
		RemoveSimDescriptor(operatingBonusGenericSimDesc);
		SimulationDescriptor moduleOperatingDescriptor = GetModuleOperatingDescriptor(module);
		if (moduleOperatingDescriptor != null)
		{
			RemoveSimDescriptor(moduleOperatingDescriptor);
		}
		else if (!string.IsNullOrEmpty(previousOperatingBonusModuleSimDescName))
		{
			RemoveSimDescriptor(previousOperatingBonusModuleSimDescName);
		}
	}

	private void OnDungeonTurnChangedDuringAction()
	{
		gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChangedDuringAction;
		if (HasOperatingBonus)
		{
			Diagnostics.LogError("{0} > OnDungeonTurnChanged: this.HasOperatingBonus shouldn't already be true!", base.name);
			return;
		}
		HasOperatingBonus = true;
		RemoveOperatingDescriptors();
		AddOperatingDescriptors();
		if (OperatingModule != null)
		{
			OperatingModule.UpdateOperatorWit(this);
			gameEventManager.TriggerHeroListChangedEvent();
			actionAnim.Trigger(SpriteAnimationTrigger.OnOperateBonus);
		}
	}

	public void RepairModule(Module module)
	{
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Hero.RepairModule should only be called on owner side!");
		}
		else if (!(RepairingModule == module))
		{
			AICpnt.OnTargetChanged += OnRepairTargetChanged;
			dungeon.CheckSituationDialog(SituationDialogType.RepairModule, this);
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_StartModuleRepairing, module.UniqueID.GetCategory(), module.UniqueID.ID);
		}
	}

	private void RPC_StartModuleRepairing(StaticString moduleCategory, int moduleID)
	{
		Module module = RepairingModule = UniqueIDManager.Get(moduleCategory, moduleID).GetComponent<Module>();
		RepairingModule.Repair(this);
		if (allowAnim)
		{
			spriteAnim.SetAnimDirection(RepairingModule.transform.position - base.transform.position);
			spriteAnim.SetBool(SpriteAnimationBool.IsActionning, value: true);
			actionAnim.Trigger(SpriteAnimationTrigger.OnRepair);
		}
		repairSFXEvent = base.AudioEmitter.PlayEvent("Master/Environment/RepairModule");
		gameEventManager.TriggerHeroListChangedEvent();
	}

	private void OnOperateTargetChanged(AITarget previousTarget, AITarget newTarget)
	{
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Hero.RepairModule should only be called on owner side!");
			return;
		}
		MajorModule majorModule = null;
		if (previousTarget != null)
		{
			majorModule = previousTarget.GetComponent<MajorModule>();
			if (majorModule != OperatingModule)
			{
				Diagnostics.LogError(base.name + " > OnOperateTargetChanged: previous target != current operating module");
				return;
			}
		}
		AICpnt.OnTargetChanged -= OnOperateTargetChanged;
		if (HasOperatingBonus && (previousTarget == null || !previousTarget.GetComponent<Health>().IsAlive()))
		{
			RemoveOperatingDescriptors(majorModule);
			HasOperatingBonus = false;
			gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChangedDuringAction;
		}
		base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_StopModuleOperating);
	}

	private void RPC_StopModuleOperating()
	{
		if (HasOperatingBonus)
		{
			RemoveOperatingDescriptors();
		}
		if (OperatingModule != null)
		{
			PreviousOperatedModule = OperatingModule;
			OperatingModule.StopOperating(this);
			OperatingModule = null;
		}
		spriteAnim.SetBool(SpriteAnimationBool.IsActionning, value: false);
		actionAnim.Stop();
		base.AudioEmitter.StopEvent(operateSFXEvent);
		gameEventManager.TriggerHeroListChangedEvent();
	}

	private void OnRepairTargetChanged(AITarget previousTarget, AITarget newTarget)
	{
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Hero.RepairModule should only be called on owner side!");
			return;
		}
		if (previousTarget != null && previousTarget.GetComponent<Module>() != RepairingModule)
		{
			Diagnostics.LogError(base.name + " > OnRepairTargetChanged: previous target != current repairing module");
			return;
		}
		AICpnt.OnTargetChanged -= OnRepairTargetChanged;
		base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_StopModuleRepairing);
	}

	private void RPC_StopModuleRepairing()
	{
		if (RepairingModule != null)
		{
			RepairingModule.StopRepairing(this);
			RepairingModule = null;
		}
		spriteAnim.SetBool(SpriteAnimationBool.IsActionning, value: false);
		actionAnim.Stop();
		base.AudioEmitter.StopEvent(repairSFXEvent);
		gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChangedDuringAction;
		gameEventManager.TriggerHeroListChangedEvent();
	}

	private SimulationDescriptor GetModuleOperatingDescriptor(Module module = null)
	{
		SimulationDescriptor value = null;
		if (OperatingModule != null)
		{
			StaticString staticString = (module ?? OperatingModule).BPConfig.ModuleName;
			if (!operatingBonusModuleSimDesc.TryGetValue(staticString, out value))
			{
				value = SimMonoBehaviour.GetDBDescriptorByName("Hero_Operating_Bonus_" + staticString);
				operatingBonusModuleSimDesc.Add(staticString, value);
			}
		}
		return value;
	}

	public void FindAndTameAMob()
	{
		Mob[] array = base.RoomElement.ParentRoom.Mobs.Where((Mob m) => m.Tamer == null && m.Config != null && m.HealthCpnt != null && m.AttackTargetCpnt != null && m.AttackTargetCpnt.CanBeAttacked()).ToArray();
		if (array.Length > 0)
		{
			if (TamedMob != null && TamedMob.HealthCpnt != null)
			{
				TamedMob.HealthCpnt.Kill();
			}
			int highestDifficultyValue = array.Max((Mob m) => m.Config.DifficultyValue);
			Mob mob = (from m in array
				where m.Config.DifficultyValue == highestDifficultyValue
				orderby m.HealthCpnt.GetHealth() descending
				select m).ElementAt(0);
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_TameMob, mob.UniqueID.GetCategory(), mob.UniqueID.ID);
		}
		else
		{
			Diagnostics.Log("No tamable mob was found");
		}
	}

	private void RPC_TameMob(StaticString mobCategory, int mobId)
	{
		Mob component = UniqueIDManager.Get(mobCategory, mobId).GetComponent<Mob>();
		if (component != null)
		{
			DoTameMob(component);
		}
	}

	public void DoTameMob(Mob mob, bool ownerChanged = false)
	{
		if (!(mob.Tamer != null))
		{
			Diagnostics.Log("Mob {0} tamed by {1}", mob.name, base.name);
			if (this.OnMobTamed != null)
			{
				this.OnMobTamed(mob, TamedMob);
			}
			if (followTarget == null)
			{
				followTarget = base.gameObject.AddComponent<MovableAITarget>();
				followTarget.Init(AITargetType.Tamer, AIInteraction.Follow);
			}
			TamedMob = mob;
			attackerCpnt.StopAttack();
			TamedMob.Tame(this, ownerChanged);
		}
	}

	public void AcquireItem()
	{
		if (allowAnim)
		{
			spriteAnim.SetBool(SpriteAnimationBool.IsActionning, value: false);
		}
		if (!(gatheringItem == null))
		{
			if (base.NetSyncElement.IsOwnedByLocalPlayer())
			{
				base.AudioEmitter.PlayEvent("Master/Environment/CollectItem");
			}
			gatheringItem.Acquire(this);
			actionAnim.Stop();
			gatheringItem = null;
		}
	}

	public bool CanEquipItem(InventoryItem item)
	{
		for (int i = 0; i < EquipmentSlots.Length; i++)
		{
			if (EquipmentSlots[i].CanHoldItem(item))
			{
				return true;
			}
		}
		return false;
	}

	public void StartItemGathering(Item item)
	{
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Hero.NetSyncStartItemGathering should only be called on owner side!");
		}
		else
		{
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_DoStartItemGathering, item.UniqueID.GetCategory(), item.UniqueID.ID);
		}
	}

	private void RPC_DoStartItemGathering(StaticString itemCategory, int itemID)
	{
		UniqueIDGetError error;
		UnityEngine.Component component = UniqueIDManager.Get(itemCategory, itemID, out error, logError: false);
		if (component == null)
		{
			if (error == UniqueIDGetError.ObjectIsNull)
			{
				Diagnostics.Log("Hero.RPC_DoStartItemGathering: {0}#{1} item not found (already gathered&destroyed?)", itemCategory, itemID);
			}
			else
			{
				Diagnostics.LogError("Hero.RPC_DoStartItemGathering: {0}#{1} item not found (error={2})", itemCategory, itemID, error);
			}
			return;
		}
		Item component2 = component.GetComponent<Item>();
		if (component2 == null)
		{
			Diagnostics.LogError("Hero.RPC_DoStartItemGathering: couldn't find Item component on {0}#{1} item!", itemCategory, itemID);
			return;
		}
		if (!component2.CanBeGathered)
		{
			Diagnostics.LogWarning(base.name + " > OnItemReached: Item cannot be gathered");
			return;
		}
		if (gatheringItem == component2)
		{
			Diagnostics.LogWarning(base.name + " > OnItemReached: Already gathering this item");
			return;
		}
		gatheringItem = component2;
		if (MoverCpnt.IsMoving)
		{
			MoverCpnt.StopMove();
		}
		if (allowAnim)
		{
			spriteAnim.SetAnimDirection(gatheringItem.transform.position - base.transform.position);
			spriteAnim.SetBool(SpriteAnimationBool.IsActionning, value: true);
		}
		actionAnim.Trigger(SpriteAnimationTrigger.OnLoot);
		gatheringItem.StartGathering(this);
		Invoke("AcquireItem", itemGatheringDuration);
		AICpnt.OnTargetChanged += OnItemLootTargetChanged;
	}

	public void CancelItemGathering()
	{
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Hero.NetSyncCancelItemGathering should only be called on owner side!");
		}
		else
		{
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_DoCancelItemGathering);
		}
	}

	private void RPC_DoCancelItemGathering()
	{
		if (gatheringItem != null)
		{
			gatheringItem.StopGathering();
			spriteAnim.SetBool(SpriteAnimationBool.IsActionning, value: false);
			actionAnim.Stop();
			gatheringItem = null;
			CancelInvoke("AcquireItem");
		}
	}

	public void EquipItemOnSlot(int slotIndex, InventoryItem item, bool removeFromInventory, bool netSync, bool checkItemInventory)
	{
		if (netSync)
		{
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_EquipItemOnSlot, slotIndex, item.UniqueIDCategory, item.UniqueID, removeFromInventory, netSync, checkItemInventory);
		}
		else
		{
			DoEquipItemOnSlot(slotIndex, item, removeFromInventory, netSync, checkItemInventory);
		}
	}

	private void RPC_EquipItemOnSlot(int slotIndex, StaticString itemUniqueIDCategory, int itemUniqueID, bool removeFromInventory, bool netSync, bool checkItemInventory)
	{
		InventoryItem item = InventoryItem.GetItem(itemUniqueIDCategory, itemUniqueID);
		if (item != null)
		{
			DoEquipItemOnSlot(slotIndex, item, removeFromInventory, netSync, checkItemInventory);
		}
	}

	private void DoEquipItemOnSlot(int slotIndex, InventoryItem item, bool removeFromInventory, bool netSync, bool checkItemInventory)
	{
		bool flag = base.NetSyncElement.IsOwnedByLocalPlayer();
		float ratio = 0f;
		if (flag)
		{
			ratio = base.HealthCpnt.GetHealthRatio();
		}
		EquipmentSlots[slotIndex].DoEquipItem(item, removeFromInventory, netSync, checkItemInventory);
		if (flag)
		{
			base.HealthCpnt.SetHealthRatio(ratio);
		}
	}

	public void UnequipItemFromSlot(int slotIndex, bool netSync, bool checkConfig = true)
	{
		if (netSync)
		{
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_UnequipItemFromSlot, slotIndex, checkConfig);
		}
		else
		{
			DoUnequipItemFromSlot(slotIndex, checkConfig);
		}
	}

	private void RPC_UnequipItemFromSlot(int slotIndex, bool checkConfig)
	{
		DoUnequipItemFromSlot(slotIndex, checkConfig);
	}

	private void DoUnequipItemFromSlot(int slotIndex, bool checkConfig = true)
	{
		bool flag = base.NetSyncElement.IsOwnedByLocalPlayer();
		float ratio = 0f;
		if (flag)
		{
			ratio = base.HealthCpnt.GetHealthRatio();
		}
		EquipmentSlots[slotIndex].DoUnequipItem(checkConfig);
		if (flag)
		{
			base.HealthCpnt.SetHealthRatio(ratio);
		}
	}

	private void InitEquipmentSlots(Dictionary<StaticString, List<ItemPersistentData>> initItemsByCategory = null)
	{
		bool flag = initItemsByCategory == null;
		EquipmentSlots = new EquipmentSlot[Config.EquipmentSlots.Length];
		StaticString staticString = null;
		StaticString staticString2 = null;
		for (int i = 0; i < EquipmentSlots.Length; i++)
		{
			EquipmentSlotConfig equipmentSlotConfig = Config.EquipmentSlots[i];
			EquipmentSlots[i] = new EquipmentSlot(i, equipmentSlotConfig, this);
			EquipmentSlots[i].OnItemChanged += OnItemEquipped;
			staticString = null;
			staticString2 = null;
			if (flag)
			{
				ItemDatatableReference defaultEquippedItem = equipmentSlotConfig.DefaultEquippedItem;
				if (defaultEquippedItem != null)
				{
					staticString = defaultEquippedItem.Name;
					staticString2 = defaultEquippedItem.RarityName;
				}
			}
			else if (initItemsByCategory.ContainsKey(equipmentSlotConfig.CategoryName) && initItemsByCategory[equipmentSlotConfig.CategoryName].Count > 0)
			{
				ItemPersistentData itemPersistentData = initItemsByCategory[equipmentSlotConfig.CategoryName].PullAt(0);
				staticString = itemPersistentData.ItemDescName;
				staticString2 = itemPersistentData.RarityDescName;
			}
			if (!(staticString != null))
			{
				continue;
			}
			InventoryItem inventoryItem = InventoryItem.BuildInventoryItem(staticString, staticString2, null, base.NetSyncElement.OwnerPlayerID);
			if (inventoryItem != null)
			{
				if (inventoryItem.ItemConfig.CategoryParameters.IsCategoryMatching(equipmentSlotConfig))
				{
					EquipmentSlots[i].EquipItem(inventoryItem, removeFromInventory: true, netSync: false, skipRequestToServer: true, checkItemInventory: false);
				}
				else
				{
					Diagnostics.LogError("[Hero] InitEquipmentSlots: the item (" + staticString + ") category and/or type is not matching with the slot for hero " + base.name);
				}
			}
		}
	}

	private void OnItemLootTargetChanged(AITarget previousTarget, AITarget newTarget)
	{
		if (!(gatheringItem == null))
		{
			if (previousTarget.GetComponent<Item>() != gatheringItem)
			{
				Diagnostics.LogError(base.name + " > OnItemLootTargetChanged: previous target != current gathering item");
				return;
			}
			AICpnt.OnTargetChanged -= OnItemLootTargetChanged;
			CancelItemGathering();
		}
	}

	public void OnItemEquipped(EquipmentSlot slot, InventoryItem item, bool equipped)
	{
		if (attackerCpnt != null)
		{
			if (equipped)
			{
				AttackTypeConfig attackTypeConfig = null;
				if (item.ItemConfig.AttackTypeConfigName != null)
				{
					attackTypeConfig = Databases.GetDatabase<AttackTypeConfig>().GetValue(item.ItemConfig.AttackTypeConfigName);
				}
				if (attackTypeConfig != null)
				{
					attackerCpnt.SwitchAttackType(attackTypeConfig);
				}
				base.AudioEmitter.PlayEvent("Master/GUI/EquipItem");
			}
			else
			{
				attackerCpnt.ResetAttackType();
			}
		}
		if (base.HealthCpnt != null)
		{
			base.HealthCpnt.ClampHealth();
		}
		if (item.ItemConfig.Skills != null && item.ItemConfig.Skills.Length > 0)
		{
			string[] skills = item.ItemConfig.Skills;
			foreach (string skillName in skills)
			{
				if (equipped)
				{
					AddSkill(skillName);
				}
				else
				{
					RemoveSkill(skillName);
				}
			}
		}
		if (OperatingModule != null)
		{
			OperatingModule.UpdateOperatorWit(this);
		}
		if (RepairingModule != null)
		{
			RepairingModule.UpdateReparatorWit(this);
		}
	}

	private void RPC_RequestBuyItemFromEquipmentSlot(StaticString itemUniqueIDCategory, int itemUniqueID, int slotIndex, ulong buyerID)
	{
		if (!gameNetManager.IsServerOrSinglePlayer())
		{
			Diagnostics.LogError(base.name + " > Hero.RPC_RequestBuyItemFromEquipmentSlot should only be called on server side!");
			return;
		}
		InventoryItem item = InventoryItem.GetItem(itemUniqueIDCategory, itemUniqueID);
		if (item != null && dungeon.RequestBuyItem(item))
		{
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_DoBuyItemFromEquipmentSlot, itemUniqueIDCategory, itemUniqueID, slotIndex, buyerID);
		}
	}

	private void RPC_DoBuyItemFromEquipmentSlot(StaticString itemUniqueIDCategory, int itemUniqueID, int slotIndex, ulong buyerID)
	{
		InventoryItem item = InventoryItem.GetItem(itemUniqueIDCategory, itemUniqueID);
		if (item == null)
		{
			return;
		}
		FIDS currency = (item.CurrentInventory.ParentSimMB as NPCMerchant).CurrencyCfg.Currency;
		bool flag = buyerID == gameNetManager.GetLocalPlayerID();
		if (gameNetManager.IsMultiplayerSession() && ((currency == FIDS.Dust && !MultiplayerConfig.SplitDust) || (currency != FIDS.Dust && !MultiplayerConfig.SplitFIS)))
		{
			flag = false;
		}
		if (flag && !Player.LocalPlayer.ConsumeFIDS(item.GetCostForCurrency(currency), currency))
		{
			Diagnostics.LogError("Hero.RPC_DoBuyItemFromEquipmentSlot: not enough resources!");
			return;
		}
		if (flag && item.IsGift)
		{
			ItemHero.SendItemAcquisitionNotification(new ItemHeroElement(item));
			audioEventManager.Play2DEvent("Master/GUI/DeathMerchant_Buy");
		}
		bool flag2 = true;
		item.MoveToInventory((!flag2) ? null : dungeon.GetBestAvailableInventoryForPlayer(buyerID));
		item.OwnerPlayerID = buyerID;
		EquipmentSlot equipmentSlot = EquipmentSlots[slotIndex];
		equipmentSlot.DoBuyCurrentItem(item);
		MerchantPanel merchantPanel = SingletonManager.Get<MainGameScreen>().MerchantPanel;
		merchantPanel.OnCurrentItemBought();
	}

	private void RPC_RequestEquipItemFromEquipmentSlot(StaticString itemUniqueIDCategory, int itemUniqueID, int slotIndex, bool removeFromInventory, bool netSync, bool checkItemInventory)
	{
		InventoryItem item = InventoryItem.GetItem(itemUniqueIDCategory, itemUniqueID);
		if (item != null)
		{
			EquipmentSlot equipmentSlot = EquipmentSlots[slotIndex];
			equipmentSlot.RequestEquipItem(item, removeFromInventory, netSync, checkItemInventory);
		}
	}

	public void MoveToRoom(Room room, bool allowMoveInterruption = false, bool isMoveOrderedByPlayer = true, bool triggerTutorialEvent = true)
	{
		if (isMoveOrderedByPlayer && !IsUsable)
		{
			Diagnostics.LogWarning("MoveToRoom: hero is not usable");
		}
		else if (!MoverCpnt.CanMove)
		{
			Diagnostics.LogWarning("MoveToRoom: hero cannot move");
		}
		else if (!base.HealthCpnt.IsAlive())
		{
			Diagnostics.Log(base.name + " > MoveToRoom but hero is dead");
		}
		else
		{
			if ((MoverCpnt.IsMoving && roomMoveTarget == room) || (!MoverCpnt.IsMoving && base.RoomElement.ParentRoom == room))
			{
				return;
			}
			if (isMoveOrderedByPlayer)
			{
				base.AudioEmitter.PlayEvent("Master/GUI/MoveHero");
			}
			if (triggerTutorialEvent && TutorialManager.IsEnable)
			{
				Services.GetService<IGameEventService>()?.TriggerHeroMovedToRoomTutorialEvent();
			}
			if (!room.IsFullyOpened)
			{
				Door openingDoor = room.GetOpeningDoor();
				if (openingDoor != null)
				{
					Diagnostics.Log(base.name + " > move to opening door and then to room");
					MoveToDoor(openingDoor, allowMoveInterruption, null, isMoveOrderedByPlayer: false);
					return;
				}
				Diagnostics.LogError("No door opening room " + room + ", impossible to reach that room");
			}
			ResetMoveTargets();
			roomMoveTarget = room;
			Vector3 centerPosition = room.CenterPosition;
			SetDestMarkerPosition(centerPosition);
			RequestMoveToPosition(centerPosition, null, allowMoveInterruption, room);
		}
	}

	public void MoveToDoor(Door door, bool allowMoveInterruption = false, Door nextMoveDoorTarget = null, bool isMoveOrderedByPlayer = true)
	{
	
	    // error checking 
		if (isMoveOrderedByPlayer && !IsUsable)
		{
			Diagnostics.LogWarning("MoveToDoor: hero is not usable");
		}
		else if (isMoveOrderedByPlayer && HasCrystal)
		{
			Diagnostics.LogWarning("[Hero.MoveToDoor] Hero cannot move to door while carrying the crystal.");
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_CannotOpenDoorCrystal"));
		}
		else if (!MoverCpnt.CanMove)
		{
			Diagnostics.LogWarning("MoveToDoor: hero cannot move");
		}
		else if (!base.HealthCpnt.IsAlive())
		{
			Diagnostics.Log(base.name + " > MoveToDoor but hero is dead");
		}
		
		
		else
		{
			if (MoverCpnt.IsMoving && doorMoveTarget == door)
			{
				return;
			}
			if (isMoveOrderedByPlayer)
			{
				base.AudioEmitter.PlayEvent("Master/GUI/OpenDoorOrder");
			}
			Room uniqueAlreadyOpenRoom = door.GetUniqueAlreadyOpenRoom();
			if (uniqueAlreadyOpenRoom != null && !uniqueAlreadyOpenRoom.IsFullyOpened)
			{
				Door openingDoor = uniqueAlreadyOpenRoom.GetOpeningDoor();
				if (openingDoor != null)
				{
					Diagnostics.Log(base.name + " > move to opening door and then to door");
					MoveToDoor(openingDoor, allowMoveInterruption, door, isMoveOrderedByPlayer: false);
				}
				else
				{
					Diagnostics.LogError("No door opening room " + uniqueAlreadyOpenRoom + ", impossible to reach door " + door);
				}
				return;
			}
			ResetMoveTargets();
			nextMoveDoorMoveTarget = nextMoveDoorTarget;
			if (nextMoveDoorMoveTarget == null)
			{
				nextMoveRoomMoveTarget = door.GetRoomToOpen(base.transform.position);
			}
			else
			{
				nextMoveRoomMoveTarget = null;
			}
			if (nextMoveDoorMoveTarget != null)
			{
				SetDestMarkerPosition(nextMoveDoorMoveTarget.DoorStep.transform.position + doorDestMarkerOffset);
			}
			else
			{
				SetDestMarkerPosition(door.DoorStep.transform.position + doorDestMarkerOffset);
			}
			doorMoveTarget = door;
			RequestMoveToPosition(door.GetOpeningSpot(base.transform.position).position, OnDoorReached, allowMoveInterruption);
			door.RegisterOpener(this);
		}
	}

	public void MoveToHero(Hero hero)
	{
		if (!IsUsable)
		{
			Diagnostics.LogWarning("MoveToHero: hero is not usable");
		}
		else if (MoverCpnt.CanMove)
		{
			if (!base.HealthCpnt.IsAlive())
			{
				Diagnostics.Log(base.name + " > MoveToHero but hero is dead");
			}
			else if (!hero.HealthCpnt.IsAlive())
			{
				Diagnostics.Log(base.name + " > MoveToHero but target is dead");
			}
			else if (!MoverCpnt.IsMoving || !(heroMoveTarget == hero))
			{
				base.AudioEmitter.PlayEvent("Master/GUI/OpenDoorOrder");
				ResetMoveTargets();
				heroMoveTarget = hero;
				SetDestMarkerPosition(heroMoveTarget.transform.position + heroDestMarkerOffset);
				RequestMoveToPosition(heroMoveTarget.transform.position + heroMoveToOffset, OnHeroReached, allowMoveInterruption: false);
			}
		}
	}

	public void MoveToNPC(NPC npc)
	{
		if (!IsUsable)
		{
			Diagnostics.LogWarning("MoveToNPC: hero is not usable");
		}
		else if (MoverCpnt.CanMove)
		{
			if (!base.HealthCpnt.IsAlive())
			{
				Diagnostics.Log(base.name + " > MoveToNPC but hero is dead");
			}
			else if (!npc.HealthCpnt.IsAlive())
			{
				Diagnostics.Log(base.name + " > MoveToNPC but npc is dead");
			}
			else if (HasCrystal)
			{
				Diagnostics.Log(base.name + " > MoveToNPC but carrying the crystal");
			}
			else if (!MoverCpnt.IsMoving || !(npcMoveTarget == npc))
			{
				base.AudioEmitter.PlayEvent("Master/GUI/OpenDoorOrder");
				ResetMoveTargets();
				EndNPCInteraction();
				npcMoveTarget = npc;
				npcMoveTarget.HealthCpnt.OnDeath += OnInteractionTargetDeath;
				SetDestMarkerPosition(npcMoveTarget.transform.position + npcDestMarkerOffset);
				RequestMoveToPosition(npcMoveTarget.transform.position + npcMoveToOffset, OnNPCReached, allowMoveInterruption: false, null, cancelCurrentNPCInteraction: false);
			}
		}
	}

	public void MoveToCrystal(MajorModule crystalModule)
	{
		if (!IsUsable)
		{
			Diagnostics.LogWarning("MoveToCrystal: hero is not usable");
		}
		else if (HasCrystal)
		{
			Diagnostics.LogWarning("[Hero.MoveToCrystal] Hero cannot move to crystal while carrying another crystal.");
		}
		else if (!MoverCpnt.CanMove)
		{
			Diagnostics.LogWarning("MoveToCrystal: hero cannot move");
		}
		else if (!base.HealthCpnt.IsAlive())
		{
			Diagnostics.Log(base.name + " > MoveToCrystal but hero is dead");
		}
		else if (!MoverCpnt.IsMoving || !(crystalMoveTarget == crystalModule))
		{
			Dungeon dungeon = SingletonManager.Get<Dungeon>();
			if (dungeon.ExitRoom == null)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_CrystalUnplugFail_ExitNotFound"));
				return;
			}
			base.AudioEmitter.PlayEvent("Master/GUI/OpenDoorOrder");
			ResetMoveTargets();
			crystalMoveTarget = crystalModule;
			SetDestMarkerPosition(crystalModule.transform.position + crystalDestMarkerOffset);
			RequestMoveToPosition(crystalModule.transform.position + crystalMoveToOffset, UnplugCrystal, allowMoveInterruption: false);
		}
	}

	public void MoveToCrystalSlot(ModuleSlot crystalSlot)
	{
		if (!HasCrystal)
		{
			Diagnostics.LogWarning("[Hero.MoveToCrystalSlot] Hero cannot move to crystal slot if he doesn't carry a crystal.");
			return;
		}
		if (!MoverCpnt.CanMove)
		{
			Diagnostics.LogWarning("MoveToCrystalSlot: hero cannot move");
			return;
		}
		if (!base.HealthCpnt.IsAlive())
		{
			Diagnostics.Log(base.name + " > MoveToCrystalSlot but hero is dead");
			return;
		}
		base.AudioEmitter.PlayEvent("Master/GUI/MoveHero");
		ResetMoveTargets();
		CrystalSlotMoveTarget = crystalSlot;
		SetDestMarkerPosition(crystalSlot.transform.position);
		RequestMoveToPosition(crystalSlot.transform.position, PlugCrystal, allowMoveInterruption: false, null, cancelCurrentNPCInteraction: true, crystalSlotApproachDistance);
		if (base.RoomElement.ParentRoom == crystalSlot.ParentRoom && ((CrystalModuleSlot)crystalSlot).IsExitSlot)
		{
			PlayLevelSuccessCinematic();
		}
	}

	public void MoveToItem(Item item)
	{
		if (!IsUsable)
		{
			Diagnostics.LogWarning("MoveToItem: hero is not usable");
		}
		else if (HasCrystal)
		{
			Diagnostics.LogWarning("[Hero.MoveToItem] Hero cannot move to an item while carrying a crystal.");
		}
		else if (!MoverCpnt.CanMove)
		{
			Diagnostics.LogWarning("MoveToItem: hero cannot move");
		}
		else if (!base.HealthCpnt.IsAlive())
		{
			Diagnostics.Log(base.name + " > MoveToItem but hero is dead");
		}
		else if (!(itemMoveTarget == item) && !(gatheringItem == item) && (!MoverCpnt.IsMoving || !(itemMoveTarget == item)))
		{
			ResetMoveTargets();
			itemMoveTarget = item;
			RequestMoveToPosition(item.GetGatheringPosition(), OnItemReached);
		}
	}

	public void MoveToSpecialMajorModule(SpecialMajorModule module)
	{
		if (!IsUsable)
		{
			Diagnostics.LogWarning("MoveToSpecialMajorModule: hero is not usable");
		}
		else if (HasCrystal)
		{
			Diagnostics.LogWarning("[Hero.MoveToSpecialMajorModule] Hero cannot move to a module while carrying a crystal.");
		}
		else if (!MoverCpnt.CanMove)
		{
			Diagnostics.LogWarning("MoveToSpecialMajorModule: hero cannot move");
		}
		else if (!base.HealthCpnt.IsAlive())
		{
			Diagnostics.Log(base.name + " > MoveToSpecialMajorModule but hero is dead");
		}
		else if (!module.HealthCpnt.IsAlive())
		{
			Diagnostics.Log(base.name + " > MoveToSpecialMajorModule but module is destroyed");
		}
		else if (!MoverCpnt.IsMoving || !(specialMajorModuleMoveTarget == module))
		{
			base.AudioEmitter.PlayEvent("Master/GUI/OpenDoorOrder");
			ResetMoveTargets();
			specialMajorModuleMoveTarget = module;
			Vector3 position = module.transform.position;
			SetDestMarkerPosition(position + specialModuleDestMarkerOffset);
			RequestMoveToPosition(position, OnSpecialMajorModuleReached, allowMoveInterruption: false);
		}
	}

	public void MoveToRoomInteractibleElement(Room room)
	{
		if (room.NPCs.Count > 0)
		{
			MoveToNPC(room.NPCs[0]);
			return;
		}
		if (room.Heroes.Count > 0)
		{
			for (int i = 0; i < room.Heroes.Count; i++)
			{
				Hero hero = room.Heroes[i];
				if (!hero.IsRecruited)
				{
					MoveToHero(hero);
					return;
				}
			}
		}
		if (room.MajorModule != null && room.MajorModule is SpecialMajorModule)
		{
			MoveToSpecialMajorModule((SpecialMajorModule)room.MajorModule);
		}
		else if (room.IsStartRoom && room.MajorModule != null && room.MajorModule.IsCrystal)
		{
			MoveToCrystal(room.MajorModule);
		}
	}

	public void OnBlockingDoorOpened()
	{
		if (IsRespawning)
		{
			return;
		}
		if (!base.HealthCpnt.IsAlive())
		{
			Diagnostics.Log(base.name + " > OnBlockingDoorOpened but hero is dead");
			return;
		}
		Door door = nextMoveDoorMoveTarget;
		Room room = nextMoveRoomMoveTarget;
		nextMoveDoorMoveTarget = null;
		nextMoveRoomMoveTarget = null;
		base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_DisplayDoorOpeningStop);
		if (door != null)
		{
			MoveToDoor(door, allowMoveInterruption: false, null, isMoveOrderedByPlayer: false);
		}
		else if (room != null)
		{
			MoveToRoom(room, allowMoveInterruption: false, isMoveOrderedByPlayer: false, triggerTutorialEvent: false);
		}
	}

	public void OnMoveByAI()
	{
		nextMoveDoorMoveTarget = null;
		nextMoveRoomMoveTarget = null;
	}

	private void RequestMoveToPosition(Vector3 position, MoveTargetReachedHandler onMoveTargetReached = null, bool allowMoveInterruption = true, Room moveInterruptionAllowedRoom = null, bool cancelCurrentNPCInteraction = true, float approachDistance = 0f)
	{
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Hero.RequestMoveToPosition should only be called on owner side!");
			return;
		}
		if (!base.HealthCpnt.IsAlive())
		{
			Diagnostics.Log(base.name + " > RequestMoveToPosition but hero is dead");
			return;
		}
		CancelItemGathering();
		if (cancelCurrentNPCInteraction)
		{
			EndNPCInteraction();
		}
		AICpnt.AllowMoveInterruption(allowMoveInterruption, moveInterruptionAllowedRoom);
		MoverCpnt.MoveToPosition(position, onMoveTargetReached, forceRePath: false, approachDistance);
	}

	private void OnDoorReached()
	{
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError("{0} > Hero.OnDoorReached should only be called on owner side!", base.name);
			return;
		}
		if (doorMoveTarget == null)
		{
			Diagnostics.LogError("{0} > Hero.OnDoorReached: this.doorMoveTarget is null!", base.name);
			return;
		}
		LockInteractions();
		AICpnt.IsActive = false;
		if (nextMoveRoomMoveTarget != null)
		{
			IsUsable = false;
		}
		if (allowAnim)
		{
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_DisplayDoorOpening, doorMoveTarget.transform.position - base.transform.position);
		}
		if (!doorMoveTarget.IsOpening)
		{
			doorMoveTarget.OpenByHeroOrMob(nextMoveRoomMoveTarget, this);
		}
	}

	private void RPC_DisplayDoorOpening(Vector3 animDirection)
	{
		spriteAnim.SetAnimDirection(animDirection);
		spriteAnim.SetBool(SpriteAnimationBool.IsActionning, value: true);
	}

	private void RPC_DisplayDoorOpeningStop()
	{
		spriteAnim.SetBool(SpriteAnimationBool.IsActionning, value: false);
	}

	private void OnItemReached()
	{
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Hero.OnItemReached should only be called on owner side!");
		}
		else if (!(itemMoveTarget == null))
		{
			StartItemGathering(itemMoveTarget);
			itemMoveTarget = null;
		}
	}

	private void OnHeroReached()
	{
		if (HasCrystal)
		{
			Diagnostics.Log(base.name + " > Cannot recruit heroes while carrying the crystal");
		}
		else if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Hero.OnHeroReached should only be called on owner side!");
		}
		else if (heroMoveTarget != null && !heroMoveTarget.IsRecruited)
		{
			heroMoveTarget.DisplayRecruitmentDialog();
		}
	}

	private void OnNPCReached()
	{
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Hero.OnNPCReached should only be called on owner side!");
		}
		else if (npcMoveTarget != null)
		{
			npcMoveTarget.BeginInteraction(this);
			IsInteracting = true;
		}
	}

	private void OnSpecialMajorModuleReached()
	{
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Hero.OnSpecialMajorModuleReached should only be called on owner side!");
		}
		else if (specialMajorModuleMoveTarget != null)
		{
			specialMajorModuleMoveTarget.Interact(this);
		}
	}

	private void OnMoveStopped()
	{
		if (destRoomMarkerRnd != null)
		{
			destRoomMarkerRnd.enabled = (nextMoveDoorMoveTarget != null || nextMoveRoomMoveTarget != null);
		}
	}

	private void Mover_OnMoveDirectionChanged(Vector3 direction)
	{
		crystalContainer.localPosition = direction.normalized * crystalDistanceToPlayer + Vector3.up * crystalHeight;
	}

	private void ResetMoveTargets()
	{
		nextMoveDoorMoveTarget = null;
		nextMoveRoomMoveTarget = null;
		roomMoveTarget = null;
		heroMoveTarget = null;
		npcMoveTarget = null;
		doorMoveTarget = null;
		crystalMoveTarget = null;
		specialMajorModuleMoveTarget = null;
		CrystalSlotMoveTarget = null;
		itemMoveTarget = null;
	}

	public void AddSkill(string skillName)
	{
		AddSkill(Databases.GetDatabase<SkillConfig>().GetValue(skillName));
	}

	public void AddSkill(SkillConfig skillConfig)
	{
		skillConfig.Init();
		if (skillConfig.IsActive)
		{
			GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(activeSkillPfb, base.transform.position, Quaternion.identity);
			gameObject.transform.parent = base.transform;
			gameObject.name = skillConfig.Name;
			ActiveSkill component = gameObject.GetComponent<ActiveSkill>();
			component.Init(base.NetSyncElement.OwnerPlayerID, skillConfig, this);
			activeSkills.Add(component);
			FilterActiveSkills();
		}
		else
		{
			GameObject gameObject2 = (GameObject)UnityEngine.Object.Instantiate(passiveSkillPfb, base.transform.position, Quaternion.identity);
			gameObject2.transform.parent = base.transform;
			gameObject2.name = skillConfig.Name;
			PassiveSkill passiveSkill = gameObject2.AddComponent<PassiveSkill>();
			passiveSkill.Init(base.NetSyncElement.OwnerPlayerID, skillConfig, this);
			passiveSkills.Add(passiveSkill);
			FilterPassiveSkills();
		}
		if (this.OnSkillsChanged != null)
		{
			this.OnSkillsChanged();
		}
	}

	public void RemoveSkill(string skillName)
	{
		RemoveSkill(Databases.GetDatabase<SkillConfig>().GetValue(skillName));
	}

	public void RemoveSkill(SkillConfig skillConfig)
	{
		if (skillConfig.IsActive)
		{
			for (int i = 0; i < activeSkills.Count; i++)
			{
				ActiveSkill activeSkill = activeSkills[i];
				if (activeSkill.Config.Name == skillConfig.Name)
				{
					if (activeSkill.IsActivated)
					{
						activeSkill.Deactivate();
					}
					activeSkills.RemoveAt(i);
					i--;
					UnityEngine.Object.Destroy(activeSkill.gameObject);
					break;
				}
			}
			FilterActiveSkills();
		}
		else
		{
			for (int j = 0; j < passiveSkills.Count; j++)
			{
				PassiveSkill passiveSkill = passiveSkills[j];
				if (passiveSkill.Config.Name == skillConfig.Name)
				{
					passiveSkills.RemoveAt(j);
					j--;
					UnityEngine.Object.Destroy(passiveSkill.gameObject);
					break;
				}
			}
			FilterPassiveSkills();
		}
		if (this.OnSkillsChanged != null)
		{
			this.OnSkillsChanged();
		}
	}

	private void FilterActiveSkills()
	{
		if (FilteredActiveSkills == null)
		{
			FilteredActiveSkills = new List<ActiveSkill>();
		}
		else
		{
			FilteredActiveSkills.Clear();
		}
		for (int i = 0; i < activeSkills.Count; i++)
		{
			ActiveSkill activeSkill = activeSkills[i];
			ActiveSkill activeSkill2 = null;
			for (int j = 0; j < FilteredActiveSkills.Count; j++)
			{
				if (FilteredActiveSkills[j].Config.BaseName == activeSkill.Config.BaseName)
				{
					activeSkill2 = FilteredActiveSkills[j];
					break;
				}
			}
			if (activeSkill2 != null)
			{
				if (activeSkill.Config.Level > activeSkill2.Config.Level)
				{
					FilteredActiveSkills.Remove(activeSkill2);
					FilteredActiveSkills.Add(activeSkill);
				}
			}
			else
			{
				FilteredActiveSkills.Add(activeSkill);
			}
		}
	}

	private void FilterPassiveSkills()
	{
		RemovePassiveSkillsEffects();
		if (FilteredPassiveSkills == null)
		{
			FilteredPassiveSkills = new List<PassiveSkill>();
		}
		else
		{
			FilteredPassiveSkills.Clear();
		}
		for (int i = 0; i < passiveSkills.Count; i++)
		{
			PassiveSkill passiveSkill = passiveSkills[i];
			PassiveSkill passiveSkill2 = null;
			for (int j = 0; j < FilteredPassiveSkills.Count; j++)
			{
				if (FilteredPassiveSkills[j].Config.BaseName == passiveSkill.Config.BaseName)
				{
					passiveSkill2 = FilteredPassiveSkills[j];
					break;
				}
			}
			if (passiveSkill2 != null)
			{
				if (passiveSkill.Config.Level > passiveSkill2.Config.Level)
				{
					FilteredPassiveSkills.Remove(passiveSkill2);
					FilteredPassiveSkills.Add(passiveSkill);
				}
			}
			else
			{
				FilteredPassiveSkills.Add(passiveSkill);
			}
		}
		ApplyPassiveSkillsEffects();
	}

	public void ActivateActiveSkill(int activeSkillIndex)
	{
		if (activeSkillIndex < 0 || activeSkillIndex > FilteredActiveSkills.Count - 1)
		{
			Diagnostics.Log("Unable to activate active skill #" + activeSkillIndex + ": INDEX OUT OF BOUNDS!");
		}
		else
		{
			FilteredActiveSkills[activeSkillIndex].Activate();
		}
	}

	public void DeactivateActiveSkills()
	{
		foreach (ActiveSkill filteredActiveSkill in FilteredActiveSkills)
		{
			if (filteredActiveSkill.IsActivated)
			{
				filteredActiveSkill.Deactivate();
			}
		}
	}

	public ActiveSkill ActiveSkillLesserThan(SkillConfig skillConf)
	{
		for (int i = 0; i < FilteredActiveSkills.Count; i++)
		{
			if (FilteredActiveSkills[i].Config.BaseName == skillConf.BaseName && FilteredActiveSkills[i].Config.Level < skillConf.Level)
			{
				return FilteredActiveSkills[i];
			}
		}
		return null;
	}

	public PassiveSkill PassiveSkillLesserThan(SkillConfig skillConf)
	{
		for (int i = 0; i < FilteredPassiveSkills.Count; i++)
		{
			if (FilteredPassiveSkills[i].Config.BaseName == skillConf.BaseName && FilteredPassiveSkills[i].Config.Level < skillConf.Level)
			{
				return FilteredPassiveSkills[i];
			}
		}
		return null;
	}

	private void RemovePassiveSkillsEffects()
	{
		foreach (PassiveSkill filteredPassiveSkill in FilteredPassiveSkills)
		{
			filteredPassiveSkill.RemoveEffects();
		}
	}

	private void ApplyPassiveSkillsEffects()
	{
		foreach (PassiveSkill filteredPassiveSkill in FilteredPassiveSkills)
		{
			filteredPassiveSkill.ApplyEffects();
		}
	}

	public static void SwitchHero(int indexInc)
	{
		if (LocalPlayerActiveRecruitedHeroes.Count < 1)
		{
			Diagnostics.LogError("No more heroes to switch to!");
			return;
		}
		int num = 0;
		if (selectedHeroes.Count == 1)
		{
			num = localPlayerActiveRecruitedHeroes.IndexOf(selectedHeroes[0]);
		}
		num = (num + indexInc + localPlayerActiveRecruitedHeroes.Count) % localPlayerActiveRecruitedHeroes.Count;
		localPlayerActiveRecruitedHeroes[num].Select();
	}

	public static void SelectAllHeroes()
	{
		bool unselectOthers = true;
		foreach (Hero localPlayerActiveRecruitedHero in localPlayerActiveRecruitedHeroes)
		{
			localPlayerActiveRecruitedHero.Select(recordSelectTime: true, unselectOthers);
			unselectOthers = false;
		}
	}

	public static void UnlockHero(HeroConfig heroConfig, bool checkStatus = true)
	{
		int num = UserProfile.Data.HeroesGameStats.FindIndex((HeroGameStatsData h) => h.ConfigName == heroConfig.Name);
		if (num < 0)
		{
			Diagnostics.LogError("No game stats for " + heroConfig.Name + "!");
			return;
		}
		HeroGameStatsData value = UserProfile.Data.HeroesGameStats[num];
		if (heroConfig.IsHidden())
		{
			return;
		}
		if (checkStatus && value.Status != HeroStatus.Discovered)
		{
			Diagnostics.LogError((string)heroConfig.Name + " not discovered (" + value.Status + ")!");
			return;
		}
		AchievementManagerDOTE achievementManagerDOTE = SingletonManager.Get<AchievementManagerDOTE>();
		achievementManagerDOTE.IncrementStatistic((heroConfig.Name.ToString().ToUpper() + "_UNLOCKS").ToEnum<StatisticName>());
		achievementManagerDOTE.IncrementStatistic(StatisticName.ANY_HERO_UNLOCKS);
		if (value.Status == HeroStatus.Unlocked)
		{
			Diagnostics.LogError(heroConfig.Name + " already unlocked!");
			return;
		}
		value.Status = HeroStatus.Unlocked;
		UserProfile.Data.HeroesGameStats[num] = value;
		UserProfile.SaveToFile();
		IGuiService service = Services.GetService<IGuiService>();
		Diagnostics.Assert(service != null);
		if (service.GuiPanelHelper.TryGetGuiElement(heroConfig.Name, out GuiElement guiElement))
		{
			string newValue = AgeLocalizer.Instance.LocalizeString(guiElement.Title);
			Dungeon dungeon = SingletonManager.Get<Dungeon>();
			if (dungeon != null)
			{
				dungeon.EnqueueUnlockNotification(AgeLocalizer.Instance.LocalizeString("%Notification_HeroUnlocked").Replace("$HeroName", newValue), NotificationType.MiscUnlock, null, heroConfig.Name, foreGround: false, heroConfig.Name);
			}
		}
	}

	public static List<Hero> GetAllPlayersActiveRecruitedHeroes()
	{
		List<Hero> list = new List<Hero>();
		list.AddRange(localPlayerActiveRecruitedHeroes);
		list.AddRange(remotePlayersActiveRecruitedHeroes);
		return list;
	}

	public static List<Hero> GetLevelWinningHeroes()
	{
		List<Hero> list = new List<Hero>();
		for (int i = 0; i < LocalPlayerActiveRecruitedHeroes.Count; i++)
		{
			Hero hero = LocalPlayerActiveRecruitedHeroes[i];
			if (hero.WasInExitRoomAtExitTime)
			{
				list.Add(hero);
			}
		}
		for (int j = 0; j < RemotePlayersActiveRecruitedHeroes.Count; j++)
		{
			Hero hero = RemotePlayersActiveRecruitedHeroes[j];
			if (hero.WasInExitRoomAtExitTime)
			{
				list.Add(hero);
			}
		}
		return list;
	}

	public void InitForGameStart(ulong ownerPlayerID, StaticString heroDescName, Room spawnRoom)
	{
		Init(ownerPlayerID, heroDescName, spawnRoom, isRecruited: true, registerRecruitment: true, 1, 0, hasOperatingBonus: false, null, displayRecruitmentDialog: true, consumeLevelUpFood: true, updateDiscoverableHeroPool: true, 1, null, isStartingHero: true);
	}

	public void InitForEvent(ulong ownerPlayerID, StaticString heroDescName, Room spawnRoom, bool displayRecruitmentDialog, int level, bool recruitable = true)
	{
		Init(ownerPlayerID, heroDescName, spawnRoom, isRecruited: false, registerRecruitment: false, level, 0, hasOperatingBonus: false, null, displayRecruitmentDialog, consumeLevelUpFood: false, updateDiscoverableHeroPool: true, -1, null, isStartingHero: false, 0, recruitable);
	}

	public void InitForSaveRestore(ulong ownerPlayerID, StaticString heroDescName, Room spawnRoom, bool isRecruited, int initLevel, int unlockLevel, bool hasOperatingBonus, Dictionary<StaticString, List<ItemPersistentData>> initItemsByCategory, int floorRecruited, StaticString[] permanentDescriptors, bool isStartingHero, int currentRespawnRoomCount, bool recruitable)
	{
		Init(ownerPlayerID, heroDescName, spawnRoom, isRecruited, registerRecruitment: false, initLevel, unlockLevel, hasOperatingBonus, initItemsByCategory, displayRecruitmentDialog: false, consumeLevelUpFood: false, updateDiscoverableHeroPool: false, floorRecruited, permanentDescriptors, isStartingHero, currentRespawnRoomCount, recruitable);
	}

	private void Init(ulong ownerPlayerID, StaticString heroDescName, Room spawnRoom, bool isRecruited = false, bool registerRecruitment = true, int initLevel = 1, int unlockLevel = 0, bool hasOperatingBonus = false, Dictionary<StaticString, List<ItemPersistentData>> initItemsByCategory = null, bool displayRecruitmentDialog = true, bool consumeLevelUpFood = true, bool updateDiscoverableHeroPool = true, int floorRecruited = 1, StaticString[] permanentDescriptors = null, bool isStartingHero = false, int currentRespawnRoomCount = 0, bool recruitable = true)
	{
		Init(ownerPlayerID);
		base.NetSyncElement.OnOwnerLeft += OnOwnerLeft;
		base.NetSyncElement.OnOwnerChanged += OnOwnerChanged;
		gameControlManager = Services.GetService<IGameControlService>();
		selectableManager = SingletonManager.Get<SelectableManager>();
		activeSkills = new List<ActiveSkill>();
		FilteredActiveSkills = new List<ActiveSkill>();
		passiveSkills = new List<PassiveSkill>();
		FilteredPassiveSkills = new List<PassiveSkill>();
		FloorRecruited = floorRecruited;
		IsStartingHero = isStartingHero;
		CurrentRespawnRoomCount = currentRespawnRoomCount;
		IsRecruitable = recruitable;
		if (operatingBonusGenericSimDesc == null)
		{
			operatingBonusGenericSimDesc = SimMonoBehaviour.GetDBDescriptorByName("Hero_Operating_Bonus");
		}
		Config = Databases.GetDatabase<HeroConfig>().GetValue(heroDescName);
		if (Config == null)
		{
			Diagnostics.LogError("Unable to find hero config by name = " + heroDescName + " in config pool");
			return;
		}
		SimulationDescriptor dBDescriptorByName = SimMonoBehaviour.GetDBDescriptorByName(Config.Name);
		base.name = dBDescriptorByName.Name.ToString().Replace("Hero_", string.Empty) + "_" + base.name;
		AddSimDescriptor(dBDescriptorByName);
		IGuiService service = Services.GetService<IGuiService>();
		Diagnostics.Assert(service != null);
		if (service.GuiPanelHelper.TryGetGuiElement(Config.Name, out GuiElement guiElement))
		{
			LocalizedName = AgeLocalizer.Instance.LocalizeString(guiElement.Title);
		}
		else
		{
			Diagnostics.LogError("Unable to find localized name for " + base.name);
		}
		if (Config.SituationDialogCount == null)
		{
			Config.SituationDialogCount = new Dictionary<StaticString, int>();
			SituationDialogType[] enumValues = GenericUtilities.GetEnumValues<SituationDialogType>();
			foreach (SituationDialogType situationDialogType in enumValues)
			{
				string str = "%" + Config.Name + "_SituationDialog_" + situationDialogType.ToString();
				int num = 1;
				string b;
				while (AgeLocalizer.Instance.LocalizeString(b = str + num.ToString()) != b)
				{
					num++;
				}
				Config.SituationDialogCount.Add(situationDialogType.ToString(), num - 1);
			}
		}
		spriteAnim.OverrideClipsFromPath("SpriteAnimations/Hero/" + Config.Name.ToString().Replace("Hero_", string.Empty));
		tacticalMapElementAnim.OverrideClipsFromPath("SpriteAnimations/Hero/" + Config.Name.ToString().Replace("Hero_", string.Empty));
		crystalSprite.OverrideClipsFromPath("SpriteAnimations/Modules/" + SimulationProperties.SpecialModule_Crystal + "_" + SingletonManager.Get<Dungeon>().CrystalType);
		base.transform.position += 0.001f * Vector3.up;
		spawnRoom.OnHeroEnter(this);
		HasOperatingBonus = hasOperatingBonus;
		Bind();
		attackerCpnt.Init(Config.AttackType);
		if (!isRecruited)
		{
			heroAttackTargetCpnt.Init(isActive: true, AITargetType.FreeHero);
		}
		else
		{
			heroAttackTargetCpnt.Init(isActive: true, Config.AITargetType);
		}
		mobsAggroAttackTargetCpnt.Init(isActive: false);
		levelConfigs = new List<HeroLevelConfig>();
		levelUpModifiersByLevel = new List<Dictionary<StaticString, float>>();
		int num2 = 1;
		while (true)
		{
			string levelDescriptorName = GetLevelDescriptorName(num2);
			IDatabase<HeroLevelConfig> database = Databases.GetDatabase<HeroLevelConfig>();
			HeroLevelConfig value = database.GetValue(levelDescriptorName);
			if (value == null)
			{
				break;
			}
			if (value.Skills != null)
			{
				value.HasActiveSkills = false;
				for (int j = 0; j < value.Skills.Length; j++)
				{
					if (value.Skills[j].StartsWith("Skill_A"))
					{
						value.HasActiveSkills = true;
						break;
					}
				}
				value.HasPassiveSkills = false;
				for (int k = 0; k < value.Skills.Length; k++)
				{
					if (value.Skills[k].StartsWith("Skill_P"))
					{
						value.HasPassiveSkills = true;
						break;
					}
				}
			}
			levelConfigs.Add(value);
			Dictionary<StaticString, float> dictionary = new Dictionary<StaticString, float>();
			SimulationDescriptor dBDescriptorByName2 = SimMonoBehaviour.GetDBDescriptorByName(levelDescriptorName);
			if (dBDescriptorByName2 != null)
			{
				SimulationObject simObj = GetSimObj();
				SimulationModifierDescriptor[] simulationModifierDescriptors = dBDescriptorByName2.SimulationModifierDescriptors;
				foreach (SimulationModifierDescriptor simulationModifierDescriptor in simulationModifierDescriptors)
				{
					dictionary.Add(simulationModifierDescriptor.TargetPropertyName, simulationModifierDescriptor.ComputeValue(simObj, simObj, SimulationPropertyRefreshContext.GetContext()));
				}
			}
			levelUpModifiersByLevel.Add(dictionary);
			num2++;
		}
		IsUsable = true;
		string text = "VFX/LevelUp/Hero";
		GameObject gameObject = (GameObject)Resources.Load(text, typeof(GameObject));
		if (gameObject != null)
		{
			GameObject gameObject2 = (GameObject)UnityEngine.Object.Instantiate(gameObject, base.transform.position, base.transform.rotation);
			gameObject2.transform.parent = base.transform;
			levelUpVfxParticles = gameObject2.GetComponent<ParticleSystem>();
		}
		else
		{
			Diagnostics.LogWarning("No level up VFX found for " + base.name + " (path=" + text + ")");
		}
		RefreshSim();
		base.HealthCpnt.InitHealth(eligibleToInstaRegen: true);
		Vector3 localScale = base.HealthCpnt.HealthBar.BarContainer.localScale;
		initalHealthBarScaleY = localScale.y;
		Vector3 localScale2 = base.HealthCpnt.HealthBar.BarContainer.localScale;
		initalHealthBarScaleX = localScale2.x;
		base.HealthCpnt.HealthBar.UpdateHealthBarHeight();
		base.HealthCpnt.OnHealthChanged += OnHealthChanged;
		InitEquipmentSlots(initItemsByCategory);
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			for (int m = 1; m <= initLevel; m++)
			{
				LevelUp(playFeedback: false, consumeLevelUpFood);
			}
		}
		UnlockLevel = unlockLevel;
		PermanentDescriptors = new List<SimulationDescriptor>();
		if (permanentDescriptors != null)
		{
			foreach (StaticString x in permanentDescriptors)
			{
				AddPermanentDescriptor(x);
			}
		}
		SelectionCategoryConfig currentCategoryConfig = selectableManager.GetCurrentCategoryConfig();
		if (currentCategoryConfig.EnableNonContextualControl && !isRecruited && displayRecruitmentDialog && base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			IGameCameraService service2 = Services.GetService<IGameCameraService>();
			if (!service2.IsTacticalMapActive() && !service2.IsSwitchingCamera)
			{
				service2.Focus(base.transform.position, LerpType.Smoothed, -1f);
				if (Services.GetService<IInputService>().CurrentControlScheme != ControlScheme.XBoxOneController)
				{
					service2.ZoomIn();
				}
			}
			DisplayRecruitmentDialog();
			base.RoomElement.ParentRoom.SelectableForMove.Select(silent: true);
		}
		dungeon.RegisterHeroSpawn(this, updateDiscoverableHeroPool);
		if (isRecruited && base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Recruit(consumeFood: false, registerRecruitment, requestAccessToServer: false);
		}
		UpdateAICpnt();
		if (IsRecruited && UnlockLevel > 0 && dungeon.Level >= UnlockLevel && base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			if (dungeon.Level > UnlockLevel)
			{
				Diagnostics.LogError((string)Config.Name + " should have been unlocked when reaching level " + UnlockLevel + "!");
			}
			UnlockHero(Config);
			UnlockLevel = 0;
		}
		gameEventManager.OnGameVictory += OnGameVictory;
		spriteAnim.MonitorAnimEvent("OnDeathEnd", OnDeathEndAnimEvent);
	}

	private void UpdateAICpnt()
	{
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			if (GetSimPropertyValue(SimulationProperties.RepairFirst) > 0f)
			{
				AICpnt.Init("RepairFirstHero");
			}
			else if (!IsRecruited)
			{
				AICpnt.Init($"Free{Config.Name}");
			}
			else
			{
				AICpnt.Init(Config.Name);
			}
			AICpnt.OnTargetChanged += OnAITargetChanged;
		}
		else
		{
			AICpnt.IsActive = false;
		}
	}

	private void OnOwnerLeft()
	{
		if (gameNetManager.IsServer())
		{
			GiveToPlayer(gameNetManager.GetLocalPlayerID(), checkIfOwnedByLocalPlayer: false);
		}
	}

	private void OnOwnerChanged()
	{
		UpdateAICpnt();
	}

	private void DisplayPlayerName()
	{
		if (playerNamePanel == null)
		{
			GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(playerNamePanelPfb, Vector3.zero, Quaternion.identity);
			gameObject.transform.parent = SingletonManager.Get<MainGameScreen>().HeroPlayerNameContainerTfm;
			gameObject.GetComponent<GameToScreenPositionSync>().GameEntityTfm = base.transform;
			playerNamePanel = gameObject.GetComponent<HeroPlayerNamePanel>();
		}
		HeroPlayerNamePanel heroPlayerNamePanel = playerNamePanel;
		string playerName = gameNetManager.GetPlayerName(base.NetSyncElement.OwnerPlayerID);
		Vector3 containerScale = dungeon.ContainerScale;
		heroPlayerNamePanel.DisplayPlayerName(playerName, containerScale.y * GetSimPropertyValue(SimulationProperties.HealthBarHeight));
	}

	private void HidePlayerName()
	{
		if (playerNamePanel != null)
		{
			playerNamePanel.Hide();
		}
	}

	public void RegisterAttackingMob(Mob mob)
	{
		attackingMobCount++;
		OnAttackingMobCountChanged();
	}

	public void UnregisterAttackingMob(Mob mob)
	{
		attackingMobCount--;
		OnAttackingMobCountChanged();
	}

	public float GetHiringFoodCost()
	{
		return Config.RecruitmentFoodCost + GenericUtilities.RoundHalfAwayFromZero((float)(base.Level * base.Level) * GameConfig.GetGameConfig().HiringFoodCoef);
	}

	public bool CanBeRecruited(bool consumeFood = true, bool checkPlayerMaxHeroCount = true, bool displayErrors = true)
	{
		if (IsRecruited)
		{
			Diagnostics.Log(base.name + " > Hero.CanBeRecruited: cannot recruit an already recruited hero!");
			return false;
		}
		if (IsDismissing)
		{
			Diagnostics.Log(base.name + " > Hero.CanBeRecruited: cannot recruit a dismissed hero!");
			return false;
		}
		if (!base.HealthCpnt.IsAlive())
		{
			Diagnostics.Log(base.name + " > Hero.CanBeRecruited: cannot recruit a dead hero!");
			return false;
		}
		if (checkPlayerMaxHeroCount && (float)localPlayerActiveRecruitedHeroes.Count >= GameConfig.GetGameConfig().PlayerMaxHeroCount.GetValue())
		{
			Diagnostics.Log(base.name + " > Hero.CanBeRecruited: player max hero count reached!");
			if (displayErrors)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_HeroRecruitmentFailMaxPlayerHeroCount"));
			}
			return false;
		}
		if (localPlayerActiveRecruitedHeroes.Count + remotePlayersActiveRecruitedHeroes.Count >= GameConfig.GetGameConfig().MaxHeroCount)
		{
			Diagnostics.Log(base.name + " > Hero.CanBeRecruited: total max hero count reached!");
			if (displayErrors)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_HeroRecruitmentFailMaxTotalHeroCount"));
			}
			return false;
		}
		if (consumeFood && Player.LocalPlayer.FoodStock < GetHiringFoodCost())
		{
			Diagnostics.Log(base.name + " > Hero.CanBeRecruited: not enough food!");
			if (displayErrors)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_HeroRecruitmentFailResources"));
			}
			return false;
		}
		return true;
	}

	public void Recruit(bool consumeFood = true, bool registerRecruitment = true, bool requestAccessToServer = true)
	{
		if (!CanBeRecruited(consumeFood))
		{
			Diagnostics.Log(base.name + " > Hero.Recruit: cannot be recruited!");
			return;
		}
		bool flag = consumeFood;
		bool flag2 = false;
		if (consumeFood && gameNetManager.IsMultiplayerSession() && MultiplayerConfig.SplitFIS)
		{
			flag = false;
			flag2 = true;
		}
		if (consumeFood)
		{
			FloorRecruited = dungeon.Level;
		}
		if (requestAccessToServer)
		{
			base.NetSyncElement.SendRPCToServer(UniqueIDRPC.Hero_RequestRecruit, gameNetManager.GetLocalPlayerID(), flag, flag2, registerRecruitment);
		}
		else if (flag2 && !Player.LocalPlayer.ConsumeFood(GetHiringFoodCost()))
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_HeroRecruitmentFailResources"));
		}
		else
		{
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_DoRecruit, gameNetManager.GetLocalPlayerID(), registerRecruitment, false);
		}
	}

	private void RPC_RequestRecruit(ulong recruiterPlayerID, bool consumeFoodOnServer, bool consumeFoodOnRecruiter, bool registerRecruitment)
	{
		if (!gameNetManager.IsServer())
		{
			Diagnostics.LogError(base.name + " > Hero.RPC_RequestRecruit should only be called on server side!");
			return;
		}
		if (!CanBeRecruited(consumeFoodOnServer, checkPlayerMaxHeroCount: false, displayErrors: false))
		{
			Diagnostics.Log(base.name + " > Hero.RPC_RequestRecruit: cannot be recruited!");
			return;
		}
		if (consumeFoodOnServer && !Player.LocalPlayer.ConsumeFood(GetHiringFoodCost()))
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_HeroRecruitmentFailResources"));
			return;
		}
		if (consumeFoodOnRecruiter || consumeFoodOnServer)
		{
			SingletonManager.Get<AchievementManagerDOTE>().IncrementStatistic(StatisticName.HIRED_HEROES);
		}
		base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_DoRecruit, recruiterPlayerID, registerRecruitment, consumeFoodOnRecruiter);
	}

	private void RPC_DoRecruit(ulong recruiterPlayerID, bool registerRecruitment, bool consumeFoodOnRecruiter)
	{
		bool consumeFood = consumeFoodOnRecruiter && gameNetManager.GetLocalPlayerID() == recruiterPlayerID;
		bool checkPlayerMaxHeroCount = gameNetManager.GetLocalPlayerID() == recruiterPlayerID;
		if (!CanBeRecruited(consumeFood, checkPlayerMaxHeroCount, displayErrors: false))
		{
			Diagnostics.LogError(base.name + " > Hero.RPC_DoRecruit: cannot be recruited!");
			return;
		}
		if (consumeFoodOnRecruiter && gameNetManager.GetLocalPlayerID() == recruiterPlayerID && !Player.LocalPlayer.ConsumeFood(GetHiringFoodCost()))
		{
			Diagnostics.LogError(base.name + " > Hero.RPC_DoRecruit: not enough resources!");
			return;
		}
		RecentlyDeceasedHeroes.Clear();
		if (base.NetSyncElement.OwnerPlayerID != recruiterPlayerID)
		{
			base.NetSyncElement.ChangeOwner(recruiterPlayerID);
		}
		if (achievementManager == null)
		{
			achievementManager = SingletonManager.Get<AchievementManagerDOTE>();
		}
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			AICpnt.UpdateAIType(Config.Name);
			ModifyLocalActiveHeroes(add: true, this);
			if (localPlayerActiveRecruitedHeroes.Count >= 4)
			{
				achievementManager.IncrementStatistic(StatisticName.FULL_TEAM);
			}
		}
		else
		{
			remotePlayersActiveRecruitedHeroes.Add(this);
			DisplayPlayerName();
		}
		gameEventManager.TriggerHeroListChangedEvent();
		if (base.NetSyncElement.IsOwnedByLocalPlayer() && registerRecruitment)
		{
			dungeon.RegisterHeroRecruitment(this);
		}
		if (heroAttackTargetCpnt.Type != Config.AITargetType)
		{
			heroAttackTargetCpnt.UpdateType(Config.AITargetType);
		}
		IsRecruited = true;
		base.HealthCpnt.HealthBar.ShowEvenWhenHolderIsHidden = true;
		if (base.RoomElement.ParentRoom != null)
		{
			base.RoomElement.ParentRoom.UpdateLightsOnHeroEnter();
		}
		if (SelectedHeroes.Count == 0 && base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Select();
		}
		if (!IsStartingHero)
		{
			achievementManager.AddToStatistic(StatisticName.RECRUITMENT_NEGATIVE, -1f);
		}
		gameEventManager.OnDungeonTurnChanged += GameEventManager_OnDungeonTurnChanged;
		if (Hero.OnHeroRecruited != null)
		{
			Hero.OnHeroRecruited();
		}
	}

	private void GameEventManager_OnDungeonTurnChanged()
	{
		if (GetSimPropertyValue(SimulationProperties.RespawnRoomCount) > 0f)
		{
			CurrentRespawnRoomCount++;
		}
	}

	public void Dismiss()
	{
		if (!IsRecruited)
		{
			Diagnostics.LogError(base.name + " > Hero.Dismiss: cannot dismiss a free hero!");
			return;
		}
		if (!base.HealthCpnt.IsAlive())
		{
			Diagnostics.LogError(base.name + " > Hero.Dismiss: cannot dismiss a dead hero!");
			return;
		}
		if (LocalPlayerActiveRecruitedHeroes.Count + RemotePlayersActiveRecruitedHeroes.Count <= 1)
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_HeroDismissFailTeamSize"));
			return;
		}
		if (HasCrystal)
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_HeroDismissFailCrystal"));
			return;
		}
		Player.LocalPlayer.AddFood((float)(base.Level * base.Level) + GameConfig.GetGameConfig().DismissingFoodCoef);
		if (selectedHeroes.Contains(this))
		{
			Unselect();
		}
		SpawnDeadHeroLoot();
		AICpnt.IsActive = false;
		MoverCpnt.StopMove();
		base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_DoDismiss);
	}

	private void RPC_DoDismiss()
	{
		IsDismissing = true;
		if (TamedMob != null && TamedMob.HealthCpnt != null)
		{
			TamedMob.HealthCpnt.Kill();
		}
		gameEventManager.OnDungeonTurnChanged -= GameEventManager_OnDungeonTurnChanged;
		dungeon.AddToDiscoverableHeroPool(Config);
		heroAttackTargetCpnt.SetActive(active: false);
		LockInteractions();
		RemoveFromDungeon();
		gameEventManager.TriggerHeroListChangedEvent();
		dismissVFX.Play(withChildren: true);
		Invoke("Hide", hideDelayOnDismiss);
		UnityEngine.Object.Destroy(base.gameObject, destroyDelayOnDismiss);
	}

	public void GiveToPlayer(ulong playerID, bool checkIfOwnedByLocalPlayer = true)
	{
		if (checkIfOwnedByLocalPlayer && !base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError("Cannot give {0} to player #{1}: hero is owned by another player! ({2})", base.name, playerID, base.NetSyncElement.OwnerPlayerID);
			return;
		}
		if (HasCrystal)
		{
			Diagnostics.LogError("Cannot give {0} to player #{1}: hero is carrying the crystal!", base.name, playerID);
			return;
		}
		if (IsRecruited && base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Unselect(triggerHeroSelectionEvent: true, assertAtLeastOneHeroIsSelected: false);
			ModifyLocalActiveHeroes(add: false, this);
			remotePlayersActiveRecruitedHeroes.Add(this);
		}
		base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_GiveToPlayer, playerID);
	}

	private void RPC_GiveToPlayer(ulong playerID)
	{
		base.NetSyncElement.ChangeOwner(playerID);
		if (IsRecruited)
		{
			UnlockLevel = dungeon.Level + Config.UnlockLevelCount;
			if (base.NetSyncElement.IsOwnedByLocalPlayer())
			{
				ModifyLocalActiveHeroes(add: true, this);
				remotePlayersActiveRecruitedHeroes.Remove(this);
				HidePlayerName();
				if (TamedMob != null)
				{
					DoTameMob(TamedMob, ownerChanged: true);
				}
				if (localPlayerActiveRecruitedHeroes.Count == 1 || (selectedHeroes.Count > 1 && selectedHeroes.Count == localPlayerActiveRecruitedHeroes.Count - 1))
				{
					Select(recordSelectTime: true, unselectOthers: false);
				}
			}
			else
			{
				DisplayPlayerName();
			}
		}
		gameEventManager.TriggerHeroListChangedEvent();
	}

	public int GetHealFoodCost()
	{
		return Mathf.Max(GenericUtilities.RoundHalfAwayFromZeroToInt((float)GetHealAmount() * GetSimPropertyValue(SimulationProperties.HealFoodCostCoeff)), 1);
	}

	public int GetRestScienceCost()
	{
		float num = 0f;
		float skillLevelScienceCoef = GameConfig.GetGameConfig().SkillLevelScienceCoef;
		foreach (ActiveSkill filteredActiveSkill in FilteredActiveSkills)
		{
			num += (float)(filteredActiveSkill.GetRemainingTurns() * filteredActiveSkill.Config.Level) * skillLevelScienceCoef;
		}
		return Mathf.CeilToInt(num);
	}

	public int GetHealAmount()
	{
		return GenericUtilities.RoundHalfAwayFromZeroToInt(base.HealthCpnt.GetMaxHealth() * GameConfig.GetGameConfig().HeroHealPct);
	}

	public bool Heal()
	{
		bool flag = TamedMob != null && !TamedMob.HealthCpnt.IsFullLive();
		float num = 0f;
		if (flag)
		{
			num = GetSimPropertyValue(SimulationProperties.MobTamedHealPct) / 100f;
			flag = (flag && num > 0f);
		}
		if (base.HealthCpnt.IsFullLive() && !flag)
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_HeroHealFailFullLife"));
			return false;
		}
		if (dungeon.CurrentGamePhase == GamePhase.Strategy && !dungeon.ShipConfig.ForbidStrategyHealthRegen)
		{
			return false;
		}
		if (!base.HealthCpnt.IsAlive())
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_HeroHealFailAlreadyDead"));
			return false;
		}
		float num2 = GetHealFoodCost();
		if (!Player.LocalPlayer.ConsumeFood(num2))
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_HeroHealFailResources"));
			return false;
		}
		float num3 = GetHealAmount();
		base.HealthCpnt.AddHealth(num3);
		if (TamedMob != null && TamedMob.HealthCpnt != null)
		{
			TamedMob.HealthCpnt.AddHealth(num3 * num);
		}
		achievementManager.AddToStatistic(StatisticName.HEAL_FOOD_USED, num2);
		return true;
	}

	public bool Rest()
	{
		if (FilteredActiveSkills.Count == 0)
		{
			return false;
		}
		int restScienceCost = GetRestScienceCost();
		if (!Player.LocalPlayer.ConsumeScience(restScienceCost))
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_HeroRestFailResources"));
			return false;
		}
		if (restScienceCost <= 0)
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_HeroNothingToRest"));
			return false;
		}
		foreach (ActiveSkill filteredActiveSkill in FilteredActiveSkills)
		{
			if (filteredActiveSkill.GetRemainingTurns() > 0)
			{
				filteredActiveSkill.EndCooldown();
			}
		}
		return true;
	}

	public void Bind()
	{
		if (dungeon == null)
		{
			dungeon = SingletonManager.Get<Dungeon>();
		}
		dungeon.OnRoomPowered += Dungeon_OnRoomPowered;
		MoverCpnt.OnMoveDirectionChanged += Mover_OnMoveDirectionChanged;
	}

	public void Unbind()
	{
		dungeon.OnRoomPowered -= Dungeon_OnRoomPowered;
		MoverCpnt.OnMoveDirectionChanged -= Mover_OnMoveDirectionChanged;
	}

	public void CancelNPCInteraction()
	{
		IsInteracting = false;
		EndNPCInteraction();
	}

	public void EndNPCInteraction()
	{
		if (npcMoveTarget != null)
		{
			npcMoveTarget.HealthCpnt.OnDeath -= OnInteractionTargetDeath;
			if (IsInteracting)
			{
				npcMoveTarget.EndInteraction(this);
			}
			else
			{
				npcMoveTarget.CancelInteraction(this);
			}
			IsInteracting = false;
			attackerCpnt.CanAttack = true;
			npcMoveTarget = null;
		}
	}

	public void ChangeCurrentRoom(Room newRoom)
	{
		if (HasOperatingBonus && base.RoomElement.ParentRoom != newRoom)
		{
			HasOperatingBonus = false;
			gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChangedDuringAction;
		}
		if (base.RoomElement.ParentRoom != null && base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			base.RoomElement.ParentRoom.OnMobDied -= ParentRoom_OnMobDied;
		}
		base.RoomElement.SetParentRoom(newRoom);
		newRoom.UpdateSupportEffectVFXs();
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			base.RoomElement.ParentRoom.OnMobDied += ParentRoom_OnMobDied;
		}
		if (!HasCrystal)
		{
			return;
		}
		CrystalModuleSlot freeCrystalModuleSlot = newRoom.GetFreeCrystalModuleSlot(isExitSlot: true);
		if (freeCrystalModuleSlot != null && CrystalSlotMoveTarget == freeCrystalModuleSlot)
		{
			int num = 1;
			num = ((!gameNetManager.IsMultiplayerSession()) ? 1 : ((!MultiplayerConfig.OneCrystalPerPlayer) ? 1 : gameNetManager.GetPlayerCount()));
			if (dungeon.PluggedOnExitSlotCrystalCount == num - 1)
			{
				PlayLevelSuccessCinematic();
			}
		}
	}

	private void ParentRoom_OnMobDied(Mob obj)
	{
		float simPropertyValue = GetSimPropertyValue(SimulationProperties.FISBonusPerRoomMobKilled);
		if (simPropertyValue > 0f)
		{
			int num = RandomGenerator.RangeInt(0, 3);
			if (num == 2)
			{
				num = 3;
			}
			Player.LocalPlayer.AddFIDS(simPropertyValue, (FIDS)num, displayFeedback: true, triggerDungeonFIDSChangedEvent: true, checkPlayerIsLocal: false);
		}
	}

	public void UpdateSupportEffectVFXs(bool on = true)
	{
		if (on && GetSimPropertyValue(SimulationProperties.SupportHealingEffect) > 0f)
		{
			if (!supportHealingVFX.isPlaying)
			{
				supportHealingVFX.Play(withChildren: true);
			}
		}
		else if (supportHealingVFX.isPlaying)
		{
			supportHealingVFX.Stop(withChildren: true);
		}
		if (on && GetSimPropertyValue(SimulationProperties.SupportBoosterEffect) > 0f)
		{
			if (!supportBoosterVFX.isPlaying)
			{
				supportBoosterVFX.Play(withChildren: true);
			}
		}
		else if (supportBoosterVFX.isPlaying)
		{
			supportBoosterVFX.Stop(withChildren: true);
		}
		if (on && GetSimPropertyValue(SimulationProperties.SupportSonarEffect) > 0f)
		{
			if (!supportSonarVFX.isPlaying)
			{
				supportSonarVFX.Play(withChildren: true);
			}
		}
		else if (supportSonarVFX.isPlaying)
		{
			supportSonarVFX.Stop(withChildren: true);
		}
	}

	public void PlayLevelSuccessCinematic()
	{
		base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_DoPlayLevelSuccessCinematic, base.RoomElement.ParentRoom.UniqueID.ID);
	}

	private void RPC_DoPlayLevelSuccessCinematic(int exitRoomID)
	{
		Room room = UniqueIDManager.Get<Room>(exitRoomID);
		CrystalModuleSlot freeCrystalModuleSlot = room.GetFreeCrystalModuleSlot(isExitSlot: true);
		if (freeCrystalModuleSlot == null)
		{
			Diagnostics.LogError("PlayLevelSuccessCinematic: Unable to find crystal slot in exit room");
			return;
		}
		foreach (Hero localPlayerActiveRecruitedHero in localPlayerActiveRecruitedHeroes)
		{
			localPlayerActiveRecruitedHero.HealthCpnt.IsInvincible = true;
		}
		dungeon.StopExitWaves();
		foreach (Mob activeMob in Mob.ActiveMobs)
		{
			activeMob.HealthCpnt.IsInvincible = true;
		}
		IsUsable = false;
		IGameCameraService service = Services.GetService<IGameCameraService>();
		if (service.IsTacticalMapActive())
		{
			service.SwitchToGameCamera();
		}
		service.Focus(freeCrystalModuleSlot.transform.position, LerpType.Smoothed, -1f);
		service.Lock();
	}

	public bool RespawnStart()
	{
		if (IsRespawning)
		{
			return true;
		}
		float simPropertyValue = GetSimPropertyValue(SimulationProperties.LifeHealPctOnRespawn);
		if (HasCrystal)
		{
			GameOver();
		}
		if ((IsRecruited && simPropertyValue > 0f) || (dungeon.CrystalType == "Respawn" && Player.LocalPlayer.FoodStock > 0f))
		{
			achievementManager.AddToStatistic(StatisticName.HERO_DEATH_NEGATIVE, -1f);
			float simPropertyValue2 = GetSimPropertyValue(SimulationProperties.RespawnRoomCount);
			float simPropertyValue3 = GetSimPropertyValue(SimulationProperties.LifeHealPctOnRespawn);
			audioEventManager.Play2DEvent("Master/Jingles/HeroDeath");
			List<KeyValuePair<EquipmentSlot, InventoryItem>> list = new List<KeyValuePair<EquipmentSlot, InventoryItem>>();
			EquipmentSlot[] equipmentSlots = EquipmentSlots;
			foreach (EquipmentSlot equipmentSlot in equipmentSlots)
			{
				if (equipmentSlot.EquippedItem != null)
				{
					list.Add(new KeyValuePair<EquipmentSlot, InventoryItem>(equipmentSlot, equipmentSlot.EquippedItem));
					equipmentSlot.UnequipItem(netSync: false, checkConfig: false);
				}
			}
			if (simPropertyValue > 0f)
			{
				CurrentRespawnRoomCount = (int)((float)CurrentRespawnRoomCount / simPropertyValue2);
				if (CurrentRespawnRoomCount > 0)
				{
					respawnHealthRatio = (float)CurrentRespawnRoomCount * simPropertyValue3;
					shipRespawn = false;
				}
			}
			else
			{
				float maxHealth = base.HealthCpnt.GetMaxHealth();
				float num = Mathf.Min(Player.LocalPlayer.FoodStock * GameConfig.GetGameConfig().RespawnFoodCoef, maxHealth);
				float num2 = GenericUtilities.RoundHalfAwayFromZero(maxHealth - num);
				respawnHealthRatio = 1f;
				base.HealthCpnt.PermanantHealthMalus += num2;
				float foodCost = num / GameConfig.GetGameConfig().RespawnFoodCoef;
				Player.LocalPlayer.ConsumeFood(foodCost);
			}
			foreach (KeyValuePair<EquipmentSlot, InventoryItem> item in list)
			{
				item.Key.EquipItem(item.Value);
			}
			if (simPropertyValue > 0f && CurrentRespawnRoomCount == 0)
			{
				return false;
			}
			for (int j = 0; j < EquipmentSlots.Length; j++)
			{
				if (EquipmentSlots[j].EquippedItem != null && EquipmentSlots[j].EquippedItem.ItemConfig.DestroyOnDeath)
				{
					InventoryItem equippedItem = EquipmentSlots[j].EquippedItem;
					EquipmentSlots[j].UnequipItem(netSync: true, checkConfig: false);
					dungeon.NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_DoRemoveItem, equippedItem.UniqueIDCategory, equippedItem.UniqueID);
					break;
				}
			}
			CurrentRespawnRoomCount = 0;
			dungeon.EnqueueAlertNotification(AgeLocalizer.Instance.LocalizeString("%Notification_HeroRespawn").Replace("$HeroName", LocalizedName), "HeroDied");
			if (!dungeon.IsLevelOver)
			{
				audioEventManager.Play2DEvent("Master/Jingles/HeroDeath");
			}
			IsRespawning = true;
			allowAnim = false;
			CancelNPCInteraction();
			LockInteractions();
			MoverCpnt.StopMoving();
			attackerCpnt.StopAttack();
			IsUsable = false;
			destRoomMarkerRnd.enabled = false;
			heroAttackTargetCpnt.SetActive(active: false);
			spriteAnim.ResetAllTriggers();
			spriteAnim.Trigger(SpriteAnimationTrigger.OnDeath);
			spriteAnim.SetBool(SpriteAnimationBool.IsActionning, value: false);
			if (simPropertyValue <= 0f)
			{
				base.HealthCpnt.SetHealthRatio(1f);
			}
			if (doorMoveTarget != null)
			{
				doorMoveTarget.RemoveOpener(this);
			}
			return true;
		}
		return false;
	}

	private void OnDeathEndAnimEvent()
	{
		if (IsRespawning)
		{
			if (shipRespawn)
			{
				RespawnEnd();
				return;
			}
			itemRespawnSprite.MonitorAnimEvent("OnHeroRespawn", RespawnEnd);
			itemRespawnSprite.Play();
			audioEventManager.Play2DEvent("Master/Jingles/HalloweenRevive");
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void RespawnEnd()
	{
		allowAnim = true;
		IsRespawning = false;
		attackerCpnt.enabled = true;
		heroAttackTargetCpnt.SetActive(active: true);
		IsUsable = true;
		UnlockInteractions();
		spriteAnim.Trigger(SpriteAnimationTrigger.OnRespawn);
		base.HealthCpnt.SetHealthRatio(respawnHealthRatio);
		if (shipRespawn)
		{
			MoverCpnt.SetPosition(dungeon.StartRoom.CenterPosition);
			dungeon.StartRoom.OnHeroEnter(this);
			MoveToRoom(base.RoomElement.ParentRoom);
		}
		else
		{
			itemRespawnSprite.UnmonitorAnimEvent("OnHeroRespawn", RespawnEnd);
			itemRespawnSprite.MonitorAnimEvent("AnimEnd", OnRespawnAnimEnd);
			shipRespawn = true;
		}
	}

	private void OnRespawnAnimEnd()
	{
		itemRespawnSprite.Stop();
	}

	public override string GetLevelDescriptorName(int level)
	{
		return (string)GetSimDescriptorByType(SimulationProperties.SimDescTypeHero).Name + "_LVL" + level;
	}

	public HeroLevelConfig GetNextLevelConfig()
	{
		int num = base.Level + 1;
		int num2 = num - 1;
		if (num2 <= levelConfigs.Count - 1)
		{
			return levelConfigs[num2];
		}
		return null;
	}

	public Dictionary<StaticString, float> GetLevelUpModifiers()
	{
		int num = base.Level + 1;
		int num2 = num - 1;
		if (num2 <= levelUpModifiersByLevel.Count - 1)
		{
			return levelUpModifiersByLevel[num2];
		}
		return null;
	}

	public void AddPermanentDescriptor(string descriptorName)
	{
		SimulationDescriptor value = Databases.GetDatabase<SimulationDescriptor>().GetValue(descriptorName);
		if (value == null)
		{
			Diagnostics.LogError("Can't find descriptor: " + descriptorName);
		}
		else if (!PermanentDescriptors.Contains(value))
		{
			PermanentDescriptors.Add(value);
			if (value.Type == "Skill")
			{
				AddSkill(descriptorName);
			}
			else
			{
				AddSimDescriptor(value, refresh: false);
			}
		}
	}

	private bool CanLevelUp(bool displayErrors = false, bool consumeFood = true)
	{
		HeroLevelConfig nextLevelConfig = GetNextLevelConfig();
		if (nextLevelConfig == null)
		{
			if (displayErrors)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_HeroLevelUpFailMaxLevel"));
			}
			return false;
		}
		if (consumeFood && nextLevelConfig.FoodCost > 0f && Player.LocalPlayer.FoodStock < nextLevelConfig.FoodCost)
		{
			if (displayErrors)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_HeroLevelUpFailResources").Replace("$HeroName", LocalizedName));
			}
			return false;
		}
		return true;
	}

	public void LevelUp(bool playFeedback = true, bool consumeFood = true)
	{
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Hero.LevelUp should only be called on owner side!");
		}
		else if (CanLevelUp(displayErrors: true, consumeFood))
		{
			if (consumeFood && gameNetManager.IsMultiplayerSession() && !MultiplayerConfig.SplitFIS)
			{
				base.NetSyncElement.SendRPCToServer(UniqueIDRPC.Hero_RequestLevelUp, playFeedback, consumeFood);
			}
			else if (consumeFood && !Player.LocalPlayer.ConsumeFood(GetNextLevelConfig().FoodCost))
			{
				Diagnostics.LogError(base.name + " > Hero.LevelUp: not enough resources!");
			}
			else
			{
				base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_DoLevelUp, playFeedback);
			}
		}
	}

	private void RPC_RequestLevelUp(bool playFeedback, bool consumeFood)
	{
		if (!gameNetManager.IsServer())
		{
			Diagnostics.LogError(base.name + " > Hero.RPC_RequestLevelUp should only be called on server side!");
		}
		else if (!CanLevelUp(displayErrors: false, consumeFood))
		{
			Diagnostics.LogWarning(base.name + " > Hero.RPC_RequestLevelUp: NOPE!");
		}
		else if (consumeFood && !Player.LocalPlayer.ConsumeFood(GetNextLevelConfig().FoodCost))
		{
			Diagnostics.LogError(base.name + " > Hero.RPC_RequestLevelUp: not enough resources!");
		}
		else
		{
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_DoLevelUp, playFeedback);
		}
	}

	private void RPC_DoLevelUp(bool playFeedback)
	{
		if (!CanLevelUp(displayErrors: false, consumeFood: false))
		{
			Diagnostics.LogError(base.name + " > Hero.RPC_DoLevelUp: CANNOT LEVEL UP!");
			return;
		}
		HeroLevelConfig nextLevelConfig = GetNextLevelConfig();
		if (nextLevelConfig.Skills != null && nextLevelConfig.Skills.Length > 0)
		{
			string[] skills = nextLevelConfig.Skills;
			foreach (string skillName in skills)
			{
				AddSkill(skillName);
			}
		}
		ApplyLevelUp();
		if (playFeedback)
		{
			if (allowAnim)
			{
				spriteAnim.Trigger(SpriteAnimationTrigger.OnLevelUp);
				levelUpSpriteAnim.Trigger(SpriteAnimationTrigger.OnLevelUp);
			}
			base.AudioEmitter.PlayEvent("Master/Jingles/LvlUpHero");
			if (levelUpVfxParticles != null)
			{
				levelUpVfxParticles.Play(withChildren: true);
			}
		}
		if (OperatingModule != null)
		{
			OperatingModule.UpdateOperatorWit(this);
		}
		if (RepairingModule != null)
		{
			RepairingModule.UpdateReparatorWit(this);
		}
		gameEventManager.TriggerDungeonFIDSChangedEvent();
		if (GetNextLevelConfig() == null && base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			SingletonManager.Get<AchievementManagerDOTE>().IncrementStatistic(StatisticName.MAX_LEVEL_HEROES);
		}
	}

	public void Select(bool recordSelectTime = true, bool unselectOthers = true, bool triggerHeroSelectionEvent = true)
	{
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError("Cannot select a hero owned by another player!");
			return;
		}
		if (!IsRecruited)
		{
			Diagnostics.LogError("Cannot select a free hero!");
			return;
		}
		if (!base.HealthCpnt.IsAlive())
		{
			Diagnostics.LogError("Cannot select a dead hero!");
			return;
		}
		if (selectedHeroes.Count >= 1 && selectedHeroes[0] == this && Time.realtimeSinceStartup <= lastSelectRealTime + doubleSelectMaxTimeDelta)
		{
			Focus();
		}
		if (gameControlManager.MultipleHeroSelectionMode && SelectedHeroes.Contains(this))
		{
			Unselect();
			return;
		}
		unselectOthers &= !gameControlManager.MultipleHeroSelectionMode;
		if (selectedHeroes.Count > 0 && unselectOthers)
		{
			while (selectedHeroes.Count > 0)
			{
				selectedHeroes[0].Unselect(triggerHeroSelectionEvent: false, assertAtLeastOneHeroIsSelected: false);
			}
		}
		selectorRenderer.enabled = true;
		destRoomMarkerRnd.enabled = (MoverCpnt.IsMoving || nextMoveDoorMoveTarget != null || nextMoveRoomMoveTarget != null);
		if (!selectedHeroes.Contains(this))
		{
			selectedHeroes.Add(this);
		}
		if (triggerHeroSelectionEvent)
		{
			gameEventManager.TriggerHeroSelectionEvent();
		}
		base.AudioEmitter.PlayEvent("Master/GUI/SelectHero");
		if (recordSelectTime)
		{
			lastSelectRealTime = Time.realtimeSinceStartup;
		}
		if (TamedMob != null)
		{
			TamedMob.Select(selected: true);
		}
		selectTacticalMapElementAnim.Play();
	}

	public void Focus()
	{
		IGameCameraService service = Services.GetService<IGameCameraService>();
		if (service.IsTacticalMapActive())
		{
			service.SwitchToGameCamera();
		}
		service.Focus(base.transform.position, LerpType.Smoothed, -1f);
		base.RoomElement.ParentRoom.SelectableForMove.Select(silent: true);
	}

	public void LockInteractions()
	{
		attackerCpnt.CanAttack = false;
		MoverCpnt.CanMove = false;
	}

	public void UnlockInteractions()
	{
		if (!IsRespawning)
		{
			attackerCpnt.CanAttack = true;
			MoverCpnt.CanMove = true;
		}
	}

	public void DisplayDialogPanel(string text, float duration = -1f)
	{
		if (situationDialogPanel == null)
		{
			GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(situationDialogPanelPfb, Vector3.zero, Quaternion.identity);
			gameObject.transform.parent = SingletonManager.Get<MainGameScreen>().SituationDialogPanelContainer;
			gameObject.GetComponent<GameToScreenPositionSync>().GameEntityTfm = base.transform;
			situationDialogPanel = gameObject.GetComponent<SituationDialogPanel>();
		}
		situationDialogPanel.Display(text, base.transform, duration);
	}

	protected override void Awake()
	{
		base.Awake();
		MoverCpnt = GetComponent<Mover>();
		AICpnt = GetComponent<HeroAI>();
		heroAttackTargetCpnt = GetComponent<AITarget>();
		achievementManager = SingletonManager.Get<AchievementManagerDOTE>();
		gameEventManager = Services.GetService<IGameEventService>();
		audioEventManager = Services.GetService<IAudioEventService>();
		Mover moverCpnt = MoverCpnt;
		moverCpnt.OnMoveStopped = (Mover.MoveStoppedHandler)Delegate.Combine(moverCpnt.OnMoveStopped, new Mover.MoveStoppedHandler(OnMoveStopped));
		base.HealthCpnt.OnDeath += OnDeath;
		base.HealthCpnt.OnHealStart += OnHealStart;
		base.HealthCpnt.OnDanger += OnDanger;
		base.Level = 0;
		attackerCpnt.OnTargetKilled += OnTargetKilled;
	}

	protected override void Update()
	{
		base.Update();
		if (defenseBonusFromMobKills > 0f)
		{
			defenseBonusFromMobKills = Mathf.Max(defenseBonusFromMobKills - GetSimPropertyValue(SimulationProperties.DefenseBonusPerMobKilled_TimeMalus) * Time.deltaTime, 0f);
			SetSimPropertyBaseValue(SimulationProperties.DefenseBonusFromMobKills, defenseBonusFromMobKills);
		}
		if (attackBonusFromMobKills > 0f)
		{
			attackBonusFromMobKills = Mathf.Max(attackBonusFromMobKills - GetSimPropertyValue(SimulationProperties.AttackBonusPerMobKilled_TimeMalus) * Time.deltaTime, 0f);
			SetSimPropertyBaseValue(SimulationProperties.AttackBonusFromMobKills, attackBonusFromMobKills);
		}
		if (!mobsAggroAttackTargetCpnt.IsActive && GetSimPropertyValue(SimulationProperties.MobsAggro) > 0f)
		{
			mobsAggroAttackTargetCpnt.SetActive(active: true);
		}
		else if (mobsAggroAttackTargetCpnt.IsActive && GetSimPropertyValue(SimulationProperties.MobsAggro) == 0f)
		{
			mobsAggroAttackTargetCpnt.SetActive(active: false);
		}
		bool flag = GetSimPropertyValue(SimulationProperties.Stealth) > 0f;
		if (!HasCrystal && heroAttackTargetCpnt.Type != AITargetType.Stealth && flag)
		{
			heroAttackTargetCpnt.UpdateType(AITargetType.Stealth);
		}
		else if (heroAttackTargetCpnt.Type == AITargetType.Stealth && !flag)
		{
			if (HasCrystal)
			{
				heroAttackTargetCpnt.UpdateType(AITargetType.HeroWithCrystal);
			}
			else if (IsRecruited)
			{
				heroAttackTargetCpnt.UpdateType(Config.AITargetType);
			}
			else
			{
				heroAttackTargetCpnt.UpdateType(AITargetType.FreeHero);
			}
		}
		bool flag2 = GetSimPropertyValue(SimulationProperties.RepairFirst) > 0f;
		if (AICpnt.AIConfigName != "RepairFirstHero" && flag2)
		{
			AICpnt.UpdateAIType("RepairFirstHero");
		}
		else if (AICpnt.AIConfigName == "RepairFirstHero" && !flag2)
		{
			if (IsRecruited)
			{
				AICpnt.UpdateAIType(Config.Name);
			}
			else
			{
				AICpnt.UpdateAIType($"Free{Config.Name}");
			}
		}
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			float simPropertyValue = GetSimPropertyValue(SimulationProperties.MobTaming);
			if (previousMobTaming == 0f && simPropertyValue > 0f)
			{
				FindAndTameAMob();
			}
			previousMobTaming = simPropertyValue;
		}
	}

	private void FixedUpdate()
	{
		float simPropertyValue = GetSimPropertyValue(SimulationProperties.Skill_A0039_Effect);
		if (simPropertyValue > 0f)
		{
			if (previousSkillA0039Value == 0f)
			{
				cachedSkill_A0039_AttackPower = GetSimPropertyValue(SimulationProperties.Skill_A0039_AttackPower);
				cachedSkill_A0039_ZoneAttackRadius = GetSimPropertyValue(SimulationProperties.Skill_A0039_ZoneAttackRadius);
			}
			for (int i = 0; i < base.RoomElement.ParentRoom.Mobs.Count; i++)
			{
				Mob mob = base.RoomElement.ParentRoom.Mobs[i];
				if (!(mob.HealthCpnt != null) || !mob.HealthCpnt.IsAlive() || !(mob.HealthCpnt.GetHealthRatio() <= 0.25f) || !mob.NetSyncElement.IsOwnedByLocalPlayer())
				{
					continue;
				}
				mob.HealthCpnt.Kill();
				mob.AttackerCpnt.ApplyZoneDamagesInRoom(heroAttackTargetCpnt, directHit: true, base.RoomElement.ParentRoom, cachedSkill_A0039_ZoneAttackRadius, cachedSkill_A0039_AttackPower);
				if (SkillA0039VFXPfb == null)
				{
					ActiveSkill activeSkill = activeSkills.First((ActiveSkill skill) => skill.Config.Name.ToString().StartsWith("Skill_A0039"));
					if (activeSkill != null)
					{
						SkillA0039VFXPfb = Resources.Load<GameObject>(activeSkill.Config.TargetVFXPath);
					}
				}
				if (SkillA0039VFXPfb != null)
				{
					UnityEngine.Object.Instantiate(SkillA0039VFXPfb, mob.transform.position, Quaternion.identity);
				}
			}
		}
		previousSkillA0039Value = simPropertyValue;
	}

	private void OnAttackingMobCountChanged()
	{
		if (attackingMobCount < 0)
		{
			Diagnostics.LogError(base.name + " > OnAttackingMobCountChanged: attackingMobCount should be >= 0 (" + attackingMobCount + ")");
		}
		else if (attackingMobCount == 1)
		{
			if (GetSimPropertyValue(SimulationProperties.IsAttackedByOneMob) != 1f)
			{
				SetSimPropertyBaseValue(SimulationProperties.IsAttackedByOneMob, 1f);
			}
		}
		else if (GetSimPropertyValue(SimulationProperties.IsAttackedByOneMob) != 0f)
		{
			SetSimPropertyBaseValue(SimulationProperties.IsAttackedByOneMob, 0f);
		}
	}

	private void SetDestMarkerPosition(Vector3 destPosition)
	{
		if (destRoomMarkerTfm != null && destRoomMarkerRnd != null)
		{
			destRoomMarkerTfm.position = destPosition;
			destRoomMarkerRnd.enabled = selectedHeroes.Contains(this);
		}
	}

	public void DisplayRecruitmentDialog()
	{
		Diagnostics.LogWarning(base.name + " > DisplayRecruitmentDialog");
		if (IsRecruited)
		{
			Diagnostics.LogError("Hero already recruited!");
		}
		IGameCameraService service = Services.GetService<IGameCameraService>();
		if (!service.IsTacticalMapActive() && !service.IsSwitchingCamera)
		{
			if (!IsRecruitable)
			{
				dungeon.EnqueueErrorNotification("%Error_UnrecruitableHero");
				return;
			}
			AgeUtils.ColorToHexaKey(recruitementTextColor, out string hexaKey);
			StaticString x = hexaKey + AgeLocalizer.Instance.LocalizeString("%" + Config.Name + "_FirstName");
			x = x + " (" + AgeLocalizer.Instance.LocalizeString("%LevelStatTitle") + " " + base.Level.ToString() + "): #REVERT#";
			string heroSpeech = x + " " + AgeLocalizer.Instance.LocalizeString(Config.IntroDialogs.GetRandom().Text);
			IGameControlService service2 = Services.GetService<IGameControlService>();
			service2.ClosePanelsAtStartOfInteraction();
			SingletonManager.Get<HeroRecruitmentPanel>().Display(this, heroSpeech);
		}
	}

	private void OnAITargetChanged(AITarget previousTarget, AITarget newTarget)
	{
		Mob previousMobTarget = null;
		if (previousTarget != null && previousTarget.Interaction == AIInteraction.Attack)
		{
			previousMobTarget = previousTarget.GetComponent<Mob>();
		}
		Mob newMobTarget = null;
		if (newTarget != null && newTarget.Interaction == AIInteraction.Attack)
		{
			newMobTarget = newTarget.GetComponent<Mob>();
		}
		foreach (ActiveSkill filteredActiveSkill in FilteredActiveSkills)
		{
			filteredActiveSkill.UpdateTarget(previousMobTarget, newMobTarget);
		}
		foreach (PassiveSkill filteredPassiveSkill in FilteredPassiveSkills)
		{
			filteredPassiveSkill.UpdateTarget(previousMobTarget, newMobTarget);
		}
	}

	private bool CanUnplugCrystal(MajorModule crystal, bool displayErrorNotifs = true)
	{
		if (crystal == null)
		{
			Diagnostics.LogWarning(base.name + " > Hero.UnplugCrystal: crystalMoveTarget is null!");
			return false;
		}
		if (crystal.IsBeingDestroyed)
		{
			Diagnostics.LogWarning(base.name + " > Hero.UnplugCrystal: crystal has already been unplugged!");
			return false;
		}
		if (dungeon.ExitRoom == null)
		{
			if (displayErrorNotifs)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_CrystalUnplugFail_ExitNotFound"));
			}
			return false;
		}
		return true;
	}

	private void UnplugCrystal()
	{
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Hero.UnplugCrystal should only be called on owner side!");
		}
		else if (!CanUnplugCrystal(crystalMoveTarget))
		{
			Diagnostics.LogWarning(base.name + " > Hero.UnplugCrystal: cannot unplug crystal!");
		}
		else
		{
			base.NetSyncElement.SendRPCToServer(UniqueIDRPC.Hero_RequestUnplugCrystal, crystalMoveTarget.UniqueID.GetCategory(), crystalMoveTarget.UniqueID.ID);
		}
	}

	private void RPC_RequestUnplugCrystal(StaticString crystalCategory, int crystalID)
	{
		UnityEngine.Component component = UniqueIDManager.Get(crystalCategory, crystalID);
		MajorModule crystal = (!(component != null)) ? null : component.GetComponent<MajorModule>();
		if (!CanUnplugCrystal(crystal, displayErrorNotifs: false))
		{
			Diagnostics.LogError(base.name + " > Hero.RPC_RequestUnplugCrystal: cannot unplug crystal!");
		}
		else
		{
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_DoUnplugCrystal, crystalCategory, crystalID);
		}
	}

	private void RPC_DoUnplugCrystal(StaticString crystalCategory, int crystalID)
	{
		UnityEngine.Component component = UniqueIDManager.Get(crystalCategory, crystalID);
		MajorModule majorModule = (!(component != null)) ? null : component.GetComponent<MajorModule>();
		if (!CanUnplugCrystal(majorModule))
		{
			Diagnostics.LogError(base.name + " > Hero.RPC_RequestUnplugCrystal: cannot unplug crystal!");
			return;
		}
		majorModule.RemoveCrystal();
		crystalLight.enabled = true;
		crystalContainer.gameObject.SetActive(value: true);
		HasCrystal = true;
		if (this.OnHasCrystalChanged != null)
		{
			this.OnHasCrystalChanged(hasCrystal: true);
		}
		if (GetSimPropertyValue(SimulationProperties.NoCrystalCarryDescriptor) < 1f)
		{
			AddSimDescriptor(SimulationProperties.SimDescHeroHasCrystal);
		}
		heroAttackTargetCpnt.UpdateType(AITargetType.HeroWithCrystal);
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			AICpnt.IsActive = false;
		}
		dungeon.OnCrystalUnplugged(base.NetSyncElement.IsOwnedByLocalPlayer());
		dungeon.UpdateCrystalTfm(base.transform);
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			dungeon.CheckSituationDialog(SituationDialogType.RemoveCrystal, this);
			DeactivateActiveSkills();
		}
	}

	private void PlugCrystal()
	{
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > Hero.PlugCrystal should only be called on owner side!");
			return;
		}
		if (!HasCrystal)
		{
			Diagnostics.LogError("Hero must have the crystal to plug it!");
			return;
		}
		CrystalModuleSlot freeCrystalModuleSlot = base.RoomElement.ParentRoom.GetFreeCrystalModuleSlot();
		if (freeCrystalModuleSlot == null)
		{
			Diagnostics.LogError("No available crystal slot found in " + base.RoomElement.name + "!");
			return;
		}
		base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_DoPlugCrystal, freeCrystalModuleSlot.UniqueID.GetCategory(), freeCrystalModuleSlot.UniqueID.ID);
		MoverCpnt.CanMove = false;
	}

	private void RPC_DoPlugCrystal(StaticString crystalSlotCategory, int crystalSlotID)
	{
		CrystalModuleSlot component = UniqueIDManager.Get(crystalSlotCategory, crystalSlotID).GetComponent<CrystalModuleSlot>();
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			if (!component.IsExitSlot)
			{
				foreach (Room openedRoom in dungeon.OpenedRooms)
				{
					if (!openedRoom.IsStartRoom)
					{
						openedRoom.Unpower();
					}
				}
				if (!dungeon.StartRoom.IsPowered)
				{
					dungeon.StartRoom.PowerByLocalPlayer(displayErrorNotif: false, checkCrystalState: false, consumeDust: false);
				}
			}
			base.RoomElement.ParentRoom.BuildCrystal();
		}
		component.PlayFlashAnimation();
		crystalLight.enabled = false;
		crystalContainer.gameObject.SetActive(value: false);
		HasCrystal = false;
		if (this.OnHasCrystalChanged != null)
		{
			this.OnHasCrystalChanged(hasCrystal: false);
		}
		RemoveSimDescriptor(SimulationProperties.SimDescHeroHasCrystal);
		heroAttackTargetCpnt.UpdateType(Config.AITargetType);
		dungeon.OnCrystalPlugged();
	}

	private void Start()
	{
		dungeon = SingletonManager.Get<Dungeon>();
		dungeon.AddDynamicElementForScaling(destRoomMarkerTfm);
	}

	public void Unselect(bool triggerHeroSelectionEvent = true, bool assertAtLeastOneHeroIsSelected = true)
	{
		if (!selectedHeroes.Contains(this))
		{
			Diagnostics.LogError("Unable to unselect " + base.name + ": this is not the selected hero!");
			return;
		}
		selectorRenderer.enabled = false;
		destRoomMarkerRnd.enabled = false;
		selectedHeroes.Remove(this);
		if (assertAtLeastOneHeroIsSelected && selectedHeroes.Count < 1 && localPlayerActiveRecruitedHeroes.Count > 0)
		{
			localPlayerActiveRecruitedHeroes[0].Select(recordSelectTime: false, unselectOthers: false, triggerHeroSelectionEvent: false);
			if (!base.HealthCpnt.IsAlive())
			{
				HeroListPanel heroListPanel = SingletonManager.Get<HeroListPanel>();
				heroListPanel.RefreshContent();
				heroListPanel.GetHeroItem(SelectedHeroes[0]).SelectHero();
			}
		}
		if (triggerHeroSelectionEvent)
		{
			gameEventManager.TriggerHeroSelectionEvent();
		}
		selectTacticalMapElementAnim.Stop();
		if (TamedMob != null)
		{
			TamedMob.Select(selected: false);
		}
	}

	private void OnDeath(ulong attackerOwnerPlayerID)
	{
		if (IsRespawning)
		{
			return;
		}
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			if (IsRecruited)
			{
				dungeon.EnqueueAlertNotification(AgeLocalizer.Instance.LocalizeString("%Notification_HeroDied").Replace("$HeroName", LocalizedName), "HeroDied");
				audioEventManager.Play2DEvent("Master/Jingles/HeroDeath");
				dungeon.Statistics.IncrementStat(DungeonStatistics.Stat_LostHeroes);
				dungeon.Statistics.IncrementStat(DungeonStatistics.Stat_LostHeroesCurrentFloor);
				achievementManager.AddToStatistic(StatisticName.HERO_DEATH_NEGATIVE, -1f);
				dungeon.RegisterHeroDeath(this);
				AchievementManagerDOTE achievementManagerDOTE = SingletonManager.Get<AchievementManagerDOTE>();
				achievementManagerDOTE.IncrementStatistic(StatisticName.LOST_HEROES);
				if (base.Level <= GameConfig.GetGameConfig().MaxLevelCount)
				{
					GoogleAnalyticsManager googleAnalyticsManager = SingletonManager.Get<GoogleAnalyticsManager>();
					if (googleAnalyticsManager != null)
					{
						googleAnalyticsManager.SendHeroDeathAnalytics(this);
					}
					try
					{
						achievementManagerDOTE.IncrementStatistic(("FLOOR_" + base.Level.ToString() + "_HERO_DEATHS").ToEnum<StatisticName>());
					}
					catch (ArgumentException ex)
					{
						Diagnostics.LogError("Missing hero death stat: " + ex.Message);
					}
				}
				if (IsInteracting && npcMoveTarget != null && Services.GetService<IInputService>().CurrentControlScheme == ControlScheme.XBoxOneController)
				{
					gameControlManager.SetHeroStatsPanelDisplay(on: false);
					SingletonManager.Get<SelectableManager>().SetCategory(SelectionCategory.RoomForMove);
				}
				if (TamedMob != null && TamedMob.HealthCpnt != null)
				{
					TamedMob.HealthCpnt.Kill();
				}
			}
			SpawnDeadHeroLoot();
		}
		if (IsRecruited)
		{
			RecentlyDeceasedHeroes.Add(this);
			if (!DeadHeroes.Contains(this))
			{
				DeadHeroes.Add(this);
			}
		}
		GameOver();
	}

	private void GameOver()
	{
		if (HasCrystal)
		{
			IGameCameraService service = Services.GetService<IGameCameraService>();
			if (service.IsTacticalMapActive())
			{
				service.SwitchToGameCamera();
			}
			else if (!service.IsSwitchingCamera)
			{
				service.Focus(base.transform.position, LerpType.Smoothed, -1f);
				service.ZoomIn();
			}
			Time.timeScale = 0.5f;
			if (base.NetSyncElement.IsOwnedByLocalPlayer())
			{
				dungeon.LevelOver();
			}
		}
		spriteAnim.ResetAllTriggers();
		spriteAnim.Trigger(SpriteAnimationTrigger.OnDeath);
		RemoveFromDungeon();
	}

	private void OnDanger()
	{
		if (!IsRecruited)
		{
			base.RoomElement.ParentRoom.DisplayOffscreenMarker(heroDangerIconData);
		}
	}

	public void SpawnDeadHeroLoot()
	{
		Room parentRoom = base.RoomElement.ParentRoom;
		if (parentRoom == null)
		{
			return;
		}
		List<InventoryItemData> list = new List<InventoryItemData>();
		for (int i = 0; i < EquipmentSlots.Length; i++)
		{
			InventoryItem equippedItem = EquipmentSlots[i].EquippedItem;
			if (equippedItem != null)
			{
				list.Add(new InventoryItemData
				{
					ItemDescName = equippedItem.ItemConfig.Name,
					RarityDescName = ((equippedItem.RarityCfg == null) ? null : equippedItem.RarityCfg.Name)
				});
			}
		}
		if (list.Count != 0)
		{
			Vector3 vector = base.transform.position;
			if (!AICpnt.CanAttack())
			{
				vector = parentRoom.CenterPosition;
			}
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Hero_InstantiateDeadHeroItem, base.NetSyncElement.OwnerPlayerID, list.ToArray(), parentRoom.UniqueID.ID, vector);
		}
	}

	private void RPC_InstantiateDeadHeroItem(ulong ownerPlayerID, InventoryItemData[] inventoryItemsData, int spawnRoomID, Vector3 spawnPosition)
	{
		Room spawnRoom = UniqueIDManager.Get<Room>(spawnRoomID);
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(dungeon.GetItemPrefab(ItemType.ItemHero), spawnPosition, Quaternion.identity);
		dungeon.AddDynamicElementForScaling(gameObject.transform);
		ItemHero component = gameObject.GetComponent<ItemHero>();
		component.InitForDeadHeroLoot(ownerPlayerID, inventoryItemsData, spawnRoom);
	}

	private void RemoveFromDungeon()
	{
		base.RoomElement.ParentRoom.OnHeroExit(this);
		dungeon.RefreshSim();
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			CancelItemGathering();
		}
		CancelNPCInteraction();
		Unbind();
		if (IsRecruited)
		{
			IsRecruited = false;
			if (base.NetSyncElement.IsOwnedByLocalPlayer())
			{
				ModifyLocalActiveHeroes(add: false, this);
			}
			else
			{
				remotePlayersActiveRecruitedHeroes.Remove(this);
			}
			if (!DeadHeroes.Contains(this))
			{
				DeadHeroes.Add(this);
			}
			bool flag = false;
			if ((!gameNetManager.IsMultiplayerSession()) ? (LocalPlayerActiveRecruitedHeroes.Count < 1) : ((!MultiplayerConfig.AllPlayersMustSurvive) ? (LocalPlayerActiveRecruitedHeroes.Count < 1 && RemotePlayersActiveRecruitedHeroes.Count < 1) : (LocalPlayerActiveRecruitedHeroes.Count < 1)))
			{
				IGameCameraService service = Services.GetService<IGameCameraService>();
				if (service.IsTacticalMapActive())
				{
					service.SwitchToGameCamera();
				}
				service.Focus(base.transform.position, LerpType.Smoothed, -1f);
				service.ZoomIn();
				Time.timeScale = 0.5f;
				if (base.NetSyncElement.IsOwnedByLocalPlayer())
				{
					dungeon.LevelOver();
				}
			}
			if (selectedHeroes.Contains(this))
			{
				Unselect();
			}
			gameEventManager.TriggerHeroListChangedEvent();
			if (Hero.OnActiveHeroDeath != null)
			{
				Hero.OnActiveHeroDeath();
			}
		}
		if (destRoomMarkerTfm != null)
		{
			UnityEngine.Object.Destroy(destRoomMarkerTfm.gameObject);
		}
	}

	private void OnHealStart()
	{
		base.AudioEmitter.PlayEvent("Master/Environment/HealState");
	}

	private void OnHealthChanged()
	{
		float num = initalHealthBarScaleY;
		float num2 = initalHealthBarScaleX;
		if (base.HealthCpnt.GetHealthRatio() < lowHealthValue)
		{
			num *= lowHealthBarScaleY;
			num2 *= lowHealthBarScaleX;
			Vector3 localScale = base.HealthCpnt.HealthBar.BarContainer.localScale;
			if (localScale.y == initalHealthBarScaleY)
			{
				audioEventManager.Play2DEvent("Master/Jingles/LowHealth");
			}
		}
		Transform barContainer = base.HealthCpnt.HealthBar.BarContainer;
		float x = num2;
		float y = num;
		Vector3 localScale2 = base.HealthCpnt.HealthBar.BarContainer.localScale;
		barContainer.localScale = new Vector3(x, y, localScale2.z);
	}

	private void OnTargetKilled(Health targetHealth)
	{
		Mob component = targetHealth.GetComponent<Mob>();
		if (!(component != null))
		{
			return;
		}
		if (dungeon.CurrentCrystalState != CrystalState.Unplugged)
		{
			foodBonusFromMobKills += GetSimPropertyValue(SimulationProperties.FoodBonusPerMobKilled);
			if (foodBonusFromMobKills >= 1f)
			{
				float num = Mathf.Floor(foodBonusFromMobKills);
				Player.LocalPlayer.AddFood(num);
				foodBonusFromMobKills -= num;
			}
			industryBonusFromMobKills += GetSimPropertyValue(SimulationProperties.IndustryBonusPerMobKilled);
			if (industryBonusFromMobKills >= 1f)
			{
				float num2 = Mathf.Floor(industryBonusFromMobKills);
				Player.LocalPlayer.AddIndustry(num2);
				industryBonusFromMobKills -= num2;
			}
		}
		defenseBonusFromMobKills = Mathf.Min(defenseBonusFromMobKills + GetSimPropertyValue(SimulationProperties.DefenseBonusPerMobKilled), GetSimPropertyValue(SimulationProperties.DefenseBonusPerMobKilled_Max));
		SetSimPropertyBaseValue(SimulationProperties.DefenseBonusFromMobKills, defenseBonusFromMobKills);
		attackBonusFromMobKills = Mathf.Min(attackBonusFromMobKills + GetSimPropertyValue(SimulationProperties.AttackBonusPerMobKilled), GetSimPropertyValue(SimulationProperties.AttackBonusPerMobKilled_Max));
		SetSimPropertyBaseValue(SimulationProperties.AttackBonusFromMobKills, attackBonusFromMobKills);
	}

	private void OnInteractionTargetDeath(ulong attackerOwnerPlayerID)
	{
		CancelNPCInteraction();
	}

	private void Dungeon_OnRoomPowered(Room room, bool powered)
	{
		RefreshSim(refreshParent: false);
	}

	private void OnGameVictory()
	{
		if (IsRecruited && base.HealthCpnt.IsAlive() && base.NetSyncElement.IsOwnedByLocalPlayer() && base.WasInExitRoomAtExitTime)
		{
			if (UnlockLevel > 0)
			{
				UnlockHero(Config);
			}
			dungeon.RegisterHeroVictory(this);
		}
	}

	private void OnLeftClickDown(ClickDownInfo clickInfo)
	{
		if (IsRecruited && base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Select();
			Services.GetService<IInputService>().StopClickEventPropagation();
		}
	}

	private void OnRightClickDown(ClickDownInfo clickInfo)
	{
		if (selectedHeroes.Count > 0)
		{
			if (!IsRecruited && !IsDismissing)
			{
				foreach (Hero selectedHero in selectedHeroes)
				{
					selectedHero.MoveToHero(this);
				}
			}
			else
			{
				foreach (Hero selectedHero2 in selectedHeroes)
				{
					selectedHero2.MoveToRoom(base.RoomElement.ParentRoom);
				}
			}
			Services.GetService<IInputService>().StopClickEventPropagation();
		}
		else if (!IsRecruited && localPlayerActiveRecruitedHeroes.Count < 1 && gameNetManager.IsMultiplayerSession())
		{
			DisplayRecruitmentDialog();
		}
	}

	private void OnDisable()
	{
		gameEventManager.OnGameVictory -= OnGameVictory;
		if (!IsRecruited && base.HealthCpnt.IsAlive())
		{
			dungeon.AddToDiscoverableHeroPool(Config);
		}
	}

	private void OnDestroy()
	{
		if (gameEventManager != null)
		{
			gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChangedDuringAction;
			gameEventManager.OnDungeonTurnChanged -= GameEventManager_OnDungeonTurnChanged;
		}
		if (playerNamePanel != null)
		{
			playerNamePanel.Unload();
			UnityEngine.Object.Destroy(playerNamePanel.gameObject);
			playerNamePanel = null;
		}
		if (gameNetManager == null)
		{
			gameNetManager = SingletonManager.Get<GameNetworkManager>();
		}
		if (gameNetManager != null)
		{
			gameNetManager.ClearCachedAITargets(this);
		}
	}

	public static void ModifyLocalActiveHeroes(bool add, Hero hero)
	{
		if (add)
		{
			LocalPlayerActiveRecruitedHeroes.Add(hero);
		}
		else
		{
			LocalPlayerActiveRecruitedHeroes.Remove(hero);
		}
		if (Hero.OnLocalActiveHeroesChange != null)
		{
			Hero.OnLocalActiveHeroesChange();
		}
	}
}
public class HeroMobCommon : SimMonoBehaviour
{
	private struct SimEffect
	{
		public StaticString SimPropertyName;

		public string VFXPath;

		public GameObject VFXGameObj;

		public string SFXPath;
	}

	public delegate void LevelUpEventHandler();

	[SerializeField]
	protected SpriteAnimationRuntime2 spriteAnim;

	[SerializeField]
	protected SpriteAnimationRuntime2 levelUpSpriteAnim;

	[SerializeField]
	private float simEffectUpdateStartTime;

	[SerializeField]
	private float simEffectUpdateRepeatPeriod;

	public LevelUpEventHandler OnLevelUp;

	protected Attacker attackerCpnt;

	protected GameNetworkManager gameNetManager;

	private List<SimEffect> simEffects = new List<SimEffect>();

	private GameObject _simEffectVFXPfb;

	private GameObject _simEffectVFXGO;

	private SimEffect _simEffectVFX;

	public RoomElement RoomElement
	{
		get;
		private set;
	}

	public UniqueIDNetSyncElement NetSyncElement
	{
		get;
		private set;
	}

	public Health HealthCpnt
	{
		get;
		private set;
	}

	public int Level
	{
		get;
		protected set;
	}

	public AudioEmitter AudioEmitter
	{
		get;
		private set;
	}

	public bool WasInExitRoomAtExitTime
	{
		get;
		set;
	}

	public SpriteAnimationRuntime2 SpriteAnim => spriteAnim;

	public virtual string GetLevelDescriptorName(int level)
	{
		return null;
	}

	private void Start()
	{
		if (simEffectUpdateStartTime >= 0f && simEffectUpdateRepeatPeriod >= 0f)
		{
			InvokeRepeating("SimEffectUpdate", simEffectUpdateStartTime, simEffectUpdateRepeatPeriod);
		}
	}

	protected void Init(ulong ownerPlayerID)
	{
		NetSyncElement.SetOwner(ownerPlayerID);
		IDatabase<SkillConfig> database = null;
		IDatabase<AttackTypeConfig> database2 = null;
		foreach (SimulationProperty property in GetSimObj().Properties)
		{
			string text = property.Name;
			if (text.StartsWith(SimulationProperties.SkillEffectPrefix) && text.EndsWith(SimulationProperties.SkillEffectSuffix))
			{
				if (database == null)
				{
					database = Databases.GetDatabase<SkillConfig>();
				}
				string text2 = text.ToString().Replace(SimulationProperties.SkillEffectSuffix, string.Empty);
				SkillConfig value = database.GetValue(text2);
				if (value == null)
				{
					Diagnostics.LogError("Unable to find {0} skill config while scanning for sim effect properties!", text2);
				}
				else
				{
					simEffects.Add(new SimEffect
					{
						SimPropertyName = text,
						SFXPath = value.TargetSFXPath,
						VFXPath = value.TargetVFXPath
					});
				}
			}
			else if (text.EndsWith(SimulationProperties.AttackBurnSuffix))
			{
				if (database2 == null)
				{
					database2 = Databases.GetDatabase<AttackTypeConfig>();
				}
				string text3 = text.ToString().Replace(SimulationProperties.AttackBurnSuffix, string.Empty);
				AttackTypeConfig value2 = database2.GetValue(text3);
				if (value2 == null)
				{
					Diagnostics.LogError("Unable to find {0} attack type config while scanning for sim effect properties!", text3);
				}
				else
				{
					simEffects.Add(new SimEffect
					{
						SimPropertyName = text,
						SFXPath = value2.BurnSFXPath,
						VFXPath = value2.BurnVFXPath
					});
				}
			}
		}
	}

	protected override void Awake()
	{
		base.Awake();
		NetSyncElement = GetComponent<UniqueIDNetSyncElement>();
		RoomElement = GetComponent<RoomElement>();
		HealthCpnt = GetComponent<Health>();
		attackerCpnt = GetComponent<Attacker>();
		AudioEmitter = GetComponent<AudioEmitter>();
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
	}

	public void SimEffectUpdate()
	{
		if (simEffects == null)
		{
			return;
		}
		for (int i = 0; i < simEffects.Count; i++)
		{
			SimEffect simEffect = simEffects[i];
			float simPropertyValue = GetSimPropertyValue(simEffect.SimPropertyName);
			if (simPropertyValue > 0f)
			{
				SimEffect simEffect2 = simEffects[i];
				if (simEffect2.VFXGameObj == null)
				{
					SimEffect simEffect3 = simEffects[i];
					if (simEffect3.VFXPath != null)
					{
						SimEffect simEffect4 = simEffects[i];
						_simEffectVFXPfb = Resources.Load<GameObject>(simEffect4.VFXPath);
						_simEffectVFXGO = (UnityEngine.Object.Instantiate(_simEffectVFXPfb, base.transform.position, Quaternion.identity) as GameObject);
						_simEffectVFXGO.transform.parent = base.transform;
						GameObject simEffectVFXGO = _simEffectVFXGO;
						SimEffect simEffect5 = simEffects[i];
						simEffectVFXGO.name = simEffect5.SimPropertyName;
						_simEffectVFX = simEffects[i];
						_simEffectVFX.VFXGameObj = _simEffectVFXGO;
						simEffects[i] = _simEffectVFX;
					}
					SimEffect simEffect6 = simEffects[i];
					if (!string.IsNullOrEmpty(simEffect6.SFXPath))
					{
						if (AudioEmitter != null)
						{
							AudioEmitter audioEmitter = AudioEmitter;
							SimEffect simEffect7 = simEffects[i];
							audioEmitter.PlayEvent(simEffect7.SFXPath);
						}
						else
						{
							Diagnostics.LogError("HeroMob is trying to play a sim effect SFX but has no audio emitter: " + base.name);
						}
					}
				}
				SimEffect simEffect8 = simEffects[i];
				if (simEffect8.VFXGameObj != null)
				{
					SimEffect simEffect9 = simEffects[i];
					if (!simEffect9.VFXGameObj.activeSelf)
					{
						SimEffect simEffect10 = simEffects[i];
						simEffect10.VFXGameObj.SetActive(value: true);
					}
				}
				continue;
			}
			SimEffect simEffect11 = simEffects[i];
			if (simEffect11.VFXGameObj != null)
			{
				SimEffect simEffect12 = simEffects[i];
				if (simEffect12.VFXGameObj.activeSelf)
				{
					SimEffect simEffect13 = simEffects[i];
					simEffect13.VFXGameObj.SetActive(value: false);
				}
			}
		}
	}

	protected void ApplyLevelUp()
	{
		float healthRatio = HealthCpnt.GetHealthRatio();
		SimulationDescriptor dBDescriptorByName = SimMonoBehaviour.GetDBDescriptorByName(GetLevelDescriptorName(Level + 1));
		if (dBDescriptorByName != null)
		{
			AddSimDescriptor(dBDescriptorByName);
		}
		if (NetSyncElement.IsOwnedByLocalPlayer())
		{
			HealthCpnt.SetHealthRatio(healthRatio);
		}
		Level++;
		if (OnLevelUp != null)
		{
			OnLevelUp();
		}
	}
}
public class HeroRoomInteractiveElement : RoomInteractiveElement
{
	protected Hero hero;

	protected override void Awake()
	{
		base.Awake();
		hero = GetComponent<Hero>();
		Hero.OnHeroRecruited += base.RefreshGUIVisibility;
	}

	protected override bool ShouldGUIBeDisplayed()
	{
		return base.ShouldGUIBeDisplayed() && !hero.IsRecruited && hero.IsRecruitable;
	}
}
public class HeroSelectMarkerTacticalMapElement : TacticalMapElement
{
	[SerializeField]
	private Hero hero;

	protected override bool ShouldBeDisplayed()
	{
		return base.ShouldBeDisplayed() && Hero.SelectedHeroes.Contains(hero);
	}
}
public class ItemHeroElement
{
	public ItemHeroConfig ItemHeroCfg
	{
		get;
		private set;
	}

	public RarityConfig RarityCfg
	{
		get;
		private set;
	}

	public ItemHeroElement(InventoryItem item)
	{
		ItemHeroCfg = item.ItemConfig;
		RarityCfg = item.RarityCfg;
	}

	public ItemHeroElement(ItemHeroConfig config, RarityConfig rarity)
	{
		ItemHeroCfg = config;
		RarityCfg = rarity;
	}

	public ItemHeroElement(StaticString configName, StaticString rarityName)
	{
		ItemHeroCfg = (ItemHeroConfig)Databases.GetDatabase<ItemConfig>().GetValue(configName);
		RarityCfg = ItemHeroCfg.GetRandomRarityParametersByName(rarityName);
	}

	public string GetItemHeroName()
	{
		string text = AgeLocalizer.Instance.LocalizeString("%Item_" + ItemHeroCfg.Name.ToString());
		string empty = string.Empty;
		if (RarityCfg != null)
		{
			empty = RarityCfg.GetRarityColorHexaValue();
			if (!string.IsNullOrEmpty(empty))
			{
				text = empty + text + "#REVERT#";
			}
		}
		return text;
	}
}
public class Item : SimMonoBehaviour
{
	protected bool isBeingGathered;

	[SerializeField]
	private Renderer spriteRnd;

	[SerializeField]
	private Vector3 gatheringSpotOffset;

	private ParticleSystem gatheringVfxParticle;

	private ParticleSystem acquiredVfxParticle;

	private AITarget lootTargetCpnt;

	private AudioEmitter audioEmitter;

	public bool IsAcquired
	{
		get;
		private set;
	}

	public StaticString ItemName
	{
		get;
		private set;
	}

	public ItemType Type
	{
		get;
		private set;
	}

	public bool CanBeGathered
	{
		get;
		private set;
	}

	public RoomElement RoomElement
	{
		get;
		private set;
	}

	public virtual void Init(ulong ownerPlayerID, StaticString itemConfigName, StaticString rarityConfigName, Room spawnRoom, ItemType type)
	{
		base.UniqueID.RequestUniqueIDForPlayer(ownerPlayerID);
		ItemName = itemConfigName;
		Type = type;
		base.name = itemConfigName.ToString() + "_" + base.name;
		RoomElement.SetParentRoom(spawnRoom);
		if (spriteRnd != null)
		{
			string text = "Materials/Items/" + ItemName;
			Material material = (Material)Resources.Load(text, typeof(Material));
			if (material == null)
			{
				Diagnostics.LogError("Unable to find \"" + base.name + "\" item texture (path=" + text + ")");
			}
			else
			{
				spriteRnd.material = material;
			}
			spriteRnd.enabled = true;
		}
		AddSimDescriptor(SimMonoBehaviour.GetDBDescriptorByName("Item_" + itemConfigName), refresh: false);
		RefreshSim(refreshParent: false);
		if (GetSimPropertyValue(SimulationProperties.Food) == 0f)
		{
			SetSimPropertyBaseValue(SimulationProperties.Food, GenericUtilities.RoundHalfAwayFromZero(RandomGenerator.RangeFloat(GetSimPropertyValue(SimulationProperties.MinFood), GetSimPropertyValue(SimulationProperties.MaxFood))), refresh: false);
		}
		if (GetSimPropertyValue(SimulationProperties.Industry) == 0f)
		{
			SetSimPropertyBaseValue(SimulationProperties.Industry, GenericUtilities.RoundHalfAwayFromZero(RandomGenerator.RangeFloat(GetSimPropertyValue(SimulationProperties.MinIndustry), GetSimPropertyValue(SimulationProperties.MaxIndustry))), refresh: false);
		}
		if (GetSimPropertyValue(SimulationProperties.Dust) == 0f)
		{
			SetSimPropertyBaseValue(SimulationProperties.Dust, GenericUtilities.RoundHalfAwayFromZero(RandomGenerator.RangeFloat(GetSimPropertyValue(SimulationProperties.MinDust), GetSimPropertyValue(SimulationProperties.MaxDust))), refresh: false);
		}
		if (GetSimPropertyValue(SimulationProperties.Science) == 0f)
		{
			SetSimPropertyBaseValue(SimulationProperties.Science, GenericUtilities.RoundHalfAwayFromZero(RandomGenerator.RangeFloat(GetSimPropertyValue(SimulationProperties.MinScience), GetSimPropertyValue(SimulationProperties.MaxScience))), refresh: false);
		}
		RefreshSim(refreshParent: false);
		GameObject gameObject = (GameObject)Resources.Load("VFX/Items/" + itemConfigName + "/ItemGathering", typeof(GameObject));
		if (gameObject != null)
		{
			GameObject gameObject2 = (GameObject)UnityEngine.Object.Instantiate(gameObject, base.transform.position, base.transform.rotation);
			gameObject2.transform.parent = base.transform;
			gatheringVfxParticle = gameObject2.GetComponent<ParticleSystem>();
		}
		gameObject = (GameObject)Resources.Load("VFX/Items/" + itemConfigName + "/ItemAcquired", typeof(GameObject));
		if (gameObject == null)
		{
			gameObject = (GameObject)Resources.Load("VFX/Items/ItemAcquiredDefault", typeof(GameObject));
		}
		if (gameObject != null)
		{
			GameObject gameObject3 = (GameObject)UnityEngine.Object.Instantiate(gameObject, base.transform.position, base.transform.rotation);
			gameObject3.transform.parent = base.transform;
			acquiredVfxParticle = gameObject3.GetComponent<ParticleSystem>();
		}
		CanBeGathered = true;
		lootTargetCpnt.Init(this);
	}

	public Vector3 GetGatheringPosition()
	{
		return base.transform.position + gatheringSpotOffset;
	}

	public virtual void StartGathering(Hero gatherer)
	{
		if (isBeingGathered)
		{
			Diagnostics.LogError("Already gathered");
			return;
		}
		isBeingGathered = true;
		CanBeGathered = false;
		ItemType type = Type;
		if (type == ItemType.ItemHero || type == ItemType.Chest)
		{
			audioEmitter.PlayEvent("Master/Environment/OpenCrest");
		}
	}

	public virtual void StopGathering()
	{
		isBeingGathered = false;
		CanBeGathered = true;
	}

	public virtual void Acquire(Hero acquisitor)
	{
		if (acquisitor.NetSyncElement.IsOwnedByLocalPlayer())
		{
			SendAcquisitionNotification();
		}
		lootTargetCpnt.SetActive(active: false);
		if (acquiredVfxParticle != null)
		{
			acquiredVfxParticle.Play(withChildren: true);
		}
		if (spriteRnd != null)
		{
			spriteRnd.enabled = false;
		}
		IsAcquired = true;
		if (acquisitor.NetSyncElement.IsOwnedByLocalPlayer() && Type == ItemType.FIDS)
		{
			StaticString fidsType;
			float fIDSAmount = GetFIDSAmount(out fidsType);
			if (fIDSAmount > 0f)
			{
				SingletonManager.Get<Dungeon>().AddSimChild(this);
			}
		}
	}

	public virtual string GetSpawnNotificationDescription(ItemConfig itemConfig)
	{
		string result = string.Empty;
		if (Type == ItemType.FIDS)
		{
			StaticString fidsType;
			float fIDSAmount = GetFIDSAmount(out fidsType);
			result = AgeLocalizer.Instance.LocalizeString("%Event_ItemFIDS").Replace("$FIDSType", AgeLocalizer.Instance.LocalizeString("%FIDS_" + fidsType)).Replace("$FIDSAmount", fIDSAmount.ToString());
		}
		return result;
	}

	public virtual void SendAcquisitionNotification()
	{
		if (Type == ItemType.FIDS)
		{
			StaticString fidsType;
			float fIDSAmount = GetFIDSAmount(out fidsType);
			if (fIDSAmount > 0f)
			{
				SingletonManager.Get<MainGameScreen>().DisplayFIDSGameFeedback(fIDSAmount, fidsType, RoomElement.ParentRoom.transform);
			}
		}
	}

	public float GetFIDSAmount(out StaticString fidsType)
	{
		if (GetSimPropertyValue(SimulationProperties.Food) > 0f)
		{
			fidsType = SimulationProperties.Food;
			return GetSimPropertyValue(SimulationProperties.Food);
		}
		if (GetSimPropertyValue(SimulationProperties.Industry) > 0f)
		{
			fidsType = SimulationProperties.Industry;
			return GetSimPropertyValue(SimulationProperties.Industry);
		}
		if (GetSimPropertyValue(SimulationProperties.Dust) > 0f)
		{
			fidsType = SimulationProperties.Dust;
			return GetSimPropertyValue(SimulationProperties.Dust);
		}
		if (GetSimPropertyValue(SimulationProperties.Science) > 0f)
		{
			fidsType = SimulationProperties.Science;
			return GetSimPropertyValue(SimulationProperties.Science);
		}
		fidsType = string.Empty;
		return 0f;
	}

	protected override Type GetSimClass()
	{
		return typeof(Item);
	}

	protected virtual void UpdateRendering()
	{
		if (isBeingGathered && !IsAcquired)
		{
			UpdateGatheringVfx();
		}
	}

	protected virtual bool CanBeDestroyed()
	{
		return IsGatheringVfxFinished() && IsAcquiredVfxFinished();
	}

	protected override void Awake()
	{
		base.Awake();
		lootTargetCpnt = GetComponent<AITarget>();
		audioEmitter = GetComponent<AudioEmitter>();
		RoomElement = GetComponent<RoomElement>();
	}

	private void UpdateGatheringVfx()
	{
		if (gatheringVfxParticle != null && !gatheringVfxParticle.isPlaying)
		{
			gatheringVfxParticle.Play(withChildren: true);
		}
	}

	protected override void Update()
	{
		base.Update();
		if (IsAcquired && CanBeDestroyed())
		{
			UnityEngine.Object.Destroy(base.gameObject);
			IsAcquired = false;
		}
		else
		{
			UpdateRendering();
		}
	}

	private bool IsGatheringVfxFinished()
	{
		return gatheringVfxParticle == null || !gatheringVfxParticle.isPlaying;
	}

	private bool IsAcquiredVfxFinished()
	{
		return acquiredVfxParticle == null || !acquiredVfxParticle.isPlaying;
	}

	private void OnDestroy()
	{
		GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
		if (gameNetworkManager != null)
		{
			gameNetworkManager.ClearCachedAITargets(this);
		}
	}
}
public class ItemAnimated : Item
{
	[SerializeField]
	protected SpriteAnimationRuntime2 spriteAnim;

	protected bool FlatSprite;

	public bool IsPlayingTransitionAnimation
	{
		get;
		private set;
	}

	public override void Init(ulong ownerPlayerID, StaticString itemConfigName, StaticString rarityConfigName, Room spawnRoom, ItemType type)
	{
		base.Init(ownerPlayerID, itemConfigName, rarityConfigName, spawnRoom, type);
		IDatabase<ItemConfig> database = Databases.GetDatabase<ItemConfig>();
		Diagnostics.Assert(database != null);
		ItemConfig value = null;
		if (database.TryGetValue(itemConfigName, out value))
		{
			FlatSprite = value.FlatSprite;
		}
		if (FlatSprite)
		{
			Transform transform = spriteAnim.transform;
			Vector3 localEulerAngles = spriteAnim.transform.localEulerAngles;
			float y = localEulerAngles.y;
			Vector3 localEulerAngles2 = spriteAnim.transform.localEulerAngles;
			transform.localEulerAngles = new Vector3(90f, y, localEulerAngles2.z);
		}
		spriteAnim.OverrideClipsFromPath("SpriteAnimations/Items/" + itemConfigName);
		IsPlayingTransitionAnimation = false;
	}

	public override void StartGathering(Hero gatherer)
	{
		base.StartGathering(gatherer);
		spriteAnim.Trigger(SpriteAnimationTrigger.OnGatheringStart);
		IsPlayingTransitionAnimation = true;
	}

	public override void StopGathering()
	{
		base.StopGathering();
		spriteAnim.Trigger(SpriteAnimationTrigger.OnGatheringStop);
		IsPlayingTransitionAnimation = true;
	}

	public override void Acquire(Hero acquisitor)
	{
		base.Acquire(acquisitor);
		spriteAnim.Trigger(SpriteAnimationTrigger.OnGathered);
	}

	protected override void UpdateRendering()
	{
		base.UpdateRendering();
		if (IsPlayingTransitionAnimation && !spriteAnim.IsPlaying)
		{
			IsPlayingTransitionAnimation = false;
		}
	}
}
public class ItemHero : ItemAnimated
{
	public static StaticString ItemHeroName_Chest = "Chest";

	private List<InventoryItem> inventoryItems;

	public List<ItemHeroElement> ItemElements
	{
		get;
		set;
	}

	public void InitForDeadHeroLoot(ulong ownerPlayerID, InventoryItemData[] inventoryItemsData, Room spawnRoom)
	{
		base.Init(ownerPlayerID, ItemHeroName_Chest, (StaticString)null, spawnRoom, ItemType.Chest);
		foreach (InventoryItemData inventoryItemData in inventoryItemsData)
		{
			AddItemElement(new ItemHeroElement(inventoryItemData.ItemDescName, inventoryItemData.RarityDescName));
		}
		BuildInventoryItems(ownerPlayerID);
	}

	public override void Init(ulong ownerPlayerID, StaticString itemConfigName, StaticString rarityConfigName, Room spawnRoom, ItemType type)
	{
		base.Init(ownerPlayerID, ItemHeroName_Chest, rarityConfigName, spawnRoom, type);
		IDatabase<ItemConfig> database = Databases.GetDatabase<ItemConfig>();
		Diagnostics.Assert(database != null);
		ItemConfig value = null;
		if (database.TryGetValue(itemConfigName, out value))
		{
			if (value is ItemHeroConfig)
			{
				ItemHeroConfig itemHeroConfig = value as ItemHeroConfig;
				RarityConfig randomRarityParametersByName = itemHeroConfig.GetRandomRarityParametersByName(rarityConfigName);
				AddItemElement(new ItemHeroElement(itemHeroConfig, randomRarityParametersByName));
			}
			else
			{
				Diagnostics.LogError("[ItemItemHero] Init: bad type for item config (" + itemConfigName + "). It must be declared as ItemHeroConfig");
			}
		}
		else
		{
			Diagnostics.LogError("[ItemItemHero] Init: item config (" + itemConfigName + ") not found in the database");
		}
		BuildInventoryItems(ownerPlayerID);
	}

	public override void Acquire(Hero acquisitor)
	{
		Diagnostics.LogWarning(base.name + " > Acquired by " + acquisitor.name);
		base.Acquire(acquisitor);
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		if (true)
		{
			int count = inventoryItems.Count;
			for (int i = 0; i < count; i++)
			{
				inventoryItems[i].OwnerPlayerID = acquisitor.NetSyncElement.OwnerPlayerID;
				dungeon.GetBestAvailableInventoryForPlayer(acquisitor.NetSyncElement.OwnerPlayerID).AddItem(inventoryItems[i]);
			}
		}
		ItemElements.Clear();
		ItemElements = null;
	}

	public override string GetSpawnNotificationDescription(ItemConfig itemConfig)
	{
		return AgeLocalizer.Instance.LocalizeString("%Event_ItemHero");
	}

	public override void SendAcquisitionNotification()
	{
		foreach (ItemHeroElement itemElement in ItemElements)
		{
			SendItemAcquisitionNotification(itemElement);
		}
	}

	public static void SendItemAcquisitionNotification(ItemHeroElement itemHeroElement)
	{
		SingletonManager.Get<Dungeon>().EnqueueNotification(AgeLocalizer.Instance.LocalizeString("%Notification_NewItemHero").Replace("$ItemName", itemHeroElement.GetItemHeroName()), OnNotificationClick, "NewItem", foreGround: false, itemHeroElement.ItemHeroCfg.Name);
	}

	public static void OnNotificationClick()
	{
		Services.GetService<IGameControlService>().SetHeroStatsPanelDisplay(on: true);
	}

	public float GetCost(bool basicCost = false, NPCMerchant merchant = null)
	{
		if (base.Type != ItemType.ItemHero)
		{
			return 0f;
		}
		float num = 0f;
		foreach (InventoryItem inventoryItem in inventoryItems)
		{
			num += ((!basicCost) ? inventoryItem.GetCost(merchant) : inventoryItem.GetBasicCost());
		}
		return num;
	}

	private void BuildInventoryItems(ulong ownerPlayerID)
	{
		inventoryItems = new List<InventoryItem>();
		foreach (ItemHeroElement itemElement in ItemElements)
		{
			if (itemElement.ItemHeroCfg != null)
			{
				InventoryItem inventoryItem = new InventoryItem(itemElement.ItemHeroCfg, itemElement.RarityCfg, ownerPlayerID);
				inventoryItem.Init();
				inventoryItems.Add(inventoryItem);
			}
		}
	}

	private void AddItemElement(ItemHeroElement item)
	{
		if (ItemElements == null)
		{
			ItemElements = new List<ItemHeroElement>();
		}
		ItemElements.Add(item);
	}
}
public class LiftCrystal : MonoBehaviour
{
	[SerializeField]
	private SpriteAnimationRuntime2 crystalAnim;

	[SerializeField]
	private SpriteAnimationRuntime2 baseAnim;

	private Dungeon dungeon;

	public void Show()
	{
		if (dungeon == null)
		{
			dungeon = SingletonManager.Get<Dungeon>();
		}
		crystalAnim.OverrideClipsFromPath("SpriteAnimations/Modules/" + SimulationProperties.SpecialModule_Crystal + "_" + dungeon.CrystalType + "/LVL1");
		crystalAnim.Play();
		baseAnim.Play();
	}

	public void Hide()
	{
		crystalAnim.Stop();
		baseAnim.Stop();
	}
}
[RequireComponent(typeof(SpriteAnimationRuntime2))]
public class LiftHero : MonoBehaviour
{
	[SerializeField]
	private SpriteAnimationRuntime2 tamedMobSpriteAnimation;

	private SpriteRendererToLightManager spriteRendererToLightManager;

	public SpriteAnimationRuntime2 SpriteAnimation
	{
		get;
		private set;
	}

	public string HeroName
	{
		get;
		private set;
	}

	public int HeroLiftNumber
	{
		get;
		private set;
	}

	public ulong OwnerPlayerId
	{
		get;
		private set;
	}

	private void Awake()
	{
		SpriteAnimation = GetComponent<SpriteAnimationRuntime2>();
		spriteRendererToLightManager = GetComponent<SpriteRendererToLightManager>();
	}

	public void BindAndShow(string heroName, int heroLiftNumber, ulong ownerId, string tamedMobName)
	{
		HeroName = heroName;
		HeroLiftNumber = heroLiftNumber;
		OwnerPlayerId = ownerId;
		SpriteAnimation.OverrideClipsFromPath("SpriteAnimations/Hero/" + heroName.Replace("Hero_", string.Empty));
		SpriteAnimation.SetAnimDirection(Vector3.forward);
		SpriteAnimation.Play();
		if (!string.IsNullOrEmpty(tamedMobName))
		{
			tamedMobSpriteAnimation.OverrideClipsFromPath("SpriteAnimations/Mob/" + tamedMobName.Replace("Mob_", string.Empty));
			tamedMobSpriteAnimation.SetAnimDirection(Vector3.forward);
			tamedMobSpriteAnimation.Play();
		}
		if (spriteRendererToLightManager != null)
		{
			spriteRendererToLightManager.enabled = true;
		}
	}

	public void Attack(int victimLiftNumber)
	{
		Vector3 vector = Vector3.zero;
		if (Mathf.Abs(HeroLiftNumber - victimLiftNumber) == 1)
		{
			if (HeroLiftNumber == 0 && victimLiftNumber == 1)
			{
				vector = Vector3.left;
			}
			else if (HeroLiftNumber == 1 && victimLiftNumber == 0)
			{
				vector = Vector3.right;
			}
			else if (HeroLiftNumber == 2 && victimLiftNumber == 3)
			{
				vector = Vector3.back;
			}
			else if (HeroLiftNumber == 3 && victimLiftNumber == 2)
			{
				vector = Vector3.forward;
			}
		}
		if (vector == Vector3.zero)
		{
			Diagnostics.LogWarning("Unsupported dialog murder positions: {0} shooting at {1}", HeroLiftNumber, victimLiftNumber);
		}
		else
		{
			SpriteAnimation.SetAnimDirection(vector);
		}
		SpriteAnimation.Trigger(SpriteAnimationTrigger.OnAttack);
	}

	public void Die()
	{
		SpriteAnimation.Trigger(SpriteAnimationTrigger.OnDeath);
	}

	public void Hide()
	{
		SpriteAnimation.Stop();
		tamedMobSpriteAnimation.Hide();
		if (spriteRendererToLightManager != null)
		{
			spriteRendererToLightManager.enabled = false;
		}
	}
}
public class LowLight : DirtyLight
{
}
public class Mob : HeroMobCommon
{
	public delegate void MobDeathHandler(Mob mob);

	private static List<Mob> activeMobs;

	private static readonly int maxMobShadowPerRoom = 5;

	private static readonly int maxTotalMobShadow = 50;

	private static readonly int maxNormalAIFreqMobPerRoom = 10;

	private static readonly int maxTotalNormalAIFreqMob = 25;

	private static SimulationDescriptor[] tamedMobLevelDescriptors;

	public bool SelfDestruct;

	[SerializeField]
	private bool debug;

	[SerializeField]
	private ParticleSystem debuffSpeedReducerVFX;

	private OffscreenMarker.OffscreenMarkerData spawnIconData;

	[SerializeField]
	private GameObject troubledVFXPfb;

	[SerializeField]
	private SpriteAnimationRuntime2 tacticalMapElementAnim;

	[SerializeField]
	private Renderer healthBarRendererBG;

	[SerializeField]
	private Renderer healthBarRenderer;

	[SerializeField]
	private Material healthBarHeroMaterialBG;

	[SerializeField]
	private Material healthBarHeroMaterial;

	[SerializeField]
	private Renderer selectorRenderer;

	private Vector3 targetLastKnownPos;

	private float nextAttackTime;

	private MobAI aiCpnt;

	private string classDescName;

	private AudioEmitter audioEmitter;

	private Dungeon dungeon;

	private int maxLevel;

	private float delayUpTimer;

	private OffscreenMarker spawnMarker;

	private CleanLight selfLight;

	private string aiConfigNameBackup;

	private AITargetType attackTargetTypeBackup;

	private ParticleSystem troubledVFX;

	private SpriteRenderer spriteRnd;

	private AITarget previousTargetHit;

	private AchievementManagerDOTE achievementManager;

	private StaticString basicMobConfigName;

	public static List<Mob> ActiveMobs
	{
		get
		{
			if (activeMobs == null)
			{
				activeMobs = new List<Mob>();
			}
			return activeMobs;
		}
		private set
		{
			activeMobs = value;
		}
	}

	public Mover MoverCpnt
	{
		get;
		private set;
	}

	public MobClassConfig Config
	{
		get;
		private set;
	}

	public MovableAITarget AttackTargetCpnt
	{
		get;
		private set;
	}

	public string ClassDescName => classDescName;

	public Attacker AttackerCpnt => attackerCpnt;

	public MobAI AICpnt => aiCpnt;

	public bool IsDisplayed
	{
		get;
		private set;
	}

	public Hero Tamer
	{
		get;
		private set;
	}

	public int TameLevel
	{
		get;
		protected set;
	}

	public int TameKillCount
	{
		get;
		set;
	}

	public event MobDeathHandler OnMobDeath;

	public event Action OnTameLevelUp;

	private void SetClass(StaticString mobClassName)
	{
		SimulationDescriptor dBDescriptorByName = SimMonoBehaviour.GetDBDescriptorByName(mobClassName);
		classDescName = dBDescriptorByName.Name;
		string str = dBDescriptorByName.Name.ToString().Replace("Mob_", string.Empty);
		base.name = str + "_" + base.name;
		AddSimDescriptor(dBDescriptorByName);
	}

	protected override void Awake()
	{
		base.Awake();
		spriteRnd = (spriteAnim.GetComponent<Renderer>() as SpriteRenderer);
		MoverCpnt = GetComponent<Mover>();
		attackerCpnt = GetComponent<Attacker>();
		aiCpnt = GetComponent<MobAI>();
		audioEmitter = GetComponent<AudioEmitter>();
		AttackTargetCpnt = GetComponent<MovableAITarget>();
		selfLight = GetComponentInChildren<CleanLight>();
		achievementManager = SingletonManager.Get<AchievementManagerDOTE>();
		base.HealthCpnt.OnDeath += OnDeath;
		base.Level = 1;
		spriteAnim.MonitorAnimEvent("OnLevelUpEnd", OnLevelUpEndAnimEvent);
	}

	public void Init(ulong ownerPlayerID, StaticString mobClassName, Room spawnRoom, SimulationDescriptor additionalSimDesc = null)
	{
		Init(ownerPlayerID);
		base.NetSyncElement.OnOwnerChanged += OnOwnerChanged;
		SetClass(mobClassName);
		if (additionalSimDesc != null)
		{
			AddSimDescriptor(additionalSimDesc);
		}
		dungeon = SingletonManager.Get<Dungeon>();
		delayUpTimer = 0f;
		ActiveMobs.Add(this);
		dungeon.UpdateGamePhase();
		spriteAnim.Play(forceShow: false);
		spriteAnim.MonitorAnimEvent("OnDeathEnd", OnDeathEndAnimEvent);
		base.transform.position += 0.001f * Vector3.up;
		spawnRoom.OnMobEnter(this, randomDelay: false);
		base.HealthCpnt.InitHealth();
		MobClassConfig mobClassConfig = Config = Databases.GetDatabase<MobClassConfig>().GetValue(classDescName);
		maxLevel = mobClassConfig.MaxLevel;
		UpdateAnimNamePrefix();
		attackerCpnt.Init(mobClassConfig.AttackType);
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			aiCpnt.Init(classDescName);
		}
		AttackTargetCpnt.Init(isActive: true, mobClassConfig.AITargetType);
		if (mobClassConfig.Immobile && MoverCpnt != null)
		{
			MoverCpnt.CanMove = false;
			MoverCpnt.enabled = false;
		}
		if (Config.SelfLight)
		{
			base.RoomElement.ParentRoom.CleanLights.Add(selfLight);
			selfLight.GetComponentInChildren<Light>().enabled = true;
		}
		else
		{
			UnityEngine.Object.Destroy(selfLight.gameObject);
		}
		spriteAnim.OverrideClipsFromPath("SpriteAnimations/Mob/" + Config.Name.ToString().Replace("Mob_", string.Empty) + "/LVL" + base.Level);
		if (!string.IsNullOrEmpty(mobClassConfig.NotificationIcon))
		{
			AnimationClip animationClip = Resources.Load<AnimationClip>("SpriteAnimations/OffscreenMarkers/" + mobClassConfig.NotificationIcon);
			if (animationClip == null)
			{
				Diagnostics.LogError(base.name + " can't find notification icon: " + mobClassConfig.NotificationIcon);
			}
			else
			{
				spawnIconData = default(OffscreenMarker.OffscreenMarkerData);
				spawnIconData.IconAnim = animationClip;
				spawnIconData.Duration = mobClassConfig.NotificationDuration;
				spawnIconData.ShowTimer = (mobClassConfig.NotificationDuration > 0f);
				spawnIconData.AlwaysVisible = Config.AlwaysVisible;
				spawnMarker = base.RoomElement.ParentRoom.DisplayOffscreenMarker(spawnIconData);
			}
		}
		basicMobConfigName = Config.Name.ToString().ToUpper().Replace("MOB_", string.Empty)
			.Replace("_ELITE", string.Empty) + "S_";
		Optimize();
	}

	private void Optimize()
	{
		bool castShadows = IsDisplayed && ActiveMobs.Count <= maxTotalMobShadow && base.RoomElement.ParentRoom.Mobs.Count <= maxMobShadowPerRoom;
		spriteRnd.SetShadowCasting(castShadows);
		if (IsDisplayed && ActiveMobs.Count <= maxTotalNormalAIFreqMob && base.RoomElement.ParentRoom.Mobs.Count <= maxNormalAIFreqMobPerRoom)
		{
			aiCpnt.SetNormalTickPeriod();
		}
		else
		{
			aiCpnt.SetSlowTickPeriod();
		}
	}

	private void OnOwnerChanged()
	{
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			aiCpnt.Init((!(GetSimPropertyValue(SimulationProperties.Troubled) > 0f)) ? classDescName : "Mob_Troubled");
			return;
		}
		aiCpnt.IsActive = false;
		if (Tamer != null)
		{
			attackerCpnt.OnHitTarget -= AttackerCpnt_OnHitTarget;
			AICpnt.OnTargetChanged -= AICpnt_OnTargetChanged;
		}
	}

	public void ChangeCurrentRoom(Room newRoom)
	{
		if (base.RoomElement.ParentRoom != null)
		{
			base.RoomElement.ParentRoom.OnRoomContentChanged -= OnCurrentRoomChanged;
		}
		base.RoomElement.SetParentRoom(newRoom);
		base.RoomElement.ParentRoom.OnRoomContentChanged += OnCurrentRoomChanged;
		OnCurrentRoomChanged();
		Optimize();
	}

	public void OnCurrentRoomChanged()
	{
		if (base.RoomElement.ParentRoom.ShouldDisplayMobs() || (Config != null && Config.AlwaysVisible) || Tamer != null)
		{
			Show();
		}
		else
		{
			Hide();
		}
	}

	public void OnTransformEnded()
	{
		if (attackerCpnt != null)
		{
			attackerCpnt.CanAttack = true;
		}
	}

	public override string GetLevelDescriptorName(int level)
	{
		return (string)GetSimDescriptorByType(SimulationProperties.SimDescTypeMob).Name + "_LVL" + level;
	}

	public SpriteAnimDir GetAnimDirection()
	{
		return spriteAnim.CurrentAnimDirection;
	}

	public void Tame(Hero tamer, bool ownerChanged = false)
	{
		Tamer = tamer;
		if (tamer.NetSyncElement.OwnerPlayerID != base.NetSyncElement.OwnerPlayerID)
		{
			base.NetSyncElement.ChangeOwner(tamer.NetSyncElement.OwnerPlayerID);
			if (tamer.NetSyncElement.IsOwnedByLocalPlayer())
			{
				AICpnt.Init(ClassDescName);
			}
		}
		if (AICpnt != null && AICpnt.CurrentTarget != null && AICpnt.CurrentTarget.Type == AITargetType.Door)
		{
			AICpnt.CurrentTarget.GetComponent<Door>().NetSyncElement.SendRPCToAll(UniqueIDRPC.Door_OnAttackerDied, base.UniqueID.GetCategory(), base.UniqueID.ID);
		}
		attackerCpnt.StopAttack();
		AttackTargetCpnt.UpdateType(AITargetType.ShortRangeHero);
		AICpnt.UpdateAIType("TamedMob");
		ActiveMobs.Remove(this);
		if (spawnMarker != null)
		{
			spawnMarker.Hide();
		}
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			attackerCpnt.OnHitTarget += AttackerCpnt_OnHitTarget;
			AICpnt.OnTargetChanged += AICpnt_OnTargetChanged;
		}
		if (!ownerChanged)
		{
			TameLevel = 0;
			SetSimPropertyBaseValue(SimulationProperties.IsTamed, 1f, refresh: false);
			TameLevelUp();
		}
		if (Hero.SelectedHeroes.Contains(tamer))
		{
			Select(selected: true);
		}
		healthBarRenderer.material = healthBarHeroMaterial;
		healthBarRendererBG.material = healthBarHeroMaterialBG;
		tacticalMapElementAnim.GetComponent<SpriteRenderer>().color = Color.green;
		base.HealthCpnt.HealthBar.ShowEvenWhenHolderIsHidden = true;
		base.HealthCpnt.EligibleToInstaRegen = true;
		StaticString staticString = basicMobConfigName + "TAMED";
		try
		{
			StatisticName stat = staticString.ToEnum<StatisticName>();
			achievementManager.IncrementStatistic(stat);
		}
		catch
		{
			Diagnostics.LogWarning("Achievement '{0}' not set", staticString);
		}
		dungeon.UpdateGamePhase();
	}

	public void TameLevelUp(bool saveRestore = false)
	{
		if (this == null || base.gameObject == null || (base.HealthCpnt != null && !base.HealthCpnt.IsAlive()))
		{
			Diagnostics.LogWarning("Can't tame level up as mob is already dead");
			return;
		}
		int tamedMobMaxLevel = GameConfig.GetGameConfig().TamedMobMaxLevel;
		if (TameLevel > tamedMobMaxLevel)
		{
			Diagnostics.LogError("Tamed mob is already max level");
			return;
		}
		Diagnostics.Log("Tamed mob {0} level up to {1}", base.name, TameLevel.ToString());
		float ratio = 0f;
		if (!saveRestore)
		{
			ratio = base.HealthCpnt.GetHealthRatio();
		}
		if (saveRestore || TameLevel == 0)
		{
			RPC_ApplyTameLevelUp(!saveRestore);
		}
		else
		{
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Mob_ApplyTameLevelUp, true);
		}
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			if (!saveRestore)
			{
				base.HealthCpnt.SetHealthRatio(ratio);
			}
			if (TameLevel <= tamedMobMaxLevel)
			{
				TameKillCount = (int)GetSimPropertyValue(SimulationProperties.TameKillCountForLevelUp);
			}
			else
			{
				attackerCpnt.OnHitTarget -= AttackerCpnt_OnHitTarget;
				AICpnt.OnTargetChanged -= AICpnt_OnTargetChanged;
			}
		}
		if (this.OnTameLevelUp != null)
		{
			this.OnTameLevelUp();
		}
	}

	private void RPC_ApplyTameLevelUp(bool feedback)
	{
		if (feedback && TameLevel > 0 && levelUpSpriteAnim != null)
		{
			levelUpSpriteAnim.Trigger(SpriteAnimationTrigger.OnLevelUp);
		}
		int tamedMobMaxLevel = GameConfig.GetGameConfig().TamedMobMaxLevel;
		if (tamedMobLevelDescriptors == null)
		{
			tamedMobLevelDescriptors = new SimulationDescriptor[tamedMobMaxLevel + 1];
			for (int i = 0; i <= tamedMobMaxLevel; i++)
			{
				SimulationDescriptor dBDescriptorByName = SimMonoBehaviour.GetDBDescriptorByName("TamedMob_LVL" + i);
				if (dBDescriptorByName != null)
				{
					tamedMobLevelDescriptors[i] = dBDescriptorByName;
				}
				else
				{
					Diagnostics.LogError("Cannot find descriptor {0}", "TamedMob_LVL" + i);
				}
			}
		}
		if (tamedMobLevelDescriptors.Length <= TameLevel)
		{
			Diagnostics.LogError("Mob.tamedMobLevelDescriptors does not contain a descritor for level " + TameLevel);
			return;
		}
		SimulationDescriptor simulationDescriptor = tamedMobLevelDescriptors[TameLevel++];
		if (simulationDescriptor != null)
		{
			AddSimDescriptor(simulationDescriptor);
		}
	}

	public void Select(bool selected)
	{
		selectorRenderer.enabled = selected;
	}

	private void AICpnt_OnTargetChanged(AITarget previousTarget, AITarget newTarget)
	{
		if (previousTarget != null && previousTarget.Mob != null)
		{
			Mob mob = previousTarget.Mob;
			mob.OnMobDeath = (MobDeathHandler)Delegate.Remove(mob.OnMobDeath, new MobDeathHandler(Mob_OnMobDeath));
		}
	}

	private void AttackerCpnt_OnHitTarget(AITarget target)
	{
		if (previousTargetHit != target && target != null && target.Mob != null && target.Mob != this)
		{
			Mob mob = target.Mob;
			mob.OnMobDeath = (MobDeathHandler)Delegate.Remove(mob.OnMobDeath, new MobDeathHandler(Mob_OnMobDeath));
			Mob mob2 = target.Mob;
			mob2.OnMobDeath = (MobDeathHandler)Delegate.Combine(mob2.OnMobDeath, new MobDeathHandler(Mob_OnMobDeath));
			previousTargetHit = target;
		}
	}

	private void Mob_OnMobDeath(Mob mob)
	{
		TameKillCount--;
		if (TameKillCount <= 0)
		{
			TameLevelUp();
		}
		if (mob != null)
		{
			mob.OnMobDeath = (MobDeathHandler)Delegate.Remove(mob.OnMobDeath, new MobDeathHandler(Mob_OnMobDeath));
		}
	}

	protected override void Update()
	{
		base.Update();
		if (base.NetSyncElement.IsOwnedByLocalPlayer() && base.Level < maxLevel && delayUpTimer >= 0f && (attackerCpnt == null || attackerCpnt.Target == null))
		{
			delayUpTimer += Time.deltaTime;
			if (delayUpTimer >= GetSimPropertyValue(SimulationProperties.DelayUp))
			{
				LevelUp();
				delayUpTimer = 0f;
			}
		}
		bool flag = GetSimPropertyValue(SimulationProperties.Troubled) > 0f;
		if (AttackTargetCpnt.Type != AITargetType.Troubled && flag && Tamer == null)
		{
			attackTargetTypeBackup = AttackTargetCpnt.Type;
			AttackTargetCpnt.UpdateType(AITargetType.Troubled);
			if (base.NetSyncElement.IsOwnedByLocalPlayer())
			{
				aiConfigNameBackup = aiCpnt.AIConfigName;
				aiCpnt.UpdateAIType("Mob_Troubled");
			}
			if (troubledVFX == null)
			{
				troubledVFX = (UnityEngine.Object.Instantiate(troubledVFXPfb, base.transform.position, Quaternion.identity) as GameObject).GetComponent<ParticleSystem>();
				troubledVFX.transform.parent = base.transform;
			}
			if (base.HealthCpnt.IsAlive())
			{
				troubledVFX.Play(withChildren: true);
			}
		}
		else if (AttackTargetCpnt.Type == AITargetType.Troubled && !flag)
		{
			AttackTargetCpnt.UpdateType(attackTargetTypeBackup);
			if (base.NetSyncElement.IsOwnedByLocalPlayer())
			{
				aiCpnt.UpdateAIType(aiConfigNameBackup);
				aiConfigNameBackup = null;
			}
			if (troubledVFX != null)
			{
				troubledVFX.Stop(withChildren: true);
			}
		}
		if (GetSimPropertyValue(SimulationProperties.DebuffSpeedReducerEffect) > 0f)
		{
			if (!debuffSpeedReducerVFX.isPlaying)
			{
				debuffSpeedReducerVFX.Play(withChildren: true);
			}
		}
		else if (debuffSpeedReducerVFX.isPlaying)
		{
			debuffSpeedReducerVFX.Stop(withChildren: true);
		}
	}

	private void Hide()
	{
		if (IsDisplayed)
		{
			spriteAnim.Hide();
			base.HealthCpnt.HealthBar.HideBar();
			tacticalMapElementAnim.Stop();
			IsDisplayed = false;
			Optimize();
		}
	}

	private void Show()
	{
		if (!IsDisplayed)
		{
			spriteAnim.Show();
			base.HealthCpnt.HealthBar.UpdateBarDisplay();
			tacticalMapElementAnim.Play();
			IsDisplayed = true;
			Optimize();
		}
	}

	private void OnDeath(ulong attackerOwnerPlayerID)
	{
		if (this.OnMobDeath != null)
		{
			this.OnMobDeath(this);
		}
		base.RoomElement.ParentRoom.OnMobExit(this);
		base.RoomElement.ParentRoom.OnRoomContentChanged -= OnCurrentRoomChanged;
		ActiveMobs.Remove(this);
		dungeon.UpdateGamePhase();
		delayUpTimer = -1f;
		spriteAnim.ResetAllTriggers();
		if ((SelfDestruct || (AttackerCpnt != null && AttackerCpnt.SelfDestructTimer < 0f)) && Tamer == null)
		{
			spriteAnim.Trigger(SpriteAnimationTrigger.OnKamikaze);
		}
		else
		{
			spriteAnim.Trigger(SpriteAnimationTrigger.OnDeath);
		}
		string deathSFXPath = Databases.GetDatabase<MobClassConfig>().GetValue(classDescName).DeathSFXPath;
		if (!string.IsNullOrEmpty(deathSFXPath))
		{
			audioEmitter.PlayEvent(deathSFXPath);
		}
		if (attackerOwnerPlayerID != 0 && attackerOwnerPlayerID == gameNetManager.GetLocalPlayerID() && RandomGenerator.Value() <= GetSimPropertyValue(SimulationProperties.DustLootProbability))
		{
			dungeon.SpawnDustLoot(GetDustLootAmount(), base.RoomElement.ParentRoom, base.transform.position);
		}
		if (Config.SelfLight)
		{
			base.RoomElement.ParentRoom.CleanLights.Remove(selfLight);
		}
		if (spawnMarker != null)
		{
			spawnMarker.Hide();
		}
		if (troubledVFX != null)
		{
			UnityEngine.Object.Destroy(troubledVFX.gameObject);
		}
		dungeon.Statistics.IncrementStat(DungeonStatistics.Stat_KilledMobs);
		achievementManager.IncrementStatistic(StatisticName.MOBS_KILLED);
		StaticString staticString = basicMobConfigName + "KILLED";
		try
		{
			StatisticName stat = staticString.ToEnum<StatisticName>();
			achievementManager.IncrementStatistic(stat);
		}
		catch
		{
			Diagnostics.LogWarning("Achievement '{0}' not set", staticString);
		}
	}

	private void OnDeathEndAnimEvent()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void LevelUp()
	{
		base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Mob_DoLevelUp);
	}

	private void RPC_DoLevelUp()
	{
		ApplyLevelUp();
		if (attackerCpnt != null)
		{
			attackerCpnt.CanAttack = false;
		}
		UpdateAnimNamePrefix();
		spriteAnim.Trigger(SpriteAnimationTrigger.OnLevelUp, autoPlayIfStopped: true, forceShow: false);
		if (base.HealthCpnt != null)
		{
			base.HealthCpnt.HealthBar.UpdateHealthBarHeight();
		}
		if (debug)
		{
			Diagnostics.Log(base.name + " > Leveled to " + base.Level);
		}
	}

	private void OnLevelUpEndAnimEvent()
	{
		spriteAnim.OverrideClipsFromPath("SpriteAnimations/Mob/" + Config.Name.ToString().Replace("Mob_", string.Empty) + "/LVL" + base.Level);
		OnTransformEnded();
	}

	private string GetLeveledAnimName(string animName)
	{
		if (maxLevel > 0)
		{
			return animName + "Lvl" + base.Level.ToString();
		}
		return animName;
	}

	private void UpdateAnimNamePrefix()
	{
		if (attackerCpnt != null && maxLevel > 0)
		{
			attackerCpnt.AnimSuffix = "Lvl" + base.Level.ToString();
		}
	}

	private void OnDestroy()
	{
		if (gameNetManager == null)
		{
			gameNetManager = SingletonManager.Get<GameNetworkManager>();
		}
		if (gameNetManager != null)
		{
			gameNetManager.ClearCachedAITargets(this);
		}
	}

	private float GetDustLootAmount()
	{
		int num = (int)GetSimPropertyValue(SimulationProperties.DustLootAmountMin);
		int num2 = (int)GetSimPropertyValue(SimulationProperties.DustLootAmountMax);
		if (num != 0 && num2 == 0)
		{
			return num;
		}
		return RandomGenerator.RangeInt(num, num2);
	}
}
public class MobAttacker : Attacker
{
	protected override void OnTargetChanged(AITarget previousTarget, AITarget newTarget)
	{
		base.OnTargetChanged(previousTarget, newTarget);
		if (previousTarget != null)
		{
			Hero component = previousTarget.GetComponent<Hero>();
			if (component != null)
			{
				component.UnregisterAttackingMob(mob);
			}
		}
		if (newTarget != null)
		{
			Hero component2 = newTarget.GetComponent<Hero>();
			if (component2 != null)
			{
				component2.RegisterAttackingMob(mob);
			}
		}
	}
}
public class MobDustLoot : MonoBehaviour
{
	[SerializeField]
	private float moveSpeed;

	[SerializeField]
	private float captureDist;

	[SerializeField]
	private float destroyDelay;

	private Hero heroTarget;

	private AudioEmitter audioEmitter;

	private Dungeon dungeon;

	private Hero _hero;

	public float DustAmount
	{
		get;
		private set;
	}

	public Room ParentRoom
	{
		get;
		private set;
	}

	public void Init(float dustAmount, Room parentRoom)
	{
		DustAmount = dustAmount;
		ParentRoom = parentRoom;
		dungeon = SingletonManager.Get<Dungeon>();
	}

	private void Awake()
	{
		audioEmitter = GetComponent<AudioEmitter>();
	}

	private void Update()
	{
		if (heroTarget == null)
		{
			heroTarget = null;
			float num = float.PositiveInfinity;
			for (int i = 0; i < Hero.LocalPlayerActiveRecruitedHeroes.Count; i++)
			{
				_hero = Hero.LocalPlayerActiveRecruitedHeroes[i];
				if (!(_hero.RoomElement.ParentRoom != ParentRoom))
				{
					float sqrDistance = dungeon.GetSqrDistance(base.transform.position, _hero.transform.position);
					if (sqrDistance < num)
					{
						heroTarget = _hero;
						num = sqrDistance;
					}
				}
			}
		}
		if (!(heroTarget == null))
		{
			if (dungeon.GetSqrDistance(base.transform.position, heroTarget.transform.position) <= captureDist * captureDist)
			{
				dungeon.AddDust(DustAmount);
				audioEmitter.PlayEvent("Master/Environment/CollectDust");
				SingletonManager.Get<MainGameScreen>().DisplayFIDSGameFeedback(DustAmount, SimulationProperties.Dust, base.transform);
				base.enabled = false;
				UnityEngine.Object.Destroy(base.gameObject, destroyDelay);
			}
			else
			{
				Vector3 a = heroTarget.transform.position - base.transform.position;
				float magnitude = a.magnitude;
				float b = Time.deltaTime * moveSpeed;
				float num2 = Mathf.Min(magnitude, b);
				base.transform.position += a * (num2 / magnitude);
			}
		}
	}
}
public class MobMover : Mover
{
	private Mob mob;

	protected override void Awake()
	{
		base.Awake();
		mob = GetComponent<Mob>();
	}

	protected override float GetMoveSpeed()
	{
		if (mob.Tamer != null)
		{
			return mob.Tamer.GetSimPropertyValue(SimulationProperties.MoveSpeedReal);
		}
		return base.GetMoveSpeed();
	}
}
public class MobTacticalMapElement : TacticalMapElement
{
	[SerializeField]
	private Mob mob;

	protected override bool ShouldBeDisplayed()
	{
		return base.ShouldBeDisplayed() && mob.IsDisplayed;
	}
}
public abstract class ActivableSpecialMajorModule : SpecialMajorModule
{
	protected Hero interactingHero;

	protected bool isInteracting;

	protected bool hasBeenActivated;

	public override void Interact(Hero interactingHero)
	{
		if (!base.HealthCpnt.IsAlive())
		{
			Diagnostics.LogError(base.name + " > Unable to interact: module has been destroyed!");
		}
		else if (hasBeenActivated)
		{
			Diagnostics.LogError(base.name + " > Unable to interact: already activated!");
		}
		else if (interactingHero != null && !interactingHero.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > ActivableSpecialMajorModule.EndInteraction should only be called on interacting hero's owner side!");
		}
		else
		{
			base.NetSyncElement.SendRPCToAll(GetType(), "RunInteraction", (!(interactingHero != null)) ? string.Empty : interactingHero.UniqueID.GetCategory().ToString(), (interactingHero != null) ? interactingHero.UniqueID.ID : 0);
		}
	}

	protected virtual void RPC_RunInteraction(StaticString heroCategory, int heroID)
	{
		UnityEngine.Component component = UniqueIDManager.Get(heroCategory, heroID);
		Hero hero = (!(component != null)) ? null : component.GetComponent<Hero>();
		isInteracting = true;
		interactingHero = hero;
	}

	public virtual void EndInteraction()
	{
		if (!isInteracting)
		{
			Diagnostics.LogError(base.name + " > Unable to end interaction: not interacting!");
		}
		else if (!base.HealthCpnt.IsAlive())
		{
			Diagnostics.LogError(base.name + " > Unable to end interaction: module has been destroyed!");
		}
		else if (interactingHero != null && !interactingHero.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > ActivableSpecialMajorModule.EndInteraction should only be called on interacting hero's owner side!");
		}
		else
		{
			base.NetSyncElement.SendRPCToAll(GetType(), "RunInteractionEnd");
		}
	}

	protected virtual void RPC_RunInteractionEnd()
	{
		isInteracting = false;
	}

	public void Activate()
	{
		if (!base.HealthCpnt.IsAlive())
		{
			Diagnostics.LogError(base.name + " > Unable to activate: module has been destroyed!");
		}
		else if (hasBeenActivated)
		{
			Diagnostics.LogError(base.name + " > Unable to activate: already activated!");
		}
		else if (interactingHero != null && !interactingHero.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > ActivableSpecialMajorModule.Activate should only be called on interacting hero's owner side!");
		}
		else if (!PreActivationCheck())
		{
			EndInteraction();
		}
		else
		{
			base.NetSyncElement.SendRPCToAll(GetType(), "RunActivation");
		}
	}

	protected abstract bool PreActivationCheck();

	protected virtual void RPC_RunActivation()
	{
		GetComponent<Collider>().enabled = false;
		isInteracting = false;
		hasBeenActivated = true;
		dungeon.ActivatingModuleCount++;
		dungeon.UpdateGamePhase();
	}

	public override void DoRemove(bool checkOwnership = true)
	{
		base.DoRemove(checkOwnership);
		dungeon.ActivatingModuleCount--;
		dungeon.UpdateGamePhase();
	}
}
public class Artifact : SpecialMajorModule
{
	[SerializeField]
	private GameObject endlessDayVFXPfb;

	public ulong ResearchPlayerID
	{
		get;
		private set;
	}

	public BluePrintConfig ResearchedBP
	{
		get;
		private set;
	}

	public int ResearchStartTurn
	{
		get;
		private set;
	}

	public override void Init(ulong ownerPlayerID, BluePrintConfig bpConfig, Room parentRoom, ModuleSlot slot, float buildDuration, bool playAppearanceAnimations = true, bool instantBuild = false, bool restoration = false, bool checkOwnershipForBuildComplete = true)
	{
		base.Init(ownerPlayerID, bpConfig, parentRoom, slot, buildDuration, playAppearanceAnimations, instantBuild, restoration, checkOwnershipForBuildComplete);
		attackTargetCpnt.SetActive(active: false);
		PrivateGameConfigManager privateGameConfigManager = SingletonManager.Get<PrivateGameConfigManager>();
		if (privateGameConfigManager.IsCommunityEventActive(CommunityEvent.EndlessDay))
		{
			GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(endlessDayVFXPfb, base.transform.position, Quaternion.identity);
			gameObject.transform.SetParent(base.transform);
			gameObject.transform.localScale = Vector3.one;
		}
	}

	public override void Interact(Hero interactingHero)
	{
		if (ResearchedBP != null)
		{
			DisplayResearchingPanel();
		}
		else
		{
			DisplayResearchPanel();
		}
	}

	public void ResearchBluePrintForSaveRestore(BluePrintConfig bpConfig, int researchStartTurn)
	{
		ResearchBluePrint(bpConfig, researchStartTurn, checkIsResearchable: false, consumeScience: false, pickResearchableBluePrints: false);
	}

	public bool ResearchBluePrintByPlayer(BluePrintConfig bpConfig)
	{
		return ResearchBluePrint(bpConfig);
	}

	private bool CanResearchBluePrint(BluePrintConfig bpConfig, int researchStartTurn = -1, bool checkIsResearchable = true, bool consumeScience = true, bool displayErrors = false)
	{
		if (!base.HealthCpnt.IsAlive())
		{
			Diagnostics.LogError("Cannot research " + bpConfig.Name + " BP: artifact has been destroyed!");
			return false;
		}
		if (ResearchedBP != null)
		{
			Diagnostics.LogError("Cannot research " + bpConfig.Name + " BP: artifact already researching!");
			return false;
		}
		if (!dungeon.CanResearchBluePrint(bpConfig, checkIsResearchable, consumeScience, displayErrors))
		{
			return false;
		}
		return true;
	}

	private bool ResearchBluePrint(BluePrintConfig bpConfig, int researchStartTurn = -1, bool checkIsResearchable = true, bool consumeScience = true, bool pickResearchableBluePrints = true)
	{
		if (!CanResearchBluePrint(bpConfig, researchStartTurn, checkIsResearchable, consumeScience, displayErrors: true))
		{
			return false;
		}
		bool flag = consumeScience;
		bool flag2 = false;
		if (consumeScience && gameNetManager.IsMultiplayerSession() && MultiplayerConfig.SplitFIS)
		{
			flag = false;
			flag2 = true;
		}
		bool flag3 = checkIsResearchable;
		bool flag4 = pickResearchableBluePrints;
		if (checkIsResearchable && gameNetManager.IsMultiplayerSession() && MultiplayerConfig.SplitBluePrints)
		{
			flag3 = false;
			flag4 = false;
		}
		base.NetSyncElement.SendRPCToServer(UniqueIDRPC.Artifact_RequestResearchBluePrint, bpConfig.Name, gameNetManager.GetLocalPlayerID(), researchStartTurn, flag3, flag, flag2, flag4);
		return true;
	}

	private void RPC_RequestResearchBluePrint(StaticString bpConfigName, ulong researchPlayerID, int researchStartTurn, bool checkIsResearchable, bool consumeScienceOnServer, bool consumeScienceOnBuyer, bool pickResearchableBluePrints)
	{
		if (!gameNetManager.IsServerOrSinglePlayer())
		{
			Diagnostics.LogError("Artifact.RPC_RequestResearchBluePrint should only be called on server!");
			return;
		}
		BluePrintConfig value = Databases.GetDatabase<BluePrintConfig>().GetValue(bpConfigName);
		if (!CanResearchBluePrint(value, researchStartTurn, checkIsResearchable, consumeScienceOnServer))
		{
			return;
		}
		if (consumeScienceOnServer && !Player.LocalPlayer.ConsumeScience(value.ResearchScienceCost))
		{
			Diagnostics.LogError("Unable to research " + value.Name + " BP: not enough science!");
			return;
		}
		base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Artifact_DoResearchBluePrint, value.Name, researchPlayerID, researchStartTurn, consumeScienceOnBuyer);
		if (pickResearchableBluePrints)
		{
			dungeon.PickResearchableBluePrintsForAllCategories();
		}
	}

	private void RPC_DoResearchBluePrint(StaticString bpConfigName, ulong researchPlayerID, int researchStartTurn, bool consumeScienceOnBuyer)
	{
		DoResearchBluePrint(bpConfigName, researchPlayerID, researchStartTurn, consumeScienceOnBuyer);
	}

	public void DoResearchBluePrint(StaticString bpConfigName, ulong researchPlayerID, int researchStartTurn, bool consumeScienceOnBuyer)
	{
		BluePrintConfig value = Databases.GetDatabase<BluePrintConfig>().GetValue(bpConfigName);
		if (consumeScienceOnBuyer && researchPlayerID == gameNetManager.GetLocalPlayerID() && !Player.LocalPlayer.ConsumeScience(value.ResearchScienceCost))
		{
			Diagnostics.LogError("Unable to research " + value.Name + " BP: not enough science!");
			return;
		}
		dungeon.ResearchBluePrint(value);
		ResearchedBP = value;
		ResearchPlayerID = researchPlayerID;
		ResearchStartTurn = ((researchStartTurn < 0) ? dungeon.Turn : researchStartTurn);
		gameEventManager.OnDungeonTurnChanged += OnDungeonTurnChanged;
		gameEventManager.OnLastDoorOpened += OnLastDoorOpened;
		attackTargetCpnt.SetActive(active: true);
		UpdateDisplay();
		if (dungeon.GetSimPropertyValue(SimulationProperties.ResearchingBP) == 0f)
		{
			dungeon.AddSimDescriptor(SimulationProperties.SimDescDungeonResearchingBP);
		}
	}

	protected override void OnDeath(ulong attackerOwnerPlayerID)
	{
		base.OnDeath(attackerOwnerPlayerID);
		gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChanged;
		gameEventManager.OnLastDoorOpened -= OnLastDoorOpened;
		if (ResearchedBP != null)
		{
			dungeon.CancelBluePrintResearch(ResearchedBP);
		}
	}

	private void DisplayResearchPanel()
	{
		SingletonManager.Get<ResearchingPanel>().Hide(instant: true);
		IGameCameraService service = Services.GetService<IGameCameraService>();
		if (!service.IsTacticalMapActive() && !service.IsSwitchingCamera)
		{
			IGameControlService service2 = Services.GetService<IGameControlService>();
			if (Services.GetService<IInputService>().CurrentControlScheme == ControlScheme.XBoxOneController && !service2.CanPauseGame() && SingletonManager.Get<HeroPanel>().IsVisible)
			{
				service2.SetHeroStatsPanelDisplay(on: false);
				SingletonManager.Get<SelectableManager>().SetCategory(SelectionCategory.RoomForMove);
			}
			SelectionCategoryData currentCategory = SingletonManager.Get<SelectableManager>().CurrentCategory;
			SelectionCategory category = currentCategory.Category;
			if (category == SelectionCategory.BuildMenu || category == SelectionCategory.RoomForBuild || category == SelectionCategory.Module)
			{
				SingletonManager.Get<SelectableManager>().SetCategory(SelectionCategory.RoomForMove);
			}
			ResearchPanel researchPanel = SingletonManager.Get<ResearchPanel>();
			researchPanel.Bind(this);
			researchPanel.RefreshContent();
			researchPanel.Show();
		}
	}

	private void DisplayResearchingPanel()
	{
		SingletonManager.Get<ResearchPanel>().Hide(instant: true);
		IGameCameraService service = Services.GetService<IGameCameraService>();
		if (!service.IsTacticalMapActive() && !service.IsSwitchingCamera)
		{
			ResearchingPanel researchingPanel = SingletonManager.Get<ResearchingPanel>();
			researchingPanel.Bind(this);
			researchingPanel.RefreshContent();
			researchingPanel.Show();
		}
	}

	private void OnDungeonTurnChanged()
	{
		if (ResearchedBP == null)
		{
			Diagnostics.LogError(base.name + " > Artifact.OnDungeonTurnChanged: not researching!");
			gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChanged;
			gameEventManager.OnLastDoorOpened -= OnLastDoorOpened;
			return;
		}
		UpdateDisplay();
		int num = ResearchStartTurn + GameConfig.GetGameConfig().BluePrintResearchTurnCount;
		if (dungeon.Turn >= num)
		{
			OnResearchComplete();
		}
	}

	private void OnLastDoorOpened()
	{
		if (ResearchedBP == null)
		{
			Diagnostics.LogError(base.name + " > Artifact.OnLastDoorOpened: not researching!");
			gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChanged;
			gameEventManager.OnLastDoorOpened -= OnLastDoorOpened;
		}
		else
		{
			OnResearchComplete();
		}
	}

	private void UpdateDisplay()
	{
		if (ResearchedBP == null)
		{
			faceSpriteAnim.OverrideClipsFromPath("SpriteAnimations/Modules/" + GetConfigName() + "/LVL1");
			SetVFXAndLights();
			return;
		}
		switch (ResearchStartTurn + GameConfig.GetGameConfig().BluePrintResearchTurnCount - dungeon.Turn)
		{
		case 1:
			faceSpriteAnim.OverrideClipsFromPath("SpriteAnimations/Modules/" + GetConfigName() + "/LVL4");
			SetVFXAndLights("_4");
			break;
		case 2:
			faceSpriteAnim.OverrideClipsFromPath("SpriteAnimations/Modules/" + GetConfigName() + "/LVL3");
			SetVFXAndLights("_3");
			break;
		case 3:
			faceSpriteAnim.OverrideClipsFromPath("SpriteAnimations/Modules/" + GetConfigName() + "/LVL2");
			SetVFXAndLights("_2");
			break;
		}
	}

	private void OnResearchComplete()
	{
		bool flag = true;
		if (gameNetManager.IsMultiplayerSession() && MultiplayerConfig.SplitBluePrints)
		{
			flag = (ResearchPlayerID == gameNetManager.GetLocalPlayerID());
		}
		if (flag)
		{
			dungeon.UnlockBluePrint(ResearchedBP);
			Services.GetService<IAudioEventService>().Play2DEvent("Master/Jingles/ResearchComplete");
		}
		ResearchedBP = null;
		attackTargetCpnt.SetActive(active: false);
		gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChanged;
		gameEventManager.OnLastDoorOpened -= OnLastDoorOpened;
		UpdateDisplay();
		dungeon.UpdateResearchingBPSimDesc();
	}

	private void OnDestroy()
	{
		gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChanged;
		gameEventManager.OnLastDoorOpened -= OnLastDoorOpened;
	}
}
public class CryoCapsule : ActivableSpecialMajorModule
{
	private enum ActivationEvent
	{
		Food,
		Hero,
		ToxicCloud
	}

	[SerializeField]
	private Vector3 spawnPosOffset;

	[SerializeField]
	private GameObject heroPfb;

	[SerializeField]
	private ParticleSystem initVFX;

	[SerializeField]
	private ParticleSystem openVFX;

	private IAudioEventService audioEventManager;

	public override void Init(ulong ownerPlayerID, BluePrintConfig bpConfig, Room parentRoom, ModuleSlot slot, float buildDuration, bool playAppearanceAnimations = true, bool instantBuild = false, bool restoration = false, bool checkOwnershipForBuildComplete = true)
	{
		base.Init(ownerPlayerID, bpConfig, parentRoom, slot, buildDuration, playAppearanceAnimations, instantBuild, restoration, checkOwnershipForBuildComplete);
		if (playAppearanceAnimations)
		{
			initVFX.Play(withChildren: true);
		}
		faceSpriteAnim.MonitorAnimEvent("OnOpenEnd", OnOpenEndAnimEvent);
	}

	protected override void RPC_RunInteraction(StaticString heroCategory, int heroID)
	{
		base.RPC_RunInteraction(heroCategory, heroID);
		if (interactingHero == null || interactingHero.NetSyncElement.IsOwnedByLocalPlayer())
		{
			IGameCameraService service = Services.GetService<IGameCameraService>();
			if (!service.IsTacticalMapActive() && !service.IsSwitchingCamera)
			{
				IGameControlService service2 = Services.GetService<IGameControlService>();
				service2.ClosePanelsAtStartOfInteraction();
				SingletonManager.Get<CryoCapsulePanel>().Display(this);
			}
		}
		else
		{
			interactingHero = null;
			isInteracting = false;
		}
	}

	protected override void Awake()
	{
		base.Awake();
		audioEventManager = Services.GetService<IAudioEventService>();
	}

	protected override bool PreActivationCheck()
	{
		if (!Player.LocalPlayer.ConsumeIndustry(GameConfig.GetGameConfig().CryoCapsuleActivationIndustryCost))
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_CryoCapsuleActivationFailResources"));
			return false;
		}
		return true;
	}

	protected override void RPC_RunActivation()
	{
		base.RPC_RunActivation();
		faceSpriteAnim.Trigger(SpriteAnimationTrigger.OnOpen);
		openVFX.Play(withChildren: true);
	}

	private void OnOpenEndAnimEvent()
	{
		if (!(interactingHero == null) && !interactingHero.NetSyncElement.IsOwnedByLocalPlayer())
		{
			return;
		}
		GameConfig gameConfig = GameConfig.GetGameConfig();
		Dictionary<ActivationEvent, float> dictionary = new Dictionary<ActivationEvent, float>();
		dictionary.Add(ActivationEvent.Food, gameConfig.CryoCapsuleFoodProbWeight);
		dictionary.Add(ActivationEvent.Hero, gameConfig.CryoCapsuleHeroProbWeight);
		dictionary.Add(ActivationEvent.ToxicCloud, gameConfig.CryoCapsuleToxicCloudProbWeight);
		Dictionary<ActivationEvent, float> dict = dictionary;
		switch (dict.GetWeightedRandom())
		{
		case ActivationEvent.Food:
		{
			Diagnostics.LogWarning("Cryo capsule activation: Food!");
			float num = RandomGenerator.RangeFloat(gameConfig.CryoCapsuleMinFood, gameConfig.CryoCapsuleMaxFood).RoundHalfAwayFromZero();
			Player.LocalPlayer.AddFood(num);
			SingletonManager.Get<MainGameScreen>().DisplayFIDSGameFeedback(num, SimulationProperties.Food, base.transform);
			audioEventManager.Play2DEvent("Master/Jingles/Ressource");
			break;
		}
		case ActivationEvent.Hero:
		{
			Diagnostics.LogWarning("Cryo capsule activation: Hero!");
			StaticString staticString = dungeon.PickRandomHeroFromDiscoverablePool();
			if (staticString == null)
			{
				Diagnostics.LogError("No more available hero config!");
				return;
			}
			audioEventManager.Play2DEvent("Master/Jingles/Hero");
			dungeon.NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_DoSpawnHero, gameNetManager.GetLocalPlayerID(), staticString, base.RoomElement.ParentRoom.UniqueID.ID, base.transform.position + spawnPosOffset, new StaticString(RoomEvent.Hero.ToString()), false, true);
			break;
		}
		case ActivationEvent.ToxicCloud:
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.CryoCapsule_SpawnToxicCloud);
			break;
		}
		base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Module_DoRemove, false);
	}

	private void RPC_SpawnToxicCloud()
	{
		Diagnostics.LogWarning("Cryo capsule activation: Toxic cloud!");
		GameConfig gameConfig = GameConfig.GetGameConfig();
		base.RoomElement.ParentRoom.AddTemporarySimDescriptor(SimulationProperties.SimDescRoomToxicCloud, dungeon.Turn + gameConfig.CryoCapsuleToxicCloudTurnCount);
	}
}
public class CrystalModuleSlot : ModuleSlot
{
	[SerializeField]
	private GameObject flashAnimPfb;

	[SerializeField]
	private GameObject destroyAnimPfb;

	private OffscreenMarker crystalMarker;

	public bool IsExitSlot
	{
		get;
		private set;
	}

	public void OpenSlot()
	{
		spriteAnim.Trigger(SpriteAnimationTrigger.OnUnplug);
	}

	public void CloseSlot()
	{
		spriteAnim.Trigger(SpriteAnimationTrigger.OnPlug);
	}

	public void Init(ulong ownerPlayerID, Room parentRoom, bool isExitSlot = false)
	{
		base.Init(parentRoom, requestUniqueID: false);
		base.UniqueID.RequestUniqueIDForPlayer(ownerPlayerID);
		IsExitSlot = isExitSlot;
		if (IsExitSlot)
		{
			crystalMarker = SingletonManager.Get<Dungeon>().DisplayCrystalAndExitOffscreenMarkers(base.transform);
		}
	}

	public void PlayFlashAnimation()
	{
		if (IsExitSlot)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(flashAnimPfb, base.transform.position + flashAnimPfb.transform.position, base.transform.rotation) as GameObject;
			gameObject.transform.parent = base.transform;
			if (crystalMarker != null)
			{
				crystalMarker.Hide();
			}
		}
	}

	public void PlayDestroyFlashAnimation()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(destroyAnimPfb, base.transform.position + destroyAnimPfb.transform.position, base.transform.rotation) as GameObject;
		gameObject.transform.parent = base.transform;
		Services.GetService<IAudioEventService>()?.Play2DEvent("Master/Environment/CrystalDestruction");
	}
}
public class DustFactory : ActivableSpecialMajorModule
{
	[SerializeField]
	private ParticleSystem openingVFX;

	[SerializeField]
	private ParticleSystem dustLootVFX;

	[SerializeField]
	private ParticleSystem explosionVFX;

	private IAudioEventService audioEventManager;

	private bool isExploding;

	public override void Init(ulong ownerPlayerID, BluePrintConfig bpConfig, Room parentRoom, ModuleSlot slot, float buildDuration, bool playAppearanceAnimations = true, bool instantBuild = false, bool restoration = false, bool checkOwnershipForBuildComplete = true)
	{
		base.Init(ownerPlayerID, bpConfig, parentRoom, slot, buildDuration, playAppearanceAnimations, instantBuild, restoration, checkOwnershipForBuildComplete);
		faceSpriteAnim.MonitorAnimEvent("OnDisappearEnd", OnDisappearEndAnimEvent);
	}

	protected override void RPC_RunInteraction(StaticString heroCategory, int heroID)
	{
		base.RPC_RunInteraction(heroCategory, heroID);
		IGameCameraService service = Services.GetService<IGameCameraService>();
		if (!service.IsTacticalMapActive() && !service.IsSwitchingCamera)
		{
			IGameControlService service2 = Services.GetService<IGameControlService>();
			service2.ClosePanelsAtStartOfInteraction();
			if (interactingHero == null || interactingHero.NetSyncElement.IsOwnedByLocalPlayer())
			{
				SingletonManager.Get<DustFactoryPanel>().Display(this);
			}
			faceSpriteAnim.Trigger(SpriteAnimationTrigger.OnOpen);
			openingVFX.Play(withChildren: true);
		}
	}

	protected override void RPC_RunInteractionEnd()
	{
		base.RPC_RunInteractionEnd();
		faceSpriteAnim.Trigger(SpriteAnimationTrigger.OnClose);
	}

	protected override void Awake()
	{
		base.Awake();
		audioEventManager = Services.GetService<IAudioEventService>();
	}

	protected override bool PreActivationCheck()
	{
		if (!Player.LocalPlayer.ConsumeIndustry(GameConfig.GetGameConfig().DustFactoryActivationIndustryCost))
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_DustFactoryActivationFailResources"));
			return false;
		}
		return true;
	}

	protected override void RPC_RunActivation()
	{
		base.RPC_RunActivation();
		if (interactingHero == null || interactingHero.NetSyncElement.IsOwnedByLocalPlayer())
		{
			GameConfig gameConfig = GameConfig.GetGameConfig();
			if (RandomGenerator.RangeFloat(0f, 1f) > gameConfig.DustFactoryExplosionProb)
			{
				float num = RandomGenerator.RangeFloat(gameConfig.DustFactoryMinDust, gameConfig.DustFactoryMaxDust).RoundHalfAwayFromZero();
				dungeon.AddDust(num);
				SingletonManager.Get<MainGameScreen>().DisplayFIDSGameFeedback(num, SimulationProperties.Dust, base.transform);
				base.NetSyncElement.SendRPCToAll(UniqueIDRPC.DustFactory_ProduceDustLoot);
			}
			else
			{
				audioEventManager.Play2DEvent("Master/Events/DustIndustryFail");
				base.NetSyncElement.SendRPCToAll(UniqueIDRPC.DustFactory_Explode);
			}
		}
	}

	private void RPC_ProduceDustLoot()
	{
		Diagnostics.LogWarning("Dust factory activation: Dust loot!");
		dustLootVFX.Play(withChildren: true);
		faceSpriteAnim.Trigger(SpriteAnimationTrigger.OnUsage);
	}

	private void RPC_Explode()
	{
		Diagnostics.LogWarning("Dust factory activation: Explosion!");
		isExploding = true;
		faceSpriteAnim.Trigger(SpriteAnimationTrigger.OnDisappear);
		explosionVFX.transform.parent = base.transform.parent;
		explosionVFX.Play(withChildren: true);
		audioEmitter.PlayEvent("Master/Events/DustIndustryExplosion");
	}

	private void OnDisappearEndAnimEvent()
	{
		if (isExploding)
		{
			if (gameNetManager.IsServerOrSinglePlayer())
			{
				base.RoomElement.ParentRoom.DestroyAllModuleSlots();
			}
		}
		else
		{
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Module_DoRemove, false);
		}
	}
}
public class MajorModule : Module
{
	[SerializeField]
	protected float operatingDist;

	[SerializeField]
	protected AITarget operateTargetCpnt;

	[SerializeField]
	protected OffscreenMarker.OffscreenMarkerData crystalDangerIconData;

	public static List<MajorModule> UnlinkedShopModules = new List<MajorModule>();

	private bool isProducingFIDS;

	private Hero heroOperator;

	public bool IsCrystal
	{
		get;
		private set;
	}

	public float OperatingDist => operatingDist;

	public bool IsBeingDestroyed
	{
		get;
		set;
	}

	public bool CanReceiveMerchant
	{
		get;
		set;
	}

	public override void Init(ulong ownerPlayerID, BluePrintConfig bpConfig, Room parentRoom, ModuleSlot slot, float buildDuration, bool playAppearanceAnimations = true, bool instantBuild = false, bool restoration = false, bool checkOwnershipForBuildComplete = true)
	{
		IsCrystal = (bpConfig.ModuleName == SimulationProperties.SpecialModule_Crystal);
		IsBeingDestroyed = false;
		CanReceiveMerchant = true;
		AITargetType aITargetType = bpConfig.GetModuleConfig().AITargetType;
		if (attackTargetCpnt != null)
		{
			attackTargetCpnt.Init(isActive: true, aITargetType);
		}
		if (repairTargetCpnt != null)
		{
			repairTargetCpnt.Init(isActive: false, aITargetType);
		}
		if (operateTargetCpnt != null)
		{
			operateTargetCpnt.Init(isActive: false, aITargetType);
		}
		base.Init(ownerPlayerID, bpConfig, parentRoom, slot, buildDuration, playAppearanceAnimations, instantBuild, restoration, checkOwnershipForBuildComplete);
		isProducingFIDS = (GetSimPropertyValue(SimulationProperties.FoodProd) > 0f || GetSimPropertyValue(SimulationProperties.IndustryProd) > 0f || GetSimPropertyValue(SimulationProperties.DustProd) > 0f || GetSimPropertyValue(SimulationProperties.ScienceProd) > 0f);
		if (IsCrystal)
		{
			faceSpriteAnim.MonitorAnimEvent("OnAnimFinished", OnAnimFinishedAnimEvent);
			baseSpriteAnim.gameObject.SetActive(value: false);
			SimulationDescriptor dBDescriptorByName = SimMonoBehaviour.GetDBDescriptorByName(GetSimDescriptorName() + "_" + dungeon.CrystalType.ToString());
			if (dBDescriptorByName != null)
			{
				AddSimDescriptor(dBDescriptorByName);
			}
		}
		if (base.BPConfig.ModuleCategory == ModuleCategory.MajorModule)
		{
			dungeon.AliveMajorModuleCount++;
		}
	}

	public override void Power(bool on)
	{
		base.Power(on);
		if (!base.IsBuilding && operateTargetCpnt != null)
		{
			UpdateOperateTarget();
		}
	}

	public void Operate(Hero heroOperator)
	{
		this.heroOperator = heroOperator;
		UpdateOperatorWit(this.heroOperator);
		OperateSubVfxController componentInChildren = GetComponentInChildren<OperateSubVfxController>();
		if (componentInChildren != null)
		{
			componentInChildren.Play();
		}
	}

	public void UpdateOperatorWit(Hero heroOperator)
	{
		if (heroOperator != this.heroOperator)
		{
			Diagnostics.LogError(base.name + " > UpdateOperatorWit: " + heroOperator + " is not current operator (" + this.heroOperator + ")");
			return;
		}
		if (this.heroOperator.HasOperatingBonus)
		{
			SetSimPropertyBaseValue(SimulationProperties.OperatorWit, this.heroOperator.GetSimPropertyValue(SimulationProperties.OperateWit));
		}
		gameEventManager.TriggerDungeonFIDSChangedEvent();
	}

	public void UpdateOperateTarget()
	{
		if (operateTargetCpnt != null)
		{
			operateTargetCpnt.SetActive(base.IsPowered && base.HealthCpnt.IsAlive() && (!base.Config.AttractMerchant || !CanReceiveMerchant));
		}
	}

	public void StopOperating(SimMonoBehaviour operatorSimMB)
	{
		if (operatorSimMB != heroOperator)
		{
			Diagnostics.LogWarning(base.name + " > StopOperating: " + operatorSimMB + " is not current operator (" + heroOperator + ") -> repair/operate switch?");
			return;
		}
		heroOperator = null;
		SetSimPropertyBaseValue(SimulationProperties.OperatorWit, 0f);
		gameEventManager.TriggerDungeonFIDSChangedEvent();
		OperateSubVfxController componentInChildren = GetComponentInChildren<OperateSubVfxController>();
		if (componentInChildren != null)
		{
			componentInChildren.Stop();
		}
	}

	public void RemoveCrystal()
	{
		Diagnostics.Assert(IsCrystal);
		IsBeingDestroyed = true;
		faceSpriteAnim.Trigger(SpriteAnimationTrigger.OnUnplug);
		((CrystalModuleSlot)base.Slot).OpenSlot();
		base.Slot.UnplugModule();
	}

	public override void DoUpdateLevelToBP(BluePrintConfig bpConfig, bool playerLevelUpVFX = true)
	{
		base.DoUpdateLevelToBP(bpConfig, playerLevelUpVFX);
		if (isProducingFIDS)
		{
			gameEventManager.TriggerDungeonFIDSChangedEvent();
		}
	}

	protected override void RPC_DoOnBuildComplete(bool instantBuild = false)
	{
		base.RPC_DoOnBuildComplete(instantBuild);
		IsBeingDestroyed = false;
		if (!IsCrystal)
		{
			audioEmitter.PlayEvent("Master/Environment/SpawnMainModule");
		}
		else
		{
			if (!instantBuild)
			{
				faceSpriteAnim.Trigger(SpriteAnimationTrigger.OnPlug);
			}
			CrystalModuleSlot crystalModuleSlot = (CrystalModuleSlot)base.Slot;
			crystalModuleSlot.CloseSlot();
			if (crystalModuleSlot.IsExitSlot)
			{
				IAudioEventService service = Services.GetService<IAudioEventService>();
				service.Play2DEvent("Master/Jingles/CrystalWin");
				if (base.NetSyncElement.IsOwnedByLocalPlayer())
				{
					dungeon.NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_OnCrystalPluggedOnExitSlot);
				}
			}
		}
		if (isProducingFIDS)
		{
			gameEventManager.TriggerDungeonFIDSChangedEvent();
		}
		if (base.Config.AttractMerchant)
		{
			NPCMerchant.AttractMerchant(this);
		}
		UpdateOperateTarget();
	}

	public void UpdateMerchantLink(bool linked)
	{
		if (linked)
		{
			UnlinkedShopModules.Remove(this);
		}
		else
		{
			UnlinkedShopModules.Add(this);
		}
		UpdateOperateTarget();
	}

	protected override void Awake()
	{
		unpowerSimDescName = SimulationProperties.SimDescMajorModuleUnpowered;
		base.Awake();
	}

	protected override Type GetSimClass()
	{
		return typeof(MajorModule);
	}

	public override string GetConfigName()
	{
		if (IsCrystal)
		{
			return base.GetConfigName() + "_" + dungeon.CrystalType.ToString();
		}
		return base.GetConfigName();
	}

	protected override void OnDeath(ulong attackerOwnerPlayerID)
	{
		base.OnDeath(attackerOwnerPlayerID);
		base.RoomElement.ParentRoom.RemoveMajorModule();
		base.Slot.IsAvailable = true;
		audioEmitter.PlayEvent("Master/Modules/MainModuleDestruction_01");
		if (IsCrystal)
		{
			IGameCameraService service = Services.GetService<IGameCameraService>();
			if (service.IsTacticalMapActive())
			{
				service.SwitchToGameCamera();
			}
			service.Focus(base.transform.position, LerpType.Smoothed, -1f);
			Time.timeScale = 0.5f;
			dungeon.CrystalTfm.GetComponent<CrystalModuleSlot>().PlayDestroyFlashAnimation();
			if (base.NetSyncElement.IsOwnedByLocalPlayer())
			{
				dungeon.LevelOver();
			}
		}
		UpdateMerchantLink(linked: true);
		gameEventManager.TriggerDungeonFIDSChangedEvent();
		if (base.BPConfig.ModuleCategory == ModuleCategory.MajorModule)
		{
			dungeon.AliveMajorModuleCount--;
		}
	}

	protected override void OnDanger()
	{
		if (IsCrystal)
		{
			base.RoomElement.ParentRoom.DisplayOffscreenMarker(crystalDangerIconData);
		}
		else
		{
			base.OnDanger();
		}
	}

	protected override void OnHealthChanged()
	{
		if (!IsCrystal)
		{
			base.OnHealthChanged();
		}
	}

	private IEnumerator Start()
	{
		if (!IsCrystal)
		{
			while (!audioEmitter.IsReady)
			{
				yield return null;
			}
			audioEmitter.PlayEvent("Master/Environment/AddMainModule");
		}
	}

	private void OnAnimFinishedAnimEvent()
	{
		if (IsCrystal)
		{
			base.Slot.IsAvailable = true;
			base.RoomElement.ParentRoom.RemoveSimChild(this);
			UnityEngine.Object.Destroy(base.gameObject);
			gameEventManager.TriggerDungeonFIDSChangedEvent();
		}
	}

	private void OnRightClickDown(ClickDownInfo clickInfo)
	{
		if (IsCrystal)
		{
			if (IsBeingDestroyed)
			{
				return;
			}
			if (dungeon.ExitRoom == null)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_CrystalUnplugFail_ExitNotFound"));
				return;
			}
			CrystalModuleSlot crystalModuleSlot = base.Slot as CrystalModuleSlot;
			if (crystalModuleSlot == null || !crystalModuleSlot.IsExitSlot)
			{
				SingletonManager.Get<CrystalPanel>().DisplayForModule(this);
			}
			Services.GetService<IInputService>().StopClickEventPropagation();
		}
		else
		{
			base.RoomElement.ParentRoom.MoveSelectedHeroesToRoom();
			Services.GetService<IInputService>().StopClickEventPropagation();
		}
	}
}
public class MajorModuleSlot : ModuleSlot
{
	public override void Activate()
	{
		base.Activate();
		gameEventManager.OnMajorModuleCategorySelected += OnMajorModuleCategorySelected;
		gameEventManager.OnMajorModuleCategoryUnselected += OnMajorModuleCategoryUnselected;
		base.ParentRoom.OnRoomPowerChanged += OnParentRoomPowerChanged;
	}

	protected override void OnDestroy()
	{
		base.OnDestroy();
		if (activated)
		{
			if (gameEventManager != null)
			{
				gameEventManager.OnMajorModuleCategorySelected -= OnMajorModuleCategorySelected;
				gameEventManager.OnMajorModuleCategoryUnselected -= OnMajorModuleCategoryUnselected;
			}
			if (base.ParentRoom != null)
			{
				base.ParentRoom.OnRoomPowerChanged -= OnParentRoomPowerChanged;
			}
		}
	}

	private void OnMajorModuleCategorySelected()
	{
		if (base.ParentRoom.IsPowered)
		{
			Highlight();
		}
	}

	private void OnMajorModuleCategoryUnselected()
	{
		UnHighlight();
	}

	private void OnParentRoomPowerChanged(bool powered)
	{
		if (powered)
		{
			if (gameControlManager.IsMajorModuleCategorySelected)
			{
				Highlight();
			}
		}
		else
		{
			UnHighlight();
		}
	}
}
public class MinorModule : Module
{
	[SerializeField]
	protected Health health;

	[SerializeField]
	protected Energy energy;

	[SerializeField]
	protected GameObject bioOrganicTransferenceFXPrefab;

	[SerializeField]
	protected GameObject recylingFXPrefab;

	[SerializeField]
	protected bool debug;

	protected bool isAttacking;

	protected ParticleSystem bioOrganicTransferenceFX;

	protected ParticleSystem recylingFX;

	protected bool lureIsActivated;

	protected float lureActivationTimer;

	protected float lureEnergy;

	protected EnergyBarDisplayer energyBar;

	protected FMOD.Event bioOrganicTransferenceSFX;

	public Transform SpriteHolderTfm
	{
		get;
		protected set;
	}

	public int MobKillCount
	{
		get;
		set;
	}

	public override void Init(ulong ownerPlayerID, BluePrintConfig bpConfig, Room parentRoom, ModuleSlot slot, float buildDuration, bool playAppearanceAnimations = true, bool instantBuild = false, bool restoration = false, bool checkOwnershipForBuildComplete = true)
	{
		base.Init(ownerPlayerID, bpConfig, parentRoom, slot, buildDuration, playAppearanceAnimations, instantBuild, restoration, checkOwnershipForBuildComplete);
		attackTargetCpnt.Init(this);
		if (repairTargetCpnt != null)
		{
			repairTargetCpnt.Init(isActive: false);
		}
		base.RoomElement.ParentRoom.OnEntityEntered += OnEntityEnteredParentRoom;
		base.RoomElement.ParentRoom.OnEntityExited += OnEntityExitedParentRoom;
		if (bioOrganicTransferenceFXPrefab != null && GetSimPropertyValue(SimulationProperties.HPByKill) != 0f)
		{
			bioOrganicTransferenceFX = (UnityEngine.Object.Instantiate(bioOrganicTransferenceFXPrefab, base.transform.position, Quaternion.identity) as GameObject).GetComponent<ParticleSystem>();
			bioOrganicTransferenceFX.transform.parent = base.transform;
		}
		if (recylingFXPrefab != null && GetSimPropertyValue(SimulationProperties.FIDSQuantityPerKill) != 0f)
		{
			recylingFX = (UnityEngine.Object.Instantiate(recylingFXPrefab, base.transform.position, Quaternion.identity) as GameObject).GetComponent<ParticleSystem>();
			recylingFX.transform.parent = base.transform;
		}
	}

	public override void DoUpdateLevelToBP(BluePrintConfig bpConfig, bool playerLevelUpVFX = true)
	{
		base.DoUpdateLevelToBP(bpConfig, playerLevelUpVFX);
		if (attackerCpnt != null && attackerCpnt.ActiveAttackType != null)
		{
			string text = attackerCpnt.ActiveAttackType.Name;
			int num = text.LastIndexOf("_LVL");
			if (num != -1)
			{
				text = text.Substring(0, num);
			}
			text = text + "_LVL" + base.Level;
			AttackTypeConfig value = Databases.GetDatabase<AttackTypeConfig>().GetValue(text);
			if (value != null)
			{
				attackerCpnt.SwitchAttackType(value);
			}
			else
			{
				Diagnostics.LogWarning("There is no " + (string)attackerCpnt.ActiveAttackType.Name + "_LVL" + base.Level + " AttackType for " + base.name);
			}
		}
	}

	public void SwitchLureMode(bool activate)
	{
		base.NetSyncElement.SendRPCToAll(UniqueIDRPC.MinorModule_DoSwitchLureMode, activate);
	}

	private void RPC_DoSwitchLureMode(bool activate)
	{
		if (attackTargetCpnt != null && health.IsAlive())
		{
			attackTargetCpnt.UpdateType((!activate) ? AITargetType.MinorModule : AITargetType.HeroLure);
			attackTargetCpnt.HealthCpnt = ((!activate) ? health : energy);
			if (attackerCpnt != null)
			{
				attackerCpnt.HealthCpnt = attackTargetCpnt.HealthCpnt;
			}
			baseSpriteAnim.Trigger((!activate) ? SpriteAnimationTrigger.OnDeactivation : SpriteAnimationTrigger.OnActivation);
			if (activate)
			{
				faceSpriteAnim.Play();
			}
			else
			{
				faceSpriteAnim.Stop();
			}
			lureIsActivated = activate;
			if (!activate)
			{
				lureActivationTimer = GetSimPropertyValue(SimulationProperties.LureActivationDelay);
				audioEmitter.PlayEvent("Master/Modules/ModuleLure_Desactivation");
			}
			else
			{
				lureEnergy = GetSimPropertyValue(SimulationProperties.LureMaxEnergy);
				energy.InitHealth();
				audioEmitter.PlayEvent("Master/Modules/ModuleLure_Activation");
			}
			attackTargetCpnt.HealthCpnt.HealthBar.UpdateBarDisplay();
		}
	}

	protected override void RPC_DoOnBuildComplete(bool instantBuild = false)
	{
		base.RPC_DoOnBuildComplete(instantBuild);
		if (base.Config.Rotate)
		{
			SpriteHolderTfm.transform.Rotate(Vector3.right, 270f, Space.Self);
			Transform transform = SpriteHolderTfm.transform;
			Vector3 localPosition = SpriteHolderTfm.transform.localPosition;
			float x = localPosition.x;
			Vector3 localPosition2 = SpriteHolderTfm.transform.localPosition;
			transform.localPosition = new Vector3(x, 1f, localPosition2.z);
		}
		if (GetSimPropertyValue(SimulationProperties.LureActivationDelay) > 0f)
		{
			SwitchLureMode(base.IsPowered);
		}
		if (GetSimPropertyValue(SimulationProperties.HPByKill) > 0f || GetSimPropertyValue(SimulationProperties.FIDSQuantityPerKill) > 0f)
		{
			foreach (Mob mob in base.RoomElement.ParentRoom.Mobs)
			{
				mob.OnMobDeath += OnMobDied;
			}
		}
		if (GetSimPropertyValue(SimulationProperties.ModuleOperatorWit) > 0f)
		{
			gameEventManager.TriggerDungeonFIDSChangedEvent();
		}
		audioEmitter.PlayEvent("Master/Environment/SpawnMinorModule");
		base.RoomElement.ParentRoom.RefreshSim(refreshParent: false, refreshChildren: true);
	}

	public override void Power(bool on)
	{
		base.Power(on);
		if (!on && lureIsActivated)
		{
			SwitchLureMode(activate: false);
		}
	}

	public override GameObject InstantiatePfb(GameObject pfb)
	{
		Transform spriteHolderTfm = SpriteHolderTfm;
		GameObject gameObject = goPoolManager.Instantiate(pfb, spriteHolderTfm.position, Quaternion.identity, SpriteHolderTfm.transform);
		gameObject.transform.localEulerAngles = pfb.transform.localEulerAngles;
		gameObject.transform.localPosition = pfb.transform.localPosition;
		return gameObject;
	}

	protected override void OnDeath(ulong attackerOwnerPlayerID)
	{
		base.OnDeath(attackerOwnerPlayerID);
		base.RoomElement.ParentRoom.OnEntityEntered -= OnEntityEnteredParentRoom;
		base.RoomElement.ParentRoom.OnEntityExited -= OnEntityExitedParentRoom;
		base.RoomElement.ParentRoom.RemoveMinorModule(this);
		base.Slot.IsAvailable = true;
		Transform transform = SpriteHolderTfm.transform;
		Vector3 localEulerAngles = SpriteHolderTfm.transform.localEulerAngles;
		transform.localEulerAngles = new Vector3(localEulerAngles.x, 0f, 0f);
		audioEmitter.PlayEvent("Master/Modules/MinorModuleDestruction_01");
		if (energyBar != null)
		{
			energyBar.HideBar();
			if (base.NetSyncElement.IsOwnedByLocalPlayer())
			{
				energy.SetHealthRatio(1f);
			}
		}
		if (GetSimPropertyValue(SimulationProperties.ModuleOperatorWit) > 0f)
		{
			gameEventManager.TriggerDungeonFIDSChangedEvent();
		}
	}

	protected override void Awake()
	{
		unpowerSimDescName = SimulationProperties.SimDescMinorModuleUnpowered;
		base.Awake();
		base.HealthCpnt = health;
		energyBar = GetComponent<EnergyBarDisplayer>();
		SpriteHolderTfm = faceSpriteAnim.transform.parent;
	}

	protected override void Update()
	{
		base.Update();
		if (base.NetSyncElement.IsOwnedByLocalPlayer() && base.IsPowered && lureActivationTimer > 0f && base.RoomElement.ParentRoom.IsPowered)
		{
			lureActivationTimer -= Time.deltaTime;
			if (lureActivationTimer <= 0f)
			{
				SwitchLureMode(activate: true);
			}
			else if (health.IsAlive())
			{
				energy.SetHealthRatio(1f - lureActivationTimer / GetSimPropertyValue(SimulationProperties.LureActivationDelay), checkOwnership: false, ignoreInvincibility: true, ignoreAlive: true);
			}
		}
	}

	private IEnumerator Start()
	{
		while (!audioEmitter.IsReady)
		{
			yield return null;
		}
		audioEmitter.PlayEvent("Master/Environment/AddMinorModule");
	}

	public void OnRightClickDown(ClickDownInfo clickInfo)
	{
		foreach (ClickDownInfo rightClickInfo in Services.GetService<IInputService>().RightClickInfos)
		{
			if (!(rightClickInfo.HitCollider.gameObject == base.gameObject) && !(rightClickInfo.HitCollider.gameObject == SpriteHolderTfm.gameObject) && !(rightClickInfo.HitCollider.GetComponent<Room>() != null) && !(rightClickInfo.HitCollider.GetComponent<FloorTile>() != null) && !(rightClickInfo.HitCollider.GetComponent<CameraDragSupport>() != null))
			{
				return;
			}
		}
		base.RoomElement.ParentRoom.MoveSelectedHeroesToRoom();
		Services.GetService<IInputService>().StopClickEventPropagation();
	}

	private void OnEntityEnteredParentRoom(SimMonoBehaviour entity)
	{
		Mob mob = entity as Mob;
		if (mob != null)
		{
			mob.OnMobDeath += OnMobDied;
		}
	}

	private void OnEntityExitedParentRoom(SimMonoBehaviour entity)
	{
		Mob mob = entity as Mob;
		if (mob != null)
		{
			mob.OnMobDeath -= OnMobDied;
		}
	}

	private void OnMobDied(Mob mob)
	{
		mob.OnMobDeath -= OnMobDied;
		MobKillCount++;
		if (!base.RoomElement.ParentRoom.IsPowered || !base.IsPowered || !base.HealthCpnt.IsAlive() || !(mob.RoomElement.ParentRoom == base.RoomElement.ParentRoom))
		{
			return;
		}
		float simPropertyValue = GetSimPropertyValue(SimulationProperties.HPByKill);
		if (simPropertyValue > 0f)
		{
			float simPropertyValue2 = mob.GetSimPropertyValue(SimulationProperties.DustLootProbability);
			float num = simPropertyValue * simPropertyValue2 / (float)base.RoomElement.ParentRoom.Heroes.Count;
			List<Hero> heroes = base.RoomElement.ParentRoom.Heroes;
			foreach (Hero item in heroes)
			{
				if (item.NetSyncElement.IsOwnedByLocalPlayer())
				{
					item.HealthCpnt.AddHealth(num);
				}
				if (bioOrganicTransferenceFX != null)
				{
					bioOrganicTransferenceFX.Play(withChildren: true);
					bioOrganicTransferenceSFX = audioEmitter.PlayEvent("Master/Modules/ModuleBioorganic");
				}
				if (debug)
				{
					Diagnostics.Log(base.name + " > has heal " + num + " HP to " + item.name + " because of the death of " + mob.name);
				}
			}
		}
		if (dungeon.CurrentCrystalState == CrystalState.Unplugged)
		{
			return;
		}
		float simPropertyValue3 = GetSimPropertyValue(SimulationProperties.FIDSQuantityPerKill);
		if (simPropertyValue3 > 0f && (float)MobKillCount % GetSimPropertyValue(SimulationProperties.FIDSRewardKillCount) == 0f)
		{
			FIDS fIDS = (FIDS)GetSimPropertyValue(SimulationProperties.FIDSResourcePerKill);
			Player.LocalPlayer.AddFIDS(simPropertyValue3 / (float)Player.GetPlayerIDs().Length, fIDS);
			if (debug)
			{
				Diagnostics.Log("{0} has recycled {1} {2} because of the death of {3}", base.name, simPropertyValue3, fIDS.ToString(), mob.name);
			}
			if (recylingFX != null)
			{
				recylingFX.Play(withChildren: true);
			}
		}
	}
}
[RequireComponent(typeof(MinorModule))]
public class MinorModuleAttacker : Attacker
{
	private MinorModule minorModule;

	public void UpdateOverheatingVFX(int level)
	{
		if (level <= overheatingLevelVFXPfb.Length)
		{
			GameObject pfb = overheatingLevelVFXPfb[level - 1];
			bool flag = false;
			if (overheatingVFX != null)
			{
				flag = overheatingVFX.isPlaying;
				goPoolManager.Recycle(overheatingVFX.gameObject);
			}
			overheatingVFX = InstantiatePfb(pfb).GetComponent<ParticleSystem>();
			if (flag && overheatingVFX != null)
			{
				overheatingVFX.Play(withChildren: true);
			}
		}
	}

	protected override void Awake()
	{
		base.Awake();
		minorModule = GetComponent<MinorModule>();
	}

	public override GameObject InstantiatePfb(GameObject pfb)
	{
		return minorModule.InstantiatePfb(pfb);
	}

	protected override void Update()
	{
		base.Update();
		if (minorModule.Config.Rotate && minorModule.IsPowered && base.Target != null && !base.IsOverheating)
		{
			minorModule.SpriteHolderTfm.transform.up = -base.Target.transform.position + minorModule.SpriteHolderTfm.transform.position;
			Transform transform = minorModule.SpriteHolderTfm.transform;
			Vector3 localEulerAngles = minorModule.SpriteHolderTfm.transform.localEulerAngles;
			float y = localEulerAngles.y + 180f;
			Vector3 localEulerAngles2 = minorModule.SpriteHolderTfm.transform.localEulerAngles;
			transform.localEulerAngles = new Vector3(270f, y, localEulerAngles2.z);
		}
	}

	protected override Vector3 GetProjectileLaunchPosition()
	{
		Vector3 result = base.GetProjectileLaunchPosition();
		if (minorModule != null && !minorModule.Config.Rotate)
		{
			float simPropertyValue = minorModule.GetSimPropertyValue(SimulationProperties.HealthBarHeight);
			if (simPropertyValue > 0f)
			{
				result = new Vector3(result.x, result.y + simPropertyValue / 2f, result.z);
			}
		}
		return result;
	}
}
public class MinorModuleSlot : ModuleSlot
{
	public override void Activate()
	{
		base.Activate();
		gameEventManager.OnMinorModuleCategorySelected += OnMinorModuleCategorySelected;
		gameEventManager.OnMinorModuleCategoryUnselected += OnMinorModuleCategoryUnselected;
		base.ParentRoom.OnRoomPowerChanged += OnParentRoomPowerChanged;
	}

	protected override void OnDestroy()
	{
		base.OnDestroy();
		if (activated)
		{
			if (gameEventManager != null)
			{
				gameEventManager.OnMinorModuleCategorySelected -= OnMinorModuleCategorySelected;
				gameEventManager.OnMinorModuleCategoryUnselected -= OnMinorModuleCategoryUnselected;
			}
			if (base.ParentRoom != null)
			{
				base.ParentRoom.OnRoomPowerChanged -= OnParentRoomPowerChanged;
			}
		}
	}

	private void OnMinorModuleCategorySelected()
	{
		Highlight();
	}

	private void OnMinorModuleCategoryUnselected()
	{
		UnHighlight();
	}

	private void OnParentRoomPowerChanged(bool powered)
	{
		if (powered)
		{
			if (gameControlManager.IsMinorModuleCategorySelected)
			{
				Highlight();
			}
		}
		else
		{
			UnHighlight();
		}
	}

	protected override GameObject GetPowerVFXPrefab()
	{
		return (!dungeon.ShipConfig.UseAlternativePulseFX) ? powerVFXPfb : dungeon.PowerPulseMinorModuleAlternativeVFXPfb;
	}
}
public abstract class Module : SimMonoBehaviour
{
	[SerializeField]
	protected float repairingDist;

	[SerializeField]
	protected SpriteAnimationRuntime2 baseSpriteAnim;

	[SerializeField]
	protected SpriteAnimationRuntime2 faceSpriteAnim;

	[SerializeField]
	protected SpriteAnimationRuntime2 buildingSpriteAnim;

	[SerializeField]
	protected SpriteAnimationRuntime2 iconSpriteAnim;

	[SerializeField]
	protected AITarget attackTargetCpnt;

	[SerializeField]
	protected AITarget repairTargetCpnt;

	[SerializeField]
	protected float instantBuildSpeedMultiplier;

	[SerializeField]
	protected ParticleSystem levelUpVFX;

	[SerializeField]
	protected ParticleSystem destructionVFX;

	[SerializeField]
	protected OffscreenMarker.OffscreenMarkerData moduleDangerIconData;

	protected Transform tfm;

	protected Attacker attackerCpnt;

	protected ModuleAI aiCpnt;

	protected AudioEmitter audioEmitter;

	protected Dungeon dungeon;

	protected GameNetworkManager gameNetManager;

	protected IGameEventService gameEventManager;

	protected bool forceVFX;

	protected StaticString unpowerSimDescName;

	protected GameObjectPoolManager goPoolManager;

	private static Dictionary<StaticString, List<Module>> ownedActiveModulesByName = new Dictionary<StaticString, List<Module>>();

	private float buildHealingRate;

	private float remainingBuildDuration;

	private bool playAppearanceAnimations;

	private ParticleSystem moduleVFX;

	private Light[] vfxLights;

	private OffscreenMarker dangerIcon;

	private SimMonoBehaviour reparatorSimMB;

	private ModuleSelectable moduleSelectable;

	private bool unpoweredDescriptorApplied;

	public ModuleConfig Config
	{
		get;
		protected set;
	}

	public BluePrintConfig BPConfig
	{
		get;
		protected set;
	}

	public bool IsPowered
	{
		get;
		protected set;
	}

	public float RepairingDist => repairingDist;

	public Health HealthCpnt
	{
		get;
		protected set;
	}

	public bool IsBuilding
	{
		get;
		protected set;
	}

	public bool CanAttack => attackerCpnt != null && attackerCpnt.CanAttack;

	public ModuleSlot Slot
	{
		get;
		protected set;
	}

	public int Level
	{
		get;
		protected set;
	}

	public RoomElement RoomElement
	{
		get;
		protected set;
	}

	public UniqueIDNetSyncElement NetSyncElement
	{
		get;
		private set;
	}

	public static void UpdateBPModulesLevel(BluePrintConfig bpConfig)
	{
		if (ownedActiveModulesByName.ContainsKey(bpConfig.ModuleName))
		{
			foreach (Module item in ownedActiveModulesByName[bpConfig.ModuleName])
			{
				item.UpdateLevelToBP(bpConfig);
			}
		}
	}

	public virtual void Power(bool on)
	{
		if (IsBuilding)
		{
			return;
		}
		if (on && Config.PowersRoom && !RoomElement.ParentRoom.IsAutoPowered)
		{
			RoomElement.ParentRoom.DoAutoPower(power: true, isFromEvent: false, NetSyncElement.OwnerPlayerID);
		}
		if (attackerCpnt != null)
		{
			attackerCpnt.CanAttack = on;
		}
		if (Config.NeedRoomPower)
		{
			ActivateVFXAndLights(on);
			if (!string.IsNullOrEmpty(unpowerSimDescName))
			{
				if (on)
				{
					RemoveSimDescriptor(unpowerSimDescName);
					unpoweredDescriptorApplied = false;
				}
				else if (!unpoweredDescriptorApplied)
				{
					AddSimDescriptor(unpowerSimDescName);
					unpoweredDescriptorApplied = true;
				}
				else
				{
					Diagnostics.LogWarning("Trying to apply '{0}' multiple time to {1}", unpowerSimDescName, base.name);
				}
			}
		}
		else if (forceVFX)
		{
			ActivateVFXAndLights(on);
		}
		IsPowered = on;
	}

	public virtual void Init(ulong ownerPlayerID, BluePrintConfig bpConfig, Room parentRoom, ModuleSlot slot, float buildDuration, bool playAppearanceAnimations = true, bool instantBuild = false, bool restoration = false, bool checkOwnershipForBuildComplete = true)
	{
		dungeon = SingletonManager.Get<Dungeon>();
		NetSyncElement.SetOwner(ownerPlayerID);
		NetSyncElement.OnOwnerChanged += OnOwnerChanged;
		Level = 1;
		BPConfig = bpConfig;
		Config = BPConfig.GetModuleConfig();
		this.playAppearanceAnimations = playAppearanceAnimations;
		base.name = Config.Name + "_" + base.name;
		RoomElement.SetParentRoom(parentRoom);
		Slot = slot;
		if (Slot != null)
		{
			Slot.PlugModule(this);
		}
		InitAnims();
		SetVFXAndLights();
		if (this.playAppearanceAnimations)
		{
			if (buildingSpriteAnim != null)
			{
				buildingSpriteAnim.Play();
			}
		}
		else
		{
			baseSpriteAnim.Play();
			faceSpriteAnim.Play();
		}
		SimulationDescriptor dBDescriptorByName = SimMonoBehaviour.GetDBDescriptorByName(Config.Name);
		if (dBDescriptorByName == null)
		{
			Diagnostics.LogError("Unable to find \"" + Config.Name + "\" module simulation descriptor");
		}
		else
		{
			AddSimDescriptor(dBDescriptorByName);
		}
		if (!Config.NeedRoomPower)
		{
			RoomElement.ParentRoom.AddSimChild(this);
		}
		if (attackerCpnt != null)
		{
			attackerCpnt.Init(Config.AttackType);
		}
		if (aiCpnt != null && NetSyncElement.IsOwnedByLocalPlayer())
		{
			aiCpnt.Init(Config.Name, autoStartAI: false);
		}
		if (!instantBuild && buildDuration > 0f)
		{
			IsBuilding = true;
			if (NetSyncElement.IsOwnedByLocalPlayer())
			{
				HealthCpnt.AddHealth(0.001f, 0uL, checkOwnership: true, ignoreInvincibility: false, ignoreAlive: true);
				remainingBuildDuration = buildDuration;
				buildHealingRate = HealthCpnt.GetMaxHealth() / buildDuration;
			}
		}
		else
		{
			HealthCpnt.InitHealth();
			if (!checkOwnershipForBuildComplete || NetSyncElement.IsOwnedByLocalPlayer())
			{
				OnBuildComplete(instantBuild);
			}
		}
		HealthCpnt.OnHealthChanged += OnHealthChanged;
		if (moduleSelectable != null)
		{
			moduleSelectable.Register(SelectionCategory.Module, parentRoom.UniqueID.ID);
		}
		if (BPConfig != null && BPConfig.ModuleCategory != ModuleCategory.SpecialModule)
		{
			GoogleAnalyticsManager googleAnalyticsManager = SingletonManager.Get<GoogleAnalyticsManager>();
			if (googleAnalyticsManager != null)
			{
				googleAnalyticsManager.RegisterBuiltModule(Config.Name);
			}
		}
	}

	private void OnOwnerChanged()
	{
		if (aiCpnt != null)
		{
			if (NetSyncElement.IsOwnedByLocalPlayer())
			{
				aiCpnt.Init(Config.Name);
			}
			else
			{
				aiCpnt.IsActive = false;
			}
		}
	}

	public string GetSimDescriptorName()
	{
		return Config.Name;
	}

	public virtual void DoRemove(bool checkOwnership = true)
	{
		HealthCpnt.Kill(checkOwnership);
		if (baseSpriteAnim != null)
		{
			baseSpriteAnim.Stop();
		}
	}

	private void RPC_DoRemove(bool checkOwnership = true)
	{
		DoRemove(checkOwnership);
	}

	public void Repair(SimMonoBehaviour reparatorSimMB)
	{
		this.reparatorSimMB = reparatorSimMB;
		UpdateReparatorWit(this.reparatorSimMB);
	}

	public void UpdateReparatorWit(SimMonoBehaviour reparatorSimMB)
	{
		if (reparatorSimMB != this.reparatorSimMB)
		{
			Diagnostics.LogError(base.name + " > UpdateReparatorWit: " + reparatorSimMB + " is not current reparator (" + this.reparatorSimMB + ")");
			return;
		}
		SetSimPropertyBaseValue(SimulationProperties.ReparatorWit, this.reparatorSimMB.GetSimPropertyValue(SimulationProperties.RepairWit), refresh: false);
		RefreshSim(refreshParent: false);
	}

	public void StopRepairing(SimMonoBehaviour reparatorSimMB)
	{
		if (reparatorSimMB != this.reparatorSimMB)
		{
			Diagnostics.LogWarning(base.name + " > StopRepairing: " + reparatorSimMB + " is not current reparator (" + this.reparatorSimMB + ") -> repair/operate switch?");
			return;
		}
		this.reparatorSimMB = null;
		SetSimPropertyBaseValue(SimulationProperties.ReparatorWit, 0f, refresh: false);
		RefreshSim(refreshParent: false);
	}

	public void UpdateLevelToBP(BluePrintConfig bpConfig, bool playerLevelUpVFX = true)
	{
		NetSyncElement.SendRPCToAll(GetType(), "DoUpdateLevelToBP", bpConfig.Name, playerLevelUpVFX);
	}

	protected void RPC_DoUpdateLevelToBP(StaticString bpConfigName, bool playerLevelUpVFX)
	{
		BluePrintConfig value = Databases.GetDatabase<BluePrintConfig>().GetValue(bpConfigName);
		DoUpdateLevelToBP(value, playerLevelUpVFX);
	}

	public virtual void DoUpdateLevelToBP(BluePrintConfig bpConfig, bool playerLevelUpVFX = true)
	{
		float num = HealthCpnt.GetHealthRatio();
		if (num >= 0.99f)
		{
			num = 1f;
		}
		while (Level < bpConfig.ModuleLevel)
		{
			Level++;
			SimulationDescriptor levelSimDesc = GetLevelSimDesc(Level);
			if (levelSimDesc != null)
			{
				AddSimDescriptor(levelSimDesc);
				continue;
			}
			Diagnostics.LogError(base.name + " > UpdateLevelToBP(" + (string)bpConfig.Name + "): Unable to get sim descriptor for level " + Level);
			break;
		}
		BPConfig = bpConfig;
		if (NetSyncElement.IsOwnedByLocalPlayer())
		{
			HealthCpnt.SetHealthRatio(num);
		}
		HealthCpnt.HealthBar.UpdateHealthBarHeight();
		faceSpriteAnim.OverrideClipsFromPath("SpriteAnimations/Modules/Default_" + BPConfig.ModuleCategory + "/LVL" + Level);
		faceSpriteAnim.OverrideClipsFromPath("SpriteAnimations/Modules/" + GetConfigName() + "/LVL" + Level);
		if (Config.HasSpecialBase)
		{
			Slot.SpriteAnim.Stop();
		}
		else
		{
			baseSpriteAnim.OverrideClipsFromPath("SpriteAnimations/Modules/Default_" + BPConfig.ModuleCategory + "/LVL" + Level);
			baseSpriteAnim.OverrideClipsFromPath("SpriteAnimations/Modules/" + GetConfigName() + "/LVL" + Level);
		}
		SetVFXAndLights();
		UpdateAttackerLevel();
		if (playerLevelUpVFX && levelUpVFX != null)
		{
			levelUpVFX.Play();
		}
	}

	public virtual GameObject InstantiatePfb(GameObject pfb)
	{
		return goPoolManager.Instantiate(pfb, tfm.position, tfm.rotation, tfm);
	}

	public void ApplyEMP(bool emp)
	{
		if (emp || RoomElement.ParentRoom.IsPowered)
		{
			Power(!emp);
		}
		if (iconSpriteAnim != null)
		{
			if (emp)
			{
				iconSpriteAnim.Play();
				audioEmitter.PlayEvent("Master/Events/EMP_Module");
			}
			else
			{
				iconSpriteAnim.Stop();
			}
		}
	}

	protected virtual void SetVFXAndLights(string vfxNameSuffix = null)
	{
		if (moduleVFX != null)
		{
			goPoolManager.Recycle(moduleVFX.gameObject);
		}
		string text = "LVL" + Level;
		if (vfxNameSuffix != null)
		{
			text += vfxNameSuffix;
		}
		string text2 = "VFX/Modules/" + Config.Name + "/" + text;
		GameObject gameObject = (GameObject)Resources.Load(text2, typeof(GameObject));
		if (gameObject != null)
		{
			GameObject gameObject2 = InstantiatePfb(gameObject);
			moduleVFX = gameObject2.GetComponent<ParticleSystem>();
			vfxLights = moduleVFX.GetComponentsInChildren<Light>();
		}
		else
		{
			Diagnostics.Log("No VFX found for " + text + " (path=" + text2 + ")");
		}
		MinorModuleAttacker minorModuleAttacker = attackerCpnt as MinorModuleAttacker;
		if (minorModuleAttacker != null)
		{
			minorModuleAttacker.UpdateOverheatingVFX(Level);
		}
		ActivateVFXAndLights(!Config.NeedRoomPower || forceVFX || (RoomElement.ParentRoom.IsPowered && !RoomElement.ParentRoom.SuffersEMP));
	}

	protected virtual void InitAnims()
	{
		baseSpriteAnim.OverrideClipsFromPath("SpriteAnimations/Modules/Default_" + BPConfig.ModuleCategory + "/LVL1");
		baseSpriteAnim.OverrideClipsFromPath("SpriteAnimations/Modules/" + GetConfigName() + "/LVL1");
		faceSpriteAnim.OverrideClipsFromPath("SpriteAnimations/Modules/Default_" + BPConfig.ModuleCategory + "/LVL1");
		faceSpriteAnim.OverrideClipsFromPath("SpriteAnimations/Modules/" + GetConfigName() + "/LVL1");
		if (iconSpriteAnim != null)
		{
			iconSpriteAnim.Stop();
		}
	}

	protected override void Awake()
	{
		base.Awake();
		tfm = GetComponent<Transform>();
		attackerCpnt = GetComponent<Attacker>();
		aiCpnt = GetComponent<ModuleAI>();
		HealthCpnt = GetComponent<Health>();
		audioEmitter = GetComponent<AudioEmitter>();
		RoomElement = GetComponent<RoomElement>();
		NetSyncElement = GetComponent<UniqueIDNetSyncElement>();
		moduleSelectable = GetComponent<ModuleSelectable>();
		gameEventManager = Services.GetService<IGameEventService>();
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
		goPoolManager = SingletonManager.Get<GameObjectPoolManager>();
		HealthCpnt.OnDeath += OnDeath;
		HealthCpnt.OnDanger += OnDanger;
	}

	protected virtual void OnDeath(ulong attackerOwnerPlayerID)
	{
		if (buildingSpriteAnim != null)
		{
			buildingSpriteAnim.Stop();
		}
		faceSpriteAnim.ResetAllTriggers();
		faceSpriteAnim.Stop();
		if (Config.HasSpecialBase)
		{
			Slot.SpriteAnim.Play();
			baseSpriteAnim.Stop();
		}
		else
		{
			baseSpriteAnim.ResetAllTriggers();
			baseSpriteAnim.Stop();
		}
		Slot.DisplayDestroyedModule(BPConfig.ModuleCategory, GetConfigName(), Level);
		ActivateVFXAndLights(on: false);
		RoomElement.ParentRoom.RemoveSimChild(this);
		if (!IsBuilding && NetSyncElement.IsOwnedByLocalPlayer())
		{
			UnregisterOwnedActiveModule(this);
		}
		if (destructionVFX != null)
		{
			destructionVFX.Play();
		}
		if (iconSpriteAnim != null)
		{
			iconSpriteAnim.Stop();
		}
		if (dangerIcon != null)
		{
			dangerIcon.Hide();
		}
		if (Config.PowersRoom)
		{
			RoomElement.ParentRoom.DoAutoPower(power: false, isFromEvent: false, 0uL);
		}
		if (moduleSelectable != null)
		{
			moduleSelectable.Unregister();
		}
		Slot.UnplugModule();
		UnityEngine.Object.Destroy(base.gameObject);
		if (moduleVFX != null)
		{
			goPoolManager.Recycle(moduleVFX.gameObject);
		}
	}

	protected virtual void OnDanger()
	{
		dangerIcon = RoomElement.ParentRoom.DisplayOffscreenMarker(moduleDangerIconData);
	}

	public void OnBuildComplete(bool instantBuild = false)
	{
		NetSyncElement.SendRPCToAll(GetType(), "DoOnBuildComplete", instantBuild);
	}

	protected virtual void RPC_DoOnBuildComplete(bool instantBuild = false)
	{
		IsBuilding = false;
		MajorModule component = GetComponent<MajorModule>();
		if ((!(component != null) || !component.IsCrystal) && !HealthCpnt.IsAlive() && HealthCpnt.GetMaxHealth() > 0f)
		{
			Diagnostics.LogError("Module building completed but module has been destroyed during building!");
			return;
		}
		RoomElement.ParentRoom.AddSimChild(this);
		if (aiCpnt != null && NetSyncElement.IsOwnedByLocalPlayer())
		{
			aiCpnt.StartAI();
		}
		if (repairTargetCpnt != null)
		{
			repairTargetCpnt.SetActive(HealthCpnt.IsAlive() && !HealthCpnt.IsFullLive());
		}
		if (RoomElement.ParentRoom.SuffersEMP)
		{
			ApplyEMP(emp: true);
		}
		else
		{
			Power(RoomElement.ParentRoom.IsPowered);
			if (Config.PowersRoom)
			{
				RoomElement.ParentRoom.DoAutoPower(power: true, isFromEvent: false, NetSyncElement.OwnerPlayerID);
			}
		}
		if (NetSyncElement.IsOwnedByLocalPlayer())
		{
			RegisterOwnedActiveModule(this);
		}
		BluePrintConfig bluePrintConfig = BPConfig;
		if (NetSyncElement.IsOwnedByLocalPlayer())
		{
			bluePrintConfig = dungeon.GetModuleUnlockedBluePrint(BPConfig.ModuleCategory, BPConfig.ModuleName);
			if (bluePrintConfig == null)
			{
				bluePrintConfig = BPConfig;
			}
		}
		if (bluePrintConfig.ModuleLevel > Level)
		{
			DoUpdateLevelToBP(bluePrintConfig, playerLevelUpVFX: false);
		}
		else
		{
			UpdateAttackerLevel();
		}
		if (HealthCpnt != null && HealthCpnt.HealthBar != null)
		{
			HealthCpnt.HealthBar.UpdateHealthBarHeight();
		}
		if (playAppearanceAnimations)
		{
			if (buildingSpriteAnim != null)
			{
				buildingSpriteAnim.Stop();
			}
			faceSpriteAnim.Trigger(SpriteAnimationTrigger.OnAppear);
			if (!Config.HasSpecialBase)
			{
				baseSpriteAnim.Trigger(SpriteAnimationTrigger.OnAppear);
			}
			else
			{
				Slot.SpriteAnim.Stop();
			}
			if ((component == null || !component.IsCrystal) && !instantBuild && NetSyncElement.IsOwnedByLocalPlayer())
			{
				SingletonManager.Get<AchievementManagerDOTE>().IncrementStatistic(StatisticName.MODULES_BUILT_CURRENT_FLOOR);
			}
		}
		if (TutorialManager.IsEnable)
		{
			Services.GetService<IGameEventService>()?.TriggerBuiltModuleTutorialEvent();
		}
		if (BPConfig.ModuleCategory == ModuleCategory.MinorModule_Support)
		{
			RoomElement.ParentRoom.UpdateSupportEffectVFXs();
		}
	}

	public void OnLeftClickUp(ClickUpInfo clickInfo)
	{
		if (!clickInfo.Dragged)
		{
			MajorModule component = GetComponent<MajorModule>();
			if (!IsBuilding && (component == null || !component.IsCrystal) && !Config.Unremovable && HealthCpnt.IsAlive() && Services.GetService<IGameControlService>().ModuleDestructionMode)
			{
				DoRemove(checkOwnership: false);
			}
		}
	}

	protected virtual void OnHealthChanged()
	{
		if (!IsBuilding && repairTargetCpnt != null)
		{
			repairTargetCpnt.SetActive(HealthCpnt.IsAlive() && !HealthCpnt.IsFullLive());
		}
	}

	public void BuildingUpdate(float deltaTime)
	{
		if (IsBuilding && NetSyncElement.IsOwnedByLocalPlayer() && HealthCpnt.IsAlive())
		{
			if (dungeon.CurrentGamePhase == GamePhase.Strategy)
			{
				deltaTime *= instantBuildSpeedMultiplier;
			}
			HealthCpnt.AddHealth(Mathf.Min(remainingBuildDuration, deltaTime) * buildHealingRate);
			remainingBuildDuration -= deltaTime;
			if (remainingBuildDuration <= 0f)
			{
				OnBuildComplete();
			}
		}
	}

	public virtual string GetConfigName()
	{
		return Config.Name;
	}

	private static void RegisterOwnedActiveModule(Module module)
	{
		if (!ownedActiveModulesByName.ContainsKey(module.Config.Name))
		{
			ownedActiveModulesByName.Add(module.Config.Name, new List<Module>());
		}
		ownedActiveModulesByName[module.Config.Name].Add(module);
	}

	private static void UnregisterOwnedActiveModule(Module module)
	{
		if (!module.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError("Module.UnregisterActiveModule: {0} is not owned by local player!", module.name);
		}
		else
		{
			ownedActiveModulesByName[module.Config.Name].Remove(module);
		}
	}

	public static void ClearOwnedActiveModules()
	{
		if (ownedActiveModulesByName != null && ownedActiveModulesByName.Count > 0)
		{
			ownedActiveModulesByName.Clear();
		}
	}

	private void ActivateVFXAndLights(bool on)
	{
		if (!(moduleVFX == null))
		{
			if (on)
			{
				moduleVFX.Play(withChildren: true);
			}
			else
			{
				moduleVFX.Stop(withChildren: true);
			}
			Light[] array = vfxLights;
			foreach (Light light in array)
			{
				light.enabled = on;
			}
		}
	}

	private void UpdateAttackerLevel()
	{
		if (attackerCpnt != null)
		{
			attackerCpnt.Level = Level;
		}
	}

	private SimulationDescriptor GetLevelSimDesc(int level)
	{
		return SimMonoBehaviour.GetDBDescriptorByName((string)Config.Name + "_LVL" + level);
	}

	private void OnDestroy()
	{
		if (gameNetManager == null)
		{
			gameNetManager = SingletonManager.Get<GameNetworkManager>();
		}
		if (gameNetManager != null)
		{
			gameNetManager.ClearCachedAITargets(this);
		}
	}
}
public class ModuleSlot : MonoBehaviour
{
	[SerializeField]
	protected SpriteAnimationRuntime2 spriteAnim;

	[SerializeField]
	protected SpriteAnimationRuntime2 destroyedFaceAnim;

	[SerializeField]
	protected SpriteAnimationRuntime2 destroyedBaseAnim;

	protected Module pluggedModule;

	protected IGameEventService gameEventManager;

	protected IGameControlService gameControlManager;

	protected bool activated;

	[SerializeField]
	protected GameObject powerVFXPfb;

	[SerializeField]
	private GameObject powerAlternativeVFXPfb;

	[SerializeField]
	private GameObject highlightPanelPfb;

	private ModuleSlotHighlightItem moduleSlotHighlightItem;

	private ParticleSystem powerVFX;

	protected Dungeon dungeon;

	public ModuleCategory DestroyedModuleCategory
	{
		get;
		private set;
	}

	public string DestroyedModuleConfigName
	{
		get;
		private set;
	}

	public int DestroyedModuleLevel
	{
		get;
		private set;
	}

	public UniqueID UniqueID
	{
		get;
		private set;
	}

	public Room ParentRoom
	{
		get;
		private set;
	}

	public Module PluggedModule => pluggedModule;

	public SpriteAnimationRuntime2 SpriteAnim => spriteAnim;

	public bool IsAvailable
	{
		get;
		set;
	}

	public virtual void Init(Room parentRoom, bool requestUniqueID = true)
	{
		if (requestUniqueID)
		{
			UniqueID.RequestUniqueID();
		}
		ParentRoom = parentRoom;
		dungeon = SingletonManager.Get<Dungeon>();
	}

	public void PlugModule(Module module)
	{
		pluggedModule = module;
		GetComponent<Collider>().enabled = false;
		DestroyedModuleConfigName = null;
		destroyedFaceAnim.Stop();
		destroyedBaseAnim.Stop();
	}

	public void UnplugModule()
	{
		if (pluggedModule == null)
		{
			Diagnostics.LogError("Trying to unplug the module on a slot without plugged module!");
			return;
		}
		pluggedModule = null;
		GetComponent<Collider>().enabled = true;
	}

	public virtual void Activate()
	{
		gameEventManager = Services.GetService<IGameEventService>();
		gameControlManager = Services.GetService<IGameControlService>();
		activated = true;
	}

	public void PlayPowerVFX()
	{
		if (powerVFX == null)
		{
			GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(GetPowerVFXPrefab(), base.transform.position, Quaternion.identity);
			gameObject.transform.parent = base.transform;
			powerVFX = gameObject.GetComponent<ParticleSystem>();
		}
		if (powerVFX != null)
		{
			powerVFX.Play(withChildren: true);
		}
	}

	protected virtual GameObject GetPowerVFXPrefab()
	{
		return (!dungeon.ShipConfig.UseAlternativePulseFX) ? powerVFXPfb : dungeon.PowerPulseMajorModuleAlternativeVFXPfb;
	}

	public void StopPowerVFX()
	{
		if (powerVFX != null)
		{
			powerVFX.Stop(withChildren: true);
		}
	}

	public void Highlight()
	{
		if (!(pluggedModule != null) && ParentRoom.IsPowered)
		{
			if (moduleSlotHighlightItem == null)
			{
				GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(highlightPanelPfb, Vector3.zero, Quaternion.identity);
				gameObject.transform.parent = SingletonManager.Get<MainGameScreen>().ModuleSlotHighlightsContainerTfm;
				moduleSlotHighlightItem = gameObject.GetComponent<ModuleSlotHighlightItem>();
			}
			moduleSlotHighlightItem.AgeTransform.Visible = true;
			moduleSlotHighlightItem.GameToScreenPositionSync.GameEntityTfm = base.transform;
		}
	}

	public void UnHighlight()
	{
		if (moduleSlotHighlightItem != null)
		{
			moduleSlotHighlightItem.AgeTransform.Visible = false;
			moduleSlotHighlightItem.GameToScreenPositionSync.GameEntityTfm = null;
		}
	}

	public void DisplayDestroyedModule(ModuleCategory moduleCategory, string moduleConfigName, int moduleLevel)
	{
		DestroyedModuleCategory = moduleCategory;
		DestroyedModuleConfigName = moduleConfigName;
		DestroyedModuleLevel = moduleLevel;
		bool flag = false;
		for (int num = moduleLevel; num >= 1; num--)
		{
			AnimationClip animationClip = Resources.Load("SpriteAnimations/Modules/" + moduleConfigName + "/LVL" + num + "/ModuleBroken") as AnimationClip;
			if (animationClip != null)
			{
				destroyedFaceAnim.OverrideClip("ModuleBroken", animationClip, restoreOriginalControllerFirst: true);
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			for (int num2 = moduleLevel; num2 >= 1; num2--)
			{
				AnimationClip animationClip = Resources.Load("SpriteAnimations/Modules/Default_" + moduleCategory + "/LVL" + num2 + "/ModuleBroken") as AnimationClip;
				if (animationClip != null)
				{
					destroyedFaceAnim.OverrideClip("ModuleBroken", animationClip, restoreOriginalControllerFirst: true);
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			destroyedFaceAnim.Play();
		}
		flag = false;
		for (int num3 = moduleLevel; num3 >= 1; num3--)
		{
			AnimationClip animationClip = Resources.Load("SpriteAnimations/Modules/" + moduleConfigName + "/LVL" + num3 + "/BaseBroken") as AnimationClip;
			if (animationClip != null)
			{
				destroyedBaseAnim.OverrideClip("BaseBroken", animationClip, restoreOriginalControllerFirst: true);
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			for (int num4 = moduleLevel; num4 >= 1; num4--)
			{
				AnimationClip animationClip = Resources.Load("SpriteAnimations/Modules/Default_" + moduleCategory + "/LVL" + num4 + "/BaseBroken") as AnimationClip;
				if (animationClip != null)
				{
					destroyedBaseAnim.OverrideClip("BaseBroken", animationClip, restoreOriginalControllerFirst: true);
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			destroyedBaseAnim.Play();
		}
	}

	protected void Awake()
	{
		UniqueID = GetComponent<UniqueID>();
		IsAvailable = true;
	}

	protected virtual void OnDestroy()
	{
		if (moduleSlotHighlightItem != null)
		{
			UnityEngine.Object.Destroy(moduleSlotHighlightItem.gameObject);
			moduleSlotHighlightItem = null;
		}
	}
}
[RequireComponent(typeof(Collider))]
public class RotatingModuleCollider : MonoBehaviour
{
	private MinorModule module;

	private void Awake()
	{
		module = base.transform.parent.GetComponent<MinorModule>();
	}

	public void OnLeftClickUp(ClickUpInfo clickInfo)
	{
		module.OnLeftClickUp(clickInfo);
	}

	public void OnRightClickDown(ClickDownInfo clickInfo)
	{
		module.OnRightClickDown(clickInfo);
	}
}
public abstract class SpecialMajorModule : MajorModule
{
	public abstract void Interact(Hero interactingHero);

	protected override void OnDeath(ulong attackerOwnerPlayerID)
	{
		base.OnDeath(attackerOwnerPlayerID);
		GetComponent<Collider>().enabled = false;
	}

	private void OnRightClickDown(ClickDownInfo clickInfo)
	{
		if (Hero.SelectedHeroes.Count > 0)
		{
			foreach (Hero selectedHero in Hero.SelectedHeroes)
			{
				if (selectedHero.HasCrystal)
				{
					selectedHero.MoveToRoom(base.RoomElement.ParentRoom);
				}
				else
				{
					selectedHero.MoveToSpecialMajorModule(this);
				}
			}
			Services.GetService<IInputService>().StopClickEventPropagation();
		}
	}
}
public class Stele : SpecialMajorModule
{
	[SerializeField]
	private GameObject steleTimerPrefab;

	private MainGameScreen mainGameScreen;

	private AgePrimitiveLabel steleTimerLabel;

	public SteleTypeEventConfig TypeEventConfig
	{
		get;
		set;
	}

	public SimulationDescriptor SimDesc
	{
		get;
		private set;
	}

	public override void Init(ulong ownerPlayerID, BluePrintConfig bpConfig, Room parentRoom, ModuleSlot slot, float buildDuration, bool playAppearanceAnimations = true, bool instantBuild = false, bool restoration = false, bool checkOwnershipForBuildComplete = true)
	{
		base.Init(ownerPlayerID, bpConfig, parentRoom, slot, buildDuration, playAppearanceAnimations, instantBuild, restoration, checkOwnershipForBuildComplete);
		mainGameScreen = SingletonManager.Get<MainGameScreen>();
		forceVFX = true;
		base.HealthCpnt.IsInvincible = true;
		base.HealthCpnt.HealthBar.ShowEvenWhenFullLife = true;
		base.HealthCpnt.HealthBar.ShowEvenWhenHolderIsHidden = true;
		GameObject gameObject = UnityEngine.Object.Instantiate(steleTimerPrefab);
		gameObject.transform.parent = mainGameScreen.SteleTimersContainer;
		gameObject.GetComponent<GameToScreenPositionSync>().GameEntityTfm = GetComponent<HealthBarDisplayer>().BarContainer;
		steleTimerLabel = gameObject.GetComponent<AgePrimitiveLabel>();
		base.HealthCpnt.OnHealthChanged += UpdateTimerLabel;
		if (!base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			return;
		}
		gameEventManager.OnDungeonTurnChanged += OnDungeonTurnChanged;
		if (!restoration)
		{
			GameConfig gameConfig = GameConfig.GetGameConfig();
			Dictionary<SteleTypeEventConfig, float> dictionary = new Dictionary<SteleTypeEventConfig, float>();
			int num = gameConfig.SteleTypeEventConfigs.Length;
			SteleTypeEventConfig steleTypeEventConfig;
			for (int i = 0; i < num; i++)
			{
				steleTypeEventConfig = gameConfig.SteleTypeEventConfigs[i];
				dictionary.Add(steleTypeEventConfig, steleTypeEventConfig.GetProbWeightValue(base.RoomElement.ParentRoom));
			}
			steleTypeEventConfig = dictionary.GetWeightedRandom();
			if (steleTypeEventConfig == null)
			{
				Diagnostics.LogError("Could not pick a stele type");
				return;
			}
			SetType(steleTypeEventConfig);
			base.HealthCpnt.SetHealthRatio(1f, checkOwnership: false, ignoreInvincibility: false, ignoreAlive: true);
		}
	}

	public void SetType(SteleTypeEventConfig typeConfig, bool netSync = true)
	{
		if (netSync)
		{
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.Stele_DoSetType, typeConfig.Name);
		}
		else
		{
			DoSetType(typeConfig.Name);
		}
	}

	private void RPC_DoSetType(StaticString typeCfgName)
	{
		DoSetType(typeCfgName);
	}

	private void DoSetType(StaticString typeCfgName)
	{
		GameConfig gameConfig = GameConfig.GetGameConfig();
		SteleTypeEventConfig steleTypeEventConfig = null;
		for (int i = 0; i < gameConfig.SteleTypeEventConfigs.Length; i++)
		{
			if (gameConfig.SteleTypeEventConfigs[i].Name == typeCfgName)
			{
				steleTypeEventConfig = gameConfig.SteleTypeEventConfigs[i];
				break;
			}
		}
		if (steleTypeEventConfig == null)
		{
			Diagnostics.LogError("Stele.DoSetType: unable to find \"" + typeCfgName + "\" stele type in game config!");
			return;
		}
		if (SimDesc != null)
		{
			RemoveSimDescriptor(SimDesc);
		}
		TypeEventConfig = steleTypeEventConfig;
		SimDesc = SimMonoBehaviour.GetDBDescriptorByName("SpecialModule_Stele_" + TypeEventConfig.Name);
		AddSimDescriptor(SimDesc);
		gameEventManager.TriggerDungeonFIDSChangedEvent();
		SetVFXAndLights();
	}

	protected override void SetVFXAndLights(string vfxNameSuffix = null)
	{
		if (TypeEventConfig != null)
		{
			base.SetVFXAndLights(vfxNameSuffix + "_" + TypeEventConfig.Name);
		}
	}

	public override void Power(bool on)
	{
		if (on)
		{
			base.Power(on);
		}
	}

	protected override void OnDeath(ulong attackerOwnerPlayerID)
	{
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChanged;
		}
		if (base.HealthCpnt != null)
		{
			base.HealthCpnt.HealthBar.HideBar();
		}
		audioEmitter.PlayEvent("Master/Events/Stele_Explosion");
		base.OnDeath(attackerOwnerPlayerID);
	}

	private void OnDestroy()
	{
		if (base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChanged;
		}
		if (steleTimerLabel != null)
		{
			UnityEngine.Object.Destroy(steleTimerLabel.gameObject);
		}
	}

	private void OnDungeonTurnChanged()
	{
		base.HealthCpnt.AddHealth(-1f, 0uL, checkOwnership: true, ignoreInvincibility: true);
		UpdateTimerLabel();
	}

	private void DisplayStelePanel()
	{
		IGameCameraService service = Services.GetService<IGameCameraService>();
		if (!service.IsTacticalMapActive() && !service.IsSwitchingCamera)
		{
			StelePanel stelePanel = SingletonManager.Get<StelePanel>();
			if (!(stelePanel != null) || !stelePanel.IsVisible)
			{
				IGameControlService service2 = Services.GetService<IGameControlService>();
				service2.ClosePanelsAtStartOfInteraction();
				stelePanel.Bind(this);
				stelePanel.RefreshContent();
				stelePanel.Show();
			}
		}
	}

	private void OnLeftClickDown(ClickDownInfo clickInfo)
	{
		DisplayStelePanel();
	}

	private void OnRightClickDown(ClickDownInfo clickInfo)
	{
		DisplayStelePanel();
	}

	public override void Interact(Hero interactingHero)
	{
		DisplayStelePanel();
	}

	private void UpdateTimerLabel()
	{
		if (steleTimerLabel != null)
		{
			steleTimerLabel.Text = base.HealthCpnt.GetHealth().ToString() + " \\7818\\";
		}
	}
}
public class Mover : MonoBehaviour
{
	public struct CachedPath
	{
		public Int2Position[] Path;

		public uint UseCount;
	}

	public delegate void MoveStoppedHandler();

	public delegate void MoveDirectionChangedHandler(Vector3 direction);

	public MoveStoppedHandler OnMoveStopped;

	private static readonly char VECTORPATH_POSITIONS_SEPARATOR = ';';

	private static readonly char VECTORPATH_COORDINATES_SEPARATOR = ',';

	private static Dictionary<StaticString, CachedPath> pathCache = new Dictionary<StaticString, CachedPath>();

	private static Dictionary<StaticString, CachedPath> pathCacheTmp = new Dictionary<StaticString, CachedPath>();

	private static readonly uint MAX_PATH_CACHE_SIZE = 100u;

	[SerializeField]
	private float moveDefaultSpeed;

	[SerializeField]
	private SpriteAnimationRuntime2 spriteAnim;

	[SerializeField]
	private bool snapToPixelGrid = true;

	[SerializeField]
	private bool netSync;

	[SerializeField]
	private float positionNetSyncPeriod;

	[SerializeField]
	private float positionNetSyncPeriodVariance;

	[SerializeField]
	private float netSyncPosCatchingSpeedModifier;

	[SerializeField]
	private float netPosLateSpeedBonus;

	[SerializeField]
	private float netPosEarlySpeedMalus;

	[SerializeField]
	private float netPosSpeedModifierMin;

	[SerializeField]
	private float netPosSpeedModifierMax;

	[SerializeField]
	private float netPosEarlyMaxLag;

	[SerializeField]
	private int maxSpriteOffset;

	[SerializeField]
	private bool debug;

	[SerializeField]
	private bool debugPath;

	[SerializeField]
	private bool debugRepulsiveForce;

	[SerializeField]
	private bool debugControllerColliderHit;

	[SerializeField]
	private bool debugPositions;

	private Seeker pathSeeker;

	private Vector3 moveTargetPos;

	private float approachDistance;

	private float previousMoveSpeed;

	private SimMonoBehaviour simMB;

	private bool isRequestingPath;

	private Vector3 currentPathRequestTargetPos;

	private bool restartPathRequestOnceCurrentDone;

	private Vector3 currentMoveDirection;

	private Dungeon dungeon;

	private GameNetworkManager gameNetManager;

	private bool isFollowingPath;

	private Int2Position[] vectorPath;

	private int pathIndex;

	private MoveTargetReachedHandler onMoveTargetReached;

	private MoveTargetReachedHandler onPathFound_onMoveTargetReached;

	private Attacker attackerCpnt;

	private UniqueIDNetSyncElement netSyncElement;

	private StaticString pathKey;

	private bool netSyncPosition;

	private float nextPositionSyncTime;

	private Transform tfm;

	private Vector3 virtualPosition;

	private Vector3 realPosition;

	private ITimeSynchronizationService timeSyncManager;

	private float additionnalDeltaTime;

	private float netPosSyncSpeedModifier = 1f;

	private StringBuilder vectorPathSerializerStrBuilder = new StringBuilder();

	private Health healthCpnt;

	private Mover _hitMover;

	public static int CurrentPathRequestCount
	{
		get;
		private set;
	}

	public bool CanMove
	{
		get;
		set;
	}

	public float MoveSpeed
	{
		get;
		set;
	}

	public bool IsMoving
	{
		get;
		private set;
	}

	public Vector3 MoveDirection => currentMoveDirection;

	public event MoveDirectionChangedHandler OnMoveDirectionChanged;

	public static void ListenToGraphsUpdates()
	{
		AstarPath.OnGraphsUpdated = (OnScanDelegate)Delegate.Combine(AstarPath.OnGraphsUpdated, new OnScanDelegate(OnGraphsUpdatedStatic));
	}

	public static GraphNode GetClosestWalkableNodeFromPosition(Vector3 position)
	{
		NNConstraint nNConstraint = new NNConstraint();
		nNConstraint.constrainWalkability = true;
		nNConstraint.constrainDistance = false;
		NNInfo nearest = AstarPath.active.GetNearest(position, nNConstraint);
		return nearest.node;
	}

	public void MoveToPosition(Vector3 targetPosition, MoveTargetReachedHandler onMoveTargetReached = null, bool forceRePath = false, float approachDistance = 0f)
	{
		if (debug)
		{
			Diagnostics.Log(base.name + " > MoveToPosition: current pos=" + tfm.position + " virtual pos=" + virtualPosition + " targetPosition=" + targetPosition + " onMoveTargetReached=" + onMoveTargetReached + " forceRePath=" + forceRePath + " approachDistance=" + approachDistance);
		}
		if (netSync && !netSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError(base.name + " > MoveToPosition should only be called on owner side!");
			return;
		}
		if (!CanMove)
		{
			Diagnostics.Log(base.name + " > Cannot move");
			return;
		}
		if (attackerCpnt != null && attackerCpnt.Target != null)
		{
			attackerCpnt.StopAttack();
		}
		if (!forceRePath && IsMoving && moveTargetPos == targetPosition && this.onMoveTargetReached == onMoveTargetReached)
		{
			if (debug)
			{
				Diagnostics.Log(base.name + " > Already moving to the same position with the same final action");
			}
			return;
		}
		IsMoving = true;
		netSyncPosition = (netSync && positionNetSyncPeriod > 0f && gameNetManager.IsMultiplayerSession() && netSyncElement.IsOwnedByLocalPlayer());
		if (netSyncPosition)
		{
			nextPositionSyncTime = Time.time + positionNetSyncPeriod + RandomGenerator.RangeFloat(0f - positionNetSyncPeriod, positionNetSyncPeriod);
		}
		moveTargetPos = targetPosition;
		onPathFound_onMoveTargetReached = onMoveTargetReached;
		this.onMoveTargetReached = null;
		this.approachDistance = approachDistance;
		if (dungeon.GetSqrDistance(tfm.position, targetPosition) <= this.approachDistance * this.approachDistance)
		{
			if (debug)
			{
				Diagnostics.LogError(base.name + " > Already reached destination");
			}
			this.onMoveTargetReached = onPathFound_onMoveTargetReached;
			OnEndOfPathReached();
			return;
		}
		NNConstraint nNConstraint = new NNConstraint();
		nNConstraint.constrainWalkability = true;
		NNInfo nearest = AstarPath.active.GetNearest(tfm.position, nNConstraint);
		GraphNode node = nearest.node;
		if (node == null)
		{
			Diagnostics.LogError(base.name + " > No nearest node found from start (" + tfm.position + ")");
		}
		NNInfo nearest2 = AstarPath.active.GetNearest(targetPosition, nNConstraint);
		GraphNode node2 = nearest2.node;
		if (node2 == null)
		{
			Diagnostics.LogError(base.name + " > No nearest node found from target (" + targetPosition + ")");
		}
		if (node != null && node2 != null && node.Area != node2.Area)
		{
			Diagnostics.LogWarning(base.name + " > Trying to move to a different pathfinding grid (" + tfm.position + " -> " + targetPosition + ")");
		}
		isFollowingPath = false;
		StringBuilder stringBuilder = new StringBuilder();
		if (node != null)
		{
			stringBuilder.Append(node.NodeIndex);
		}
		else
		{
			Vector3 position = tfm.position;
			object arg = position.x.RoundHalfAwayFromZeroToInt();
			Vector3 position2 = tfm.position;
			stringBuilder.AppendFormat("{0},{1}", arg, position2.z.RoundHalfAwayFromZeroToInt());
		}
		stringBuilder.Append(">");
		if (node2 != null)
		{
			stringBuilder.Append(node2.NodeIndex);
		}
		else
		{
			stringBuilder.AppendFormat("{0},{1}", moveTargetPos.x.RoundHalfAwayFromZeroToInt(), moveTargetPos.z.RoundHalfAwayFromZeroToInt());
		}
		pathKey = stringBuilder.ToString();
		if (pathCache.ContainsKey(pathKey))
		{
			CachedPath value = pathCache[pathKey];
			value.UseCount++;
			pathCache[pathKey] = value;
			if (debug)
			{
				Diagnostics.Log("{0} > Mover.MoveToPosition({1} > {2}): Getting path from cache! \\o/ (pathKey={3}, use count={4})", base.name, tfm.position, moveTargetPos, pathKey, value.UseCount);
			}
			this.onMoveTargetReached = onPathFound_onMoveTargetReached;
			FollowPath(value.Path);
			return;
		}
		if (debug)
		{
			Diagnostics.LogWarning("{0} > Mover.MoveToPosition({1} > {2}): path not in cache, computing it :( (pathKey={3})", base.name, tfm.position, moveTargetPos, pathKey);
		}
		if (AstarPath.active.IsAnyGraphUpdatesQueued)
		{
			if (debug)
			{
				Diagnostics.Log(base.name + " > Graph is updating, waiting for it to complete...");
			}
			AstarPath.OnGraphsUpdated = (OnScanDelegate)Delegate.Combine(AstarPath.OnGraphsUpdated, new OnScanDelegate(OnGraphsUpdated));
			return;
		}
		if (isRequestingPath && currentPathRequestTargetPos != moveTargetPos)
		{
			if (debug)
			{
				Diagnostics.Log(base.name + " > Already requesting path, waiting for it to complete, then we'll restart...");
			}
			restartPathRequestOnceCurrentDone = true;
			return;
		}
		isRequestingPath = true;
		restartPathRequestOnceCurrentDone = false;
		currentPathRequestTargetPos = moveTargetPos;
		CurrentPathRequestCount++;
		if (debug)
		{
			Diagnostics.Log(base.name + " > Mover.MoveToPosition(" + tfm.position + " > " + moveTargetPos + "): >>>>> Requesting path");
		}
		pathSeeker.StartPath(tfm.position, moveTargetPos, OnPathFound);
	}

	public void SetPosition(Vector3 position)
	{
		virtualPosition = position;
		realPosition = position;
		tfm.position = position;
	}

	public void OnGraphsUpdated(AstarPath astarPath)
	{
		AstarPath.OnGraphsUpdated = (OnScanDelegate)Delegate.Remove(AstarPath.OnGraphsUpdated, new OnScanDelegate(OnGraphsUpdated));
		MoveToPosition(moveTargetPos, onMoveTargetReached, forceRePath: true);
	}

	public void UpdateMoveDirection(Vector3 direction)
	{
		if (currentMoveDirection.normalized != direction.normalized)
		{
			if (this.OnMoveDirectionChanged != null)
			{
				this.OnMoveDirectionChanged(direction);
			}
			currentMoveDirection = direction;
		}
		if (spriteAnim != null)
		{
			spriteAnim.SetAnimDirection(direction);
		}
	}

	public void StopMove(bool playIdleAnim = true)
	{
		if (IsMoving)
		{
			if (netSync)
			{
				netSyncElement.SendRPCToAll(UniqueIDRPC.Mover_DoStopMove, playIdleAnim, (Int2Position)tfm.position);
			}
			else
			{
				DoStopMove(playIdleAnim, tfm.position);
			}
		}
	}

	private void RPC_DoStopMove(bool playIdleAnim, Int2Position stopPosition)
	{
		DoStopMove(playIdleAnim, (Vector3)stopPosition);
	}

	private void DoStopMove(bool playIdleAnim, Vector3 stopPosition)
	{
		if (IsMoving)
		{
			virtualPosition = stopPosition;
			isFollowingPath = false;
			IsMoving = false;
			netSyncPosition = false;
			isRequestingPath = false;
			if (OnMoveStopped != null)
			{
				OnMoveStopped();
			}
			StopRunAnim();
		}
	}

	private static void OnGraphsUpdatedStatic(AstarPath astarPath)
	{
		pathCache.Clear();
	}

	protected virtual void Awake()
	{
		tfm = base.transform;
		virtualPosition = tfm.position;
		realPosition = tfm.position;
		pathSeeker = GetComponent<Seeker>();
		simMB = GetComponent<SimMonoBehaviour>();
		attackerCpnt = GetComponent<Attacker>();
		netSyncElement = GetComponent<UniqueIDNetSyncElement>();
		dungeon = SingletonManager.Get<Dungeon>();
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
		timeSyncManager = Services.GetService<ITimeSynchronizationService>();
		healthCpnt = GetComponent<Health>();
		if (healthCpnt != null)
		{
			healthCpnt.OnDeath += OnDeath;
		}
		float num = moveDefaultSpeed;
		Vector3 tileSize = dungeon.GetTileSize();
		moveDefaultSpeed = num * tileSize.x;
		CanMove = true;
		if (spriteAnim != null && maxSpriteOffset > 0)
		{
			spriteAnim.transform.localPosition += UnityEngine.Random.Range(-maxSpriteOffset, maxSpriteOffset + 1) * Vector3.right;
			spriteAnim.transform.localPosition += UnityEngine.Random.Range(-maxSpriteOffset, maxSpriteOffset + 1) * Vector3.forward;
		}
	}

	private void OnPathFound(Pathfinding.Path path)
	{
		CurrentPathRequestCount--;
		isRequestingPath = false;
		if (restartPathRequestOnceCurrentDone)
		{
			if (debug)
			{
				Diagnostics.LogWarning(base.name + " > Mover.OnPathFound: restarting path request to " + moveTargetPos + "!");
			}
			MoveToPosition(moveTargetPos, onPathFound_onMoveTargetReached, forceRePath: true);
			return;
		}
		onMoveTargetReached = onPathFound_onMoveTargetReached;
		Int2Position[] array = new Int2Position[path.vectorPath.Count];
		for (int i = 0; i < path.vectorPath.Count; i++)
		{
			ref Int2Position reference = ref array[i];
			Vector3 vector = path.vectorPath[i];
			reference.x = vector.x.RoundHalfAwayFromZeroToInt();
			ref Int2Position reference2 = ref array[i];
			Vector3 vector2 = path.vectorPath[i];
			reference2.y = vector2.z.RoundHalfAwayFromZeroToInt();
		}
		if (pathCache.ContainsKey(pathKey))
		{
			if (debug)
			{
				Diagnostics.LogWarning("{0} > Mover.OnPathFound: {1} path already cached!", base.name, pathKey);
			}
		}
		else
		{
			if (pathCache.Count > MAX_PATH_CACHE_SIZE)
			{
				pathCacheTmp.Clear();
				IEnumerator enumerator = pathCache.Keys.GetEnumerator();
				while (enumerator.MoveNext())
				{
					StaticString key = enumerator.Current as StaticString;
					CachedPath cachedPath = pathCache[key];
					if (cachedPath.UseCount > 1)
					{
						CachedPath value = pathCache[key];
						value.UseCount = 0u;
						pathCacheTmp.Add(key, value);
					}
				}
				pathCache = new Dictionary<StaticString, CachedPath>(pathCacheTmp);
				if (debug)
				{
					Diagnostics.LogWarning("{0} > Mover.OnPathFound: path cache cleaned, {1} paths kept!", base.name, pathCache.Count);
				}
			}
			pathCache.Add(pathKey, new CachedPath
			{
				Path = array,
				UseCount = 1u
			});
		}
		if (!IsMoving)
		{
			Diagnostics.Log(base.name + " > Move stopped during path finding");
		}
		else
		{
			FollowPath(array);
		}
	}

	public void FollowPath(Int2Position[] vectorPath)
	{
		if (netSync)
		{
			vectorPathSerializerStrBuilder.Length = 0;
			for (int i = 0; i < vectorPath.Length; i++)
			{
				vectorPathSerializerStrBuilder.AppendFormat("{0}{1}{2}", vectorPath[i].x, VECTORPATH_COORDINATES_SEPARATOR, vectorPath[i].y);
				if (i < vectorPath.Length - 1)
				{
					vectorPathSerializerStrBuilder.Append(VECTORPATH_POSITIONS_SEPARATOR);
				}
			}
			netSyncElement.SendRPCToOthers(UniqueIDRPC.Mover_DoFollowPath, pathKey, vectorPathSerializerStrBuilder.ToString(), timeSyncManager.Time.RoundWithDecimals(2));
			DoFollowPath(pathKey, vectorPath);
		}
		else
		{
			DoFollowPath(pathKey, vectorPath);
		}
	}

	private void RPC_DoFollowPath(StaticString pathKey, string vectorPathSerial, float ownerStartTime)
	{
		string[] array = vectorPathSerial.Split(VECTORPATH_POSITIONS_SEPARATOR);
		Int2Position[] array2 = new Int2Position[array.Length];
		for (int i = 0; i < array.Length; i++)
		{
			string[] array3 = array[i].Split(VECTORPATH_COORDINATES_SEPARATOR);
			array2[i].x = int.Parse(array3[0]);
			array2[i].y = int.Parse(array3[1]);
		}
		DoFollowPath(pathKey, array2, ownerStartTime);
	}

	private void DoFollowPath(StaticString pathKey, Int2Position[] vectorPath, float ownerStartTime = -1f)
	{
		if (vectorPath.Length < 1)
		{
			Diagnostics.LogError(base.name + " > Empty path returned!");
		}
		else if (CanMove)
		{
			virtualPosition = (Vector3)vectorPath[0];
			if (simMB != null)
			{
				float moveSpeed = GetMoveSpeed();
				Vector3 tileSize = dungeon.GetTileSize();
				MoveSpeed = moveSpeed * tileSize.x;
			}
			previousMoveSpeed = MoveSpeed;
			IsMoving = true;
			isFollowingPath = true;
			this.pathKey = pathKey;
			this.vectorPath = vectorPath;
			pathIndex = 0;
			float num = (float)timeSyncManager.Time;
			if (ownerStartTime > 0f && ownerStartTime < num)
			{
				additionnalDeltaTime = num - ownerStartTime;
			}
			else
			{
				additionnalDeltaTime = 0f;
			}
			PlayRunAnim();
		}
	}

	protected virtual float GetMoveSpeed()
	{
		return simMB.GetSimPropertyValue(SimulationProperties.MoveSpeedReal);
	}

	private void Update()
	{
		if (isFollowingPath)
		{
			if (debugPath)
			{
				int num = 0;
				Int2Position[] array = vectorPath;
				foreach (Int2Position o in array)
				{
					Vector3 vector = (Vector3)o;
					UnityEngine.Debug.DrawLine(vector, vector + 2f * Vector3.up, (pathIndex != num) ? Color.blue : Color.red);
					num++;
				}
			}
			float num2 = dungeon.GetSqrDistance(virtualPosition, (Vector3)vectorPath[pathIndex]);
			while (pathIndex + 1 < vectorPath.Length)
			{
				float sqrDistance = dungeon.GetSqrDistance(virtualPosition, (Vector3)vectorPath[pathIndex + 1]);
				if (sqrDistance < num2)
				{
					num2 = sqrDistance;
					pathIndex++;
					continue;
				}
				break;
			}
			if (pathIndex + 1 < vectorPath.Length && Vector3.Dot((Vector3)vectorPath[pathIndex + 1] - virtualPosition, (Vector3)vectorPath[pathIndex] - virtualPosition) < 0f)
			{
				pathIndex++;
			}
			Vector3 vector2 = virtualPosition;
			float num3 = Time.deltaTime + additionnalDeltaTime;
			additionnalDeltaTime = 0f;
			float num4 = MoveSpeed * num3;
			if (netSync && !netSyncElement.IsOwnedByLocalPlayer())
			{
				num4 *= netPosSyncSpeedModifier;
			}
			bool flag = false;
			Vector3 a;
			while (!flag && num4 > 0f)
			{
				a = (Vector3)vectorPath[pathIndex] - vector2;
				float magnitude = a.magnitude;
				if (magnitude < num4)
				{
					vector2 = (Vector3)vectorPath[pathIndex];
					num4 -= magnitude;
					pathIndex++;
					if (pathIndex >= vectorPath.Length)
					{
						flag = true;
						break;
					}
					continue;
				}
				vector2 += a * (num4 / magnitude);
				break;
			}
			a = vector2 - virtualPosition;
			UpdateMoveDirection(a);
			virtualPosition = vector2;
			if (approachDistance > 0f && dungeon.GetSqrDistance(tfm.position, moveTargetPos) <= approachDistance * approachDistance)
			{
				flag = true;
			}
			if (flag)
			{
				OnEndOfPathReached();
			}
		}
		if (netSyncPosition && Time.time >= nextPositionSyncTime)
		{
			netSyncElement.SendUnreliableRPCToOthers(UniqueIDRPC.Mover_UpdatePosition, (Int2Position)virtualPosition, pathKey, pathIndex, timeSyncManager.Time.RoundWithDecimals(2));
			nextPositionSyncTime = Time.time + positionNetSyncPeriod + UnityEngine.Random.Range(0f - positionNetSyncPeriod, positionNetSyncPeriod);
		}
		Vector3 direction = virtualPosition - realPosition;
		direction -= direction.y * Vector3.up;
		float sqrMagnitude = direction.sqrMagnitude;
		if (sqrMagnitude > 0f)
		{
			if (sqrMagnitude > 10f)
			{
				UpdateMoveDirection(direction);
			}
			if (netSync && !netSyncElement.IsOwnedByLocalPlayer())
			{
				float num5 = MoveSpeed * netSyncPosCatchingSpeedModifier * Time.deltaTime;
				if (sqrMagnitude > num5 * num5)
				{
					realPosition += num5 * direction.normalized;
				}
				else
				{
					realPosition = virtualPosition;
				}
			}
			else
			{
				realPosition = virtualPosition;
			}
		}
		if (snapToPixelGrid)
		{
			Vector3 position = new Vector3(realPosition.x, 0f, realPosition.z);
			Vector3 v = tfm.InverseTransformPoint(position);
			v = v.RoundHalfAwayFromZero();
			position = tfm.TransformPoint(v);
			if (tfm.position != position)
			{
				tfm.position = position;
			}
		}
		else
		{
			tfm.position = realPosition;
		}
	}

	private void LateUpdate()
	{
		if (IsMoving && spriteAnim != null && Time.timeScale > 0f)
		{
			if (simMB != null)
			{
				float moveSpeed = GetMoveSpeed();
				Vector3 tileSize = dungeon.GetTileSize();
				MoveSpeed = moveSpeed * tileSize.x;
			}
			if (MoveSpeed != previousMoveSpeed)
			{
				PlayRunAnim();
				previousMoveSpeed = MoveSpeed;
			}
		}
	}

	private void RPC_UpdatePosition(Int2Position remotePosition, StaticString remotePathKey, int remotePathIndex, float remoteTime)
	{
		if (healthCpnt != null && !healthCpnt.IsAlive())
		{
			return;
		}
		float num = (float)timeSyncManager.Time;
		bool flag = false;
		bool flag2 = false;
		if (remoteTime > num || remotePathKey != pathKey)
		{
			return;
		}
		if (remotePathIndex > pathIndex)
		{
			flag = true;
		}
		else if (remotePathIndex == pathIndex)
		{
			Vector3 a = (Vector3)vectorPath[pathIndex];
			flag = (Vector3.SqrMagnitude(a - (Vector3)remotePosition) < Vector3.SqrMagnitude(a - virtualPosition));
		}
		else
		{
			flag2 = (num - remoteTime <= netPosEarlyMaxLag);
		}
		if (flag)
		{
			if (netPosSyncSpeedModifier < 1f)
			{
				netPosSyncSpeedModifier = 1f;
			}
			netPosSyncSpeedModifier = Mathf.Min(netPosSyncSpeedModifier + netPosLateSpeedBonus, netPosSpeedModifierMax);
			if (debugPositions)
			{
				Diagnostics.LogWarning("{0} > LATE this.netPosSyncSpeedModifier={1}", base.name, netPosSyncSpeedModifier);
			}
			pathIndex = remotePathIndex;
		}
		else if (flag2)
		{
			if (netPosSyncSpeedModifier > 1f)
			{
				netPosSyncSpeedModifier = 1f;
			}
			netPosSyncSpeedModifier = Mathf.Max(netPosSyncSpeedModifier - netPosEarlySpeedMalus, netPosSpeedModifierMin);
			if (debugPositions)
			{
				Diagnostics.LogWarning("{0} > EARLY this.netPosSyncSpeedModifier={1}", base.name, netPosSyncSpeedModifier);
			}
			pathIndex = remotePathIndex;
		}
		else
		{
			netPosSyncSpeedModifier = 1f;
		}
	}

	private GraphNode GetClosestWalkableNode()
	{
		return GetClosestWalkableNodeFromPosition(tfm.position);
	}

	private void OnEndOfPathReached()
	{
		if (debug)
		{
			Diagnostics.LogWarning("Mover.OnEndOfPathReached");
		}
		isFollowingPath = false;
		if (netSync && netSyncElement.IsOwnedByLocalPlayer())
		{
			StopMove();
		}
		if (onMoveTargetReached != null)
		{
			onMoveTargetReached();
			onMoveTargetReached = null;
		}
	}

	private void PlayRunAnim()
	{
		if (spriteAnim != null)
		{
			float num = MoveSpeed / moveDefaultSpeed;
			if (num != 1f)
			{
				spriteAnim.SetSpeed(num, "RunBT");
			}
			spriteAnim.SetBool(SpriteAnimationBool.IsMoving, value: true);
		}
	}

	private void StopRunAnim()
	{
		if (spriteAnim != null)
		{
			spriteAnim.SetBool(SpriteAnimationBool.IsMoving, value: false);
		}
	}

	private void OnDeath(ulong attackerOwnerPlayerID)
	{
		StopMoving();
		if (isRequestingPath)
		{
			CurrentPathRequestCount--;
			isRequestingPath = false;
		}
	}

	public void StopMoving()
	{
		CanMove = false;
		if (IsMoving)
		{
			StopMove(playIdleAnim: false);
		}
	}
}
public class NPC : SimMonoBehaviour
{
	protected Dungeon dungeon;

	protected GameNetworkManager gameNetManager;

	protected bool forbidInteractionAnim;

	[SerializeField]
	protected OffscreenMarker.OffscreenMarkerData npcDangerIconData;

	[SerializeField]
	protected SpriteAnimationRuntime2 spriteAnim;

	private Attacker attackerCpnt;

	private AITarget attackTargetCpnt;

	public Health HealthCpnt
	{
		get;
		private set;
	}

	public NPCConfig Config
	{
		get;
		private set;
	}

	public ModuleSlot SpawnModuleSlot
	{
		get;
		private set;
	}

	public List<Hero> InteractionInstigators
	{
		get;
		private set;
	}

	public RoomElement RoomElement
	{
		get;
		private set;
	}

	public UniqueIDNetSyncElement NetSyncElement
	{
		get;
		private set;
	}

	public virtual void Init(ulong ownerPlayerID, NPCConfig config, Room spawnRoom)
	{
		NetSyncElement.SetOwner(ownerPlayerID);
		Config = config;
		Diagnostics.Assert(Config != null);
		string text = Config.Name.ToString().Replace("NPC_", string.Empty);
		base.name = text + "_" + base.name;
		SimulationDescriptor dBDescriptorByName = SimMonoBehaviour.GetDBDescriptorByName(Config.Name);
		if (dBDescriptorByName != null)
		{
			AddSimDescriptor(dBDescriptorByName, refresh: false);
			RefreshSim();
		}
		spriteAnim.OverrideClipsFromPath("SpriteAnimations/NPC/" + text);
		HealthCpnt = GetComponent<Health>();
		base.transform.position += 0.001f * Vector3.up;
		spawnRoom.OnNPCEnter(this);
		dungeon = SingletonManager.Get<Dungeon>();
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
		HealthCpnt.InitHealth();
		if (attackerCpnt != null)
		{
			attackerCpnt.Init(config.AttackType);
			attackTargetCpnt.Init(this);
		}
		InteractionInstigators = new List<Hero>();
		spriteAnim.MonitorAnimEvent("OnDeathEnd", OnDeathEndAnimEvent);
		Show();
	}

	public virtual void BeginInteraction(Hero instigator)
	{
		if (instigator != null)
		{
			if (!InteractionInstigators.Contains(instigator))
			{
				InteractionInstigators.Add(instigator);
			}
			if (!forbidInteractionAnim)
			{
				spriteAnim.Trigger(SpriteAnimationTrigger.OnInteractionStart);
			}
		}
	}

	public virtual void CancelInteraction(Hero instigator)
	{
		InteractionInstigators.Remove(instigator);
	}

	public virtual void EndInteraction(Hero instigator)
	{
		InteractionInstigators.Remove(instigator);
		if (!forbidInteractionAnim)
		{
			spriteAnim.Trigger(SpriteAnimationTrigger.OnInteractionEnd);
		}
	}

	public string GetDialogLocalizedTextByName(StaticString name)
	{
		DialogConfig dialogByName = Config.GetDialogByName(name);
		if (dialogByName != null)
		{
			return AgeLocalizer.Instance.LocalizeString(dialogByName.Text);
		}
		return string.Empty;
	}

	public void ChangeCurrentRoom(Room newRoom)
	{
		if (RoomElement.ParentRoom != null)
		{
			RoomElement.ParentRoom.OnEntityEntered -= Room_OnEntityEntered;
		}
		RoomElement.SetParentRoom(newRoom);
		RoomElement.ParentRoom.OnEntityEntered += Room_OnEntityEntered;
	}

	protected override Type GetSimClass()
	{
		return typeof(NPC);
	}

	protected override void Awake()
	{
		base.Awake();
		HealthCpnt = GetComponent<Health>();
		attackerCpnt = GetComponent<Attacker>();
		attackTargetCpnt = GetComponent<AITarget>();
		RoomElement = GetComponent<RoomElement>();
		NetSyncElement = GetComponent<UniqueIDNetSyncElement>();
		HealthCpnt.OnDeath += OnDeath;
		HealthCpnt.OnDanger += OnDanger;
	}

	private void Hide()
	{
		spriteAnim.Stop();
		HealthCpnt.HealthBar.HideBar();
	}

	private void Show()
	{
		spriteAnim.Play();
		if (HealthCpnt.HealthBar != null)
		{
			HealthCpnt.HealthBar.UpdateBarDisplay();
		}
	}

	protected virtual void OnDeath(ulong attackerOwnerPlayerID)
	{
		RoomElement.ParentRoom.OnNPCExit(this);
		RoomElement.ParentRoom.OnEntityEntered -= Room_OnEntityEntered;
		spriteAnim.ResetAllTriggers();
		spriteAnim.Trigger(SpriteAnimationTrigger.OnDeath);
		if (SpawnModuleSlot != null)
		{
			SpawnModuleSlot.IsAvailable = true;
		}
	}

	private void OnDeathEndAnimEvent()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}

	protected virtual void OnDanger()
	{
		RoomElement.ParentRoom.DisplayOffscreenMarker(npcDangerIconData);
	}

	protected virtual void Room_OnEntityEntered(SimMonoBehaviour entity)
	{
		if (!forbidInteractionAnim && entity is Hero && InteractionInstigators.Count == 0)
		{
			spriteAnim.Trigger(SpriteAnimationTrigger.OnSalute);
		}
	}

	private void OnDestroy()
	{
		if (gameNetManager == null)
		{
			gameNetManager = SingletonManager.Get<GameNetworkManager>();
		}
		if (gameNetManager != null)
		{
			gameNetManager.ClearCachedAITargets(this);
		}
	}
}
public class NPCMerchant : NPC
{
	private static ItemHeroConfig[] availableItemHeroArray;

	[SerializeField]
	protected float introDialogDuration;

	[SerializeField]
	private Vector3 moduleShopPosOffset;

	private NPCMerchantConfig merchantConfig;

	private MajorModule linkedModule;

	private Room teleportDest;

	private bool displayDialogOnArrival;

	private SpriteAnimationRuntime2 tacticMapAnim;

	private SelectableManager selectableManager;

	private IAudioEventService audioEventService;

	public Inventory CurrentInventory
	{
		get;
		private set;
	}

	public CurrencyConfig CurrencyCfg
	{
		get;
		private set;
	}

	public float GiftCost
	{
		get;
		set;
	}

	public MajorModule LinkedModule => linkedModule;

	public NPCMerchantConfig MerchantConfig => merchantConfig;

	public bool IsTeleporting => teleportDest != null;

	protected override void Awake()
	{
		base.Awake();
		audioEventService = Services.GetService<IAudioEventService>();
		TacticalMapElement componentInChildren = GetComponentInChildren<TacticalMapElement>();
		if (componentInChildren != null)
		{
			tacticMapAnim = componentInChildren.GetComponent<SpriteAnimationRuntime2>();
		}
	}

	public void InitForEvent(ulong ownerPlayerID, NPCConfig config, Room spawnRoom, CurrencyConfig currencyConfig, bool displayDialog)
	{
		Init(ownerPlayerID, config, spawnRoom, currencyConfig, displayDialog);
	}

	public void InitForSaveRestore(ulong ownerPlayerID, NPCConfig config, Room spawnRoom, CurrencyConfig currencyConfig, bool isInShop)
	{
		Init(ownerPlayerID, config, spawnRoom, currencyConfig, displayDialog: false, buildRandomInventory: false, isInShop);
		if (isInShop)
		{
			LinkWithShop(spawnRoom, saveRestore: true);
		}
	}

	private void Init(ulong ownerPlayerID, NPCConfig config, Room spawnRoom, CurrencyConfig currencyConfig, bool displayDialog = true, bool buildRandomInventory = true, bool forbidTeleport = false)
	{
		base.Init(ownerPlayerID, config, spawnRoom);
		Diagnostics.Assert(base.Config is NPCMerchantConfig);
		selectableManager = SingletonManager.Get<SelectableManager>();
		merchantConfig = (base.Config as NPCMerchantConfig);
		CurrencyCfg = currencyConfig;
		BuildInventory(spawnRoom, buildRandomInventory);
		if (!forbidTeleport && MajorModule.UnlinkedShopModules.Count > 0 && CanTeleport())
		{
			MajorModule majorModule = MajorModule.UnlinkedShopModules.FirstOrDefault((MajorModule module) => module.CanReceiveMerchant);
			if (majorModule != null)
			{
				StartTeleport(majorModule.RoomElement.ParentRoom, displayDialog);
			}
		}
		else if (displayDialog)
		{
			DisplayDialog();
		}
		spriteAnim.MonitorAnimEvent("OnTeleportOutEnd", OnTeleportOutEndAnimEvent);
		spriteAnim.MonitorAnimEvent("OnTeleportInEnd", OnTeleportInEndAnimEvent);
		if (tacticMapAnim != null && CurrencyCfg != null)
		{
			tacticMapAnim.SetFloat(SpriteAnimationFloat.FIDSType, (float)CurrencyCfg.Currency);
		}
	}

	public override void BeginInteraction(Hero instigator)
	{
		IGameCameraService service = Services.GetService<IGameCameraService>();
		if (!service.IsTacticalMapActive() && !service.IsSwitchingCamera)
		{
			MainGameScreen mainGameScreen = SingletonManager.Get<MainGameScreen>();
			if ((!(mainGameScreen.MerchantPanel != null) || !mainGameScreen.MerchantPanel.IsVisible) && teleportDest == null)
			{
				base.BeginInteraction(instigator);
				IGameControlService service2 = Services.GetService<IGameControlService>();
				service2.ClosePanelsAtStartOfInteraction();
				mainGameScreen.DisplayInventoryPanel(mainGameScreen.MerchantPanel, this);
				MerchantPanel merchantPanel = mainGameScreen.MerchantPanel;
				merchantPanel.OnHidePanel = (MerchantPanel.OnHidePanelHandler)Delegate.Combine(merchantPanel.OnHidePanel, new MerchantPanel.OnHidePanelHandler(MerchantPanel_OnHidePanel));
				mainGameScreen.MerchantPanel.DisplayBuyInventory(forceRefresh: true);
				SingletonManager.Get<SelectableManager>().SetCategory(SelectionCategory.HeroStatsPanel_Merchant);
			}
		}
	}

	public override void CancelInteraction(Hero instigator)
	{
		base.CancelInteraction(instigator);
		OnInteractionInterrupted();
	}

	public override void EndInteraction(Hero instigator)
	{
		base.EndInteraction(instigator);
		OnInteractionInterrupted();
	}

	private void OnInteractionInterrupted()
	{
		MerchantPanel merchantPanel = SingletonManager.Get<MainGameScreen>().MerchantPanel;
		if (merchantPanel == MainGameScreen.CurrentInventoryPanel && merchantPanel.Merchant == this)
		{
			merchantPanel.Hide();
		}
		if (Services.GetService<IInputService>().CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			HeroPanel heroPanel = SingletonManager.Get<HeroPanel>();
			if (heroPanel.IsVisible)
			{
				heroPanel.Hide();
			}
		}
		SelectionCategoryData currentCategory = selectableManager.CurrentCategory;
		if (currentCategory.Category != SelectionCategory.HeroStatsPanel_Merchant)
		{
			SelectionCategoryData currentCategory2 = selectableManager.CurrentCategory;
			if (currentCategory2.Category != SelectionCategory.HeroStatsPanel)
			{
				return;
			}
		}
		selectableManager.SetCategory(SelectionCategory.RoomForMove, -1, overrideHigherLevelCategory: true);
	}

	public float GetCurrentPriceFor(float dustValue)
	{
		return dustValue * CurrencyCfg.ExchangeRate;
	}

	protected override void OnDeath(ulong attackerOwnerPlayerID)
	{
		base.OnDeath(attackerOwnerPlayerID);
		if (linkedModule != null)
		{
			linkedModule.CanReceiveMerchant = true;
			linkedModule = null;
			AttractMerchant(base.RoomElement.ParentRoom.MajorModule);
		}
	}

	public static void BuildAvailableItemHeroList()
	{
		IDatabase<ItemConfig> database = Databases.GetDatabase<ItemConfig>();
		DLCController dlcManager = SingletonManager.Get<DLCController>();
		List<string> unavailableItems = SingletonManager.Get<Dungeon>().ShipConfig.UnavailableItems.ToList();
		ItemConfig[] array = (from item in database.GetValues()
			where dlcManager.IsObjectAvailable(DLCObjectType.Item, item.Name) && !unavailableItems.Contains(item.Name)
			select item).ToArray();
		List<ItemHeroConfig> list = new List<ItemHeroConfig>();
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] is ItemHeroConfig)
			{
				list.Add(array[i] as ItemHeroConfig);
			}
		}
		availableItemHeroArray = list.ToArray();
	}

	private void BuildInventory(Room spawnRoom, bool buildRandomInventory = true)
	{
		CurrentInventory = new Inventory(string.Format(Inventory.MerchantInventoryName, base.UniqueID.ID), this);
		if (buildRandomInventory)
		{
			if (!base.NetSyncElement.IsOwnedByLocalPlayer())
			{
				return;
			}
			int num = RandomGenerator.RangeInt(merchantConfig.ItemsCountMin, merchantConfig.ItemsCountMax);
			int num2 = dungeon.Level + merchantConfig.ItemsRelativeLevelMin;
			int num3 = dungeon.Level + merchantConfig.ItemsRelativeLevelMax;
			int num4 = GenericUtilities.RoundHalfAwayFromZeroToInt(spawnRoom.FloorSurface);
			List<InventoryItemData> list = new List<InventoryItemData>();
			int num5 = 0;
			while (merchantConfig.ConstantItems != null && num5 < merchantConfig.ConstantItems.Length)
			{
				list.Add(new InventoryItemData(merchantConfig.ConstantItems[num5].Name, merchantConfig.ConstantItems[num5].Rarity, base.NetSyncElement.OwnerPlayerID, isGift: false));
				num5++;
			}
			for (int i = 0; i < num; i++)
			{
				ItemHeroConfig itemHeroConfig = ProbabilityConfig.PickRandomElementByLevelRange(availableItemHeroArray, dungeon.OpenRoomsCount, num4, num2, num3);
				if (itemHeroConfig == null)
				{
					Diagnostics.LogError("[NPCMerchant] BuildInventory: no item found for dungeon levels [" + num2 + ", " + num3 + "]");
					break;
				}
				RarityConfig rarityConfig = itemHeroConfig.PickRandomRarityParametersByLevelRange(dungeon.OpenRoomsCount, num4, num2, num3);
				StaticString rarityDescName = null;
				if (rarityConfig != null)
				{
					rarityDescName = rarityConfig.Name;
				}
				list.Add(new InventoryItemData(itemHeroConfig.Name, rarityDescName, base.NetSyncElement.OwnerPlayerID, MerchantConfig.SellsGiftItems));
			}
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.NPCMerchant_FillInventory, list);
		}
		else
		{
			AddInventoryDescriptor();
		}
	}

	private void RPC_FillInventory(List<InventoryItemData> itemDatas)
	{
		float num = 0f;
		float num2 = 0f;
		for (int i = 0; i < itemDatas.Count; i++)
		{
			InventoryItem inventoryItem = InventoryItem.BuildInventoryItem(itemDatas[i].ItemDescName, itemDatas[i].RarityDescName, CurrentInventory, base.NetSyncElement.OwnerPlayerID, isCreatorOwner: true, itemDatas[i].IsGift);
			if (GiftCost == 0f && itemDatas[i].IsGift)
			{
				num += inventoryItem.GetPropertyValue(SimulationProperties.Cost);
				num2 += 1f;
			}
		}
		if (MerchantConfig.SellsGiftItems && GiftCost == 0f)
		{
			GiftCost = num / num2;
		}
		AddInventoryDescriptor();
	}

	private void AddInventoryDescriptor()
	{
		CurrentInventory.SetPropertyBaseValue(SimulationProperties.GiftItemCost, GiftCost);
		SimulationDescriptor dBDescriptorByName = SimMonoBehaviour.GetDBDescriptorByName("Inventory_" + base.Config.Name);
		if (dBDescriptorByName != null)
		{
			CurrentInventory.AddDescriptor(dBDescriptorByName);
		}
	}

	public static void AttractMerchant(MajorModule shopModule)
	{
		Room moduleRoom = shopModule.RoomElement.ParentRoom;
		Room[] array = SingletonManager.Get<Dungeon>().OpenedRooms.OrderBy((Room r) => r != moduleRoom).ToArray();
		Room[] array2 = array;
		foreach (Room room in array2)
		{
			foreach (NPC nPC in room.NPCs)
			{
				NPCMerchant nPCMerchant = nPC as NPCMerchant;
				if (nPCMerchant != null && nPCMerchant.linkedModule == null && nPCMerchant.CanTeleport())
				{
					nPCMerchant.StartTeleport(moduleRoom);
					return;
				}
			}
		}
		shopModule.UpdateMerchantLink(linked: false);
	}

	private void StartTeleport(Room teleportDest, bool displayDialog = false)
	{
		if (teleportDest == null || teleportDest.MajorModule == null)
		{
			Diagnostics.LogError("NPC Merchant is trying to teleport to nowhere");
			return;
		}
		this.teleportDest = teleportDest;
		displayDialogOnArrival = displayDialog;
		teleportDest.MajorModule.CanReceiveMerchant = false;
		spriteAnim.Trigger(SpriteAnimationTrigger.OnTeleportOut);
		forbidInteractionAnim = true;
	}

	private void OnTeleportOutEndAnimEvent()
	{
		spriteAnim.Trigger(SpriteAnimationTrigger.OnTeleportIn);
		if (teleportDest != null && teleportDest.MajorModule != null)
		{
			LinkWithShop(teleportDest);
		}
		else
		{
			teleportDest = null;
		}
	}

	private void LinkWithShop(Room room, bool saveRestore = false)
	{
		base.RoomElement.ParentRoom.OnNPCEnter(this);
		base.transform.position = room.MajorModule.transform.position + moduleShopPosOffset;
		linkedModule = room.MajorModule;
		if (saveRestore)
		{
			linkedModule.CanReceiveMerchant = false;
		}
		room.MajorModule.HealthCpnt.OnDeath += OnLinkedModuleDeath;
		room.MajorModule.UpdateMerchantLink(linked: true);
	}

	private void OnTeleportInEndAnimEvent()
	{
		if (teleportDest != null)
		{
			if (displayDialogOnArrival)
			{
				displayDialogOnArrival = false;
				DisplayDialog();
			}
			teleportDest = null;
			forbidInteractionAnim = false;
			spriteAnim.Trigger(SpriteAnimationTrigger.OnSalute);
		}
	}

	private bool CanTeleport()
	{
		return !IsTeleporting && (merchantConfig == null || !merchantConfig.IsLimited);
	}

	private void DisplayDialog()
	{
		SelectionCategoryConfig currentCategoryConfig = selectableManager.GetCurrentCategoryConfig();
		if (!currentCategoryConfig.EnableNonContextualControl || !base.NetSyncElement.IsOwnedByLocalPlayer())
		{
			return;
		}
		IGameCameraService service = Services.GetService<IGameCameraService>();
		if (!service.IsTacticalMapActive() && !service.IsSwitchingCamera)
		{
			service.Focus(base.transform.position, LerpType.Smoothed, -1f);
			if (Services.GetService<IInputService>().CurrentControlScheme != ControlScheme.XBoxOneController)
			{
				service.ZoomIn();
			}
		}
		SingletonManager.Get<DialogPanel>().Display(AgeLocalizer.Instance.LocalizeString(merchantConfig.IntroDialogs.GetRandom().Text), base.transform, Vector2.zero, base.RoomElement.ParentRoom.CenterPosition, introDialogDuration);
		audioEventService.Play2DEvent("Master/Jingles/Merchant");
		base.RoomElement.ParentRoom.SelectableForMove.Select(silent: true);
	}

	private void MerchantPanel_OnHidePanel()
	{
		MainGameScreen mainGameScreen = SingletonManager.Get<MainGameScreen>();
		MerchantPanel merchantPanel = mainGameScreen.MerchantPanel;
		merchantPanel.OnHidePanel = (MerchantPanel.OnHidePanelHandler)Delegate.Remove(merchantPanel.OnHidePanel, new MerchantPanel.OnHidePanelHandler(MerchantPanel_OnHidePanel));
		for (int i = 0; i < base.InteractionInstigators.Count; i++)
		{
			Hero hero = base.InteractionInstigators[i];
			if (hero.IsInteracting && spriteAnim != null && spriteAnim.Animator != null)
			{
				spriteAnim.Trigger(SpriteAnimationTrigger.OnInteractionEnd);
			}
			hero.EndNPCInteraction();
		}
	}

	private void OnRightClickDown(ClickDownInfo clickInfo)
	{
		if (Hero.SelectedHeroes.Count > 0)
		{
			foreach (Hero selectedHero in Hero.SelectedHeroes)
			{
				if (selectedHero.HasCrystal)
				{
					selectedHero.MoveToRoom(base.RoomElement.ParentRoom);
				}
				else
				{
					selectedHero.MoveToNPC(this);
				}
			}
			Services.GetService<IInputService>().StopClickEventPropagation();
		}
	}

	private void OnLinkedModuleDeath(ulong attackerOwnerPlayerID = 0)
	{
		linkedModule = null;
		if (MajorModule.UnlinkedShopModules.Count > 0)
		{
			StartTeleport(MajorModule.UnlinkedShopModules[0].RoomElement.ParentRoom);
		}
	}

	private void RPC_RequestBuyItemFromMerchantPanel(StaticString itemUniqueIDCategory, int itemUniqueID, ulong buyerID)
	{
		if (!gameNetManager.IsServerOrSinglePlayer())
		{
			Diagnostics.LogError(base.name + " > NPCMerchant.RPC_RequestBuyItemFromMerchantPanel should only be called on server side!");
			return;
		}
		InventoryItem item = InventoryItem.GetItem(itemUniqueIDCategory, itemUniqueID);
		if (item != null && dungeon.RequestBuyItem(item))
		{
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.NPCMerchant_DoBuyItemFromMerchantPanel, itemUniqueIDCategory, itemUniqueID, buyerID);
		}
	}

	private void RPC_DoBuyItemFromMerchantPanel(StaticString itemUniqueIDCategory, int itemUniqueID, ulong buyerID)
	{
		InventoryItem item = InventoryItem.GetItem(itemUniqueIDCategory, itemUniqueID);
		if (item == null)
		{
			return;
		}
		FIDS currency = CurrencyCfg.Currency;
		bool flag = buyerID == gameNetManager.GetLocalPlayerID();
		if (gameNetManager.IsMultiplayerSession() && ((currency == FIDS.Dust && !MultiplayerConfig.SplitDust) || (currency != FIDS.Dust && !MultiplayerConfig.SplitFIS)))
		{
			flag = false;
		}
		if (flag && !Player.LocalPlayer.ConsumeFIDS(item.GetCostForCurrency(currency), currency))
		{
			Diagnostics.LogError("NPCMerchant.RPC_DoBuyItemFromMerchantPanel: not enough resources!");
			return;
		}
		if (flag && item.IsGift)
		{
			ItemHero.SendItemAcquisitionNotification(new ItemHeroElement(item));
			audioEventService.Play2DEvent("Master/GUI/DeathMerchant_Buy");
		}
		bool flag2 = true;
		item.MoveToInventory((!flag2) ? null : dungeon.GetBestAvailableInventoryForPlayer(buyerID));
		item.OwnerPlayerID = buyerID;
		MerchantPanel merchantPanel = SingletonManager.Get<MainGameScreen>().MerchantPanel;
		merchantPanel.OnCurrentItemBought();
	}

	private void RPC_RequestSellItemFromMerchantPanel(StaticString itemUniqueIDCategory, int itemUniqueID, ulong sellerID)
	{
		if (!gameNetManager.IsServer())
		{
			Diagnostics.LogError(base.name + " > NPCMerchant.RPC_RequestSellItemFromMerchantPanel should only be called on server side!");
			return;
		}
		InventoryItem item = InventoryItem.GetItem(itemUniqueIDCategory, itemUniqueID);
		if (item != null && dungeon.RequestSellItem(item, CurrencyCfg.Currency))
		{
			base.NetSyncElement.SendRPCToAll(UniqueIDRPC.NPCMerchant_DoSellItemFromMerchantPanel, itemUniqueIDCategory, itemUniqueID, sellerID);
		}
	}

	private void RPC_DoSellItemFromMerchantPanel(StaticString itemUniqueIDCategory, int itemUniqueID, ulong sellerID)
	{
		InventoryItem item = InventoryItem.GetItem(itemUniqueIDCategory, itemUniqueID);
		if (item != null)
		{
			FIDS currency = CurrencyCfg.Currency;
			bool flag = false;
			if (gameNetManager.IsMultiplayerSession() && ((currency == FIDS.Dust && MultiplayerConfig.SplitDust) || (currency != FIDS.Dust && MultiplayerConfig.SplitFIS)))
			{
				flag = (sellerID == gameNetManager.GetLocalPlayerID());
			}
			if (flag && !Player.LocalPlayer.ConsumeFIDS(0f - item.GetSellingCostForCurrency(currency), currency))
			{
				Diagnostics.LogError("NPCMerchant.RPC_DoBuyItemFromMerchantPanel: not enough resources!");
				return;
			}
			item.MoveToInventory(CurrentInventory);
			MerchantPanel merchantPanel = SingletonManager.Get<MainGameScreen>().MerchantPanel;
			merchantPanel.OnCurrentItemSold();
		}
	}
}
public class Player : MonoBehaviour
{
	private struct FIDSAddedData
	{
		public float Amount;

		public bool DisplayFeedback;

		public bool TriggerDungeonFIDSChangedEvent;

		public bool CheckPlayerIsLocal;

		public bool IsAutoTransfert;
	}

	private FIDSAddedData[] currentFIDSAddedData = new FIDSAddedData[4];

	private Dictionary<FIDS, ulong> fidsAutoTransferPlayerIDs = new Dictionary<FIDS, ulong>();

	private ulong playerID;

	private GameNetworkManager gameNetManager;

	private IGameEventService gameEventManager;

	private Dungeon dungeon;

	private static Dictionary<ulong, Player> playersByPlayerID = new Dictionary<ulong, Player>();

	private static List<ulong> playerIDs = new List<ulong>();

	public float FoodStock
	{
		get;
		private set;
	}

	public float IndustryStock
	{
		get;
		private set;
	}

	public float ScienceStock
	{
		get;
		private set;
	}

	public Dictionary<FIDS, ulong> FIDSAutoTransferPlayerIDs => fidsAutoTransferPlayerIDs;

	public UniqueIDNetSyncElement NetSyncElement
	{
		get;
		private set;
	}

	public bool IsDungeonCreated
	{
		get;
		private set;
	}

	public bool IsDungeonPreFilled
	{
		get;
		private set;
	}

	public bool IsDungeonFilled
	{
		get;
		private set;
	}

	public static Player LocalPlayer
	{
		get;
		private set;
	}

	public static Player ServerPlayer
	{
		get;
		private set;
	}

	public void AddFIDS(float amount, FIDS type, bool displayFeedback = true, bool triggerDungeonFIDSChangedEvent = true, bool checkPlayerIsLocal = true, bool isAutoTransfert = false)
	{
		currentFIDSAddedData[(int)type].Amount += amount;
		currentFIDSAddedData[(int)type].DisplayFeedback |= displayFeedback;
		currentFIDSAddedData[(int)type].TriggerDungeonFIDSChangedEvent |= triggerDungeonFIDSChangedEvent;
		currentFIDSAddedData[(int)type].CheckPlayerIsLocal |= checkPlayerIsLocal;
		currentFIDSAddedData[(int)type].IsAutoTransfert |= isAutoTransfert;
	}

	public void AddFood(float foodAmount, bool displayFeedback = true, bool triggerDungeonFIDSChangedEvent = true, bool checkPlayerIsLocal = true, bool isAutoTransfert = false)
	{
		if (checkPlayerIsLocal && !NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError("Player.AddFood should only be accessed on local player!");
		}
		else if (foodAmount != 0f)
		{
			NetSyncElement.SendRPCToAll(UniqueIDRPC.Player_DoAddFood, foodAmount, displayFeedback, triggerDungeonFIDSChangedEvent, isAutoTransfert);
		}
	}

	private void RPC_DoAddFood(float foodAmount, bool displayFeedback = true, bool triggerDungeonFIDSChangedEvent = true, bool isAutoTransfert = false)
	{
		if (!NetSyncElement.IsOwnedByLocalPlayer())
		{
			displayFeedback = false;
			triggerDungeonFIDSChangedEvent = false;
		}
		DoAddFood(foodAmount, displayFeedback, triggerDungeonFIDSChangedEvent, isAutoTransfert);
	}

	private void DoAddFood(float foodAmount, bool displayFeedback = true, bool triggerDungeonFIDSChangedEvent = true, bool isAutoTransfert = false)
	{
		FoodStock += foodAmount;
		if (displayFeedback)
		{
			SingletonManager.Get<MainGameScreen>().AddFIDSFeedback(foodAmount, FIDS.Food);
		}
		if (triggerDungeonFIDSChangedEvent)
		{
			gameEventManager.TriggerDungeonFIDSChangedEvent();
		}
		gameEventManager.TriggerHeroListChangedEvent();
		if (foodAmount > 0f && NetSyncElement.IsOwnedByLocalPlayer())
		{
			dungeon.Statistics.IncrementStat(DungeonStatistics.Stat_GatheredFIS, foodAmount);
			CheckTotalFISAchievement();
			if (!isAutoTransfert && fidsAutoTransferPlayerIDs.ContainsKey(FIDS.Food))
			{
				SendFIDSToPlayer(foodAmount, FIDS.Food, fidsAutoTransferPlayerIDs[FIDS.Food], isAutoTransfert: true);
			}
		}
	}

	private void CheckTotalFISAchievement()
	{
		int num = Mathf.FloorToInt(FoodStock + IndustryStock + ScienceStock);
		SingletonManager.Get<AchievementManagerDOTE>().SetStatisticValue(StatisticName.FIS_STOCK, num);
	}

	public void AddIndustry(float industryAmount, bool displayFeedback = true, bool triggerDungeonFIDSChangedEvent = true, bool checkPlayerIsLocal = true, bool isAutoTransfert = false)
	{
		if (checkPlayerIsLocal && !NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError("Player.AddIndustry should only be accessed on local player!");
		}
		else if (industryAmount != 0f)
		{
			NetSyncElement.SendRPCToAll(UniqueIDRPC.Player_DoAddIndustry, industryAmount, displayFeedback, triggerDungeonFIDSChangedEvent, isAutoTransfert);
		}
	}

	private void RPC_DoAddIndustry(float industryAmount, bool displayFeedback = true, bool triggerDungeonFIDSChangedEvent = true, bool isAutoTransfert = false)
	{
		if (!NetSyncElement.IsOwnedByLocalPlayer())
		{
			displayFeedback = false;
			triggerDungeonFIDSChangedEvent = false;
		}
		DoAddIndustry(industryAmount, displayFeedback, triggerDungeonFIDSChangedEvent, isAutoTransfert);
	}

	private void DoAddIndustry(float industryAmount, bool displayFeedback = true, bool triggerDungeonFIDSChangedEvent = true, bool isAutoTransfert = false)
	{
		IndustryStock += industryAmount;
		if (displayFeedback)
		{
			SingletonManager.Get<MainGameScreen>().AddFIDSFeedback(industryAmount, FIDS.Industry);
		}
		if (triggerDungeonFIDSChangedEvent)
		{
			gameEventManager.TriggerDungeonFIDSChangedEvent();
		}
		if (industryAmount > 0f && NetSyncElement.IsOwnedByLocalPlayer())
		{
			dungeon.Statistics.IncrementStat(DungeonStatistics.Stat_GatheredFIS, industryAmount);
			CheckTotalFISAchievement();
			if (!isAutoTransfert && fidsAutoTransferPlayerIDs.ContainsKey(FIDS.Industry))
			{
				SendFIDSToPlayer(industryAmount, FIDS.Industry, fidsAutoTransferPlayerIDs[FIDS.Industry], isAutoTransfert: true);
			}
		}
	}

	public void AddScience(float scienceAmount, bool displayFeedback = true, bool triggerDungeonFIDSChangedEvent = true, bool checkPlayerIsLocal = true, bool isAutoTransfert = false)
	{
		if (checkPlayerIsLocal && !NetSyncElement.IsOwnedByLocalPlayer())
		{
			Diagnostics.LogError("Player.AddScience should only be accessed on local player!");
		}
		else if (scienceAmount != 0f)
		{
			NetSyncElement.SendRPCToAll(UniqueIDRPC.Player_DoAddScience, scienceAmount, displayFeedback, triggerDungeonFIDSChangedEvent, isAutoTransfert);
		}
	}

	private void RPC_DoAddScience(float scienceAmount, bool displayFeedback = true, bool triggerDungeonFIDSChangedEvent = true, bool isAutoTransfert = false)
	{
		if (!NetSyncElement.IsOwnedByLocalPlayer())
		{
			displayFeedback = false;
			triggerDungeonFIDSChangedEvent = false;
		}
		DoAddScience(scienceAmount, displayFeedback, triggerDungeonFIDSChangedEvent, isAutoTransfert);
	}

	private void DoAddScience(float scienceAmount, bool displayFeedback = true, bool triggerDungeonFIDSChangedEvent = true, bool isAutoTransfert = false)
	{
		ScienceStock += scienceAmount;
		if (displayFeedback)
		{
			SingletonManager.Get<MainGameScreen>().AddFIDSFeedback(scienceAmount, FIDS.Science);
		}
		if (triggerDungeonFIDSChangedEvent)
		{
			gameEventManager.TriggerDungeonFIDSChangedEvent();
		}
		if (scienceAmount > 0f && NetSyncElement.IsOwnedByLocalPlayer())
		{
			dungeon.Statistics.IncrementStat(DungeonStatistics.Stat_GatheredFIS, scienceAmount);
			CheckTotalFISAchievement();
			if (!isAutoTransfert && fidsAutoTransferPlayerIDs.ContainsKey(FIDS.Science))
			{
				SendFIDSToPlayer(scienceAmount, FIDS.Science, fidsAutoTransferPlayerIDs[FIDS.Science], isAutoTransfert: true);
			}
		}
	}

	public bool ConsumeIndustry(float industryCost)
	{
		if (industryCost == 0f)
		{
			return true;
		}
		if (industryCost > 0f && IndustryStock < industryCost)
		{
			return false;
		}
		AddIndustry(0f - industryCost);
		return true;
	}

	public bool ConsumeFood(float foodCost)
	{
		if (foodCost == 0f)
		{
			return true;
		}
		if (foodCost > 0f && FoodStock < foodCost)
		{
			return false;
		}
		AddFood(0f - foodCost);
		return true;
	}

	public bool ConsumeScience(float scienceCost)
	{
		if (scienceCost == 0f)
		{
			return true;
		}
		if (scienceCost > 0f && ScienceStock < scienceCost)
		{
			return false;
		}
		AddScience(0f - scienceCost);
		return true;
	}

	public bool ConsumeFIDS(float cost, FIDS type)
	{
		switch (type)
		{
		case FIDS.Dust:
			return dungeon.ConsumeDust(cost);
		case FIDS.Food:
			return ConsumeFood(cost);
		case FIDS.Industry:
			return ConsumeIndustry(cost);
		case FIDS.Science:
			return ConsumeScience(cost);
		default:
			Diagnostics.LogError("Player.ConsumeFIDS: Invalid FIDS type: {0}", type);
			return false;
		}
	}

	public bool CanConsumeFIDS(float amount, FIDS type)
	{
		switch (type)
		{
		case FIDS.Dust:
			return dungeon.CanConsumeDust(amount);
		case FIDS.Food:
			return amount <= FoodStock;
		case FIDS.Industry:
			return amount <= IndustryStock;
		case FIDS.Science:
			return amount <= ScienceStock;
		default:
			Diagnostics.LogError("Player.CanConsumeFIDS: Invalid FIDS type: {0}", type);
			return false;
		}
	}

	public void SendFIDSToPlayer(float amount, FIDS fidsType, ulong playerID, bool isAutoTransfert = false)
	{
		if (!gameNetManager.IsMultiplayerSession())
		{
			Diagnostics.LogError("Player.SendFIDSToPlayer is only usable in multiplayer!");
			return;
		}
		ulong[] lobbyPlayerIDs = gameNetManager.GetLobbyPlayerIDs();
		bool flag = false;
		for (int i = 0; i < lobbyPlayerIDs.Length; i++)
		{
			if (lobbyPlayerIDs[i] == playerID)
			{
				flag = true;
			}
		}
		if (!flag)
		{
			Diagnostics.LogError("Dungeon.SendFIDSToPlayer: player not in current multiplayer session!");
		}
		else if (!ConsumeFIDS(amount, fidsType))
		{
			Diagnostics.LogError("Dungeon.SendFIDSToPlayer: not enough resources!");
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_SendFIDSToPlayerFailResources"));
		}
		else
		{
			Player playerByID = GetPlayerByID(playerID);
			playerByID.AddFIDS(amount, fidsType, displayFeedback: true, triggerDungeonFIDSChangedEvent: true, checkPlayerIsLocal: false, isAutoTransfert);
		}
	}

	public void ToggleFIDSAutoTransferPlayerID(FIDS fidsType, ulong playerID)
	{
		bool flag = false;
		if (!fidsAutoTransferPlayerIDs.ContainsKey(fidsType))
		{
			fidsAutoTransferPlayerIDs.Add(fidsType, playerID);
			flag = true;
		}
		else if (fidsAutoTransferPlayerIDs[fidsType] == playerID)
		{
			fidsAutoTransferPlayerIDs.Remove(fidsType);
		}
		else
		{
			fidsAutoTransferPlayerIDs[fidsType] = playerID;
			flag = true;
		}
		if (flag)
		{
			float amount = 0f;
			switch (fidsType)
			{
			case FIDS.Industry:
				amount = IndustryStock;
				break;
			case FIDS.Food:
				amount = FoodStock;
				break;
			case FIDS.Science:
				amount = ScienceStock;
				break;
			}
			SendFIDSToPlayer(amount, fidsType, playerID, isAutoTransfert: true);
		}
		SingletonManager.Get<PlayerListPanel>().RefreshContent();
	}

	protected virtual void Update()
	{
		for (int i = 0; i < currentFIDSAddedData.Length; i++)
		{
			float amount = currentFIDSAddedData[i].Amount;
			if (amount != 0f)
			{
				bool displayFeedback = currentFIDSAddedData[i].DisplayFeedback;
				bool triggerDungeonFIDSChangedEvent = currentFIDSAddedData[i].TriggerDungeonFIDSChangedEvent;
				bool checkPlayerIsLocal = currentFIDSAddedData[i].CheckPlayerIsLocal;
				bool isAutoTransfert = currentFIDSAddedData[i].IsAutoTransfert;
				switch (i)
				{
				case 0:
					AddFood(amount, displayFeedback, triggerDungeonFIDSChangedEvent, checkPlayerIsLocal, isAutoTransfert);
					break;
				case 1:
					AddIndustry(amount, displayFeedback, triggerDungeonFIDSChangedEvent, checkPlayerIsLocal, isAutoTransfert);
					break;
				case 3:
					AddScience(amount, displayFeedback, triggerDungeonFIDSChangedEvent, checkPlayerIsLocal, isAutoTransfert);
					break;
				default:
					Diagnostics.LogError("Player.AddFIDS: Invalid FIDS type: {0}", (FIDS)i);
					break;
				}
			}
		}
		currentFIDSAddedData = new FIDSAddedData[4];
	}

	private void Awake()
	{
		NetSyncElement = GetComponent<UniqueIDNetSyncElement>();
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
		gameEventManager = Services.GetService<IGameEventService>();
		dungeon = SingletonManager.Get<Dungeon>();
	}

	public void Init(ulong playerID)
	{
		Diagnostics.Log("Init player #{0}", playerID);
		this.playerID = playerID;
		NetSyncElement.SetOwner(playerID);
		base.name = "Player#" + playerID;
		playersByPlayerID.Add(playerID, this);
		playerIDs.Add(playerID);
		if (NetSyncElement.IsOwnedByLocalPlayer())
		{
			LocalPlayer = this;
			base.name += "[local]";
		}
		if (NetSyncElement.IsOwnedByServerPlayer())
		{
			ServerPlayer = this;
			base.name += "[server]";
		}
	}

	public bool IsStillConnected()
	{
		ulong[] lobbyPlayerIDs = gameNetManager.GetLobbyPlayerIDs();
		for (int i = 0; i < lobbyPlayerIDs.Length; i++)
		{
			if (lobbyPlayerIDs[i] == playerID)
			{
				return true;
			}
		}
		return false;
	}

	private void RPC_DungeonCreated()
	{
		IsDungeonCreated = true;
	}

	private void RPC_DungeonPreFilled()
	{
		IsDungeonPreFilled = true;
	}

	private void RPC_DungeonFilled()
	{
		IsDungeonFilled = true;
	}

	private void OnDestroy()
	{
		Diagnostics.Log("OnDestroy player #{0}", playerID);
		playersByPlayerID.Remove(playerID);
		playerIDs.Remove(playerID);
	}

	public static Player GetPlayerByID(ulong playerID, bool reportError = true)
	{
		if (!playersByPlayerID.ContainsKey(playerID))
		{
			if (reportError)
			{
				Diagnostics.LogError("Unable to find #{0} player!", playerID);
			}
			return null;
		}
		return playersByPlayerID[playerID];
	}

	public static ulong[] GetPlayerIDs()
	{
		return playerIDs.ToArray();
	}

	public static bool AreAllPlayersDungeonCreated()
	{
		GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
		ulong[] lobbyPlayerIDs = gameNetworkManager.GetLobbyPlayerIDs();
		foreach (ulong num in lobbyPlayerIDs)
		{
			Player playerByID = GetPlayerByID(num);
			if (playerByID == null)
			{
				Diagnostics.LogWarning("Player.AreAllPlayersDungeonCreated: Unable to find #{0} player", num);
				return false;
			}
			if (!playerByID.IsDungeonCreated)
			{
				return false;
			}
		}
		return true;
	}

	public static bool AreAllPlayersDungeonPreFilled()
	{
		GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
		ulong[] lobbyPlayerIDs = gameNetworkManager.GetLobbyPlayerIDs();
		foreach (ulong num in lobbyPlayerIDs)
		{
			Player playerByID = GetPlayerByID(num);
			if (playerByID == null)
			{
				Diagnostics.LogWarning("Player.AreAllPlayersDungeonPreFilled: Unable to find #{0} player", num);
				return false;
			}
			if (!playerByID.IsDungeonPreFilled)
			{
				return false;
			}
		}
		Diagnostics.Log("{0} players dungeon created", lobbyPlayerIDs.Length);
		return true;
	}

	public static bool AreAllPlayersDungeonFilled()
	{
		GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
		ulong[] lobbyPlayerIDs = gameNetworkManager.GetLobbyPlayerIDs();
		foreach (ulong num in lobbyPlayerIDs)
		{
			Player playerByID = GetPlayerByID(num);
			if (playerByID == null)
			{
				Diagnostics.LogWarning("Player.AreAllPlayersDungeonFilled: Unable to find #{0} player", num);
				return false;
			}
			if (!playerByID.IsDungeonFilled)
			{
				return false;
			}
		}
		Diagnostics.Log("{0} players dungeon created", lobbyPlayerIDs.Length);
		return true;
	}
}
public class Room : SimMonoBehaviour
{
	private struct RoomMarker
	{
		public OffscreenMarker Marker;

		public int Priority;

		public AnimationClip Anim;

		public bool AlwaysVisible;
	}

	public delegate void RoomPowerChangedEventHandler(bool powered);

	public delegate void RoomChangedEventHandler();

	public delegate void EntityEnteredEventHandler(SimMonoBehaviour entity);

	public delegate void EntityExitedEventHandler(SimMonoBehaviour entity);

	public delegate void HeroEnteredOrExitedExitRoomEventHandler(Hero hero, bool enter);

	private static List<int> cleanedFromModuleSlotIDs = new List<int>();

	[SerializeField]
	private GameObject majorModulePfb;

	[SerializeField]
	private GameObject crystalPfb;

	[SerializeField]
	private GameObject artifactPfb;

	[SerializeField]
	private GameObject stelePfb;

	[SerializeField]
	private GameObject dustFactoryPfb;

	[SerializeField]
	private GameObject cryoCapsulePfb;

	[SerializeField]
	private GameObject minorModulePfb;

	[SerializeField]
	private GameObject crystalModuleSlotPfb;

	[SerializeField]
	private GameObject powerVFXPfb;

	[SerializeField]
	private GameObject powerAlternativeVFXPfb;

	[SerializeField]
	private GameObject autoPowerVFXPfb;

	[SerializeField]
	private float unpowerMinDelay;

	[SerializeField]
	private float unpowerMaxDelay;

	private List<RoomPowerVFX> powerVFXs = new List<RoomPowerVFX>();

	private ParticleSystem[] autoPowerVFXs;

	private ulong delayedUnpowerPlayerID;

	private readonly StaticString poweredPropsTag = "PropsPoweredRoom";

	[SerializeField]
	private bool needLights = true;

	[SerializeField]
	private GameObject vfxZonePfb;

	[SerializeField]
	private GameObject fogOfWarVFXPfb;

	[SerializeField]
	private GameObject toxicCloudVFXPfb;

	[SerializeField]
	private OffscreenMarker.OffscreenMarkerData waveIconData;

	[SerializeField]
	private RoomTacticalMapElement tacticalMapElement;

	[SerializeField]
	private Transform[] testProps;

	private Door selectedDoor;

	private int wallsTileSetVariance = -1;

	private Dungeon dungeon;

	private AudioEmitter audioEmitter;

	private IGameEventService gameEventManager;

	private DirtyLight[] dirtyLights;

	private List<CleanLight> cleanLights;

	private LowLight[] lowLights;

	private List<Door> doors;

	private FloorTile[] floorTiles;

	private VFXZone[] vfxZones;

	private GameNetworkManager gameNetManager;

	private ParticleSystem[] fogOfWarVFXs;

	private ParticleSystem[] toxicCloudVFXs;

	private SpriteAnimationRuntime2[] powerableProps;

	private AITarget aiTarget;

	private List<RoomMarker> notificationMarkersPriorities;

	private UniqueIDNetSyncElement netSyncElement;

	private bool updateMarkersVisibility;

	private RoomForMoveSelectable selectableForMove;

	private RoomForBuildSelectable selectableForBuild;

	private bool needSimRefreshOnLateUpdate;

	private bool isRequestingModuleBuild;

	private Vector3 openDoorPosition;

	private Room _previousRoom;

	private RoomDetector _roomDetector;

	public static List<int> CleanedFromModuleSlotsIDs => cleanedFromModuleSlotIDs;

	public MajorModuleSlot MajorModuleSlot
	{
		get;
		private set;
	}

	public List<CrystalModuleSlot> CrystalModuleSlots
	{
		get;
		private set;
	}

	public List<MinorModuleSlot> MinorModuleSlots
	{
		get;
		private set;
	}

	public MajorModule MajorModule
	{
		get;
		private set;
	}

	public List<MinorModule> MinorModules
	{
		get;
		private set;
	}

	public bool IsExitRoom
	{
		get;
		private set;
	}

	public bool IsPowered
	{
		get;
		private set;
	}

	public bool IsUnpoweringWithDelay
	{
		get;
		private set;
	}

	public bool IsAutoPowered
	{
		get;
		private set;
	}

	public bool IsAutoPoweredByEvent
	{
		get;
		private set;
	}

	public bool SuffersEMP
	{
		get;
		private set;
	}

	public ulong LastPowerChangePlayerID
	{
		get;
		private set;
	}

	public float LastPowerChangeTime
	{
		get;
		private set;
	}

	public int EmpTurnsRemaining
	{
		get;
		private set;
	}

	public Vector3 Size
	{
		get;
		private set;
	}

	public List<Room> AdjacentRooms
	{
		get;
		set;
	}

	public List<CleanLight> CleanLights => cleanLights;

	public bool IsVisible
	{
		get;
		private set;
	}

	public bool IsFullyOpened
	{
		get;
		private set;
	}

	public bool WasAlreadyOpen
	{
		get;
		private set;
	}

	public int Depth
	{
		get;
		set;
	}

	public bool IsStartRoom
	{
		get;
		set;
	}

	public List<Mob> Mobs
	{
		get;
		private set;
	}

	public List<Hero> Heroes
	{
		get;
		private set;
	}

	public List<NPC> NPCs
	{
		get;
		private set;
	}

	public bool NeedLights => needLights;

	public int OpeningIndex
	{
		get;
		set;
	}

	public Vector3 CenterPosition
	{
		get;
		private set;
	}

	public float FloorSurface
	{
		get;
		private set;
	}

	public AITarget AITarget => aiTarget;

	public int DustLootAmount
	{
		get;
		private set;
	}

	public RoomEvent StaticRoomEvent
	{
		get;
		set;
	}

	public bool ForbidDungeonEvent
	{
		get;
		set;
	}

	public int ModulesCount => MinorModules.Count + (HasNormalMajorModule ? 1 : 0);

	public bool HasNormalMajorModule => MajorModule != null && !MajorModule.IsCrystal && !(MajorModule is Artifact) && !(MajorModule is Stele);

	public RoomForMoveSelectable SelectableForMove => selectableForMove;

	public RoomForBuildSelectable SelectableForBuild => selectableForBuild;

	public event RoomPowerChangedEventHandler OnRoomPowerChanged;

	public event EntityEnteredEventHandler OnEntityEntered;

	public event EntityExitedEventHandler OnEntityExited;

	public event RoomChangedEventHandler OnRoomContentChanged;

	public event Action<Mob> OnMobDied;

	public static event HeroEnteredOrExitedExitRoomEventHandler OnHeroEnteredOrExitedExitRoom;

	public CrystalModuleSlot GetFreeCrystalModuleSlot(bool isExitSlot = false)
	{
		for (int i = 0; i < CrystalModuleSlots.Count; i++)
		{
			if (CrystalModuleSlots[i].PluggedModule == null && (!isExitSlot || CrystalModuleSlots[i].IsExitSlot))
			{
				return CrystalModuleSlots[i];
			}
		}
		return null;
	}

	public void AddCrystalSlot(bool isExitSlot = false)
	{
		netSyncElement.SendRPCToAll(UniqueIDRPC.Room_DoAddCrystalSlot, gameNetManager.GetLocalPlayerID(), isExitSlot);
	}

	private void RPC_DoAddCrystalSlot(ulong ownerPlayerID, bool isExitSlot)
	{
		DoAddCrystalSlot(ownerPlayerID, isExitSlot);
	}

	public void DoAddCrystalSlot(ulong ownerPlayerID, bool isExitSlot)
	{
		Vector3 position = CenterPosition;
		if (MajorModuleSlot != null)
		{
			position = MajorModuleSlot.transform.position;
		}
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(crystalModuleSlotPfb, position, Quaternion.identity);
		dungeon.AddDynamicElementForScaling(gameObject.transform);
		CrystalModuleSlot component = gameObject.GetComponent<CrystalModuleSlot>();
		component.Init(ownerPlayerID, this, isExitSlot);
		CrystalModuleSlots.Add(component);
		if (isExitSlot)
		{
			IsExitRoom = true;
			dungeon.ExitRoom = this;
		}
		AstarPath.active.UpdateGraphs(gameObject.GetComponent<Collider>().bounds);
		if (MajorModuleSlot != null)
		{
			UnityEngine.Object.Destroy(MajorModuleSlot.gameObject);
		}
	}

	public void BuildCrystal(bool instantBuild = false)
	{
		ulong localPlayerID = gameNetManager.GetLocalPlayerID();
		BuildModule(SimulationProperties.SpecialModule_Crystal, localPlayerID, instantBuild, restoration: false, checkRoomPower: true, consumeIndustry: true, -1f);
	}

	public void BuildSpecialModule(StaticString bpName)
	{
		ulong localPlayerID = gameNetManager.GetLocalPlayerID();
		BuildModule(bpName, localPlayerID, instantBuild: true, restoration: false, checkRoomPower: true, consumeIndustry: true, -1f);
	}

	public void BuildModule(StaticString bpName, ulong builderPlayerID, bool instantBuild = false, bool restoration = false, bool checkRoomPower = true, bool consumeIndustry = true, float health = -1f)
	{
		BuildModuleAtPosition(bpName, CenterPosition, builderPlayerID, instantBuild, restoration, checkRoomPower, consumeIndustry, health);
	}

	public void BuildModuleAtPosition(StaticString bpName, Vector3 worldPos, ulong builderPlayerID, bool instantBuild = false, bool restoration = false, bool checkRoomPower = true, bool consumeIndustry = true, float health = -1f)
	{
		if (isRequestingModuleBuild)
		{
			Diagnostics.Log("Already requesting a module build to server, waiting for response...");
			return;
		}
		BluePrintConfig value = Databases.GetDatabase<BluePrintConfig>().GetValue(bpName);
		if (value.ModuleCategory == ModuleCategory.MajorModule || value.ModuleCategory == ModuleCategory.SpecialModule)
		{
			if (!CanBuildMajorModule(value, consumeIndustry))
			{
				Diagnostics.Log("Room.BuildModuleAtPosition: cannot build major module!");
				IAudioEventService service = Services.GetService<IAudioEventService>();
				service.Play2DEvent("Master/GUI/ErrorActionMenu");
				return;
			}
		}
		else if (!CanBuildMinorModule(value, consumeIndustry))
		{
			Diagnostics.Log("Room.BuildModuleAtPosition: cannot build minor module!");
			IAudioEventService service2 = Services.GetService<IAudioEventService>();
			service2.Play2DEvent("Master/GUI/ErrorActionMenu");
			return;
		}
		bool flag = consumeIndustry;
		bool flag2 = false;
		if (consumeIndustry && gameNetManager.IsMultiplayerSession() && MultiplayerConfig.SplitFIS)
		{
			flag = false;
			flag2 = true;
		}
		isRequestingModuleBuild = !gameNetManager.IsServerOrSinglePlayer();
		netSyncElement.SendRPCToServer(UniqueIDRPC.Room_RequestBuildModuleAtPosition, bpName, (Int2Position)worldPos, instantBuild, restoration, checkRoomPower, flag, flag2, builderPlayerID, health, isRequestingModuleBuild);
	}

	private void RPC_RequestBuildModuleAtPosition(StaticString bpName, Int2Position worldPos, bool instantBuild, bool restoration, bool checkRoomPower, bool consumeIndustryOnServer, bool consumeIndustryOnBuyer, ulong buyerPlayerID, float health, bool sendRequestResponseToBuyer)
	{
		if (!gameNetManager.IsServerOrSinglePlayer())
		{
			Diagnostics.LogError("Room.RPC_RequestBuildModuleAtPosition should only be called on server!");
			return;
		}
		BluePrintConfig value = Databases.GetDatabase<BluePrintConfig>().GetValue(bpName);
		if (value.ModuleCategory == ModuleCategory.SpecialModule || value.ModuleCategory == ModuleCategory.MajorModule)
		{
			RequestBuildMajorModule(value, checkRoomPower, consumeIndustryOnServer, consumeIndustryOnBuyer, instantBuild, restoration, buyerPlayerID, health);
		}
		else
		{
			RequestBuildMinorModule(value, (Vector3)worldPos, checkRoomPower, consumeIndustryOnServer, consumeIndustryOnBuyer, instantBuild, restoration, buyerPlayerID, health);
		}
		if (sendRequestResponseToBuyer)
		{
			netSyncElement.SendRPCToPlayer(buyerPlayerID, UniqueIDRPC.Room_ModuleBuildRequestResponse);
		}
	}

	private void RPC_ModuleBuildRequestResponse()
	{
		if (!isRequestingModuleBuild)
		{
			Diagnostics.LogError("{0} > Room.RPC_ModuleBuildRequestResponse: shouldn't be received while no request is pending!");
		}
		else
		{
			isRequestingModuleBuild = false;
		}
	}

	public void OnMajorModuleLevelUp()
	{
		if (this.OnRoomContentChanged != null)
		{
			this.OnRoomContentChanged();
		}
	}

	public void DestroyAllModuleSlots()
	{
		foreach (MinorModuleSlot minorModuleSlot in MinorModuleSlots)
		{
			if (minorModuleSlot.PluggedModule != null)
			{
				minorModuleSlot.PluggedModule.DoRemove(checkOwnership: false);
			}
		}
		if (MajorModuleSlot != null && MajorModuleSlot.PluggedModule != null)
		{
			MajorModuleSlot.PluggedModule.DoRemove(checkOwnership: false);
		}
		netSyncElement.SendRPCToAll(UniqueIDRPC.Room_ClearAllModuleSlotsRefs);
	}

	private void RPC_ClearAllModuleSlotsRefs()
	{
		cleanedFromModuleSlotIDs.Add(base.UniqueID.ID);
		foreach (MinorModuleSlot minorModuleSlot in MinorModuleSlots)
		{
			UnityEngine.Object.Destroy(minorModuleSlot.gameObject);
		}
		MinorModuleSlots.Clear();
		if (MajorModuleSlot != null)
		{
			UnityEngine.Object.Destroy(MajorModuleSlot.gameObject);
		}
		MajorModuleSlot = null;
	}

	private bool CanBuildMajorModule(BluePrintConfig bpConfig, bool checkIndustryStock = true, bool displayErrors = true, bool checkIsFullyOpened = true)
	{
		if (checkIsFullyOpened && !IsFullyOpened)
		{
			Diagnostics.Log("{0} > Room.CanBuildMajorModule: room not fully opened!", base.name);
			return false;
		}
		if ((MajorModuleSlot == null || !MajorModuleSlot.IsAvailable) && bpConfig.ModuleName != SimulationProperties.SpecialModule_Crystal)
		{
			Diagnostics.Log("{0} > Room.CanBuildMajorModule: no available major module slot! ({1})", base.name, MajorModuleSlot);
			if (displayErrors)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_MajorModuleBuildFailNoSlot"));
			}
			return false;
		}
		ModuleConfig value = Databases.GetDatabase<ModuleConfig>().GetValue(bpConfig.ModuleName);
		float industryCost = value.GetIndustryCost();
		if (checkIndustryStock && industryCost > Player.LocalPlayer.IndustryStock)
		{
			Diagnostics.Log("{0} > Room.CanBuildMajorModule: not enough industry! ({1} > {2})", base.name, industryCost, Player.LocalPlayer.IndustryStock);
			if (displayErrors)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_MajorModuleBuildFailResources"));
			}
			return false;
		}
		return true;
	}

	private bool RequestBuildMajorModule(BluePrintConfig bpConfig, bool checkRoomPower, bool consumeIndustryOnServer, bool consumeIndustryOnBuyer, bool instantBuild, bool restoration, ulong buyerPlayerID, float health = -1f)
	{
		if (!CanBuildMajorModule(bpConfig, consumeIndustryOnServer, displayErrors: false))
		{
			Diagnostics.Log("Room.RequestBuildMajorModule: cannot build major module!");
			return false;
		}
		ModuleConfig value = Databases.GetDatabase<ModuleConfig>().GetValue(bpConfig.ModuleName);
		float industryCost = value.GetIndustryCost();
		if (checkRoomPower && value.NeedRoomPower && !IsPowered && Player.LocalPlayer.IndustryStock >= industryCost && !value.PowersRoom && bpConfig.ModuleName != SimulationProperties.SpecialModule_Crystal && !TogglePower())
		{
			return false;
		}
		if (consumeIndustryOnServer && !Player.LocalPlayer.ConsumeIndustry(industryCost))
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_MajorModuleBuildFailResources"));
			return false;
		}
		netSyncElement.SendRPCToAll(UniqueIDRPC.Room_DoBuildMajorModule, buyerPlayerID, bpConfig.Name, instantBuild, restoration, consumeIndustryOnBuyer, health);
		return true;
	}

	private void RPC_DoBuildMajorModule(ulong buyerPlayerID, StaticString bpConfigName, bool instantBuild, bool restoration, bool consumeIndustryOnBuyer, float health)
	{
		DoBuildMajorModule(buyerPlayerID, bpConfigName, instantBuild, restoration, consumeIndustryOnBuyer, health);
	}

	public void DoBuildMajorModule(ulong buyerPlayerID, StaticString bpConfigName, bool instantBuild, bool restoration, bool consumeIndustryOnBuyer, float health, bool checkOwnershipForBuildComplete = true)
	{
		BluePrintConfig value = Databases.GetDatabase<BluePrintConfig>().GetValue(bpConfigName);
		ModuleConfig value2 = Databases.GetDatabase<ModuleConfig>().GetValue(value.ModuleName);
		if (!CanBuildMajorModule(value, consumeIndustryOnBuyer && buyerPlayerID == gameNetManager.GetLocalPlayerID(), displayErrors: true, checkIsFullyOpened: false))
		{
			Diagnostics.LogError("Room.RPC_DoBuildMajorModule: cannot build major module!");
			return;
		}
		float industryCost = value2.GetIndustryCost();
		if (consumeIndustryOnBuyer && buyerPlayerID == gameNetManager.GetLocalPlayerID() && !Player.LocalPlayer.ConsumeIndustry(industryCost))
		{
			Diagnostics.LogError("Room.RPC_DoBuildMajorModule: not enough resources!");
			return;
		}
		Vector3 zero = Vector3.zero;
		ModuleSlot moduleSlot = null;
		if (value.ModuleName != SimulationProperties.SpecialModule_Crystal)
		{
			moduleSlot = MajorModuleSlot;
		}
		else
		{
			moduleSlot = GetFreeCrystalModuleSlot();
			if (moduleSlot == null)
			{
				Diagnostics.LogError("Unable to find a free crystal module slot in " + base.name);
				return;
			}
			dungeon.UpdateCrystalTfm(moduleSlot.transform);
		}
		zero = moduleSlot.transform.position;
		moduleSlot.IsAvailable = false;
		moduleSlot.UnHighlight();
		GameObject original = majorModulePfb;
		if (value.Name.ToString().StartsWith("SpecialModule_Crystal"))
		{
			original = crystalPfb;
		}
		else if (value.Name == SimulationProperties.SpecialModule_Artifact)
		{
			original = artifactPfb;
		}
		else if (value.Name == SimulationProperties.SpecialModule_Stele)
		{
			original = stelePfb;
		}
		else if (value.Name == SimulationProperties.SpecialModule_DustFactory)
		{
			original = dustFactoryPfb;
		}
		else if (value.Name == SimulationProperties.SpecialModule_CryoCapsule)
		{
			original = cryoCapsulePfb;
		}
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(original, zero, Quaternion.identity);
		dungeon.AddDynamicElementForScaling(gameObject.transform);
		MajorModule = gameObject.GetComponent<MajorModule>();
		MajorModule.Init(buyerPlayerID, value, this, moduleSlot, value2.BuildDuration, !instantBuild, instantBuild, restoration, checkOwnershipForBuildComplete);
		UpdateTacticalMapElementDefenses();
		if (this.OnRoomContentChanged != null)
		{
			this.OnRoomContentChanged();
		}
		if (gameNetManager.GetLocalPlayerID() == buyerPlayerID)
		{
			if (health >= 0f)
			{
				MajorModule.HealthCpnt.SetHealth(health, ignoreInvincibility: false, ignoreAlive: true);
			}
			gameEventManager.TriggerModuleBuiltEvent(value);
			GoogleAnalyticsManager googleAnalyticsManager = SingletonManager.Get<GoogleAnalyticsManager>();
			if (googleAnalyticsManager != null)
			{
				googleAnalyticsManager.SendBuiltModuleAnalytics(value);
			}
		}
	}

	private bool CanBuildMinorModule(BluePrintConfig bpConfig, bool checkIndustryStock = true, bool displayErrors = true)
	{
		if (!IsFullyOpened)
		{
			Diagnostics.Log("{0} > Room.CanBuildMinorModule: room not fully opened!", base.name);
			return false;
		}
		MinorModuleSlot[] array = MinorModuleSlots.FindAll((MinorModuleSlot s) => s.IsAvailable).ToArray();
		if (array.Length < 1)
		{
			Diagnostics.Log("{0} > Room.CanBuildMinorModule: no available minor module slot! ({1})", base.name, array.Length);
			if (displayErrors)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_MinorModuleBuildFailNoSlot"));
			}
			return false;
		}
		ModuleConfig value = Databases.GetDatabase<ModuleConfig>().GetValue(bpConfig.ModuleName);
		float industryCost = value.GetIndustryCost();
		if (checkIndustryStock && industryCost > Player.LocalPlayer.IndustryStock)
		{
			Diagnostics.Log("{0} > Room.CanBuildMinorModule: not enough industry! ({1} > {2})", base.name, industryCost, Player.LocalPlayer.IndustryStock);
			if (displayErrors)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_MinorModuleBuildFailResources"));
			}
			return false;
		}
		return true;
	}

	private bool RequestBuildMinorModule(BluePrintConfig bpConfig, Vector3 clickWorldPos, bool checkRoomPower, bool consumeIndustryOnServer, bool consumeIndustryOnBuyer, bool instantBuild, bool restoration, ulong buyerPlayerID, float health = -1f)
	{
		if (!CanBuildMinorModule(bpConfig, consumeIndustryOnServer, displayErrors: false))
		{
			Diagnostics.Log("Room.RequestBuildMinorModule: cannot build minor module!");
			return false;
		}
		MinorModuleSlot[] array = MinorModuleSlots.FindAll((MinorModuleSlot s) => s.IsAvailable).ToArray();
		if (array.Length < 1)
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_MinorModuleBuildFailNoSlot"));
			return false;
		}
		ModuleConfig value = Databases.GetDatabase<ModuleConfig>().GetValue(bpConfig.ModuleName);
		float industryCost = value.GetIndustryCost();
		if (checkRoomPower && !IsPowered && !TogglePower())
		{
			return false;
		}
		if (consumeIndustryOnServer && !Player.LocalPlayer.ConsumeIndustry(industryCost))
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_MinorModuleBuildFailResources"));
			return false;
		}
		netSyncElement.SendRPCToAll(UniqueIDRPC.Room_DoBuildMinorModule, buyerPlayerID, bpConfig.Name, (Int2Position)clickWorldPos, instantBuild, restoration, consumeIndustryOnBuyer, health, 0);
		return true;
	}

	private void RPC_DoBuildMinorModule(ulong buyerPlayerID, StaticString bpConfigName, Int2Position clickWorldPos, bool instantBuild, bool restoration, bool consumeIndustryOnBuyer, float health, int killCount)
	{
		MinorModuleSlot[] source = MinorModuleSlots.FindAll((MinorModuleSlot s) => s.IsAvailable).ToArray();
		MinorModuleSlot slot = source.OrderBy((MinorModuleSlot s) => ((Vector3)clickWorldPos - s.transform.position).sqrMagnitude).ToArray()[0];
		DoBuildMinorModule(buyerPlayerID, bpConfigName, slot, instantBuild, restoration, consumeIndustryOnBuyer, health, killCount);
	}

	public void DoBuildMinorModule(ulong buyerPlayerID, StaticString bpConfigName, MinorModuleSlot slot, bool instantBuild, bool restoration, bool consumeIndustryOnBuyer, float health, int killCount, bool checkOwnershipForBuildComplete = true)
	{
		BluePrintConfig value = Databases.GetDatabase<BluePrintConfig>().GetValue(bpConfigName);
		ModuleConfig value2 = Databases.GetDatabase<ModuleConfig>().GetValue(value.ModuleName);
		if (!CanBuildMinorModule(value, consumeIndustryOnBuyer && buyerPlayerID == gameNetManager.GetLocalPlayerID()))
		{
			Diagnostics.LogError("Room.RPC_DoBuildMinorModule: cannot build minor module!");
			return;
		}
		float industryCost = value2.GetIndustryCost();
		if (consumeIndustryOnBuyer && buyerPlayerID == gameNetManager.GetLocalPlayerID() && !Player.LocalPlayer.ConsumeIndustry(industryCost))
		{
			Diagnostics.LogError("Room.RPC_DoBuildMinorModule: not enough resources!");
			return;
		}
		slot.IsAvailable = false;
		slot.UnHighlight();
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(minorModulePfb, slot.transform.position, Quaternion.identity);
		dungeon.AddDynamicElementForScaling(gameObject.transform);
		MinorModule component = gameObject.GetComponent<MinorModule>();
		component.Init(buyerPlayerID, value, this, slot, value2.BuildDuration, !instantBuild, instantBuild, restoration, checkOwnershipForBuildComplete);
		component.MobKillCount = killCount;
		MinorModules.Add(component);
		UpdateTacticalMapElementDefenses();
		if (gameNetManager.GetLocalPlayerID() == buyerPlayerID)
		{
			if (health >= 0f)
			{
				component.HealthCpnt.SetHealth(health, ignoreInvincibility: false, ignoreAlive: true);
			}
			gameEventManager.TriggerModuleBuiltEvent(value);
			GoogleAnalyticsManager googleAnalyticsManager = SingletonManager.Get<GoogleAnalyticsManager>();
			if (googleAnalyticsManager != null)
			{
				googleAnalyticsManager.SendBuiltModuleAnalytics(value);
			}
		}
	}

	private void UpdateTacticalMapElementDefenses()
	{
		int num = 0;
		if (MajorModule != null && MajorModule.GetType() == typeof(MajorModule))
		{
			num++;
		}
		num += MinorModules.Count;
		tacticalMapElement.SetModulePresence(num > 0);
	}

	public void RemoveMinorModule(MinorModule minorModule)
	{
		MinorModules.Remove(minorModule);
		UpdateTacticalMapElementDefenses();
		UpdateSupportEffectVFXs();
	}

	public void RemoveMajorModule()
	{
		MajorModule = null;
		UpdateTacticalMapElementDefenses();
		UpdateSupportEffectVFXs();
	}

	public Room GetPoweringRoom(bool ignoreOpeningDoors = false, List<Room> alreadyCheckedRooms = null)
	{
		if (IsStartRoom)
		{
			return this;
		}
		if (alreadyCheckedRooms == null)
		{
			alreadyCheckedRooms = new List<Room>();
		}
		alreadyCheckedRooms.Add(this);
		foreach (Room adjacentRoom in AdjacentRooms)
		{
			bool flag = false;
			foreach (Door door in doors)
			{
				if (!(door == null))
				{
					if (ignoreOpeningDoors && door.IsOpening)
					{
						Diagnostics.LogWarning("Ignoring {0}", door.name);
					}
					else if ((door.Room1 == this && door.Room2 == adjacentRoom) || (door.Room2 == this && door.Room1 == adjacentRoom))
					{
						flag = true;
					}
				}
			}
			if (!flag && !alreadyCheckedRooms.Contains(adjacentRoom) && adjacentRoom.IsPowered)
			{
				Room poweringRoom = adjacentRoom.GetPoweringRoom(ignoreOpeningDoors, alreadyCheckedRooms);
				if (poweringRoom != null)
				{
					return adjacentRoom;
				}
			}
		}
		return null;
	}

	private bool CanBePowered(out string errorNotif, bool displayErrorNotif = false, bool checkCrystalState = true, bool checkInitialization = true, bool ignoreOpeningDoorsForPowerChainCheck = false, bool checkPowerChain = true)
	{
		errorNotif = null;
		if (checkCrystalState && dungeon.CurrentCrystalState != 0)
		{
			Diagnostics.Log(base.name + " > Cannot power room: Crystal is unplugged");
			return false;
		}
		if (IsAutoPowered)
		{
			return true;
		}
		if (!IsVisible)
		{
			Diagnostics.Log(base.name + " > Cannot power room: Invisible room");
			return false;
		}
		if (checkInitialization && !IsFullyOpened)
		{
			Diagnostics.Log(base.name + " > Cannot power room: Room uninitialized");
			return false;
		}
		if (IsPowered)
		{
			Diagnostics.Log(base.name + " > Cannot power room: Room already powered!");
			return false;
		}
		if (checkPowerChain)
		{
			Room poweringRoom = GetPoweringRoom(ignoreOpeningDoorsForPowerChainCheck);
			if (poweringRoom == null || !poweringRoom.IsInPowerChain())
			{
				Diagnostics.LogError(base.name + " > Cannot power room: No power chain to room");
				errorNotif = AgeLocalizer.Instance.LocalizeString("%Error_PowerRoomFailPowerChain");
				if (displayErrorNotif)
				{
					dungeon.EnqueueErrorNotification(errorNotif);
				}
				return false;
			}
		}
		if (!dungeon.CanPowerRoom(this))
		{
			Diagnostics.LogError(base.name + " > Cannot power room: Not enough dust");
			errorNotif = AgeLocalizer.Instance.LocalizeString("%Error_PowerRoomFailResources");
			if (displayErrorNotif)
			{
				dungeon.EnqueueErrorNotification(errorNotif);
			}
			return false;
		}
		return true;
	}

	private bool CanBePowered(bool displayErrorNotif = false, bool checkCrystalState = true, bool checkInitialization = true, bool ignoreOpeningDoorsForPowerChainCheck = false, bool checkPowerChain = true)
	{
		string errorNotif;
		return CanBePowered(out errorNotif, displayErrorNotif, checkCrystalState, checkInitialization, ignoreOpeningDoorsForPowerChainCheck, checkPowerChain);
	}

	public bool PowerByLocalPlayer(bool displayErrorNotif = true, bool checkCrystalState = true, bool consumeDust = true, bool playPowerVFX = true, bool syncPowerOverNetwork = true, bool checkIfCanBePowered = true, bool checkPowerChain = true)
	{
		return Power(gameNetManager.GetLocalPlayerID(), displayErrorNotif, checkCrystalState, consumeDust, playPowerVFX, syncPowerOverNetwork, checkIfCanBePowered, checkPowerChain);
	}

	public bool Power(ulong powerPlayerID, bool displayErrorNotif = true, bool checkCrystalState = true, bool consumeDust = true, bool playPowerVFX = true, bool netSync = true, bool checkIfCanBePowered = true, bool checkPowerChain = true)
	{
		if (checkIfCanBePowered && !IsAutoPowered && !CanBePowered(displayErrorNotif, checkCrystalState, checkInitialization: true, ignoreOpeningDoorsForPowerChainCheck: false, checkPowerChain))
		{
			return false;
		}
		if (netSync)
		{
			netSyncElement.SendRPCToServer(UniqueIDRPC.Room_RequestPower, powerPlayerID, playPowerVFX, checkCrystalState, consumeDust, checkIfCanBePowered);
		}
		else
		{
			DoPower(powerPlayerID, playPowerVFX, checkCrystalState, consumeDust, checkIfCanBePowered);
		}
		return true;
	}

	private void RPC_RequestPower(ulong powerPlayerID, bool playPowerVFX, bool checkCrystalState, bool consumeDust, bool checkIfCanBePowered)
	{
		if (!gameNetManager.IsServer())
		{
			Diagnostics.LogError("Room.RPC_RequestPower should only be called on server side!");
		}
		else if (checkIfCanBePowered && !CanBePowered(displayErrorNotif: false, checkCrystalState))
		{
			Diagnostics.Log("Room.RPC_RequestPower: NOPE");
		}
		else
		{
			netSyncElement.SendRPCToAll(UniqueIDRPC.Room_DoPower, powerPlayerID, playPowerVFX, checkCrystalState, consumeDust, checkIfCanBePowered);
		}
	}

	private void RPC_DoPower(ulong powerPlayerID, bool playPowerVFX, bool checkCrystalState, bool consumeDust, bool checkIfCanBePowered)
	{
		DoPower(powerPlayerID, playPowerVFX, checkCrystalState, consumeDust, checkIfCanBePowered);
	}

	public void DoPower(ulong powerPlayerID, bool playPowerVFX, bool checkCrystalState, bool consumeDust, bool checkIfCanBePowered)
	{
		if (checkIfCanBePowered && !CanBePowered(displayErrorNotif: false, checkCrystalState, checkInitialization: false, ignoreOpeningDoorsForPowerChainCheck: true))
		{
			Diagnostics.LogError("Room.RPC_DoPower: CANNOT BE POWERED!");
			return;
		}
		TurnCleanLights(on: true);
		TurnDirtyLights(on: false);
		if (!SuffersEMP)
		{
			if (MajorModule != null && MajorModule.GetComponent<Health>().IsAlive() && !MajorModule.IsBuilding)
			{
				MajorModule.Power(on: true);
			}
			foreach (MinorModule minorModule in MinorModules)
			{
				if (minorModule.GetComponent<Health>().IsAlive() && !minorModule.IsBuilding)
				{
					minorModule.Power(on: true);
				}
			}
		}
		if (!GetSimObj().Tags.Contains(SimulationProperties.SimDescRoomIsPowered))
		{
			AddSimDescriptor(SimulationProperties.SimDescRoomIsPowered, refresh: false);
		}
		if (!IsStartRoom && powerPlayerID != gameNetManager.GetLocalPlayerID() && gameNetManager.IsMultiplayerSession() && MultiplayerConfig.SplitRoomPowering && !GetSimObj().Tags.Contains(SimulationProperties.SimDescRoomIsPoweredByAnotherPlayer))
		{
			AddSimDescriptor(SimulationProperties.SimDescRoomIsPoweredByAnotherPlayer, refresh: false);
		}
		dungeon.RefreshSim();
		if (!IsStartRoom && playPowerVFX)
		{
			audioEmitter.PlayEvent("Master/Environment/LinkRoom");
			Room poweringRoom = GetPoweringRoom();
			if (poweringRoom != null && powerVFXs.Count == 0)
			{
				Vector3 position = (!(poweringRoom.MajorModuleSlot != null)) ? poweringRoom.CenterPosition : poweringRoom.MajorModuleSlot.transform.position;
				GameObjectPoolManager gameObjectPoolManager = SingletonManager.Get<GameObjectPoolManager>();
				GameObject prefab = (!dungeon.ShipConfig.UseAlternativePulseFX) ? powerVFXPfb : powerAlternativeVFXPfb;
				if (MajorModuleSlot != null)
				{
					GameObject gameObject = gameObjectPoolManager.Instantiate(prefab, position, Quaternion.identity);
					dungeon.AddDynamicElementForScaling(gameObject.transform);
					RoomPowerVFX component = gameObject.GetComponent<RoomPowerVFX>();
					component.Init(MajorModuleSlot);
					powerVFXs.Add(component);
				}
				foreach (MinorModuleSlot minorModuleSlot in MinorModuleSlots)
				{
					GameObject gameObject = gameObjectPoolManager.Instantiate(prefab, position, Quaternion.identity);
					dungeon.AddDynamicElementForScaling(gameObject.transform);
					RoomPowerVFX component = gameObject.GetComponent<RoomPowerVFX>();
					component.Init(minorModuleSlot);
					powerVFXs.Add(component);
				}
			}
		}
		IsPowered = true;
		LastPowerChangePlayerID = powerPlayerID;
		LastPowerChangeTime = Time.time;
		tacticalMapElement.SetPower(power: true);
		UpdateSupportEffectVFXs();
		if (consumeDust)
		{
			dungeon.NotifyRoomPowered(this, powered: true);
		}
		gameEventManager.TriggerDungeonFIDSChangedEvent();
		if (this.OnRoomContentChanged != null)
		{
			this.OnRoomContentChanged();
		}
		if (this.OnRoomPowerChanged != null)
		{
			this.OnRoomPowerChanged(powered: true);
		}
		if (TutorialManager.IsEnable)
		{
			Services.GetService<IGameEventService>()?.TriggerRoomPoweredTutorialEvent();
		}
	}

	public void AutoPower(bool power, bool isFromEvent, ulong instigatorId)
	{
		netSyncElement.SendRPCToAll(UniqueIDRPC.Room_DoAutoPower, power, isFromEvent, instigatorId);
	}

	private void RPC_DoAutoPower(bool power, bool isFromEvent, ulong instigatorId)
	{
		DoAutoPower(power, isFromEvent, instigatorId);
	}

	public void DoAutoPower(bool power, bool isFromEvent, ulong instigatorId, bool playPowerVFX = true)
	{
		if (!isFromEvent && IsAutoPowered && IsAutoPoweredByEvent)
		{
			return;
		}
		IsAutoPowered = power;
		IsAutoPoweredByEvent = isFromEvent;
		if (power)
		{
			if (IsPowered)
			{
				dungeon.NotifyRoomPowered(this, powered: false);
				gameEventManager.TriggerDungeonFIDSChangedEvent();
			}
			else
			{
				Power(instigatorId, displayErrorNotif: false, checkCrystalState: false, consumeDust: false, playPowerVFX);
			}
		}
		else
		{
			Unpower(delay: false, checkCrystalState: false, checkPoweringPlayer: false, checkPowerChangeCooldown: false, ignoreShipConfig: false);
		}
		if (autoPowerVFXPfb != null)
		{
			ParticleSystem[] array = autoPowerVFXs;
			foreach (ParticleSystem particleSystem in array)
			{
				if (power)
				{
					particleSystem.Play(withChildren: true);
				}
				else
				{
					particleSystem.Stop(withChildren: true);
				}
			}
		}
		if (isFromEvent)
		{
			dungeon.EnqueueEventNotification(RoomEvent.AutoPower);
		}
	}

	public void ApplyEMP(bool emp, int remainingTurns)
	{
		netSyncElement.SendRPCToAll(UniqueIDRPC.Room_DoApplyEMP, emp, remainingTurns, false);
	}

	private void RPC_DoApplyEMP(bool emp, int remainingTurns, bool silent)
	{
		DoApplyEMP(emp, remainingTurns, silent);
	}

	public void DoApplyEMP(bool emp, int remainingTurns, bool silent = false)
	{
		if (!emp || remainingTurns > 0)
		{
			Diagnostics.Log("EMP applied to room to: " + base.name);
			if (SuffersEMP != emp)
			{
				SuffersEMP = emp;
				EmpTurnsRemaining = remainingTurns;
				if (emp)
				{
					gameEventManager.OnDungeonTurnChanged += DecreaseEMPDuration;
				}
				else
				{
					gameEventManager.OnDungeonTurnChanged -= DecreaseEMPDuration;
				}
				foreach (MinorModule minorModule in MinorModules)
				{
					minorModule.ApplyEMP(emp);
				}
				if (HasNormalMajorModule)
				{
					MajorModule.ApplyEMP(emp);
				}
			}
			else if (emp)
			{
				EmpTurnsRemaining = remainingTurns;
			}
		}
		UpdateSupportEffectVFXs();
		if (emp && !silent)
		{
			dungeon.EnqueueEventNotification(RoomEvent.EMP);
		}
	}

	private void DecreaseEMPDuration()
	{
		EmpTurnsRemaining--;
		if (EmpTurnsRemaining == 0)
		{
			ApplyEMP(emp: false, 0);
		}
	}

	private bool CanBeUnpowered(bool checkCrystalState = false, bool checkPoweringPlayer = false, bool checkPowerChangeCooldown = false, bool ignoreShipConfig = true, bool displayError = true)
	{
		if (!IsVisible)
		{
			Diagnostics.Log(base.name + " > Cannot unpower room: Invisible room");
			return false;
		}
		if (!IsFullyOpened)
		{
			Diagnostics.Log(base.name + " > Cannot unpower room: Room uninitialized");
			return false;
		}
		if (!ignoreShipConfig && dungeon.ShipConfig.ForbidUnpower)
		{
			if (displayError)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_UnPowerRoomFailShipConfig"));
			}
			return false;
		}
		if (!IsPowered)
		{
			Diagnostics.Log(base.name + " > Cannot unpower room: Room already unpowered!");
			return false;
		}
		if (checkCrystalState && dungeon.CurrentCrystalState != 0)
		{
			Diagnostics.Log(base.name + " > Cannot unpower room: Crystal is unplugged");
			return false;
		}
		if (checkPowerChangeCooldown && LastPowerChangePlayerID != gameNetManager.GetLocalPlayerID() && Time.time <= LastPowerChangeTime + MultiplayerConfig.RoomPowerChangeCooldown)
		{
			if (displayError)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_UnPowerRoomFailCooldown"));
			}
			return false;
		}
		if (checkPoweringPlayer && LastPowerChangePlayerID != gameNetManager.GetLocalPlayerID())
		{
			if (displayError)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_UnPowerRoomFailNotPowerer"));
			}
			return false;
		}
		if (IsAutoPowered)
		{
			if (displayError)
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_UnPowerRoomFailForcedPower"));
			}
			return false;
		}
		return true;
	}

	public bool UnpowerByPlayer()
	{
		bool checkPoweringPlayer = false;
		bool checkPowerChangeCooldown = false;
		if (gameNetManager.IsMultiplayerSession())
		{
			checkPoweringPlayer = MultiplayerConfig.SplitRoomPowering;
			checkPowerChangeCooldown = (MultiplayerConfig.RoomPowerChangeCooldown > 0f);
		}
		return Unpower(delay: false, checkCrystalState: true, checkPoweringPlayer, checkPowerChangeCooldown, ignoreShipConfig: false, displayError: true, gameNetManager.GetLocalPlayerID());
	}

	public bool Unpower(bool delay = false, bool checkCrystalState = false, bool checkPoweringPlayer = false, bool checkPowerChangeCooldown = false, bool ignoreShipConfig = true, bool displayError = true, ulong unpowerPlayerID = 0)
	{
		if (!CanBeUnpowered(checkCrystalState, checkPoweringPlayer, checkPowerChangeCooldown, ignoreShipConfig, displayError))
		{
			return false;
		}
		IsUnpoweringWithDelay = delay;
		if (delay)
		{
			delayedUnpowerPlayerID = unpowerPlayerID;
			if (!IsInvoking("DelayedUnpower"))
			{
				Invoke("DelayedUnpower", RandomGenerator.RangeFloat(unpowerMinDelay, unpowerMaxDelay));
			}
		}
		else
		{
			RequestUnpower(unpowerPlayerID);
		}
		return true;
	}

	private void CancelDelayedUnpower()
	{
		if (IsInvoking("DelayedUnpower"))
		{
			CancelInvoke("DelayedUnpower");
		}
		IsUnpoweringWithDelay = false;
	}

	private void DelayedUnpower()
	{
		IsUnpoweringWithDelay = false;
		RequestUnpower(delayedUnpowerPlayerID);
	}

	private void RequestUnpower(ulong unpowerPlayerID)
	{
		if (!CanBeUnpowered())
		{
			Diagnostics.LogWarning("Room.DoUnpower: NOPE!");
		}
		else
		{
			netSyncElement.SendRPCToServer(UniqueIDRPC.Room_RequestUnpower, unpowerPlayerID);
		}
	}

	private void RPC_RequestUnpower(ulong unpowerPlayerID)
	{
		if (!gameNetManager.IsServer())
		{
			Diagnostics.LogError("Room.RPC_RequestUnpower should only be called on server side!");
		}
		else if (!CanBeUnpowered())
		{
			Diagnostics.LogWarning("Room.RPC_RequestUnpower: NOPE!");
		}
		else
		{
			netSyncElement.SendRPCToAll(UniqueIDRPC.Room_DoUnpower, unpowerPlayerID);
		}
	}

	private void RPC_DoUnpower(ulong unpowerPlayerID)
	{
		DoUnpower(unpowerPlayerID);
	}

	public void DoUnpower(ulong unpowerPlayerID)
	{
		if (!CanBeUnpowered())
		{
			Diagnostics.LogError("Room.RPC_DoUnpower: CANNOT BE UNPOWERED! (shouldn't happen)");
			return;
		}
		if (dungeon.CurrentCrystalState == CrystalState.Plugged)
		{
			TurnCleanLights(on: false);
			TurnDirtyLights(on: true);
			ToggleDirtyLightsIntensity(IsOccupied());
		}
		else
		{
			TurnCleanLights(on: false);
			TurnLowLights(on: true);
			ToggleLowLightsIntensity(IsOccupied());
		}
		if (!SuffersEMP)
		{
			if (MajorModule != null && MajorModule.GetComponent<Health>().IsAlive())
			{
				MajorModule.Power(on: false);
			}
			foreach (MinorModule minorModule in MinorModules)
			{
				if (minorModule.GetComponent<Health>().IsAlive())
				{
					minorModule.Power(on: false);
				}
			}
		}
		RemoveSimDescriptor(SimulationProperties.SimDescRoomIsPowered, refresh: false);
		RemoveSimDescriptor(SimulationProperties.SimDescRoomIsPoweredByAnotherPlayer, refresh: false);
		dungeon.RefreshSim();
		if (powerVFXs != null)
		{
			foreach (RoomPowerVFX powerVFX in powerVFXs)
			{
				if (powerVFX != null && powerVFX.gameObject != null && powerVFX.gameObject.activeSelf)
				{
					powerVFX.SelfDestruct();
				}
			}
			powerVFXs.Clear();
		}
		if (MajorModuleSlot != null)
		{
			MajorModuleSlot.StopPowerVFX();
		}
		foreach (MinorModuleSlot minorModuleSlot in MinorModuleSlots)
		{
			minorModuleSlot.StopPowerVFX();
		}
		if (audioEmitter != null)
		{
			audioEmitter.PlayEvent("Master/Environment/UnLinkRoom");
		}
		IsPowered = false;
		LastPowerChangePlayerID = unpowerPlayerID;
		LastPowerChangeTime = Time.time;
		dungeon.NotifyRoomPowered(this, powered: false);
		tacticalMapElement.SetPower(power: false);
		UpdateSupportEffectVFXs();
		gameEventManager.TriggerDungeonFIDSChangedEvent();
		if (this.OnRoomContentChanged != null)
		{
			this.OnRoomContentChanged();
		}
		if (this.OnRoomPowerChanged != null)
		{
			this.OnRoomPowerChanged(powered: false);
		}
	}

	public void OnAdjacentRoomPowerChanged(bool isAdjacentRoomPowered)
	{
		if (isAdjacentRoomPowered && IsInPowerChain())
		{
			CancelDelayedUnpower();
		}
		if (IsPowered == isAdjacentRoomPowered || !gameNetManager.IsServerOrSinglePlayer())
		{
			return;
		}
		if (!isAdjacentRoomPowered)
		{
			if (GetPoweringRoom() == null)
			{
				Unpower(delay: true, checkCrystalState: false, checkPoweringPlayer: false, checkPowerChangeCooldown: false, ignoreShipConfig: false, displayError: false);
			}
			if (dungeon.CurrentCrystalState != 0)
			{
				return;
			}
			for (int i = 0; i < AdjacentRooms.Count; i++)
			{
				Room room = AdjacentRooms[i];
				if (room.IsPowered && !room.IsAutoPowered && !room.IsInPowerChain())
				{
					room.Unpower(delay: true);
				}
			}
		}
		else
		{
			CancelDelayedUnpower();
		}
	}

	public bool IsInPowerChain(List<Room> checkedRoom = null)
	{
		if (checkedRoom == null)
		{
			checkedRoom = new List<Room>();
		}
		checkedRoom.Add(this);
		if (IsStartRoom)
		{
			return true;
		}
		if (!IsPowered)
		{
			return false;
		}
		foreach (Room adjacentRoom in AdjacentRooms)
		{
			if (!checkedRoom.Contains(adjacentRoom) && adjacentRoom.IsInPowerChain(checkedRoom))
			{
				return true;
			}
		}
		return false;
	}

	public bool TogglePower()
	{
		if (IsStartRoom)
		{
			return true;
		}
		if (IsPowered)
		{
			UnpowerByPlayer();
		}
		else
		{
			List<Room> currentPowerPath = new List<Room>();
			List<List<Room>> powerPaths = new List<List<Room>>();
			Dungeon dungeon = SingletonManager.Get<Dungeon>();
			int poweringCapability = dungeon.GetMaxPoweredRoomCount() - dungeon.PoweredRooms.Count;
			string errorMessage = null;
			if (FindPowerPath(ref powerPaths, ref currentPowerPath, poweringCapability, isFirstRoom: true, out errorMessage))
			{
				List<Room> list = powerPaths.OrderBy((List<Room> p) => p.Count).ToArray()[0];
				for (int num = list.Count - 1; num >= 0; num--)
				{
					Room room = list[num];
					if (!room.IsPowered)
					{
						room.PowerByLocalPlayer(displayErrorNotif: false, checkCrystalState: true, consumeDust: true, playPowerVFX: true, syncPowerOverNetwork: true, checkIfCanBePowered: true, checkPowerChain: false);
					}
				}
			}
			else if (errorMessage != null)
			{
				this.dungeon.EnqueueErrorNotification(errorMessage);
				return false;
			}
		}
		return true;
	}

	private bool FindPowerPath(ref List<List<Room>> powerPaths, ref List<Room> currentPowerPath, int poweringCapability, bool isFirstRoom, out string errorMessage)
	{
		errorMessage = null;
		if (IsPowered && !IsAutoPowered)
		{
			powerPaths.Add(currentPowerPath);
			return true;
		}
		if (poweringCapability == 0 && !IsAutoPowered)
		{
			errorMessage = AgeLocalizer.Instance.LocalizeString("%Error_PowerRoomFailResources");
			return false;
		}
		if (!CanBePowered(out errorMessage, displayErrorNotif: false, checkCrystalState: true, checkInitialization: true, ignoreOpeningDoorsForPowerChainCheck: false, checkPowerChain: false))
		{
			return false;
		}
		currentPowerPath.Add(this);
		int poweringCapability2 = (!IsAutoPowered) ? (poweringCapability - 1) : poweringCapability;
		for (int i = 0; i < AdjacentRooms.Count; i++)
		{
			Room room = AdjacentRooms[i];
			if (room.IsVisible && !currentPowerPath.Contains(room) && IsConnectedTo(room))
			{
				List<Room> currentPowerPath2 = new List<Room>(currentPowerPath);
				room.FindPowerPath(ref powerPaths, ref currentPowerPath2, poweringCapability2, isFirstRoom: false, out errorMessage);
			}
		}
		if (!isFirstRoom)
		{
			return false;
		}
		return powerPaths.Count != 0;
	}

	private bool IsConnectedTo(Room otherRoom)
	{
		for (int i = 0; i < AdjacentRooms.Count; i++)
		{
			if (!(AdjacentRooms[i] == otherRoom))
			{
				continue;
			}
			for (int j = 0; j < otherRoom.doors.Count; j++)
			{
				Door door = otherRoom.doors[j];
				if (door != null && ((door.Room1 == this && door.Room2 == otherRoom) || (door.Room2 == this && door.Room1 == otherRoom)))
				{
					return false;
				}
			}
			return true;
		}
		return false;
	}

	public void SetSize(Vector3 size)
	{
		Size = size;
		tacticalMapElement.Init(this);
	}

	public bool IsOccupied()
	{
		for (int i = 0; i < Heroes.Count; i++)
		{
			if (Heroes[i].IsRecruited)
			{
				return true;
			}
		}
		return false;
	}

	public bool ShouldDisplayMobs()
	{
		return IsPowered || IsOccupied();
	}

	public void Init()
	{
		GameConfig gameConfig = GameConfig.GetGameConfig();
		MinorModules = new List<MinorModule>();
		Mobs = new List<Mob>();
		Heroes = new List<Hero>();
		NPCs = new List<NPC>();
		notificationMarkersPriorities = new List<RoomMarker>();
		floorTiles = GetComponentsInChildren<FloorTile>();
		FloorTile[] array = floorTiles;
		foreach (FloorTile floorTile in array)
		{
			floorTile.Init(this);
		}
		FloorSurface = 0f;
		FloorTile[] array2 = floorTiles;
		foreach (FloorTile floorTile2 in array2)
		{
			FloorSurface += floorTile2.Width * floorTile2.Height;
		}
		SpriteAnimationRuntime2[] componentsInChildren = GetComponentsInChildren<SpriteAnimationRuntime2>();
		List<SpriteAnimationRuntime2> list = new List<SpriteAnimationRuntime2>();
		for (int k = 0; k < componentsInChildren.Length; k++)
		{
			if (componentsInChildren[k].CompareTag(poweredPropsTag))
			{
				list.Add(componentsInChildren[k]);
			}
		}
		powerableProps = list.ToArray();
		List<MajorModuleSlot> list2 = new List<MajorModuleSlot>(GetComponentsInChildren<MajorModuleSlot>());
		if (list2.Count > 0 && (IsStartRoom || RandomGenerator.Value() <= gameConfig.RoomMajorModuleSlotProbability.GetValue(this)))
		{
			MajorModuleSlot = list2.PullRandom();
			MajorModuleSlot.Init(this);
			dungeon.MajorModuleSlotCount++;
		}
		if (IsStartRoom && MajorModuleSlot == null)
		{
			Diagnostics.LogError("No major module slot in start room!");
		}
		foreach (MajorModuleSlot item in list2)
		{
			UnityEngine.Object.DestroyImmediate(item.gameObject);
		}
		MinorModuleSlots = new List<MinorModuleSlot>();
		List<MinorModuleSlot> list3 = new List<MinorModuleSlot>(GetComponentsInChildren<MinorModuleSlot>());
		if (list3.Count > 0 && RandomGenerator.Value() <= gameConfig.RoomMinorModuleSlotProbability.GetValue(this))
		{
			int a = GenericUtilities.RoundHalfAwayFromZeroToInt(RandomGenerator.RangeFloat(gameConfig.RoomMinorModuleSlotCountMin.GetValue(this), gameConfig.RoomMinorModuleSlotCountMax.GetValue(this)));
			a = Mathf.Min(a, list3.Count);
			for (int l = 0; l < a; l++)
			{
				MinorModuleSlot minorModuleSlot = list3.PullRandom();
				minorModuleSlot.Init(this);
				MinorModuleSlots.Add(minorModuleSlot);
				dungeon.MinorModuleSlotCount++;
			}
		}
		foreach (MinorModuleSlot item2 in list3)
		{
			UnityEngine.Object.DestroyImmediate(item2.gameObject);
		}
		CrystalModuleSlots = new List<CrystalModuleSlot>();
		dirtyLights = GetComponentsInChildren<DirtyLight>();
		cleanLights = new List<CleanLight>(GetComponentsInChildren<CleanLight>());
		lowLights = GetComponentsInChildren<LowLight>();
		aiTarget = GetComponent<AITarget>();
		for (int m = 0; m < cleanLights.Count; m++)
		{
			cleanLights[m].Init();
		}
		RoomElement component = GetComponent<RoomElement>();
		if (component != null)
		{
			component.SetParentRoom(this);
		}
		RoomCenter componentInChildren = GetComponentInChildren<RoomCenter>();
		if (componentInChildren != null)
		{
			CenterPosition = componentInChildren.transform.position;
		}
		else
		{
			CenterPosition = base.transform.position;
		}
		dungeon.OnCrystalStateChanged += Dungeon_OnCrystalStateChanged;
		this.OnRoomContentChanged = (RoomChangedEventHandler)Delegate.Combine(this.OnRoomContentChanged, new RoomChangedEventHandler(UpdateMarkersVisibility));
		vfxZones = GetComponentsInChildren<VFXZone>();
		if (vfxZones.Length == 0)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(vfxZonePfb, base.transform.position, Quaternion.identity) as GameObject;
			(gameObject.GetComponent<Collider>() as BoxCollider).size = (GetComponent<Collider>() as BoxCollider).size;
			gameObject.transform.localScale = Vector3.one;
			VFXZone component2 = gameObject.GetComponent<VFXZone>();
			component2.DefaultSize = true;
			vfxZones = new VFXZone[1]
			{
				component2
			};
		}
		VFXZone[] array3 = vfxZones;
		foreach (VFXZone vFXZone in array3)
		{
			vFXZone.transform.parent = base.transform;
		}
		fogOfWarVFXs = new ParticleSystem[vfxZones.Length];
		for (int num = 0; num < vfxZones.Length; num++)
		{
			fogOfWarVFXs[num] = vfxZones[num].AdaptVFXToRoom(fogOfWarVFXPfb);
		}
		toxicCloudVFXs = new ParticleSystem[vfxZones.Length];
		for (int num2 = 0; num2 < vfxZones.Length; num2++)
		{
			toxicCloudVFXs[num2] = vfxZones[num2].AdaptVFXToRoom(toxicCloudVFXPfb);
		}
		if (autoPowerVFXPfb != null)
		{
			autoPowerVFXs = new ParticleSystem[vfxZones.Length];
			for (int num3 = 0; num3 < vfxZones.Length; num3++)
			{
				autoPowerVFXs[num3] = vfxZones[num3].AdaptVFXToRoom(autoPowerVFXPfb, ignoreSubEmitters: true);
			}
		}
		if (dungeon.GetSimPropertyValue(SimulationProperties.ModuleDamagePerTurn) != 0f)
		{
			gameEventManager.OnDungeonTurnChanged += GameEventManager_OnDungeonTurnChanged;
		}
	}

	private void GameEventManager_OnDungeonTurnChanged()
	{
		if (!IsPowered || IsStartRoom)
		{
			return;
		}
		float num = 0f - dungeon.GetSimPropertyValue(SimulationProperties.ModuleDamagePerTurn);
		for (int i = 0; i < MinorModules.Count; i++)
		{
			if (MinorModules[i].HealthCpnt != null && MinorModules[i].NetSyncElement.IsOwnedByLocalPlayer())
			{
				float simPropertyValue = MinorModules[i].GetSimPropertyValue(SimulationProperties.Defense);
				MinorModules[i].HealthCpnt.AddHealth(num * (1f - simPropertyValue / (simPropertyValue + 100f)));
			}
		}
		if (MajorModule != null && MajorModule.HealthCpnt != null && MajorModule.NetSyncElement.IsOwnedByLocalPlayer())
		{
			float simPropertyValue2 = MajorModule.GetSimPropertyValue(SimulationProperties.Defense);
			MajorModule.HealthCpnt.AddHealth(num * (1f - simPropertyValue2 / (simPropertyValue2 + 100f)));
		}
	}

	public void SetDustLootAmount(int remainingDungeonDustLootAmount)
	{
		GameConfig gameConfig = GameConfig.GetGameConfig();
		DustLootAmount = Mathf.Min(remainingDungeonDustLootAmount, GenericUtilities.RoundHalfAwayFromZeroToInt(RandomGenerator.RangeFloat(gameConfig.RoomDustLootMin.GetValue(this), gameConfig.RoomDustLootMax.GetValue(this))));
	}

	public void AddDoor(Door door)
	{
		if (doors == null)
		{
			doors = new List<Door>();
		}
		doors.Add(door);
	}

	public void PropagateDepth(bool checkMaxDepth = true)
	{
		int num = Depth + 1;
		foreach (Room adjacentRoom in AdjacentRooms)
		{
			if (!(adjacentRoom == null) && (adjacentRoom.Depth < 0 || adjacentRoom.Depth > num))
			{
				adjacentRoom.Depth = num;
				if (checkMaxDepth && num > dungeon.MaxDepth)
				{
					dungeon.MaxDepth = num;
				}
				adjacentRoom.PropagateDepth(checkMaxDepth);
			}
		}
	}

	public void OnHeroEnter(Hero hero)
	{
		if (!Heroes.Contains(hero))
		{
			_previousRoom = hero.RoomElement.ParentRoom;
			if (_previousRoom != null)
			{
				_previousRoom.OnHeroExit(hero);
			}
			Heroes.Add(hero);
			tacticalMapElement.SetHeroPresence(heroPresence: true);
			if (hero.IsRecruited)
			{
				UpdateLightsOnHeroEnter();
			}
			if (this.OnRoomContentChanged != null)
			{
				this.OnRoomContentChanged();
			}
			AddSimChild(hero, refresh: false);
			if (!hero.IsUsable)
			{
				hero.IsUsable = true;
			}
			if (hero.NetSyncElement.IsOwnedByLocalPlayer() && !hero.AICpnt.IsActive && !hero.HasCrystal)
			{
				hero.AICpnt.IsActive = true;
			}
			if (this.OnEntityEntered != null)
			{
				this.OnEntityEntered(hero);
			}
			dungeon.RefreshSim();
			hero.ChangeCurrentRoom(this);
			if (IsExitRoom && Room.OnHeroEnteredOrExitedExitRoom != null)
			{
				Room.OnHeroEnteredOrExitedExitRoom(hero, enter: true);
			}
		}
	}

	public void OnHeroExit(Hero hero)
	{
		if (!Heroes.Contains(hero))
		{
			Diagnostics.LogError(base.name + " > OnHeroExit: hero=" + hero.name + " never entered!");
			return;
		}
		Heroes.Remove(hero);
		tacticalMapElement.SetHeroPresence(Heroes.Count > 0);
		if (!IsOccupied() && !IsPowered)
		{
			if (dungeon.CurrentCrystalState == CrystalState.Plugged)
			{
				ToggleDirtyLightsIntensity(on: false);
			}
			else
			{
				ToggleLowLightsIntensity(on: false);
			}
		}
		if (this.OnRoomContentChanged != null)
		{
			this.OnRoomContentChanged();
		}
		RemoveSimChild(hero, refresh: false);
		if (this.OnEntityExited != null)
		{
			this.OnEntityExited(hero);
		}
		if (IsExitRoom && Room.OnHeroEnteredOrExitedExitRoom != null)
		{
			Room.OnHeroEnteredOrExitedExitRoom(hero, enter: false);
		}
	}

	public void UpdateLightsOnHeroEnter()
	{
		if (!IsPowered)
		{
			if (dungeon.CurrentCrystalState == CrystalState.Plugged)
			{
				TurnDirtyLights(on: true);
				ToggleDirtyLightsIntensity(on: true);
			}
			else
			{
				TurnLowLights(on: true);
				ToggleLowLightsIntensity(on: true);
			}
		}
	}

	public void OnMobEnter(Mob mob, bool randomDelay = true)
	{
		if (!Mobs.Contains(mob))
		{
			_previousRoom = mob.RoomElement.ParentRoom;
			if (_previousRoom != null)
			{
				_previousRoom.OnMobExit(mob, refreshSim: false);
			}
			Mobs.Add(mob);
			AddSimChild(mob, refresh: false);
			if (this.OnRoomContentChanged != null)
			{
				this.OnRoomContentChanged();
			}
			if (this.OnEntityEntered != null)
			{
				this.OnEntityEntered(mob);
			}
			mob.OnMobDeath += Mob_OnMobDeath;
			needSimRefreshOnLateUpdate = true;
			mob.ChangeCurrentRoom(this);
		}
	}

	private void Mob_OnMobDeath(Mob mob)
	{
		if (this.OnMobDied != null)
		{
			this.OnMobDied(mob);
		}
	}

	public void OnMobExit(Mob mob, bool refreshSim = true)
	{
		if (!Mobs.Contains(mob))
		{
			Diagnostics.LogError(base.name + " > OnMobExit: mob=" + mob.name + " never entered!");
			return;
		}
		Mobs.Remove(mob);
		if (this.OnRoomContentChanged != null)
		{
			this.OnRoomContentChanged();
		}
		RemoveSimChild(mob, refresh: false);
		needSimRefreshOnLateUpdate |= refreshSim;
		if (this.OnEntityExited != null)
		{
			this.OnEntityExited(mob);
		}
		mob.OnMobDeath -= Mob_OnMobDeath;
		if (Mobs.Count != 0)
		{
			return;
		}
		for (int i = 0; i < notificationMarkersPriorities.Count; i++)
		{
			RoomMarker roomMarker = notificationMarkersPriorities[i];
			if (roomMarker.Marker.AutoStopWhenSafe)
			{
				RoomMarker roomMarker2 = notificationMarkersPriorities[i];
				roomMarker2.Marker.Invoke("Hide", 1f);
			}
		}
	}

	public void OnNPCEnter(NPC npc)
	{
		if (!NPCs.Contains(npc))
		{
			_previousRoom = npc.RoomElement.ParentRoom;
			if (_previousRoom != null)
			{
				_previousRoom.OnNPCExit(npc);
			}
			NPCs.Add(npc);
			if (this.OnRoomContentChanged != null)
			{
				this.OnRoomContentChanged();
			}
			AddSimChild(npc, refresh: false);
			if (this.OnEntityEntered != null)
			{
				this.OnEntityEntered(npc);
			}
			needSimRefreshOnLateUpdate = true;
			npc.ChangeCurrentRoom(this);
		}
	}

	public void OnNPCExit(NPC npc)
	{
		if (!NPCs.Contains(npc))
		{
			Diagnostics.LogError(base.name + " > OnNPCExit: npc=" + npc.name + " never entered!");
			return;
		}
		NPCs.Remove(npc);
		if (this.OnRoomContentChanged != null)
		{
			this.OnRoomContentChanged();
		}
		RemoveSimChild(npc, refresh: false);
		if (this.OnEntityExited != null)
		{
			this.OnEntityExited(npc);
		}
	}

	public void TurnCleanLights(bool on)
	{
		foreach (CleanLight cleanLight in cleanLights)
		{
			cleanLight.gameObject.SetActive(on);
		}
		if (on && !IsStartRoom)
		{
			dungeon.AddPowerableProps(powerableProps, openDoorPosition);
		}
		if (!IsStartRoom && on)
		{
			ShowFog(show: false);
		}
	}

	public void TurnDirtyLights(bool on)
	{
		DirtyLight[] array = dirtyLights;
		foreach (DirtyLight dirtyLight in array)
		{
			dirtyLight.gameObject.SetActive(on);
		}
	}

	public void TurnLowLights(bool on)
	{
		LowLight[] array = lowLights;
		foreach (LowLight lowLight in array)
		{
			lowLight.gameObject.SetActive(on);
		}
	}

	public void ToggleDirtyLightsIntensity(bool on)
	{
		DirtyLight[] array = dirtyLights;
		foreach (DirtyLight dirtyLight in array)
		{
			dirtyLight.ToggleLightIntensity(on);
		}
		if (!IsStartRoom)
		{
			ShowFog(!on);
		}
	}

	public void ToggleLowLightsIntensity(bool on)
	{
		LowLight[] array = lowLights;
		foreach (LowLight lowLight in array)
		{
			lowLight.ToggleLightIntensity(on);
		}
		if (!IsStartRoom)
		{
			ShowFog(!on);
		}
	}

	public void ShowFog(bool show)
	{
		ParticleSystem[] array = fogOfWarVFXs;
		foreach (ParticleSystem particleSystem in array)
		{
			if (show)
			{
				particleSystem.Play(withChildren: true);
			}
			else
			{
				particleSystem.Stop(withChildren: true);
			}
		}
	}

	public void Open(Door openingDoor, bool ignoreVisibility = false)
	{
		Diagnostics.Log("{0} > Room.Open", base.name);
		if (!IsVisible || ignoreVisibility)
		{
			if (openingDoor != null)
			{
				openDoorPosition = openingDoor.transform.position;
			}
			foreach (Door door in doors)
			{
				if (!(door == null))
				{
					door.Show(this);
					Vector3 eulerAngles = Quaternion.LookRotation(door.transform.position - base.transform.position).eulerAngles;
					door.RoomAngle = eulerAngles.y;
				}
			}
			if (MajorModuleSlot != null)
			{
				MajorModuleSlot.Activate();
			}
			foreach (MinorModuleSlot minorModuleSlot in MinorModuleSlots)
			{
				minorModuleSlot.Activate();
			}
			OpeningIndex = dungeon.OpenRoomsCount - 1;
			dungeon.AddOpenedRoom(this);
			SelectDoorFromRoomAngle(0f);
			if (dungeon.CurrentCrystalState == CrystalState.Plugged)
			{
				ToggleDirtyLightsIntensity(on: false);
				TurnDirtyLights(on: true);
			}
			else
			{
				ToggleLowLightsIntensity(on: false);
				TurnLowLights(on: true);
			}
			base.gameObject.SetActive(value: true);
			IsVisible = true;
			IGameCameraService service = Services.GetService<IGameCameraService>();
			Vector3 position = base.transform.position;
			float x = position.x;
			Vector3 size = Size;
			float left = x - size.x / 2f;
			Vector3 position2 = base.transform.position;
			float z = position2.z;
			Vector3 size2 = Size;
			float top = z - size2.z / 2f;
			Vector3 size3 = Size;
			float x2 = size3.x;
			Vector3 size4 = Size;
			service.AddVisibleZone(new Rect(left, top, x2, size4.z));
			selectableForMove.SetSize(Size);
			selectableForMove.Register();
			selectableForBuild.SetSize(Size);
			selectableForBuild.Register();
		}
	}

	public void InitAgents()
	{
		if (!IsVisible)
		{
			return;
		}
		if (IsFullyOpened)
		{
			Diagnostics.LogError("{0} > Room.InitAgents: Room already initialized!", base.name);
			return;
		}
		RoomDefenseSpot[] componentsInChildren = GetComponentsInChildren<RoomDefenseSpot>();
		RoomDefenseSpot[] array = componentsInChildren;
		foreach (RoomDefenseSpot roomDefenseSpot in array)
		{
			roomDefenseSpot.Init(this);
		}
		if (IsFullyOpened)
		{
			WasAlreadyOpen = true;
		}
		IsFullyOpened = true;
		if (this.OnRoomContentChanged != null)
		{
			this.OnRoomContentChanged();
		}
		if (dungeon.CurrentCrystalState == CrystalState.Unplugged && gameNetManager.IsServerOrSinglePlayer())
		{
			OpenDoorsForCrystalPhase();
		}
	}

	public bool Hide()
	{
		foreach (Door door in doors)
		{
			if (!(door == null))
			{
				door.Hide();
			}
		}
		base.gameObject.SetActive(value: false);
		IsVisible = false;
		return true;
	}

	public void SelectDoorFromRoomAngle(float targetRoomAngle)
	{
		RemoveOpenedDoors();
		float num = float.PositiveInfinity;
		Door x = null;
		foreach (Door door in doors)
		{
			if (!(door == null))
			{
				float num2 = Mathf.Abs(Mathf.DeltaAngle(targetRoomAngle, door.RoomAngle));
				if (num2 < num)
				{
					x = door;
					num = num2;
				}
			}
		}
		if (x != null)
		{
			selectedDoor = x;
		}
	}

	public Door GetSelectedDoor()
	{
		RemoveOpenedDoors();
		if (selectedDoor == null && doors.Count > 0)
		{
			selectedDoor = doors[0];
		}
		return selectedDoor;
	}

	public Door GetOpeningDoor()
	{
		foreach (Door door in doors)
		{
			if (door != null && door.IsOpening)
			{
				return door;
			}
		}
		Diagnostics.LogWarning("No opening door found!");
		return null;
	}

	public void RemoveOpenedDoors()
	{
		for (int i = 0; i < doors.Count; i++)
		{
			Door door = doors[i];
			if (door == null)
			{
				doors.Remove(door);
				i--;
			}
		}
	}

	public int GetWallsTileSetVariance(int tileSetCount)
	{
		if (wallsTileSetVariance < 0)
		{
			wallsTileSetVariance = RandomGenerator.RangeInt(0, tileSetCount);
		}
		return wallsTileSetVariance;
	}

	public void PlayDustLootVFX(int dustLootAmount)
	{
		FloorTile[] array = floorTiles;
		foreach (FloorTile floorTile in array)
		{
			floorTile.PlayDustLootVFX(dustLootAmount, base.transform.position);
		}
	}

	public void MoveSelectedHeroesToRoom()
	{
		foreach (Hero selectedHero in Hero.SelectedHeroes)
		{
			selectedHero.MoveToRoom(this);
		}
	}

	public void InteractWithRoomInteractible()
	{
		if (NPCs.Count > 0)
		{
			(NPCs[0] as NPCMerchant).BeginInteraction(null);
			return;
		}
		if (Heroes.Count > 0)
		{
			for (int i = 0; i < Heroes.Count; i++)
			{
				Hero hero = Heroes[i];
				if (!hero.IsRecruited)
				{
					hero.DisplayRecruitmentDialog();
					return;
				}
			}
		}
		if (MajorModule != null && MajorModule is SpecialMajorModule)
		{
			(MajorModule as SpecialMajorModule).Interact(null);
		}
	}

	public void DisplayWaveOffscreenMarker()
	{
		netSyncElement.SendRPCToAll(UniqueIDRPC.Room_DoDisplayWaveOffscreenMarker);
	}

	private void RPC_DoDisplayWaveOffscreenMarker()
	{
		DisplayOffscreenMarker(waveIconData);
	}

	public OffscreenMarker DisplayOffscreenMarker(OffscreenMarker.OffscreenMarkerData markerData)
	{
		RoomMarker roomMarker = default(RoomMarker);
		bool flag = false;
		for (int i = 0; i < notificationMarkersPriorities.Count; i++)
		{
			RoomMarker roomMarker2 = notificationMarkersPriorities[i];
			if (roomMarker2.Anim == markerData.IconAnim && roomMarker2.Priority == markerData.Priority)
			{
				roomMarker = roomMarker2;
				flag = true;
				break;
			}
		}
		if (flag)
		{
			OffscreenMarker marker = roomMarker.Marker;
			marker.UpdateDisplayDuration(markerData.Duration);
			return marker;
		}
		OffscreenMarker offscreenMarker = dungeon.DisplayOffscreenMarker(CenterPosition, markerData);
		offscreenMarker.AutoStopWhenSafe = markerData.AutoStopWhenSafe;
		offscreenMarker.OnHide += OnMarkerHide;
		AddNewMarker(offscreenMarker, markerData.Priority, markerData.IconAnim, markerData.AlwaysVisible);
		return offscreenMarker;
	}

	public void UpdateSupportEffectVFXs()
	{
		for (int i = 0; i < Heroes.Count; i++)
		{
			Heroes[i].UpdateSupportEffectVFXs(IsPowered && !SuffersEMP);
		}
	}

	protected override void Awake()
	{
		base.Awake();
		audioEmitter = GetComponent<AudioEmitter>();
		netSyncElement = GetComponent<UniqueIDNetSyncElement>();
		selectableForMove = GetComponent<RoomForMoveSelectable>();
		selectableForBuild = GetComponent<RoomForBuildSelectable>();
		gameEventManager = Services.GetService<IGameEventService>();
		dungeon = SingletonManager.Get<Dungeon>();
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
		doors = new List<Door>();
		Depth = -1;
	}

	private void Dungeon_OnCrystalStateChanged(CrystalState state)
	{
		if (!IsVisible)
		{
			return;
		}
		switch (state)
		{
		case CrystalState.Plugged:
			TurnCleanLights(IsPowered);
			TurnDirtyLights(!IsPowered);
			TurnLowLights(on: false);
			break;
		case CrystalState.Unplugged:
			if (!IsPowered)
			{
				TurnDirtyLights(on: false);
				TurnLowLights(on: true);
				ToggleLowLightsIntensity(IsOccupied());
			}
			if (gameNetManager.IsServerOrSinglePlayer())
			{
				OpenDoorsForCrystalPhase();
			}
			break;
		}
	}

	private void OpenDoorsForCrystalPhase()
	{
		if (dungeon.CurrentCrystalState != CrystalState.Unplugged)
		{
			Diagnostics.LogError("{0} > Room.OpenDoorsForCrystalPhase: shouldn't be called when crystal is not unplugged ({1})!", base.name, dungeon.CurrentCrystalState);
			return;
		}
		int count = doors.Count;
		for (int i = 0; i < count; i++)
		{
			doors[i].OpenForCrystalPhase(this);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		_roomDetector = other.GetComponent<RoomDetector>();
		if (_roomDetector != null)
		{
			switch (_roomDetector.Type)
			{
			case RoomDetectorType.Hero:
				OnHeroEnter(_roomDetector.Hero);
				break;
			case RoomDetectorType.Mob:
				OnMobEnter(_roomDetector.Mob);
				break;
			case RoomDetectorType.NPC:
				OnNPCEnter(_roomDetector.NPC);
				break;
			}
		}
	}

	protected override void Update()
	{
		base.Update();
		if (updateMarkersVisibility)
		{
			updateMarkersVisibility = false;
			UpdateMarkersVisibility();
		}
		if (!IsFullyOpened)
		{
			return;
		}
		if (!toxicCloudVFXs[0].isPlaying && GetSimPropertyValue(SimulationProperties.ToxicCloud) > 0f)
		{
			ParticleSystem[] array = toxicCloudVFXs;
			foreach (ParticleSystem particleSystem in array)
			{
				particleSystem.Play(withChildren: true);
			}
		}
		else if (toxicCloudVFXs[0].isPlaying && GetSimPropertyValue(SimulationProperties.ToxicCloud) == 0f)
		{
			ParticleSystem[] array2 = toxicCloudVFXs;
			foreach (ParticleSystem particleSystem2 in array2)
			{
				particleSystem2.Stop(withChildren: true);
			}
		}
	}

	private void AddNewMarker(OffscreenMarker newMarker, int priority, AnimationClip anim, bool alwaysVisible)
	{
		notificationMarkersPriorities.Add(new RoomMarker
		{
			Marker = newMarker,
			Priority = priority,
			Anim = anim,
			AlwaysVisible = alwaysVisible
		});
		notificationMarkersPriorities.OrderByDescending((RoomMarker m) => m.Priority);
		updateMarkersVisibility = true;
	}

	private void UpdateMarkersVisibility()
	{
		bool flag = (!IsPowered || IsStartRoom) && !IsOccupied();
		for (int i = 0; i < notificationMarkersPriorities.Count; i++)
		{
			RoomMarker roomMarker = notificationMarkersPriorities[i];
			OffscreenMarker marker = roomMarker.Marker;
			RoomMarker roomMarker2 = notificationMarkersPriorities[i];
			marker.Show(roomMarker2.AlwaysVisible || (flag && i == 0));
		}
	}

	private void OnLeftClickUp(ClickUpInfo clickInfo)
	{
		if (!clickInfo.Dragged)
		{
			IGameControlService service = Services.GetService<IGameControlService>();
			if (service.RoomPowerMode)
			{
				TogglePower();
			}
		}
	}

	private void OnRightClickDown(ClickDownInfo clickInfo)
	{
		foreach (ClickDownInfo rightClickInfo in Services.GetService<IInputService>().RightClickInfos)
		{
			if (!(rightClickInfo.HitCollider.gameObject == base.gameObject) && !(rightClickInfo.HitCollider.GetComponent<FloorTile>() != null) && !(rightClickInfo.HitCollider.GetComponent<CameraDragSupport>() != null) && !(rightClickInfo.HitCollider.GetComponent<OffscreenMarker>() != null) && !(rightClickInfo.HitCollider.GetComponent<ModuleSlot>() != null))
			{
				return;
			}
		}
		if (Hero.SelectedHeroes.Count > 0)
		{
			MoveSelectedHeroesToRoom();
			Services.GetService<IInputService>().StopClickEventPropagation();
		}
	}

	private void OnMiddleClickDown(ClickDownInfo clickInfo)
	{
		if (!IsStartRoom)
		{
			TogglePower();
			Services.GetService<IInputService>().StopClickEventPropagation();
		}
	}

	private void OnMarkerHide(OffscreenMarker marker)
	{
		if (notificationMarkersPriorities.Count <= 0)
		{
			return;
		}
		RoomMarker roomMarker = notificationMarkersPriorities[0];
		OffscreenMarker marker2 = roomMarker.Marker;
		int num = notificationMarkersPriorities.RemoveAll((RoomMarker m) => m.Marker == marker);
		if (num > 0 && notificationMarkersPriorities.Count > 0)
		{
			RoomMarker roomMarker2 = notificationMarkersPriorities[0];
			OffscreenMarker marker3 = roomMarker2.Marker;
			if (marker2 != marker3)
			{
				marker3.Show(show: true);
			}
		}
	}

	private void LateUpdate()
	{
		if (needSimRefreshOnLateUpdate)
		{
			dungeon.RefreshSim();
			needSimRefreshOnLateUpdate = false;
		}
	}

	public bool HasDestructibleModules()
	{
		if (MajorModule != null && !MajorModule.Config.Unremovable)
		{
			return true;
		}
		for (int i = 0; i < MinorModules.Count; i++)
		{
			if (!MinorModules[i].Config.Unremovable)
			{
				return true;
			}
		}
		return false;
	}

	private void OnDestroy()
	{
		if (gameNetManager == null)
		{
			gameNetManager = SingletonManager.Get<GameNetworkManager>();
		}
		if (gameNetManager != null)
		{
			gameNetManager.ClearCachedAITargets(this);
		}
	}
}
public class RoomCenter : MonoBehaviour
{
}
public class RoomDefenseSpot : MonoBehaviour
{
	public void Init(Room parentRoom)
	{
		GetComponent<RoomElement>().SetParentRoom(parentRoom);
		GetComponent<UniqueID>().RequestUniqueID();
		GetComponent<AITarget>().Init(this);
	}

	private void OnDestroy()
	{
		GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
		if (gameNetworkManager != null)
		{
			gameNetworkManager.ClearCachedAITargets(this);
		}
	}
}
public enum RoomDetectorType
{
	Hero,
	Mob,
	NPC
}
public class RoomDetector : MonoBehaviour
{
	[SerializeField]
	private RoomDetectorType type;

	[SerializeField]
	private Hero hero;

	[SerializeField]
	private Mob mob;

	[SerializeField]
	private NPC npc;

	public Hero Hero => hero;

	public Mob Mob => mob;

	public NPC NPC => npc;

	public RoomDetectorType Type => type;
}
public class RoomDustLootVFX : MonoBehaviour
{
	[SerializeField]
	private float moveSpeed;

	[SerializeField]
	private GameObject[] vfxPfbs;

	private ParticleSystem vfx;

	private bool isLaunched;

	private Vector3 targetPos;

	private GameObject vfxGO;

	public void Init(int dustLootAmount, Vector3 targetPos)
	{
		this.targetPos = targetPos;
		isLaunched = true;
		GameObjectPoolManager gameObjectPoolManager = SingletonManager.Get<GameObjectPoolManager>();
		GameObject vFXPfb = GetVFXPfb(dustLootAmount);
		vfxGO = gameObjectPoolManager.Instantiate(vFXPfb, base.transform.position, Quaternion.identity, base.transform);
		vfx = vfxGO.GetComponent<ParticleSystem>();
		vfx.Play(withChildren: true);
	}

	private GameObject GetVFXPfb(int dustLootAmount)
	{
		return vfxPfbs.GetRandom();
	}

	private void Update()
	{
		if (isLaunched)
		{
			base.transform.position += (targetPos - base.transform.position).normalized * Time.deltaTime * moveSpeed;
			if (!vfx.isPlaying)
			{
				GameObjectPoolManager gameObjectPoolManager = SingletonManager.Get<GameObjectPoolManager>();
				gameObjectPoolManager.Recycle(vfxGO);
				gameObjectPoolManager.Recycle(base.gameObject);
			}
		}
	}
}
public class RoomElement : MonoBehaviour
{
	public delegate void OnParentRoomChangedHandler(Room previousParentRoom, Room newParentRoom);

	public Room ParentRoom
	{
		get;
		private set;
	}

	public event OnParentRoomChangedHandler OnParentRoomChanged;

	public virtual void SetParentRoom(Room newParentRoom)
	{
		Room parentRoom = ParentRoom;
		ParentRoom = newParentRoom;
		if (this.OnParentRoomChanged != null)
		{
			this.OnParentRoomChanged(parentRoom, newParentRoom);
		}
	}
}
public class RoomInteractiveElement : RoomElement
{
	protected WorldPosGUI gui;

	protected RoomSelectable roomSelectable;

	private IGameCameraService gameCamManager;

	protected virtual void Awake()
	{
		gui = GetComponent<WorldPosGUI>();
	}

	public override void SetParentRoom(Room parentRoom)
	{
		base.SetParentRoom(parentRoom);
		roomSelectable = parentRoom.GetComponent<RoomSelectable>();
		roomSelectable.OnSelected += RefreshGUIVisibility;
		roomSelectable.OnUnselected += RefreshGUIVisibility;
		gameCamManager = Services.GetService<IGameCameraService>();
		gameCamManager.OnBeginTacticalMapCameraToggle += OnTacticalMapCameraToggled;
		gameCamManager.OnEndTacticalMapCameraToggle += OnTacticalMapCameraToggled;
	}

	protected virtual bool ShouldGUIBeDisplayed()
	{
		return roomSelectable.IsSelected && !gameCamManager.IsTacticalMapActive();
	}

	private void OnTacticalMapCameraToggled(bool on)
	{
		RefreshGUIVisibility();
	}

	protected void RefreshGUIVisibility()
	{
		gui.SetVisibility(ShouldGUIBeDisplayed());
	}
}
public class RoomLight : MonoBehaviour
{
}
[RequireComponent(typeof(Mover))]
public class RoomPowerVFX : MonoBehaviour
{
	[SerializeField]
	private float minMoveSpeed;

	[SerializeField]
	private float maxMoveSpeed;

	[SerializeField]
	private float destroyDelay;

	[SerializeField]
	private ParticleSystem particles;

	[SerializeField]
	private TrailRenderer trail;

	private Mover mover;

	private ModuleSlot targetSlot;

	private float trailTime;

	public static int VFXCount
	{
		get;
		private set;
	}

	private void Awake()
	{
		mover = GetComponent<Mover>();
		mover.MoveSpeed = RandomGenerator.RangeFloat(minMoveSpeed, maxMoveSpeed);
		if (trail != null)
		{
			trailTime = trail.time;
		}
		VFXCount++;
	}

	public void Init(ModuleSlot targetSlot)
	{
		this.targetSlot = targetSlot;
		Init(targetSlot.transform.position);
	}

	public void Init(Vector3 destPos)
	{
		StartCoroutine(InitCoroutine(destPos));
	}

	private IEnumerator InitCoroutine(Vector3 destPos)
	{
		mover.enabled = false;
		yield return null;
		if (trail != null)
		{
			trail.time = trailTime;
		}
		if (particles != null)
		{
			particles.Play();
		}
		mover.enabled = true;
		mover.MoveToPosition(destPos, OnMoveTargetReached);
	}

	private void OnMoveTargetReached()
	{
		if (targetSlot != null)
		{
			targetSlot.PlayPowerVFX();
		}
		if (particles != null)
		{
			particles.Stop(withChildren: true);
		}
		Invoke("SelfDestruct", destroyDelay);
	}

	public void SelfDestruct()
	{
		if (base.gameObject.activeSelf)
		{
			StartCoroutine(SelfDestructCoroutine());
		}
	}

	private IEnumerator SelfDestructCoroutine()
	{
		if (trail != null)
		{
			trail.time = 0f;
		}
		if (particles != null)
		{
			particles.Stop(withChildren: true);
			particles.Clear(withChildren: true);
		}
		mover.enabled = false;
		yield return null;
		GameObjectPoolManager goPoolManager = SingletonManager.Get<GameObjectPoolManager>();
		goPoolManager.Recycle(base.gameObject);
		VFXCount--;
	}
}
public class RoomProp : MonoBehaviour
{
}
public class RoomTacticalMapElement : TacticalMapElement
{
	[SerializeField]
	private float spriteBaseSize;

	private Room room;

	private IAudioEventService audioManager;

	protected override void Awake()
	{
		base.Awake();
		audioManager = Services.GetService<IAudioEventService>();
	}

	public void Init(Room room)
	{
		this.room = room;
		SetSize(this.room.Size);
	}

	public void SetSize(Vector3 size)
	{
		((BoxCollider)GetComponent<Collider>()).size = new Vector3(spriteBaseSize, spriteBaseSize, 1f);
		base.transform.localScale = new Vector3(size.x / spriteBaseSize, size.z / spriteBaseSize, 1f);
	}

	public void SetPower(bool power)
	{
		anim.SetBool(SpriteAnimationBool.IsPowered, power);
	}

	public void SetHeroPresence(bool heroPresence)
	{
		anim.SetBool(SpriteAnimationBool.IsOccupiedByHeroes, heroPresence);
	}

	public void SetModulePresence(bool hasModules)
	{
		anim.SetBool(SpriteAnimationBool.HasModules, hasModules);
	}

	private void OnMouseWheelUp()
	{
		ZoomIn();
		Services.GetService<IInputService>().StopMouseWheelEventPropagation();
	}

	private void OnLeftClickDown(ClickDownInfo clickInfo)
	{
		IGameControlService service = Services.GetService<IGameControlService>();
		if (service.RoomPowerMode)
		{
			room.TogglePower();
			return;
		}
		ZoomIn();
		audioManager.Play2DEvent("Master/GUI/MapClick");
	}

	private void OnRightClickDown(ClickDownInfo clickInfo)
	{
		room.MoveSelectedHeroesToRoom();
	}

	private void OnMiddleClickDown(ClickDownInfo clickInfo)
	{
		room.TogglePower();
	}

	private void ZoomIn()
	{
		if (gameCamManager == null)
		{
			gameCamManager = Services.GetService<IGameCameraService>();
		}
		gameCamManager.MoveTo(base.transform.position);
		gameCamManager.SwitchToGameCamera();
	}
}
public class TacticalMapElement : MonoBehaviour
{
	protected IGameCameraService gameCamManager;

	protected SpriteAnimationRuntime2 anim;

	protected virtual bool ShouldBeDisplayed()
	{
		return gameCamManager != null && (gameCamManager.IsTacticalMapActive() || gameCamManager.IsSwitchingCamera);
	}

	protected virtual void Awake()
	{
		anim = GetComponent<SpriteAnimationRuntime2>();
	}

	private IEnumerator Start()
	{
		for (gameCamManager = Services.GetService<IGameCameraService>(); gameCamManager == null; gameCamManager = Services.GetService<IGameCameraService>())
		{
			yield return null;
		}
		gameCamManager.OnBeginTacticalMapCameraToggle += OnBeginOrEndTacticalMapCameraToggle;
		gameCamManager.OnEndTacticalMapCameraToggle += OnBeginOrEndTacticalMapCameraToggle;
		OnBeginOrEndTacticalMapCameraToggle(ShouldBeDisplayed());
	}

	private void OnDestroy()
	{
		if (gameCamManager != null)
		{
			gameCamManager.OnEndTacticalMapCameraToggle -= OnBeginOrEndTacticalMapCameraToggle;
			gameCamManager.OnBeginTacticalMapCameraToggle -= OnBeginOrEndTacticalMapCameraToggle;
		}
	}

	private void OnBeginOrEndTacticalMapCameraToggle(bool on)
	{
		if (ShouldBeDisplayed())
		{
			anim.Play();
		}
		else
		{
			anim.Stop();
		}
	}
}
public class VFXZone : MonoBehaviour
{
	[SerializeField]
	private Vector2 fogSizeCoefficient;

	[SerializeField]
	private Vector2 fogSizeMin;

	[SerializeField]
	private Vector2 fogSizeMax;

	[SerializeField]
	private float bigSize;

	[SerializeField]
	private float bigSizeReduction;

	[SerializeField]
	private float fogDensityCoefficient;

	private Room room;

	private float particleScaleX;

	private float particleScaleY;

	private float fogMult;

	private BoxCollider boxCollider;

	private bool isInit;

	public bool DefaultSize;

	public void Init()
	{
		room = GetComponentInParent<Room>();
		boxCollider = (GetComponent<Collider>() as BoxCollider);
		if (boxCollider == null)
		{
			Diagnostics.LogError("VFXZone of room " + room.name + " has no BoxCollider component.");
			return;
		}
		Vector3 size = boxCollider.size;
		particleScaleX = size.x * size.x * fogSizeCoefficient.x / 1000f;
		particleScaleY = size.z * size.z * fogSizeCoefficient.y / 1000f;
		if (DefaultSize)
		{
			particleScaleX = Mathf.Min(fogSizeMax.x, Mathf.Max(fogSizeMin.x, particleScaleX));
			particleScaleY = Mathf.Min(fogSizeMax.y, Mathf.Max(fogSizeMin.y, particleScaleY));
		}
		if (size.x >= bigSize)
		{
			particleScaleX *= bigSizeReduction;
		}
		if (size.y >= bigSize)
		{
			particleScaleY *= bigSizeReduction;
		}
		fogMult = size.x * size.z * fogDensityCoefficient / 1000f;
		isInit = true;
		UnityEngine.Object.Destroy(boxCollider);
	}

	public ParticleSystem AdaptVFXToRoom(GameObject particlePfb, bool ignoreSubEmitters = false)
	{
		if (!isInit)
		{
			Init();
		}
		ParticleSystem component = (UnityEngine.Object.Instantiate(particlePfb, base.transform.position, Quaternion.identity) as GameObject).GetComponent<ParticleSystem>();
		component.transform.parent = base.transform;
		component.transform.rotation = particlePfb.transform.rotation;
		component.transform.localPosition = boxCollider.center + particlePfb.transform.localPosition;
		Transform transform = component.transform;
		float x = particleScaleX;
		float y = particleScaleY;
		Vector3 localScale = component.transform.localScale;
		transform.localScale = new Vector3(x, y, localScale.z);
		ParticleSystem[] componentsInChildren = component.GetComponentsInChildren<ParticleSystem>();
		ParticleSystem[] array = componentsInChildren;
		foreach (ParticleSystem particleSystem in array)
		{
			if (!ignoreSubEmitters || particleSystem.enableEmission || !(particleSystem != component))
			{
				particleSystem.emissionRate *= fogMult;
			}
		}
		return component;
	}
}
public class GameManager : Amplitude.Unity.Game.GameManager
{
	public class Preferences
	{
		private static GameGraphicSettings gameGraphicSettings;

		public static GameGraphicSettings GameGraphicSettings => gameGraphicSettings;

		static Preferences()
		{
			gameGraphicSettings = new GameGraphicSettings();
		}
	}

	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		if (base.LastError == 0)
		{
			IPlatformService steamManager;
			for (steamManager = Services.GetService<IPlatformService>(); steamManager == null; steamManager = Services.GetService<IPlatformService>())
			{
				yield return null;
			}
			if (steamManager.IsPlatformSpecificRunning)
			{
				SetLastError(0, "Waiting for service dependencies...");
				yield return BindService(delegate(INetworkingService service)
				{
					RegisterSteamNetworkingMessageClasses(service);
				});
			}
		}
	}

	protected override IEnumerator OnCreateGameAsync()
	{
		yield return base.OnCreateGameAsync();
		Game game = Game as Game;
		if (game == null)
		{
			throw new GameException("Invalid null game.");
		}
		yield return game.Launch();
	}

	private void RegisterSteamNetworkingMessageClasses(INetworkingService steamNetworkingService)
	{
		if (steamNetworkingService == null)
		{
			SetLastError(10, "The steam networking service is down; cannot register the game client & server messages for translation.");
		}
		else
		{
			SetLastError(0, "All steam networking messages have been registered.");
		}
	}

	public override void ReleaseGame()
	{
		base.ReleaseGame();
		StartCoroutine(DungeonsApplication.FreeMemory());
	}
}
public class EquipmentSlot
{
	public delegate void ItemChangedHandler(EquipmentSlot sender, InventoryItem item, bool equip);

	private SimMonoBehaviour parentSimMB;

	private int slotIndex;

	private NetSyncElement parentNetSyncElement;

	private IInputService inputService;

	public EquipmentSlotConfig CategoryParameters
	{
		get;
		set;
	}

	public InventoryItem EquippedItem
	{
		get;
		private set;
	}

	public Hero ParentHero
	{
		get;
		private set;
	}

	public event ItemChangedHandler OnItemChanged;

	public EquipmentSlot(int slotIndex, EquipmentSlotConfig categoryParameters, SimMonoBehaviour parentSimMB)
	{
		this.slotIndex = slotIndex;
		EquippedItem = null;
		CategoryParameters = categoryParameters;
		this.parentSimMB = parentSimMB;
		ParentHero = (parentSimMB as Hero);
		parentNetSyncElement = parentSimMB.GetComponent<NetSyncElement>();
		Diagnostics.Assert(this.parentSimMB != null);
	}

	public static EquipmentSlot GetBestEquipmentSlotForItem(EquipmentSlot[] slots, InventoryItem item)
	{
		EquipmentSlot equipmentSlot = null;
		for (int i = 0; i < slots.Length; i++)
		{
			if (slots[i].CanHoldItem(item))
			{
				if (slots[i].EquippedItem == null)
				{
					equipmentSlot = slots[i];
					break;
				}
				if (equipmentSlot == null)
				{
					equipmentSlot = slots[i];
				}
			}
		}
		return equipmentSlot;
	}

	public bool CanHoldItem(InventoryItem item)
	{
		if (EquippedItem != null && EquippedItem.ItemConfig.CannotBeUnequipped)
		{
			return false;
		}
		return item.ItemConfig.CategoryParameters.IsCategoryMatching(CategoryParameters);
	}

	public bool CanEquipItem(InventoryItem item, bool checkItemInventory = true)
	{
		if (item == null)
		{
			Diagnostics.LogError("EquipmentSlot.CanEquipItem: item is null!");
			return false;
		}
		if (checkItemInventory)
		{
			if (item.CurrentInventory == null)
			{
				Diagnostics.LogError("EquipmentSlot.CanEquipItem: item is in no inventory!");
				return false;
			}
			if (item.CurrentInventory.Name != Inventory.SharedInventoryName && item.CurrentInventory.Name != Inventory.BackpackInventoryName)
			{
				Diagnostics.LogError("EquipmentSlot.CanEquipItem: item is not in general or backpack inventory! ({0})", item.CurrentInventory.Name);
				return false;
			}
		}
		if (EquippedItem == item)
		{
			Diagnostics.LogError("EquipmentSlot.CanEquipItem: item already equipped on this slot!");
			return false;
		}
		if (item.OwnerPlayerID != 0 && item.OwnerPlayerID != parentNetSyncElement.OwnerPlayerID && item.CurrentInventory.Name != Inventory.SharedInventoryName)
		{
			Diagnostics.LogError("EquipmentSlot.CanEquipItem: item owner is not local player! (owner={0}, local={1})", item.OwnerPlayerID, parentNetSyncElement.OwnerPlayerID);
			return false;
		}
		return true;
	}

	public void EquipItem(InventoryItem item, bool removeFromInventory = true, bool netSync = true, bool skipRequestToServer = false, bool checkItemInventory = true)
	{
		if (CanEquipItem(item, checkItemInventory))
		{
			if (!skipRequestToServer && SingletonManager.Get<GameNetworkManager>().IsMultiplayerSession() && !MultiplayerConfig.SplitInventory)
			{
				parentNetSyncElement.SendRPCToServer(parentSimMB.GetType(), "RequestEquipItemFromEquipmentSlot", item.UniqueIDCategory, item.UniqueID, slotIndex, removeFromInventory, netSync, checkItemInventory);
			}
			else
			{
				ParentHero.EquipItemOnSlot(slotIndex, item, removeFromInventory, netSync, checkItemInventory);
			}
		}
	}

	public void RequestEquipItem(InventoryItem item, bool removeFromInventory, bool netSync, bool checkItemInventory)
	{
		if (CanEquipItem(item, checkItemInventory))
		{
			ParentHero.EquipItemOnSlot(slotIndex, item, removeFromInventory, netSync, checkItemInventory);
		}
	}

	public void DoEquipItem(InventoryItem item, bool removeFromInventory, bool netSync, bool checkItemInventory = true)
	{
		if (!CanEquipItem(item, checkItemInventory))
		{
			return;
		}
		InventoryItem equippedItem = EquippedItem;
		Inventory currentInventory = item.CurrentInventory;
		if (removeFromInventory)
		{
			if (EquippedItem != null)
			{
				UnequipItem(netSync: false);
			}
			if (item.CurrentInventory != null)
			{
				item.CurrentInventory.RemoveItem(item);
			}
		}
		EquippedItem = item;
		parentSimMB.AddSimChild(item);
		item.OwnerPlayerID = ParentHero.NetSyncElement.OwnerPlayerID;
		if (inputService == null)
		{
			inputService = Services.GetService<IInputService>();
		}
		if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard && removeFromInventory && equippedItem != null && equippedItem.CurrentInventory != currentInventory)
		{
			equippedItem.MoveToInventory(currentInventory);
		}
		if (this.OnItemChanged != null)
		{
			this.OnItemChanged(this, EquippedItem, equip: true);
		}
	}

	public bool CanUnequipItem(bool checkConfig = true)
	{
		if (EquippedItem == null)
		{
			Diagnostics.LogError("EquipmentSlot.CanUnequipItem: no equipped item on this slot!");
			return false;
		}
		if (checkConfig && EquippedItem.ItemConfig.CannotBeUnequipped)
		{
			return false;
		}
		return true;
	}

	public void UnequipItem(bool netSync = true, bool checkConfig = true)
	{
		if (CanUnequipItem(checkConfig))
		{
			ParentHero.UnequipItemFromSlot(slotIndex, netSync, checkConfig);
		}
	}

	public void DoUnequipItem(bool checkConfig = true)
	{
		if (CanUnequipItem(checkConfig))
		{
			parentSimMB.RemoveSimChild(EquippedItem);
			InventoryItem equippedItem = EquippedItem;
			EquippedItem = null;
			if (this.OnItemChanged != null)
			{
				this.OnItemChanged(this, equippedItem, equip: false);
			}
			SingletonManager.Get<Dungeon>().GetBestAvailableInventoryForPlayer(equippedItem.OwnerPlayerID).AddItem(equippedItem);
		}
	}

	public void OnSlotPanelClick()
	{
		if (!(InventoryListPanel.SelectedGuiItem != null) || InventoryListPanel.SelectedGuiItem.GetItem() == null)
		{
			return;
		}
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		InventoryItem item = InventoryListPanel.SelectedGuiItem.GetItem();
		Inventory currentInventory = item.CurrentInventory;
		EquipmentSlotItem equipmentSlotItem = InventoryListPanel.SelectedGuiItem as EquipmentSlotItem;
		if (equipmentSlotItem != null)
		{
			equipmentSlotItem.UnequipCurrentItem();
			EquipCurrentItem(item);
		}
		else if (currentInventory == dungeon.SharedInventory || currentInventory == dungeon.BackpackInventory)
		{
			EquipCurrentItem();
		}
		else if (currentInventory != null)
		{
			NPCMerchant nPCMerchant = currentInventory.ParentSimMB as NPCMerchant;
			if (InventoryListPanel.SelectedGuiItem.GetItem().CanBuy(nPCMerchant))
			{
				BuyAndEquipCurrentItem();
			}
			else
			{
				dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_ItemBuyFailResources" + nPCMerchant.CurrencyCfg.Name));
			}
		}
	}

	private void EquipCurrentItem(InventoryItem inventoryItem = null)
	{
		if (inventoryItem == null && (InventoryListPanel.SelectedGuiItem == null || InventoryListPanel.SelectedGuiItem.GetItem() == null))
		{
			return;
		}
		InventoryItem item = inventoryItem ?? InventoryListPanel.SelectedGuiItem.GetItem();
		EquipItem(item);
		if (InventoryListPanel.SelectedGuiItem != null && InventoryListPanel.SelectedGuiItem.GetItem() != null)
		{
			InventoryListPanel inventoryListPanel = InventoryListPanel.SelectedGuiItem.GetInventoryListPanel();
			if (inventoryListPanel != null)
			{
				inventoryListPanel.SelectItem(null);
			}
		}
	}

	private void BuyAndEquipCurrentItem()
	{
		if (!(InventoryListPanel.SelectedGuiItem == null) && InventoryListPanel.SelectedGuiItem.GetItem() != null)
		{
			InventoryItem item = InventoryListPanel.SelectedGuiItem.GetItem();
			parentNetSyncElement.SendRPCToServer(parentSimMB.GetType(), "RequestBuyItemFromEquipmentSlot", item.UniqueIDCategory, item.UniqueID, slotIndex, SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID());
		}
	}

	public void DoBuyCurrentItem(InventoryItem item)
	{
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		if (EquippedItem != null)
		{
			EquippedItem.MoveToInventory(dungeon.GetBestAvailableInventoryForPlayer(item.OwnerPlayerID));
		}
		EquipItem(item);
		if (InventoryListPanel.SelectedGuiItem != null)
		{
			InventoryListPanel inventoryListPanel = InventoryListPanel.SelectedGuiItem.GetInventoryListPanel();
			if (inventoryListPanel != null)
			{
				inventoryListPanel.SelectItem(null);
				inventoryListPanel.RefreshContent();
			}
		}
	}
}
public class Inventory : SimulationObjectWrapper
{
	public delegate void ItemAddedHandler(InventoryItem item);

	public delegate void ItemRemovedHandler(InventoryItem item);

	public static readonly StaticString SharedInventoryName = "SharedInventory";

	public static readonly StaticString BackpackInventoryName = "BackpackInventory";

	public static readonly StaticString MerchantInventoryName = "Merchant#{0}Inventory";

	private static SimulationDescriptor inventoryClassDescriptor;

	public ItemAddedHandler OnItemAdded;

	public ItemRemovedHandler OnItemRemoved;

	private int capacity;

	public SimMonoBehaviour ParentSimMB
	{
		get;
		private set;
	}

	public List<InventoryItem> Items
	{
		get;
		private set;
	}

	public Inventory(StaticString name, SimMonoBehaviour parentSimMB, int capacity = -1)
		: base(name)
	{
		Items = new List<InventoryItem>();
		ParentSimMB = parentSimMB;
		ParentSimMB.AddSimChild(this);
		if (inventoryClassDescriptor == null)
		{
			inventoryClassDescriptor = SimMonoBehaviour.GetDBDescriptorByName("Inventory");
		}
		AddDescriptor(inventoryClassDescriptor);
		this.capacity = capacity;
	}

	public static Inventory GetBestAvailableInventory(Inventory[] inventories, ulong playerID)
	{
		for (int i = 0; i < inventories.Length; i++)
		{
			if (inventories[i].IsAvailableForPlayer(playerID))
			{
				return inventories[i];
			}
		}
		return null;
	}

	public bool IsAvailableForPlayer(ulong playerID)
	{
		if (capacity < 0)
		{
			return true;
		}
		int num = 0;
		for (int i = 0; i < Items.Count; i++)
		{
			if (Items[i].OwnerPlayerID == playerID || Items[i].OwnerPlayerID == ulong.MaxValue)
			{
				num++;
			}
		}
		if (num < capacity)
		{
			return true;
		}
		return false;
	}

	public void AddItem(InventoryItem item, bool silent = false)
	{
		if (item == null)
		{
			Diagnostics.LogError("Inventory.AddItem: item is null!");
			return;
		}
		if (item.CurrentInventory != null)
		{
			Diagnostics.LogError(string.Format("{0} > Inventory.AddItem: item #{1} is in another inventory! ({2})", base.Name, item.UniqueID, (item.CurrentInventory == null) ? "<NULL>" : item.CurrentInventory.Name.ToString()));
			return;
		}
		if (item.CurrentInventory == this)
		{
			Diagnostics.LogError($"{base.Name} > Inventory.AddItem: item #{item.UniqueID} already in current inventory!");
			return;
		}
		if (Items.Contains(item))
		{
			Diagnostics.LogError($"{base.Name} > Inventory.AddItem: item #{item.UniqueID} already in current inventory items!");
			return;
		}
		Items.Add(item);
		AddChild(item);
		Refresh();
		item.CurrentInventory = this;
		if (!silent && OnItemAdded != null)
		{
			OnItemAdded(item);
		}
	}

	public void RemoveItem(InventoryItem item, bool silent = false)
	{
		if (item == null)
		{
			Diagnostics.LogError("Inventory.RemoveItem: item is null!");
		}
		else if (item.CurrentInventory != this)
		{
			Diagnostics.LogError(string.Format("{0} > Inventory.RemoveItem: item #{1} is not in current inventory! ({2}!={3})", base.Name, item.UniqueID, (item.CurrentInventory == null) ? "<NULL>" : item.CurrentInventory.Name.ToString(), base.Name));
		}
		else if (!Items.Contains(item))
		{
			Diagnostics.LogError($"{base.Name} > Inventory.RemoveItem: item #{item.UniqueID} not in current inventory items!");
		}
		else if (ParentSimMB != null)
		{
			Items.Remove(item);
			RemoveChild(item);
			Refresh();
			item.CurrentInventory = null;
			if (!silent && OnItemRemoved != null)
			{
				OnItemRemoved(item);
			}
		}
	}
}
public class InventoryItem : SimulationObjectWrapper
{
	public static StaticString simulationType = "ItemHero";

	private IDatabase<SimulationDescriptor> descriptorsDatabase;

	private string defaultDescriptorName;

	public ItemHeroConfig ItemConfig
	{
		get;
		set;
	}

	public RarityConfig RarityCfg
	{
		get;
		set;
	}

	public ulong OwnerPlayerID
	{
		get;
		set;
	}

	public int UniqueID
	{
		get;
		private set;
	}

	public StaticString UniqueIDCategory
	{
		get;
		private set;
	}

	public bool IsGift
	{
		get;
		private set;
	}

	public Inventory CurrentInventory
	{
		get;
		set;
	}

	public InventoryItem(ItemHeroConfig config, RarityConfig rarity, ulong creatorPlayerID)
	{
		UniqueIDCategory = GetItemUniqueIDCategory(creatorPlayerID);
		UniqueID = UniqueIDManager.RequestUniqueID(this, UniqueIDCategory);
		StaticString name = $"{UniqueIDCategory}#{UniqueID}";
		Init(name);
		Diagnostics.Assert(config != null);
		ItemConfig = config;
		RarityCfg = rarity;
		OwnerPlayerID = SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID();
	}

	public static InventoryItem GetItem(string uniqueIDCategory, int uniqueID)
	{
		return UniqueIDManager.GetObject(uniqueIDCategory, uniqueID) as InventoryItem;
	}

	private static StaticString GetItemUniqueIDCategory(ulong creatorPlayerID)
	{
		return $"{creatorPlayerID}_{simulationType}";
	}

	public static InventoryItem BuildInventoryItem(StaticString itemCfgName, StaticString rarityCfgName, Inventory targetInventory = null, ulong creatorPlayerID = ulong.MaxValue, bool isCreatorOwner = true, bool isGift = false)
	{
		if (itemCfgName == null)
		{
			return null;
		}
		IDatabase<ItemConfig> database = Databases.GetDatabase<ItemConfig>();
		ItemConfig value = null;
		if (database.TryGetValue(itemCfgName, out value))
		{
			ItemHeroConfig itemHeroConfig = null;
			if (value is ItemHeroConfig)
			{
				itemHeroConfig = (value as ItemHeroConfig);
			}
			if (itemHeroConfig != null)
			{
				RarityConfig randomRarityParametersByName = itemHeroConfig.GetRandomRarityParametersByName(rarityCfgName);
				if (creatorPlayerID == ulong.MaxValue)
				{
					creatorPlayerID = SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID();
				}
				InventoryItem inventoryItem = new InventoryItem(itemHeroConfig, randomRarityParametersByName, creatorPlayerID);
				if (isCreatorOwner)
				{
					inventoryItem.OwnerPlayerID = creatorPlayerID;
				}
				inventoryItem.IsGift = isGift;
				inventoryItem.Init();
				targetInventory?.AddItem(inventoryItem);
				return inventoryItem;
			}
		}
		else
		{
			Diagnostics.LogError("[InventoryItem] BuildInventoryItem: the item (" + itemCfgName + ") is not defined in the database");
		}
		return null;
	}

	public void Init()
	{
		descriptorsDatabase = Databases.GetDatabase<SimulationDescriptor>();
		Diagnostics.Assert(descriptorsDatabase != null);
		defaultDescriptorName = simulationType + "_" + ItemConfig.Name;
		base.SimulationObject.AddDescriptor(descriptorsDatabase.GetValue(simulationType));
		base.SimulationObject.AddDescriptor(descriptorsDatabase.GetValue(defaultDescriptorName));
		if (RarityCfg != null)
		{
			base.SimulationObject.AddDescriptor(descriptorsDatabase.GetValue(defaultDescriptorName + "_" + RarityCfg.GetItemHeroRarityConfig().Name));
		}
		base.SimulationObject.Refresh();
	}

	public float GetCost(NPCMerchant merchant)
	{
		return Mathf.CeilToInt(merchant.GetCurrentPriceFor(GetPropertyValue(SimulationProperties.Cost)));
	}

	public float GetCostForCurrency(FIDS currency)
	{
		CurrencyConfig currencyConfig = CurrencyConfig.GetCurrencyConfig(currency);
		return Mathf.CeilToInt(currencyConfig.ExchangeRate * GetPropertyValue(SimulationProperties.Cost));
	}

	public float GetBasicCost()
	{
		return Mathf.CeilToInt(GetPropertyValue(SimulationProperties.Cost));
	}

	public float GetSellingCostForCurrency(FIDS currency)
	{
		CurrencyConfig currencyConfig = CurrencyConfig.GetCurrencyConfig(currency);
		return Mathf.CeilToInt(currencyConfig.ExchangeRate * GetPropertyValue(SimulationProperties.SellingCost));
	}

	public bool CanBuy(NPCMerchant merchant)
	{
		return Player.LocalPlayer.CanConsumeFIDS(GetCost(merchant), merchant.CurrencyCfg.Currency);
	}

	public void MoveToInventory(Inventory destInventory = null, bool silent = false)
	{
		if (CurrentInventory == destInventory)
		{
			Diagnostics.LogWarning("Item already in destination inventory!");
			return;
		}
		if (CurrentInventory != null)
		{
			CurrentInventory.RemoveItem(this, silent);
		}
		if (destInventory != null)
		{
			IsGift = false;
			destInventory.AddItem(this, silent);
		}
	}
}
public class Lift : MonoBehaviour
{
	[SerializeField]
	private LiftHero[] liftHeroes;

	[SerializeField]
	private GameObject normalPropsHolder;

	[SerializeField]
	private GameObject finalPropsHolder;

	[SerializeField]
	private Camera liftCamera;

	private LiftCrystal liftCrystal;

	private StoryDialogManager storyDialogManager;

	private EndLevelPanel endLevelPanel;

	private StoryDialogPanel dialogPanel;

	private Dungeon dungeon;

	private IAudioEventService audioEventManager;

	private LightToLightManagerAdder newLightToLightManagerAdder;

	private GameObject currentPropsHolder;

	public LiftHero[] LiftHeroes => liftHeroes;

	public bool UnlockedBackstories
	{
		get;
		set;
	}

	public bool TriggerStoryCompletedAchievement
	{
		get;
		set;
	}

	public List<Hero> WinningHeroes
	{
		get;
		private set;
	}

	public FMOD.Event LastLiftSFX
	{
		get;
		private set;
	}

	public Camera LiftCamera => liftCamera;

	private void Awake()
	{
		LiftCamera.enabled = false;
		liftCrystal = GetComponentInChildren<LiftCrystal>();
	}

	public void Show()
	{
		SingletonManager.Get<MainGameScreen>().Hide();
		SingletonManager.Get<AlbumPanel>().Hide();
		SingletonManager.Get<RequesterPanel>().Hide();
		if (storyDialogManager == null)
		{
			storyDialogManager = SingletonManager.Get<StoryDialogManager>();
		}
		if (dungeon == null)
		{
			dungeon = SingletonManager.Get<Dungeon>();
		}
		if (audioEventManager == null)
		{
			audioEventManager = Services.GetService<IAudioEventService>();
		}
		storyDialogManager.enabled = true;
		UnlockedBackstories = false;
		TriggerStoryCompletedAchievement = false;
		GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
		IDatatableElement datatableElement = null;
		if (gameNetworkManager == null || !gameNetworkManager.IsMultiplayerSession())
		{
			datatableElement = storyDialogManager.GetSelectedStory();
		}
		WinningHeroes = Hero.GetLevelWinningHeroes();
		StoryDialogConfig storyDialogConfig = datatableElement as StoryDialogConfig;
		StatDialogConfig statDialogConfig = datatableElement as StatDialogConfig;
		if (storyDialogConfig != null)
		{
			List<string> storyHeroes = storyDialogConfig.Heroes.ToList();
			WinningHeroes = WinningHeroes.OrderBy((Hero hero) => (storyHeroes.IndexOf(hero.Config.Name) == -1) ? int.MaxValue : storyHeroes.IndexOf(hero.Config.Name)).ToList();
		}
		if (currentPropsHolder != null)
		{
			UnityEngine.Object.Destroy(currentPropsHolder);
		}
		bool flag = dungeon.IsLastLevel();
		GameObject gameObject = (!flag) ? normalPropsHolder : finalPropsHolder;
		currentPropsHolder = (UnityEngine.Object.Instantiate(gameObject, base.transform.position, base.transform.rotation) as GameObject);
		currentPropsHolder.transform.parent = base.transform;
		currentPropsHolder.transform.localScale = gameObject.transform.localScale;
		int i;
		for (i = 0; i < WinningHeroes.Count; i++)
		{
			liftHeroes[i].BindAndShow(WinningHeroes[i].Config.Name, i, WinningHeroes[i].NetSyncElement.OwnerPlayerID, (!(WinningHeroes[i].TamedMob != null) || WinningHeroes[i].TamedMob.Config.Immobile) ? null : WinningHeroes[i].TamedMob.Config.Name);
		}
		for (int j = i; j < liftHeroes.Length; j++)
		{
			liftHeroes[j].Hide();
		}
		liftCrystal.Show();
		if (!GameManager.Preferences.GameGraphicSettings.HxLightTotallyDeactivated)
		{
			newLightToLightManagerAdder = base.gameObject.GetComponent<LightToLightManagerAdder>();
			if (newLightToLightManagerAdder == null)
			{
				GameObject gameObject2 = Resources.Load("HxLight/PostGenerationDungeon") as GameObject;
				Diagnostics.Assert(gameObject2 != null);
				LightToLightManagerAdder component = gameObject2.GetComponent<LightToLightManagerAdder>();
				newLightToLightManagerAdder = base.gameObject.AddComponent<LightToLightManagerAdder>();
				newLightToLightManagerAdder.LoadFrom(component);
			}
			newLightToLightManagerAdder.ConvertAllMaterialNow();
		}
		Services.GetService<IGameCameraService>().ActivateCamera(on: false);
		LiftCamera.enabled = true;
		if (endLevelPanel == null)
		{
			endLevelPanel = SingletonManager.Get<EndLevelPanel>();
		}
		endLevelPanel.Show();
		if (storyDialogConfig != null)
		{
			audioEventManager.Play2DEvent("Master/Jingles/GlodDialog");
			storyDialogManager.TriggerStory(storyDialogConfig);
		}
		else if (statDialogConfig != null)
		{
			storyDialogManager.TriggerStatDialog(statDialogConfig);
		}
		else
		{
			endLevelPanel.OnDialogFinished();
		}
		if (flag)
		{
			LastLiftSFX = audioEventManager.Play2DEvent("Master/Events/Elevator_End");
		}
	}

	public void Hide()
	{
		LiftCamera.enabled = false;
		liftCrystal.Hide();
		LiftHero[] array = liftHeroes;
		foreach (LiftHero liftHero in array)
		{
			liftHero.Hide();
		}
		ParticleSystem[] componentsInChildren = LiftHeroes[0].transform.parent.GetComponentsInChildren<ParticleSystem>();
		ParticleSystem[] array2 = componentsInChildren;
		foreach (ParticleSystem particleSystem in array2)
		{
			UnityEngine.Object.Destroy(particleSystem.gameObject);
		}
		if (currentPropsHolder != null)
		{
			UnityEngine.Object.Destroy(currentPropsHolder);
		}
		UnityEngine.Object.Destroy(newLightToLightManagerAdder);
	}

	public void OnDialogFinished()
	{
		TriggerGameplayEffects();
		if (UnlockedBackstories)
		{
			dungeon.EnqueueUnlockNotification(AgeLocalizer.Instance.LocalizeString("%NewBackstoriesUnlocked"), NotificationType.Backstory);
		}
		if (TriggerStoryCompletedAchievement)
		{
			AchievementManagerDOTE achievementManagerDOTE = SingletonManager.Get<AchievementManagerDOTE>();
			string text = "STORY_COMPLETED_" + storyDialogManager.LastStoryPlayed.Replace(" ", "_").ToUpper();
			try
			{
				StatisticName stat = text.ToEnum<StatisticName>();
				achievementManagerDOTE.IncrementStatistic(stat);
			}
			catch
			{
				Diagnostics.LogError("Achievement for finished story is missing: " + text);
			}
		}
	}

	private void TriggerGameplayEffects()
	{
		if (!TriggerMurder())
		{
			TriggerVFXs();
		}
	}

	private void TriggerVFXs()
	{
		if (storyDialogManager != null && storyDialogManager.VFXsToPlay != null && storyDialogManager.VFXsToPlay.Count > 0)
		{
			audioEventManager.Play2DEvent("Master/Jingles/DialogBonus");
			foreach (KeyValuePair<Transform, GameObject> item in storyDialogManager.VFXsToPlay)
			{
				GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(item.Value, item.Key.position, Quaternion.identity);
				gameObject.transform.parent = item.Key;
				gameObject.name = "LiftOwnerVFX";
			}
		}
		if (storyDialogManager.MurderToPlay.Value != null)
		{
			storyDialogManager.MurderToPlay.Value.SpriteAnimation.UnmonitorAnimEvent("OnDeathEnd", TriggerVFXs);
		}
	}

	private bool TriggerMurder()
	{
		if (storyDialogManager != null && storyDialogManager.MurderToPlay.Key != null)
		{
			storyDialogManager.MurderToPlay.Key.Attack(storyDialogManager.MurderToPlay.Value.HeroLiftNumber);
			storyDialogManager.MurderToPlay.Key.SpriteAnimation.MonitorAnimEvent("OnAttackHit", TriggerDeath);
			audioEventManager.Play2DEvent("Master/Jingles/DialogMurder");
			return true;
		}
		return false;
	}

	private void TriggerDeath()
	{
		if (storyDialogManager != null && storyDialogManager.MurderToPlay.Key != null)
		{
			storyDialogManager.MurderToPlay.Key.SpriteAnimation.UnmonitorAnimEvent("OnAttackHit", TriggerDeath);
			storyDialogManager.MurderToPlay.Value.Die();
			storyDialogManager.MurderToPlay.Value.SpriteAnimation.MonitorAnimEvent("OnDeathEnd", TriggerVFXs);
			Hero hero2 = Hero.LocalPlayerActiveRecruitedHeroes.FirstOrDefault((Hero hero) => hero.Config.Name == storyDialogManager.MurderToPlay.Value.HeroName);
			Diagnostics.Assert(hero2 != null && hero2.HealthCpnt != null);
			hero2.HealthCpnt.Kill(checkOwnership: false);
		}
	}
}
public abstract class Order : Amplitude.Unity.Game.Orders.Order
{
	[Flow(Control.Internal)]
	public int EmpireIndex
	{
		get;
		private set;
	}

	public Order(int empireIndex)
	{
		EmpireIndex = empireIndex;
	}

	public override void Pack(System.IO.BinaryWriter writer)
	{
		base.Pack(writer);
		writer.Write(IPAddress.HostToNetworkOrder(EmpireIndex));
	}

	public override void Unpack(System.IO.BinaryReader reader)
	{
		base.Unpack(reader);
		EmpireIndex = IPAddress.NetworkToHostOrder(reader.ReadInt32());
	}
}
public class PlayerController : Amplitude.Unity.Game.PlayerController
{
	public IGameInterface GameInterface
	{
		get;
		private set;
	}

	public PlayerController(IGameInterface gameInterface)
	{
		if (gameInterface == null)
		{
			throw new ArgumentNullException("The game interface argument must not be null.");
		}
		GameInterface = gameInterface;
	}

	public void PostOrder(Amplitude.Unity.Game.Orders.Order order)
	{
		if (!string.IsNullOrEmpty(base.PlayerID))
		{
			Message message = new GameClientPostOrderMessage(order);
			GameInterface.SendMessageToServer(ref message);
		}
	}

	public void PostOrder(Amplitude.Unity.Game.Orders.Order order, out Ticket ticket, EventHandler<TicketRaisedEventArgs> eventHandler = null)
	{
		ticket = null;
		if (!string.IsNullOrEmpty(base.PlayerID))
		{
			Message message = new GameClientPostOrderMessage(order);
			GameInterface.SendMessageToServer(ref message);
			if (GameInterface is IGameClient)
			{
				(GameInterface as IGameClient).Trace(order, out ticket, eventHandler);
			}
		}
	}
}
public enum CommunityEvent
{
	EndlessDay,
	FreeWeekend,
	Halloween
}
[Serializable]
public class CommunityEventConfig
{
	public CommunityEvent Event;

	public string StartDateStr;

	public string EndDateStr;

	public string DateFormat;

	public string disclaimerAckRegistryKey;

	public string disclaimerTitle;

	public string disclaimerMessage;

	public string disclaimerMoreInfoURL;
}
[Serializable]
public struct HiddenHeroConfig
{
	public string HeroName;

	public float RandomSelectionWeight;
}
[Serializable]
public struct CommunityEventHeroConfig
{
	public string HeroName;

	public CommunityEvent CommunityEvent;
}
[Serializable]
public struct ShipUnlockData
{
	public string ShipName;

	public List<AchievementName> UnlockingAchievement;
}
public class PrivateGameConfigManager : MonoBehaviour
{
	[SerializeField]
	private CommunityEventConfig[] communityEvents;

	[SerializeField]
	private HiddenHeroConfig[] hiddenHeroes;

	[SerializeField]
	private CommunityEventHeroConfig[] communityEventHeroes;

	[SerializeField]
	private ShipUnlockData[] shipUnlocks;

	public CommunityEventConfig[] CommunityEvents => communityEvents;

	public HiddenHeroConfig[] HiddenHeroes => hiddenHeroes;

	public CommunityEventHeroConfig[] CommunityEventHeroes => communityEventHeroes;

	public ShipUnlockData[] ShipUnlocks => shipUnlocks;

	public bool IsCommunityEventActive(CommunityEvent commEvt)
	{
		DateTime utcNow = DateTime.UtcNow;
		for (int i = 0; i < communityEvents.Length; i++)
		{
			CommunityEventConfig communityEventConfig = communityEvents[i];
			DateTime t = DateTime.ParseExact(communityEventConfig.StartDateStr, communityEvents[i].DateFormat, CultureInfo.InvariantCulture);
			DateTime t2 = DateTime.ParseExact(communityEventConfig.EndDateStr, communityEvents[i].DateFormat, CultureInfo.InvariantCulture);
			if (communityEventConfig.Event == commEvt && utcNow >= t && utcNow < t2)
			{
				return true;
			}
		}
		return false;
	}

	public CommunityEventConfig GetActiveCommunityEventConfig()
	{
		DateTime utcNow = DateTime.UtcNow;
		for (int i = 0; i < communityEvents.Length; i++)
		{
			CommunityEventConfig communityEventConfig = communityEvents[i];
			DateTime t = DateTime.ParseExact(communityEventConfig.StartDateStr, communityEvents[i].DateFormat, CultureInfo.InvariantCulture);
			DateTime t2 = DateTime.ParseExact(communityEventConfig.EndDateStr, communityEvents[i].DateFormat, CultureInfo.InvariantCulture);
			if (utcNow >= t && utcNow < t2)
			{
				return communityEventConfig;
			}
		}
		return null;
	}
}
public class ActiveSkill : Skill
{
	public delegate void CooldownEndedEventHandler();

	public delegate void ActivatedEventHandler();

	public delegate void DeactivatedEventHandler();

	public bool IsActivated;

	public float LastActivityStartTime;

	public int LastActivityTurn;

	private Dungeon dungeon;

	private IGameEventService gameEventManager;

	public event CooldownEndedEventHandler OnCooldownEnded;

	public event ActivatedEventHandler OnActivated;

	public event DeactivatedEventHandler OnDeactivated;

	public override void Init(ulong ownerPlayerID, SkillConfig config, Hero owner)
	{
		base.Init(ownerPlayerID, config, owner);
		LastActivityStartTime = float.NegativeInfinity;
		LastActivityTurn = -1000;
		IsActivated = false;
	}

	public void Activate()
	{
		if (IsActivated)
		{
			Diagnostics.LogWarning("Unable to activate active skill: ALREADY ACTIVATED!");
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_SkillInCooldown"));
		}
		else if (dungeon.Turn < LastActivityTurn + base.Config.CooldownTurnsCount)
		{
			Diagnostics.LogWarning("Unable to activate active skill: COOLDOWN NOT OVER!");
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_SkillInCooldown"));
		}
		else if (owner.HasCrystal)
		{
			Diagnostics.LogWarning("Unable to activate active skill: hero has the crystal!");
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_SkillCrystalCarrier"));
		}
		else
		{
			netSyncElement.SendRPCToAll(UniqueIDRPC.ActiveSkill_DoActivate);
		}
	}

	private void RPC_DoActivate()
	{
		ApplyEffects();
		IsActivated = true;
		LastActivityStartTime = Time.time;
		LastActivityTurn = dungeon.Turn;
		if (owner != null && owner.AudioEmitter != null && !string.IsNullOrEmpty(base.Config.OwnerSFXPath))
		{
			owner.AudioEmitter.PlayEvent(base.Config.OwnerSFXPath);
		}
		gameEventManager.OnDungeonTurnChanged += OnDungeonTurnChanged;
		if (base.Config.Duration > 0f)
		{
			Invoke("Deactivate", base.Config.Duration);
		}
		else
		{
			IsActivated = false;
		}
		if (base.Config.DeactivateOnNewTurn)
		{
			gameEventManager.OnRoomEventFinished += Deactivate;
		}
		if (this.OnActivated != null)
		{
			this.OnActivated();
		}
	}

	public void Deactivate()
	{
		if (!IsActivated && base.Config.Duration > 0f)
		{
			Diagnostics.LogError("Unable to deactivate current active skill: CURRENT ACTIVE SKILL IS NOT ACTIVE ANYMORE!");
			return;
		}
		if (base.Config.Duration > 0f)
		{
			CancelInvoke("Deactivate");
		}
		RemoveEffects();
		IsActivated = false;
		if (base.Config.DeactivateOnNewTurn)
		{
			gameEventManager.OnRoomEventFinished -= Deactivate;
		}
		if (this.OnDeactivated != null)
		{
			this.OnDeactivated();
		}
	}

	public int GetRemainingTurns()
	{
		if (LastActivityTurn < 0)
		{
			return 0;
		}
		int num = LastActivityTurn + base.Config.CooldownTurnsCount;
		if (dungeon.Turn > num)
		{
			return 0;
		}
		return num - dungeon.Turn;
	}

	protected override void Awake()
	{
		base.Awake();
		dungeon = SingletonManager.Get<Dungeon>();
		gameEventManager = Services.GetService<IGameEventService>();
	}

	private void OnDungeonTurnChanged()
	{
		if (dungeon.Turn >= LastActivityTurn + base.Config.CooldownTurnsCount)
		{
			EndCooldown();
		}
	}

	public void EndCooldown()
	{
		LastActivityTurn = -1000;
		if (this.OnCooldownEnded != null)
		{
			this.OnCooldownEnded();
		}
		gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChanged;
	}

	private void OnDestroy()
	{
		gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChanged;
	}
}
public class PassiveSkill : Skill
{
}
public class Skill : SimMonoBehaviour
{
	protected Hero owner;

	protected bool areEffectsApplied;

	protected GameObject ownerVFXGO;

	protected Mob currentTarget;

	protected UniqueIDNetSyncElement netSyncElement;

	public int PreviewLevel
	{
		get;
		set;
	}

	public SkillConfig Config
	{
		get;
		private set;
	}

	public SimulationDescriptor OwnerSimDesc
	{
		get;
		private set;
	}

	public SimulationDescriptor TargetSimDesc
	{
		get;
		private set;
	}

	public virtual void Init(ulong ownerPlayerID, SkillConfig config, Hero owner)
	{
		netSyncElement.SetOwner(ownerPlayerID);
		Config = config;
		this.owner = owner;
		IDatabase<SimulationDescriptor> simDescDatabase = SimMonoBehaviour.GetSimDescDatabase();
		OwnerSimDesc = simDescDatabase.GetValue(Config.Name);
		if (OwnerSimDesc != null)
		{
			AddSimDescriptor(OwnerSimDesc);
		}
		TargetSimDesc = simDescDatabase.GetValue(Config.Name + "_Target");
		if (Config.OwnerVFXPath != null)
		{
			GameObject original = Resources.Load<GameObject>(Config.OwnerVFXPath);
			ownerVFXGO = (GameObject)UnityEngine.Object.Instantiate(original, base.transform.position, Quaternion.identity);
			ownerVFXGO.transform.parent = base.transform;
			ownerVFXGO.SetActive(value: false);
			ownerVFXGO.name = "OwnerVFX";
		}
	}

	public void ApplyEffects()
	{
		if (areEffectsApplied && Config.Duration > 0f)
		{
			Diagnostics.LogError("Skill.ApplyEffects: effects already applied!");
			return;
		}
		owner.AddSimChild(this);
		if (ownerVFXGO != null)
		{
			ownerVFXGO.SetActive(value: true);
		}
		if (TargetSimDesc != null && owner.AICpnt.CurrentTarget != null && owner.AICpnt.CurrentTarget.Interaction == AIInteraction.Attack)
		{
			currentTarget = owner.AICpnt.CurrentTarget.GetComponent<Mob>();
			ApplyEffectsToCurrentTarget();
		}
		if (Config.Damages > 0f || Config.DamagesRatio > 0f)
		{
			SimulationObject[] validatedObjects = new SimulationPath(Config.DamagesTargetsPath).GetValidatedObjects(GetSimObj());
			SimulationObject[] array = validatedObjects;
			foreach (SimulationObject simulationObject in array)
			{
				SimMonoBehaviour simMonoBhvByName = SimMonoBehaviour.GetSimMonoBhvByName(simulationObject.Name);
				if (simMonoBhvByName == null)
				{
					continue;
				}
				Health component = simMonoBhvByName.GetComponent<Health>();
				if (component == null)
				{
					Diagnostics.LogError(simulationObject.Name + " has no Health component!");
				}
				else if (component.IsAlive() && netSyncElement.IsOwnedByLocalPlayer())
				{
					float num = Config.Damages;
					if (Config.DamagesRatio > 0f)
					{
						num += component.GetHealth() * Config.DamagesRatio;
					}
					if (num > Config.DamagesMaxValue)
					{
						num = Config.DamagesMaxValue;
					}
					component.Hit(new AttackInfo
					{
						Damages = num,
						AttackerPos = owner.transform.position,
						DisplayHit = true
					});
				}
			}
		}
		areEffectsApplied = true;
	}

	public void RemoveEffects()
	{
		if (!areEffectsApplied)
		{
			Diagnostics.LogError("Skill.RemoveEffects: effects not currently applied");
			return;
		}
		owner.RemoveSimChild(this);
		if (ownerVFXGO != null)
		{
			ownerVFXGO.SetActive(value: false);
		}
		if (TargetSimDesc != null && currentTarget != null)
		{
			RemoveEffectsFromCurrentTarget();
		}
		areEffectsApplied = false;
	}

	public void UpdateTarget(Mob previousMobTarget, Mob newMobTarget)
	{
		if (areEffectsApplied && TargetSimDesc != null)
		{
			if (currentTarget != previousMobTarget)
			{
				Diagnostics.LogError("Skill.UpdateTarget: invalid previous mob target (" + previousMobTarget + " != " + currentTarget + ")");
				return;
			}
			RemoveEffectsFromCurrentTarget();
			currentTarget = newMobTarget;
			ApplyEffectsToCurrentTarget();
		}
	}

	protected override void Awake()
	{
		base.Awake();
		netSyncElement = GetComponent<UniqueIDNetSyncElement>();
	}

	protected void ApplyEffectsToCurrentTarget()
	{
		if (TargetSimDesc != null && !(currentTarget == null))
		{
			currentTarget.AddSimDescriptor(TargetSimDesc);
		}
	}

	protected void RemoveEffectsFromCurrentTarget()
	{
		if (TargetSimDesc != null && !(currentTarget == null))
		{
			currentTarget.RemoveSimDescriptor(TargetSimDesc);
		}
	}
}
public class TutorialManager : MonoBehaviour
{
	[SerializeField]
	private OffscreenMarker.OffscreenMarkerData TutorialMarkerData;

	private TutorialStepConfig[] tutorialSteps;

	private int currentStepIndex;

	private TutorialInteractivePanel tutorialPanel;

	private HeroPanel heroStatsPanel;

	private HeroesPadPanel heroesPadPanel;

	private IGameEventService gameEventManager;

	private IGuiService guiService;

	private GameNetworkManager gameNetworkManager;

	private Dungeon dungeon;

	private List<OffscreenMarker> offscreenMarkers;

	private AgeTransform ageMarker;

	private float initialPanelPercentLeft;

	public static bool IsEnable;

	private TutorialStepConfig CurrentStep => tutorialSteps[currentStepIndex];

	public void TriggerTutorial(float delay = 0f)
	{
		if (gameNetworkManager == null)
		{
			gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
		}
		if (!gameNetworkManager.IsMultiplayerSession())
		{
			if (delay > 0f)
			{
				Invoke("StartTutorial", delay);
			}
			else
			{
				StartTutorial();
			}
		}
	}

	private void StartTutorial()
	{
		if (tutorialSteps == null)
		{
			tutorialSteps = Databases.GetDatabase<TutorialStepConfig>().GetValues();
		}
		if (tutorialPanel == null)
		{
			tutorialPanel = SingletonManager.Get<TutorialInteractivePanel>();
			initialPanelPercentLeft = tutorialPanel.AgeTransform.PercentLeft;
		}
		if (heroStatsPanel == null)
		{
			heroStatsPanel = SingletonManager.Get<HeroPanel>();
		}
		if (gameEventManager == null)
		{
			gameEventManager = Services.GetService<IGameEventService>();
		}
		if (guiService == null)
		{
			guiService = Services.GetService<IGuiService>();
		}
		if (dungeon == null)
		{
			dungeon = SingletonManager.Get<Dungeon>();
		}
		gameEventManager.OnDoorOpenedByHero += GameEventManager_OnDoorOpenedByHero;
		gameEventManager.OnHeroMovedToRoom += GameEventManager_OnHeroMovedToRoom;
		gameEventManager.OnRoomPowered += GameEventManager_OnRoomPowered;
		gameEventManager.OnBuiltModule += GameEventManager_OnBuiltModule;
		TutorialInteractivePanel tutorialInteractivePanel = tutorialPanel;
		tutorialInteractivePanel.OnNextClicked = (EventHandler<EventArgs>)Delegate.Combine(tutorialInteractivePanel.OnNextClicked, new EventHandler<EventArgs>(OnTutorialNextButtonClicked));
		if (heroStatsPanel == null)
		{
			heroStatsPanel = SingletonManager.Get<HeroPanel>();
		}
		heroStatsPanel.OnShowDuringTutorial += OnHeroStatsPanelShow;
		currentStepIndex = -1;
		IsEnable = true;
		MovePanelLeft();
		NextStep();
	}

	private void NextStep()
	{
		CleanMarkers();
		if (currentStepIndex < tutorialSteps.Length - 1)
		{
			TutorialStepConfig tutorialStepConfig = tutorialSteps[++currentStepIndex];
			if (currentStepIndex == 0)
			{
				tutorialPanel.Show();
			}
			tutorialPanel.UpdateContent(AgeLocalizer.Instance.LocalizeString(tutorialStepConfig.Text), tutorialStepConfig.Condition == TutorialCondition.NextButtonClick, currentStepIndex + 1, tutorialSteps.Length);
			if (!string.IsNullOrEmpty(tutorialStepConfig.ArrowTarget3D))
			{
				Type type = Type.GetType(tutorialStepConfig.ArrowTarget3D);
				if (type == null)
				{
					Diagnostics.LogError("Unknown type: " + tutorialStepConfig.ArrowTarget3D);
				}
				else
				{
					offscreenMarkers = new List<OffscreenMarker>();
					UnityEngine.Object[] array = UnityEngine.Object.FindObjectsOfType(type);
					UnityEngine.Object[] array2 = array;
					foreach (UnityEngine.Object @object in array2)
					{
						MonoBehaviour monoBehaviour = @object as MonoBehaviour;
						TutorialMarker componentInChildren = monoBehaviour.GetComponentInChildren<TutorialMarker>();
						Transform trackedTfm = (!(componentInChildren != null)) ? monoBehaviour.transform : componentInChildren.transform;
						offscreenMarkers.Add(dungeon.DisplayOffscreenMarker(trackedTfm, TutorialMarkerData));
					}
				}
			}
			if (string.IsNullOrEmpty(tutorialStepConfig.ArrowTarget2D))
			{
				return;
			}
			Transform transform = (guiService as GuiManager).transform.Search(tutorialStepConfig.ArrowTarget2D);
			if (transform != null)
			{
				ageMarker = transform.GetComponent<AgeTransform>();
				if (ageMarker == null)
				{
					Diagnostics.LogError(transform.name + " has no AgeTransform");
				}
				else
				{
					ageMarker.Visible = true;
				}
			}
		}
		else
		{
			StopTutorial();
		}
	}

	public void MovePanelCenter()
	{
		tutorialPanel.AgeTransform.PercentTop = 0f;
		tutorialPanel.AgeTransform.PercentLeft = tutorialPanel.PanelCenterRightPercent;
	}

	public void MovePanelLeft()
	{
		tutorialPanel.AgeTransform.PercentTop = 0f;
		tutorialPanel.AgeTransform.PercentLeft = initialPanelPercentLeft;
	}

	public void MovePanelRight()
	{
		tutorialPanel.AgeTransform.PercentTop = tutorialPanel.PanelCenterTopPercent;
		tutorialPanel.AgeTransform.PercentLeft = 65f;
	}

	public void StopTutorial()
	{
		CleanMarkers();
		if (IsEnable)
		{
			tutorialPanel.Hide();
			gameEventManager.OnDoorOpenedByHero -= GameEventManager_OnDoorOpenedByHero;
			gameEventManager.OnHeroMovedToRoom -= GameEventManager_OnHeroMovedToRoom;
			gameEventManager.OnRoomPowered -= GameEventManager_OnRoomPowered;
			gameEventManager.OnBuiltModule -= GameEventManager_OnBuiltModule;
			TutorialInteractivePanel tutorialInteractivePanel = tutorialPanel;
			tutorialInteractivePanel.OnNextClicked = (EventHandler<EventArgs>)Delegate.Remove(tutorialInteractivePanel.OnNextClicked, new EventHandler<EventArgs>(OnTutorialNextButtonClicked));
			if (heroStatsPanel != null)
			{
				heroStatsPanel.OnShowDuringTutorial -= OnHeroStatsPanelShow;
			}
			IsEnable = false;
		}
		CancelInvoke("StartTutorial");
	}

	private void CleanMarkers()
	{
		if (offscreenMarkers != null)
		{
			foreach (OffscreenMarker offscreenMarker in offscreenMarkers)
			{
				offscreenMarker.Hide();
			}
			offscreenMarkers.Clear();
		}
		if (ageMarker != null)
		{
			ageMarker.Visible = false;
		}
	}

	private void GameEventManager_OnBuiltModule()
	{
		if (CurrentStep.Condition == TutorialCondition.BuildModule)
		{
			NextStep();
		}
	}

	private void GameEventManager_OnRoomPowered()
	{
		if (CurrentStep.Condition == TutorialCondition.RoomPower)
		{
			NextStep();
		}
	}

	private void GameEventManager_OnHeroMovedToRoom()
	{
		if (CurrentStep.Condition == TutorialCondition.HeroMoveToRoom)
		{
			NextStep();
		}
	}

	private void GameEventManager_OnDoorOpenedByHero()
	{
		if (CurrentStep.Condition == TutorialCondition.OpenDoor)
		{
			NextStep();
		}
	}

	private void OnTutorialNextButtonClicked(object sender, EventArgs e)
	{
		if (CurrentStep.Condition == TutorialCondition.NextButtonClick)
		{
			NextStep();
		}
	}

	private void OnHeroStatsPanelShow(object sender, EventArgs e)
	{
		if (CurrentStep.Condition == TutorialCondition.OpenHeroPanel)
		{
			NextStep();
		}
	}
}
public enum TutorialCondition
{
	NextButtonClick,
	OpenDoor,
	HeroMoveToRoom,
	RoomPower,
	BuildModule,
	OpenHeroPanel
}
public class TutorialMarker : MonoBehaviour
{
}
public class AnimVariance : MonoBehaviour
{
	private void OnEnable()
	{
		GetComponent<Animation>()[GetComponent<Animation>().clip.name].normalizedTime = RandomGenerator.RangeFloat(0f, 1f);
	}
}
public class ApproachCamera : MonoBehaviour
{
	[SerializeField]
	private float distance;

	private void Start()
	{
		Vector3 vector = Services.GetService<IGameCameraService>().GetCamPosition() - base.transform.position;
		vector = new Vector3(0f, vector.y, vector.z).normalized;
		base.transform.position += distance * vector;
	}
}
public class ForceForwardDir : MonoBehaviour
{
	[SerializeField]
	private Vector3 dir;

	[SerializeField]
	private bool everyFrame;

	private void Start()
	{
		Apply();
	}

	private void Update()
	{
		if (everyFrame)
		{
			Apply();
		}
	}

	private void Apply()
	{
		base.transform.forward = dir;
	}
}
public class GPUGlobalTimeManager : MonoBehaviour
{
	public string ShaderParameterName = "_AmplitudeTime";

	public float SpeedMultiplier = 1f;

	private int shaderParameterId = -1;

	private float currentTime;

	private float lastTime;

	public void Awake()
	{
		shaderParameterId = Shader.PropertyToID(ShaderParameterName);
		lastTime = Time.realtimeSinceStartup;
	}

	public void Update()
	{
		Diagnostics.Assert(shaderParameterId != -1);
		float num = SpeedMultiplier * (Time.realtimeSinceStartup - lastTime);
		lastTime = Time.realtimeSinceStartup;
		currentTime += num;
		Shader.SetGlobalVector(vec: new Vector4(currentTime, num, 0f, 0f), nameID: shaderParameterId);
	}
}
[RequireComponent(typeof(Camera))]
public class CameraPosShaderExport : MonoBehaviour
{
	private static readonly string Camera2WorldShaderParamName = "_Camera2World";

	private static readonly string CameraPosShaderParamName = "_CameraPos";

	private static readonly string CameraDirectionShaderParamName = "_CameraDirection";

	private static int camera2WorldShaderParamId = -1;

	private static int cameraPosShaderParamId = -1;

	private static int cameraDirectionShaderParamId = -1;

	private Camera worldCamera;

	private ILightManagerService lightManagerService;

	protected IEnumerator Start()
	{
		worldCamera = GetComponent<Camera>();
		yield return null;
	}

	protected void OnPreRender()
	{
		if (worldCamera.enabled)
		{
			if (camera2WorldShaderParamId == -1)
			{
				camera2WorldShaderParamId = Shader.PropertyToID(Camera2WorldShaderParamName);
				cameraPosShaderParamId = Shader.PropertyToID(CameraPosShaderParamName);
				cameraDirectionShaderParamId = Shader.PropertyToID(CameraDirectionShaderParamName);
			}
			Shader.SetGlobalMatrix(camera2WorldShaderParamId, worldCamera.cameraToWorldMatrix);
			Shader.SetGlobalVector(cameraPosShaderParamId, worldCamera.transform.position);
			Shader.SetGlobalVector(cameraDirectionShaderParamId, worldCamera.transform.forward);
			if (lightManagerService == null)
			{
				lightManagerService = Services.GetService<ILightManagerService>();
			}
			if (lightManagerService != null)
			{
				lightManagerService.OnPreRenderHook(worldCamera);
			}
		}
	}
}
public class GameGraphicSettings
{
	public bool HxLightTotallyDeactivated;

	public bool HxDungeonMeshPackingDeactivated;

	public bool HxLightShowDebug;

	public bool CustomTemporary0;

	public bool CustomTemporary1;

	public bool CustomTemporary2;

	public bool CustomTemporary3;

	public bool CustomTemporary4;

	public bool CustomTemporary5;

	public bool CustomTemporary6;

	public bool CustomTemporary7;

	public bool CustomTemporary8;

	public bool CustomTemporary9;

	public bool DisplayShaderParameters;

	public int CustomShaderParametersIndex;

	public float[] CustomShaderParameters = new float[50];

	public GameGraphicSettings()
	{
		SetCustomShaderParameter();
	}

	public void SetCustomShaderParameter()
	{
		int num = Math.Max(0, Math.Min(4, CustomShaderParametersIndex));
		for (int i = 0; i < 10; i++)
		{
			Shader.SetGlobalFloat($"_CustomShader{i}", CustomShaderParameters[i + 10 * num]);
		}
	}

	public void UpdateSavedSettings()
	{
	}
}
public struct HiPerformanceCounter
{
	private static double PerformanceFrequency;

	private long startTime;

	private long total;

	private int count;

	private double durationLastClear;

	private int countLastClear;

	public int Count => count;

	public double Duration => (double)total / PerformanceFrequency;

	public double DurationPerCall => (double)total / ((double)Count * PerformanceFrequency);

	public double DurationPerCallLastClear => durationLastClear / (double)countLastClear;

	public double DurationLastClear => durationLastClear;

	public int CountLastClear => countLastClear;

	public bool Started => startTime > 0;

	[DllImport("Kernel32.dll")]
	private static extern bool QueryPerformanceCounter(out long lpPerformanceCount);

	[DllImport("Kernel32.dll")]
	private static extern bool QueryPerformanceFrequency(out long lpFrequency);

	public static void InitFreq()
	{
		PerformanceFrequency = 0.0;
		if (!QueryPerformanceFrequency(out long lpFrequency))
		{
			throw new Win32Exception();
		}
		PerformanceFrequency = lpFrequency;
	}

	public void Clear()
	{
		durationLastClear = (double)total / PerformanceFrequency;
		countLastClear = count;
		count = 0;
		total = 0L;
	}

	public void Start()
	{
		QueryPerformanceCounter(out startTime);
	}

	public void Stop()
	{
		long lpPerformanceCount = 0L;
		QueryPerformanceCounter(out lpPerformanceCount);
		total += lpPerformanceCount - startTime;
		startTime = 0L;
		count++;
	}

	public void Stop(int autoClearIfCountSuperior)
	{
		long lpPerformanceCount = 0L;
		QueryPerformanceCounter(out lpPerformanceCount);
		total += lpPerformanceCount - startTime;
		startTime = 0L;
		count++;
		if (count > autoClearIfCountSuperior)
		{
			Clear();
		}
	}
}
public class HxDungeonMeshPacker : MonoBehaviour
{
	public class OneMaterialMesh
	{
		private GameObject addedGameObject;

		private MeshFilter addedMeshFilter;

		private MeshRenderer addedMeshRenderer;

		private Material unityMaterial;

		private Transform whereToAdd;

		public List<KeyValuePair<int, MeshRenderer>> roomIndexAndMeshRenderers;

		public Material UnityMaterial => unityMaterial;

		public OneMaterialMesh(Material unityMaterial, Shader convertedShader, Transform whereToAdd)
		{
			this.unityMaterial = new Material(unityMaterial);
			this.unityMaterial.shader = convertedShader;
			roomIndexAndMeshRenderers = new List<KeyValuePair<int, MeshRenderer>>();
			this.whereToAdd = whereToAdd;
		}

		public void AddMeshRenderer(int roomIndex, MeshRenderer meshRenderer)
		{
			roomIndexAndMeshRenderers.Add(new KeyValuePair<int, MeshRenderer>(roomIndex, meshRenderer));
		}

		public void MeshGroup()
		{
			int num = 0;
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			bool flag5 = false;
			for (int i = 0; i < roomIndexAndMeshRenderers.Count; i++)
			{
				MeshFilter component = roomIndexAndMeshRenderers[i].Value.GetComponent<MeshFilter>();
				if (!(component == null) && !(component.sharedMesh == null))
				{
					Mesh sharedMesh = component.sharedMesh;
					Diagnostics.Assert(sharedMesh.isReadable);
					if (sharedMesh.isReadable)
					{
						Diagnostics.Assert(sharedMesh.subMeshCount == 1);
						flag = (flag || (sharedMesh.normals != null && sharedMesh.normals.Length > 0));
						flag2 = (flag2 || (sharedMesh.tangents != null && sharedMesh.tangents.Length > 0));
						flag3 = (flag3 || (sharedMesh.uv != null && sharedMesh.uv.Length > 0));
						flag4 = (flag4 || (sharedMesh.uv2 != null && sharedMesh.uv2.Length > 0));
						flag5 = (flag5 || (sharedMesh.colors32 != null && sharedMesh.colors32.Length > 0));
						Diagnostics.Assert(sharedMesh.boneWeights == null || sharedMesh.boneWeights.Length == 0);
						num += sharedMesh.vertexCount;
					}
				}
			}
			Vector3[] array = new Vector3[num];
			Vector3[] array2 = null;
			Vector4[] array3 = null;
			Vector2[] array4 = null;
			Vector2[] array5 = null;
			Color32[] array6 = new Color32[num];
			if (flag)
			{
				array2 = new Vector3[num];
			}
			if (flag2)
			{
				array3 = new Vector4[num];
			}
			if (flag3)
			{
				array4 = new Vector2[num];
			}
			if (flag4)
			{
				array5 = new Vector2[num];
			}
			List<int> list = new List<int>();
			Matrix4x4 worldToLocalMatrix = whereToAdd.transform.worldToLocalMatrix;
			MeshTopology meshTopology = MeshTopology.Triangles;
			bool flag6 = false;
			int num2 = 0;
			for (int j = 0; j < roomIndexAndMeshRenderers.Count; j++)
			{
				int key = roomIndexAndMeshRenderers[j].Key;
				MeshRenderer value = roomIndexAndMeshRenderers[j].Value;
				MeshFilter component2 = value.GetComponent<MeshFilter>();
				if (component2 == null || component2.sharedMesh == null)
				{
					continue;
				}
				Mesh sharedMesh2 = component2.sharedMesh;
				Diagnostics.Assert(sharedMesh2.isReadable);
				Diagnostics.Assert(sharedMesh2.subMeshCount == 1);
				if (!flag6)
				{
					meshTopology = sharedMesh2.GetTopology(0);
					flag6 = true;
				}
				else
				{
					Diagnostics.Assert(meshTopology == sharedMesh2.GetTopology(0));
				}
				if (!sharedMesh2.isReadable)
				{
					continue;
				}
				Vector3[] vertices = sharedMesh2.vertices;
				Vector3[] normals = sharedMesh2.normals;
				Vector4[] tangents = sharedMesh2.tangents;
				Vector2[] uv = sharedMesh2.uv;
				Vector2[] uv2 = sharedMesh2.uv2;
				int vertexCount = sharedMesh2.vertexCount;
				Matrix4x4 matrix4x = worldToLocalMatrix * component2.transform.localToWorldMatrix;
				Vector3 normalized = matrix4x.MultiplyVector(new Vector3(1f, 0f, 0f)).normalized;
				Vector3 normalized2 = matrix4x.MultiplyVector(new Vector3(0f, 1f, 0f)).normalized;
				Vector3 normalized3 = matrix4x.MultiplyVector(new Vector3(0f, 0f, 1f)).normalized;
				Vector3 lhs = Vector3.Cross(normalized, normalized2);
				float num3 = Vector3.Dot(lhs, normalized3);
				bool flag7 = num3 < 0f;
				if (flag7)
				{
					flag7 = true;
				}
				Color32 color = new Color32((byte)(key % 256), (byte)(key / 256), 0, 0);
				for (int k = 0; k < vertexCount; k++)
				{
					array[num2 + k] = matrix4x.MultiplyPoint(vertices[k]);
					array6[num2 + k] = color;
				}
				if (flag)
				{
					if (normals != null && normals.Length > 0)
					{
						for (int l = 0; l < vertexCount; l++)
						{
							Vector3 vector = normals[l];
							array2[num2 + l] = (vector.x * normalized + vector.y * normalized2 + vector.z * normalized3).normalized;
						}
					}
					else
					{
						for (int m = 0; m < vertexCount; m++)
						{
							array2[num2 + m] = normalized2;
						}
					}
					Diagnostics.Assert(array2.Length == array.Length);
				}
				if (flag2)
				{
					float num4 = (!flag7) ? 1 : (-1);
					if (tangents != null && tangents.Length > 0)
					{
						for (int n = 0; n < vertexCount; n++)
						{
							Vector4 vector2 = tangents[n];
							Vector3 normalized4 = (vector2.x * normalized + vector2.y * normalized2 + vector2.z * normalized3).normalized;
							array3[num2 + n] = new Vector4(normalized4.x * num4, normalized4.y * num4, normalized4.z * num4, vector2.w);
						}
					}
					else
					{
						for (int num5 = 0; num5 < vertexCount; num5++)
						{
							array3[num2 + num5] = new Vector4(normalized3.x, normalized3.y, normalized3.z, 1f);
						}
					}
					Diagnostics.Assert(array3.Length == array.Length);
				}
				if (flag3)
				{
					if (uv != null && uv.Length > 0)
					{
						for (int num6 = 0; num6 < vertexCount; num6++)
						{
							array4[num2 + num6] = uv[num6];
						}
					}
					else
					{
						for (int num7 = 0; num7 < vertexCount; num7++)
						{
							array4[num2 + num7] = Vector2.zero;
						}
					}
					Diagnostics.Assert(array4.Length == array.Length);
				}
				if (flag4)
				{
					if (uv2 != null && uv2.Length > 0)
					{
						for (int num8 = 0; num8 < vertexCount; num8++)
						{
							array5[num2 + num8] = uv2[num8];
						}
					}
					else
					{
						for (int num9 = 0; num9 < vertexCount; num9++)
						{
							array5[num2 + num9] = Vector2.zero;
						}
					}
					Diagnostics.Assert(array5.Length == array.Length);
				}
				int[] indices = sharedMesh2.GetIndices(0);
				if (meshTopology == MeshTopology.Triangles && flag7)
				{
					int num10 = indices.Length / 3;
					for (int num11 = 0; num11 < num10; num11++)
					{
						int num12 = indices[num11 * 3];
						int num13 = indices[num11 * 3 + 1];
						int num14 = indices[num11 * 3 + 2];
						list.Add(num12 + num2);
						list.Add(num14 + num2);
						list.Add(num13 + num2);
					}
				}
				else
				{
					for (int num15 = 0; num15 < indices.Length; num15++)
					{
						list.Add(indices[num15] + num2);
					}
				}
				num2 += vertexCount;
				value.enabled = false;
			}
			Mesh mesh = new Mesh();
			mesh.name = $"MESH-{unityMaterial.name}";
			mesh.vertices = array;
			mesh.colors32 = array6;
			if (flag)
			{
				mesh.normals = array2;
			}
			if (flag2)
			{
				mesh.tangents = array3;
			}
			if (flag3)
			{
				mesh.uv = array4;
			}
			if (flag4)
			{
				mesh.uv2 = array5;
			}
			mesh.SetIndices(list.ToArray(), meshTopology, 0);
			mesh.RecalculateBounds();
			addedGameObject = new GameObject($"GO-{unityMaterial.name}");
			addedGameObject.transform.parent = whereToAdd;
			addedGameObject.transform.localPosition = Vector3.zero;
			addedGameObject.transform.localRotation = Quaternion.identity;
			addedGameObject.transform.localScale = Vector3.one;
			addedMeshFilter = addedGameObject.AddComponent<MeshFilter>();
			addedMeshRenderer = addedGameObject.AddComponent<MeshRenderer>();
			addedMeshRenderer.material = unityMaterial;
			addedMeshFilter.mesh = mesh;
		}

		public void Unload()
		{
			for (int i = 0; i < roomIndexAndMeshRenderers.Count; i++)
			{
				roomIndexAndMeshRenderers[i] = new KeyValuePair<int, MeshRenderer>(0, null);
			}
			roomIndexAndMeshRenderers = null;
			addedGameObject = null;
			if (UnityMaterial != null)
			{
				UnityEngine.Object.DestroyImmediate(UnityMaterial, allowDestroyingAssets: true);
				unityMaterial = null;
			}
		}

		public void Hide()
		{
			if (addedMeshRenderer != null)
			{
				addedMeshRenderer.enabled = false;
			}
		}

		public void Show()
		{
			if (addedMeshRenderer != null)
			{
				addedMeshRenderer.enabled = true;
			}
		}
	}

	public Shader[] impactedShaders;

	public Shader[] convertedShaders;

	private List<OneMaterialMesh> oneMaterialMeshes;

	private int currentRoomIndex;

	private LookupTextureHandler roomActivationLookupTextureHandler;

	private List<HxRoomToDungeonMeshPacker> hxRoomToDungeonMeshPackers;

	public void LoadFrom(HxDungeonMeshPacker other)
	{
		impactedShaders = other.impactedShaders;
		convertedShaders = other.convertedShaders;
	}

	public void DoItNow()
	{
		Diagnostics.Assert(roomActivationLookupTextureHandler != null);
		Diagnostics.Assert(impactedShaders != null);
		Diagnostics.Assert(convertedShaders != null);
		Harvest();
		MeshGroup();
	}

	protected void Awake()
	{
		if (GameManager.Preferences.GameGraphicSettings.HxDungeonMeshPackingDeactivated)
		{
			UnityEngine.Object.DestroyImmediate(this);
		}
		else
		{
			roomActivationLookupTextureHandler = new LookupTextureHandler("RoomActivation", "_RoomActivation", 16, 16, TextureWrapMode.Clamp);
		}
	}

	protected void OnDisable()
	{
		if (hxRoomToDungeonMeshPackers != null)
		{
			for (int i = 0; i < hxRoomToDungeonMeshPackers.Count; i++)
			{
				hxRoomToDungeonMeshPackers[i] = null;
			}
			hxRoomToDungeonMeshPackers = null;
		}
		if (oneMaterialMeshes != null)
		{
			for (int j = 0; j < oneMaterialMeshes.Count; j++)
			{
				oneMaterialMeshes[j].Unload();
			}
			oneMaterialMeshes = null;
		}
	}

	protected void OnDestroy()
	{
		if (roomActivationLookupTextureHandler != null)
		{
			roomActivationLookupTextureHandler.Unload();
			roomActivationLookupTextureHandler = null;
		}
	}

	protected void Update()
	{
		if (roomActivationLookupTextureHandler != null)
		{
			roomActivationLookupTextureHandler.Update(null, doBlit: false);
		}
	}

	public void OnRoomEnabled(int roomIndex)
	{
		roomActivationLookupTextureHandler.ColorBuffer[roomIndex] = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
		roomActivationLookupTextureHandler.MarkAsDirty();
	}

	public void OnRoomDisabled(int roomIndex)
	{
		roomActivationLookupTextureHandler.ColorBuffer[roomIndex] = new Color32(0, 0, 0, 0);
		roomActivationLookupTextureHandler.MarkAsDirty();
	}

	private void Harvest()
	{
		Diagnostics.Assert(convertedShaders != null);
		Diagnostics.Assert(impactedShaders != null);
		Diagnostics.Assert(convertedShaders.Length == impactedShaders.Length);
		oneMaterialMeshes = new List<OneMaterialMesh>();
		hxRoomToDungeonMeshPackers = new List<HxRoomToDungeonMeshPacker>();
		currentRoomIndex = 0;
		HarvestRecursively(base.transform, currentRoomIndex);
	}

	protected void HarvestRecursively(Transform currentTransform, int roomIndex)
	{
		Room component = currentTransform.GetComponent<Room>();
		bool flag = false;
		if (component != null)
		{
			currentRoomIndex++;
			roomIndex = currentRoomIndex;
			flag = true;
		}
		DoorStep component2 = currentTransform.GetComponent<DoorStep>();
		if (component2 != null)
		{
			currentRoomIndex++;
			roomIndex = currentRoomIndex;
			flag = true;
		}
		if (flag)
		{
			HxRoomToDungeonMeshPacker hxRoomToDungeonMeshPacker = currentTransform.gameObject.AddComponent<HxRoomToDungeonMeshPacker>();
			hxRoomToDungeonMeshPacker.Init(roomIndex, this);
			hxRoomToDungeonMeshPackers.Add(hxRoomToDungeonMeshPacker);
		}
		MeshRenderer component3 = currentTransform.GetComponent<MeshRenderer>();
		if (component3 != null)
		{
			Material sharedMaterial = component3.sharedMaterial;
			if (sharedMaterial != null)
			{
				Shader shader = sharedMaterial.shader;
				Shader shader2 = null;
				for (int i = 0; i < impactedShaders.Length; i++)
				{
					if (impactedShaders[i] == shader)
					{
						shader2 = convertedShaders[i];
					}
				}
				if (shader2 != null)
				{
					OneMaterialMesh orCreateOneMaterialMesh = GetOrCreateOneMaterialMesh(sharedMaterial, shader2);
					orCreateOneMaterialMesh.AddMeshRenderer(currentRoomIndex, component3);
				}
			}
		}
		int childCount = currentTransform.childCount;
		for (int j = 0; j < childCount; j++)
		{
			HarvestRecursively(currentTransform.GetChild(j), roomIndex);
		}
	}

	protected void MeshGroup()
	{
		for (int i = 0; i < oneMaterialMeshes.Count; i++)
		{
			oneMaterialMeshes[i].MeshGroup();
		}
	}

	private OneMaterialMesh GetOrCreateOneMaterialMesh(Material material, Shader convertedShader)
	{
		for (int i = 0; i < oneMaterialMeshes.Count; i++)
		{
			if (oneMaterialMeshes[i].UnityMaterial == material || oneMaterialMeshes[i].UnityMaterial.name == material.name)
			{
				Diagnostics.Assert(oneMaterialMeshes[i].UnityMaterial.shader == convertedShader);
				return oneMaterialMeshes[i];
			}
		}
		OneMaterialMesh oneMaterialMesh = new OneMaterialMesh(material, convertedShader, base.transform);
		oneMaterialMeshes.Add(oneMaterialMesh);
		return oneMaterialMesh;
	}
}
public class HxRoomToDungeonMeshPacker : MonoBehaviour
{
	private HxDungeonMeshPacker dungeonMeshPacker;

	private int roomIndex;

	public void Init(int roomIndex, HxDungeonMeshPacker dungeonMeshPacker)
	{
		this.roomIndex = roomIndex;
		this.dungeonMeshPacker = dungeonMeshPacker;
		if (base.gameObject.activeSelf)
		{
			this.dungeonMeshPacker.OnRoomEnabled(roomIndex);
		}
	}

	public void OnEnable()
	{
		if (dungeonMeshPacker != null)
		{
			dungeonMeshPacker.OnRoomEnabled(roomIndex);
		}
	}

	public void OnDisable()
	{
		if (dungeonMeshPacker != null)
		{
			dungeonMeshPacker.OnRoomDisabled(roomIndex);
		}
	}
}
public interface ILightManagerService : IService
{
	bool Enabled
	{
		get;
	}

	void AddEvent(ILightManagerServiceOnUpdateEvent oneEvent);

	void RemoveEvent(ILightManagerServiceOnUpdateEvent oneEvent);

	void OnPreRenderHook(Camera camera);

	int RegisterLight(Light light, bool castShadow, bool ignoreSmallMove);

	void UnregisterLight(int index);

	int RegisterSprite(Vector3 pos, Vector3 rightTopCornerDirection, Vector2 texCoord, Vector2 sizeInPixels, bool transparent, bool dynamic);

	void MoveSprite(int index, Vector3 pos, Vector3 rightTopCornerDirection);

	void UpdateSprite(int index, Vector2 texCoord, Vector2 sizeInPixels, bool transparent);

	void UnregisterSprite(int index);
}
public interface IRunTimeSpritePackerService : IService
{
	void GetBlackOpaqueSpriteInfo(out Vector2 texCoord, out Vector2 sizeInPixels, out Vector2 centerPosRelativeToHotSpot);

	int UseSprite(Sprite sprite, Shader shader, Vector2 hotSpotIn01, out Vector2 texCoord, out Vector2 sizeInPixels, out Vector2 centerPosRelativeToHotSpot, out bool transparent);
}
[RequireComponent(typeof(MeshFilter))]
public class LightBlockerToLightManager : MonoBehaviour
{
	public enum UsageType
	{
		LightBlocker,
		DoorWall,
		Door
	}

	private int spriteIndex = -1;

	private ILightManagerService lightManagerService;

	private IRunTimeSpritePackerService runTimeSpritePackerService;

	private MeshFilter meshFilter;

	private bool eventAdded;

	[SerializeField]
	private UsageType usage;

	private Vector3 previousSpritePos;

	private Vector3 previousRightTopCornerDirection;

	public UsageType Usage
	{
		get
		{
			return usage;
		}
		set
		{
			if (usage != value)
			{
				usage = value;
				if (spriteIndex >= 0)
				{
					OnDisable();
					OnEnable();
				}
			}
		}
	}

	protected IEnumerator Start()
	{
		if (GameManager.Preferences.GameGraphicSettings.HxLightTotallyDeactivated)
		{
			UnityEngine.Object.DestroyImmediate(this);
			yield break;
		}
		while (lightManagerService == null)
		{
			lightManagerService = Services.GetService<ILightManagerService>();
			if (lightManagerService == null)
			{
				yield return null;
			}
		}
		Diagnostics.Assert(lightManagerService != null);
		while (runTimeSpritePackerService == null)
		{
			runTimeSpritePackerService = Services.GetService<IRunTimeSpritePackerService>();
			if (runTimeSpritePackerService == null)
			{
				yield return null;
			}
		}
		meshFilter = base.transform.GetComponent<MeshFilter>();
		lightManagerService.AddEvent(OnUpdateEvent);
		eventAdded = true;
		AddAndUpdateSprite();
		yield return null;
	}

	protected void OnUpdateEvent(Camera camera, Vector3 minBBox, Vector3 maxBBox)
	{
		AddAndUpdateSprite();
	}

	protected void AddAndUpdateSprite()
	{
		Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
		Vector3 vector = localToWorldMatrix.MultiplyPoint(meshFilter.sharedMesh.bounds.center);
		Vector3 vector2 = localToWorldMatrix.MultiplyVector(meshFilter.sharedMesh.bounds.extents * 2f);
		if (spriteIndex == -1)
		{
			runTimeSpritePackerService.GetBlackOpaqueSpriteInfo(out Vector2 texCoord, out Vector2 sizeInPixels, out Vector2 _);
			bool dynamic = GetDynamic();
			if (dynamic)
			{
				sizeInPixels = new Vector2(1f, 1f);
			}
			spriteIndex = lightManagerService.RegisterSprite(vector, vector2, texCoord, sizeInPixels, transparent: false, dynamic);
		}
		else if (previousSpritePos != vector || previousRightTopCornerDirection != vector2)
		{
			lightManagerService.MoveSprite(spriteIndex, vector, vector2);
		}
		previousSpritePos = vector;
		previousRightTopCornerDirection = vector2;
	}

	protected void OnDisable()
	{
		if (lightManagerService != null && spriteIndex >= 0)
		{
			lightManagerService.UnregisterSprite(spriteIndex);
			if (eventAdded)
			{
				lightManagerService.RemoveEvent(OnUpdateEvent);
				eventAdded = false;
			}
			spriteIndex = -1;
		}
	}

	protected void OnEnable()
	{
		if (lightManagerService != null && spriteIndex < 0)
		{
			AddAndUpdateSprite();
			if (!eventAdded)
			{
				eventAdded = true;
				lightManagerService.AddEvent(OnUpdateEvent);
			}
		}
	}

	protected void OnDestroy()
	{
		if (lightManagerService != null)
		{
			if (spriteIndex >= 0)
			{
				lightManagerService.UnregisterSprite(spriteIndex);
				spriteIndex = -1;
			}
			if (eventAdded)
			{
				lightManagerService.RemoveEvent(OnUpdateEvent);
				eventAdded = false;
			}
		}
		lightManagerService = null;
		meshFilter = null;
	}

	private bool GetDynamic()
	{
		switch (usage)
		{
		case UsageType.LightBlocker:
			return false;
		case UsageType.DoorWall:
			return false;
		case UsageType.Door:
			return true;
		default:
			Diagnostics.Assert(condition: false);
			return false;
		}
	}
}
public class LightManager : MonoBehaviour, ILightManagerService, IService
{
	private struct InternalSpriteLightBlocker
	{
		public static readonly int PixelToEncode = 4;

		public static readonly string LookupTextureName = "_SpriteLightBlockerTextureLookup";

		private Vector3 pos;

		private Vector3 rightTopCornerDirection;

		public Vector2 TexCoord;

		public Vector2 TexSize;

		private bool transparent;

		private bool used;

		private bool dynamic;

		private bool occluder;

		public int TexCoordForNoDoublon;

		public bool Useless => Unused || Transparent;

		public bool Unused => !used;

		public bool Transparent => transparent;

		public bool Dynamic => dynamic;

		public bool Occluder => occluder;

		public Vector3 Pos => pos;

		public Vector3 RightTopCornerDirection => rightTopCornerDirection;

		public InternalSpriteLightBlocker(Vector3 pos, Vector3 rightTopCornerDirection, Vector2 texCoord, Vector2 texSize, bool transparent, bool dynamic, bool occluder)
		{
			this.pos = pos;
			this.rightTopCornerDirection = rightTopCornerDirection;
			TexCoord = texCoord;
			TexSize = texSize;
			TexCoordForNoDoublon = -1;
			this.transparent = transparent;
			used = true;
			this.dynamic = dynamic;
			this.occluder = occluder;
		}

		public void EncodeTo(Color32[] colorBuffer, int startIndex, Vector4 encodingLightAndSpriteBBoxMin, Vector4 max16BitValueOverBBoxExtent, Vector4 minSpriteSizeBBox, Vector4 max16BitValueOverSpriteSizeBBoxExtent)
		{
			int val = 65535;
			Diagnostics.Assert(startIndex % PixelToEncode == 0);
			int num = Math.Max(0, Math.Min(val, (int)((pos.x - encodingLightAndSpriteBBoxMin.x) * max16BitValueOverBBoxExtent.x)));
			int num2 = Math.Max(0, Math.Min(val, (int)((pos.y - encodingLightAndSpriteBBoxMin.y) * max16BitValueOverBBoxExtent.y)));
			int num3 = Math.Max(0, Math.Min(val, (int)((pos.z - encodingLightAndSpriteBBoxMin.z) * max16BitValueOverBBoxExtent.z)));
			int num4 = Math.Max(0, Math.Min(val, (int)((rightTopCornerDirection.x - minSpriteSizeBBox.x) * max16BitValueOverSpriteSizeBBoxExtent.x)));
			int num5 = Math.Max(0, Math.Min(val, (int)((rightTopCornerDirection.y - minSpriteSizeBBox.y) * max16BitValueOverSpriteSizeBBoxExtent.y)));
			int num6 = Math.Max(0, Math.Min(val, (int)((rightTopCornerDirection.z - minSpriteSizeBBox.z) * max16BitValueOverSpriteSizeBBoxExtent.z)));
			byte r = (byte)Math.Max(0, Math.Min(255, (int)(TexCoord.x * 256f)));
			byte g = (byte)Math.Max(0, Math.Min(255, (int)(TexCoord.y * 256f)));
			byte b = (byte)Math.Max(0, Math.Min(255, (int)TexSize.x));
			byte a = (byte)Math.Max(0, Math.Min(255, (int)TexSize.y));
			int num7 = 255;
			int num8 = 65280;
			colorBuffer[startIndex] = new Color32((byte)(num & num7), (byte)((num & num8) >> 8), (byte)(num3 & num7), (byte)((num3 & num8) >> 8));
			colorBuffer[startIndex + 1] = new Color32((byte)(num4 & num7), (byte)((num4 & num8) >> 8), (byte)(num6 & num7), (byte)((num6 & num8) >> 8));
			colorBuffer[startIndex + 2] = new Color32(r, g, b, a);
			colorBuffer[startIndex + 3] = new Color32((byte)(num5 & num7), (byte)((num5 & num8) >> 8), (byte)(num2 & num7), (byte)((num2 & num8) >> 8));
		}

		public void Forget()
		{
			TexCoord = Vector2.zero;
			TexSize = Vector2.zero;
			pos = Vector3.zero;
			transparent = true;
			used = false;
			rightTopCornerDirection = Vector3.zero;
		}

		public void Move(Vector3 pos, Vector3 rightTopCornerDirection)
		{
			this.pos = pos;
			this.rightTopCornerDirection = rightTopCornerDirection;
		}

		public void Modify(Vector2 texCoord, Vector2 texSize, bool transparent)
		{
			TexCoord = texCoord;
			TexSize = texSize;
			this.transparent = transparent;
		}

		public void Reuse(Vector3 pos, Vector3 rightTopCornerDirection, Vector2 texCoord, Vector2 texSize, bool transparent, bool dynamic, bool occluder)
		{
			TexCoord = texCoord;
			TexSize = texSize;
			used = true;
			this.transparent = transparent;
			this.pos = pos;
			this.rightTopCornerDirection = rightTopCornerDirection;
			this.dynamic = dynamic;
			this.occluder = occluder;
		}
	}

	private struct InternalLight
	{
		public static readonly int PixelToEncode = 4;

		public static readonly string LookupTextureName = "_LightTextureLookup";

		private Vector3 pos;

		private float range;

		private Color color;

		private float intensity;

		private Light light;

		private bool castShadow;

		private bool active;

		private bool ignoreSmallMove;

		public Light Light => light;

		public Vector3 Pos => pos;

		public Color Color => color;

		public float Range => range;

		public float Intensity => intensity;

		public bool CastShadow => castShadow;

		public bool IgnoreSmallMove => ignoreSmallMove;

		public bool Active => active;

		public InternalLight(int lightIndex, Light light, bool castShadow, bool ignoreSmallMove)
		{
			this.light = light;
			pos = Vector3.zero;
			color = Color.black;
			range = 0f;
			intensity = 0f;
			active = false;
			this.ignoreSmallMove = ignoreSmallMove;
			this.castShadow = castShadow;
			Update();
		}

		public bool Update()
		{
			bool flag = false;
			if (light != null)
			{
				Color lhs = light.color;
				float num = light.range;
				float num2 = light.intensity;
				Vector3 position = light.transform.position;
				bool flag2 = castShadow;
				bool enabled = light.enabled;
				flag = (lhs != color || num != range || num2 != intensity || position != pos || flag2 != castShadow || enabled != active);
				color = lhs;
				range = num;
				intensity = num2;
				pos = position;
				castShadow = flag2;
				active = enabled;
			}
			else
			{
				flag = active;
				color = Color.black;
				range = 0f;
				intensity = 0f;
				pos = Vector3.zero;
				active = false;
				castShadow = false;
			}
			return flag;
		}

		public void EncodeTo(Color32[] colorBuffer, int startIndex, Vector4 encodingLightAndSpriteBBoxMin, Vector4 max16BitValueOverBBoxExtent)
		{
			Diagnostics.Assert(startIndex % PixelToEncode == 0);
			int val = 65535;
			int num = Math.Max(0, Math.Min(val, (int)((pos.x - encodingLightAndSpriteBBoxMin.x) * max16BitValueOverBBoxExtent.x)));
			int num2 = Math.Max(0, Math.Min(val, (int)((pos.y - encodingLightAndSpriteBBoxMin.y) * max16BitValueOverBBoxExtent.y)));
			int num3 = Math.Max(0, Math.Min(val, (int)((pos.z - encodingLightAndSpriteBBoxMin.z) * max16BitValueOverBBoxExtent.z)));
			int num4 = Math.Max(0, Math.Min(val, (int)((range - encodingLightAndSpriteBBoxMin.w) * max16BitValueOverBBoxExtent.w)));
			byte a = (byte)Math.Max(0, Math.Min(255, (int)((double)intensity * 0.2 * 255.0)));
			Color32 color = this.color;
			color.a = a;
			int num5 = 255;
			int num6 = 65280;
			colorBuffer[startIndex] = new Color32((byte)(num & num5), (byte)((num & num6) >> 8), (byte)(num2 & num5), (byte)((num2 & num6) >> 8));
			colorBuffer[startIndex + 1] = new Color32((byte)(num3 & num5), (byte)((num3 & num6) >> 8), (byte)(num4 & num5), (byte)((num4 & num6) >> 8));
			colorBuffer[startIndex + 2] = color;
		}

		public void Forget()
		{
			light = null;
			castShadow = false;
			pos = Vector3.zero;
			color = Color.black;
			range = -1f;
			intensity = -1f;
		}

		public void Reuse(Light light, bool castShadow, bool ignoreSmallMove)
		{
			Diagnostics.Assert(this.light == null);
			Diagnostics.Assert(light != null);
			this.light = light;
			this.ignoreSmallMove = ignoreSmallMove;
			this.castShadow = castShadow;
			Update();
		}
	}

	private class LightAndBlockerIndexBuffer
	{
		public int[] LightWithShadowIndexBuffer;

		public float[] LightWithShadowIndexIntensity;

		public int LightWithShadowCount;

		public int[] LightWithoutShadowIndexBuffer;

		public float[] LightWithoutShadowIndexIntensity;

		public int LightWithoutShadowCount;

		public int[] BlockerIndexBuffer;

		public int BlockerIndexCount;

		public LightAndBlockerIndexBuffer()
		{
			LightWithShadowIndexBuffer = new int[255];
			LightWithShadowIndexIntensity = new float[255];
			LightWithoutShadowIndexBuffer = new int[255];
			LightWithoutShadowIndexIntensity = new float[255];
			BlockerIndexBuffer = new int[255];
		}

		public void Clear()
		{
			LightWithShadowCount = 0;
			LightWithoutShadowCount = 0;
			BlockerIndexCount = 0;
		}
	}

	private class LightAndIndexUpdateStackElem
	{
		public int StartX;

		public int StartY;

		public int Level;
	}

	private struct DirtyRect
	{
		public Vector2 Center;

		public float RangeSq;

		public DirtyRect(Vector2 center, float range)
		{
			Center = center;
			RangeSq = range * range;
		}
	}

	private const string MinBBoxShaderParamName = "_MinBBox";

	private const string MaxBBoxShaderParamName = "_MaxBBox";

	private const string MinLookupBBoxShaderParamName = "_MinLookupBBox";

	private const string MaxLookupBBoxShaderParamName = "_MaxLookupBBox";

	private const string MinSpriteSizeBBoxShaderParamName = "_MinSpriteSizeBBox";

	private const string MaxSpriteSizeBBoxShaderParamName = "_MaxSpriteSizeBBox";

	private const string DynamicLightAndBlockerIndexLookupTextureName = "_DynamicFirstPassLightAndBlockerIndexLookup";

	private const string DynamicLightAndBlockerIndexLookupRenderTextureName = "_DynamicLightAndBlockerIndexLookup";

	private const string StaticLightAndBlockerIndexLookupTextureName = "_StaticFirstPassLightAndBlockerIndexLookup";

	private const string StaticLightAndBlockerIndexLookupRenderTextureName = "_StaticLightAndBlockerIndexLookup";

	private const string FusionLightAndBlockerIndexLookupRenderTextureName = "_LightAndBlockerIndexLookup";

	[SerializeField]
	public Vector4 MinSpriteSizeBBox = new Vector4(-512f, -512f, -512f, 0f);

	[SerializeField]
	public Vector4 MaxSpriteSizeBBox = new Vector4(512f, 512f, 512f, 512f);

	[SerializeField]
	public int DebugAlternateEnable;

	[SerializeField]
	public bool Verbose;

	[SerializeField]
	public bool StopUpdateForDebug;

	[SerializeField]
	public bool StopRenderUpdateForDebug;

	[SerializeField]
	public bool AlwaysUpdateStaticContent;

	private static readonly int StartPixelToEncodeLightWithoutShadowIndex;

	private static readonly int PixelToEncodeLightWithoutShadowIndex = 2;

	private static readonly int StartPixelToEncodeLightWithShadowIndex = 2;

	private static readonly int PixelToEncodeLightWithShadowIndex = 2;

	private static readonly int StartPixelToEncodeBlockerIndex = 4;

	private static readonly int PixelToEncodeBlockerIndex = 2;

	private static readonly int PixelToEncodeLightAndBlockerIndex = 8;

	private static readonly int MinValidLightIndex = 2;

	private static readonly int MinValidSpriteIndex = 2;

	private HiPerformanceCounter preRenderTimePC;

	private HiPerformanceCounter fpsPC;

	private HiPerformanceCounter encodingPC;

	private HiPerformanceCounter staticPartUpdatePC;

	private HiPerformanceCounter dynamicPartUpdatePC;

	private HiPerformanceCounter updateLoopPC;

	private HiPerformanceCounter fillLightBufferPC;

	private HiPerformanceCounter fillBlockerBufferPC;

	private HiPerformanceCounter fillColorBufferPC;

	[SerializeField]
	private int lightAndBlockerLookupSize = 16;

	[SerializeField]
	private int lightAndBlockerLookupFirstPassSize = 4;

	[SerializeField]
	private int secondLightAndBlockerLookupSize = 128;

	[SerializeField]
	private string[] upscaleStaticLightAndBlockerLookupRTMaterialNames = new string[2]
	{
		"HxLight/UpscaleStaticLightAndBlockerTextureLookupMat",
		"HxLight/UpscaleStaticLightAndBlockerTextureLookupSecondPassMat"
	};

	[SerializeField]
	private string[] upscaleDynamicLightAndBlockerLookupRTMaterialNames = new string[2]
	{
		"HxLight/UpscaleDynamicLightAndBlockerTextureLookupMat",
		"HxLight/UpscaleDynamicLightAndBlockerTextureLookupSecondPassMat"
	};

	[SerializeField]
	private string[] fusionLightAndBlockerLookupRTMaterialNames = new string[1]
	{
		"HxLight/FusionLightAndBlockerTextureLookupMat"
	};

	[SerializeField]
	private int maxBlockerCount = 8;

	[SerializeField]
	private int maxLightWithShadowCount = 4;

	[SerializeField]
	private int maxLightWithoutShadowCount = 8;

	private Vector4 max16BitValueOverBBoxExtent;

	private Vector4 max16BitValueOverSpriteSizeBBoxExtent;

	private bool loaded;

	private Vector4 bboxExtent;

	private Vector4 spriteSizeBBoxExtent;

	private LookupTextureHandler lightLookupTexture;

	private InternalLight[] internalLights;

	private int internalLightCount;

	private float biggestLightRange;

	private float biggestBlockerRange;

	private float minLightY;

	private float maxLightY;

	private LookupTextureHandler spriteLightBlockerLookupTexture;

	private InternalSpriteLightBlocker[] internalSpriteLightBlockers;

	private int internalSpriteLightBlockerCount;

	private LookupTextureHandler dynamicLightAndBlockerIndexLookupTexture;

	private LookupTextureHandler staticLightAndBlockerIndexLookupTexture;

	private LookupTextureHandler fusionLightAndBlockerIndexLookupTexture;

	private List<LightAndBlockerIndexBuffer> lightAndBlockerIndexBuffers;

	private List<LightAndIndexUpdateStackElem> lightAndIndexUpdateStackElems;

	private Vector4 encodingLightAndSpriteBBoxMin = Vector4.zero;

	private Vector4 encodingLightAndSpriteBBoxMax = Vector4.zero;

	private Vector4 lookupBBoxMin;

	private Vector4 lookupBBoxMax;

	private bool forceRecomputeStaticContentNextUpdate;

	private List<DirtyRect> staticPartDirtyRects;

	private int lastFrameIndexOnPreRender = -1;

	private IVideoStateService videoStateService;

	private bool manualyEnabled = true;

	public bool Loaded => loaded;

	public bool Enabled => manualyEnabled;

	public int MaxLightWithShadowCount
	{
		get
		{
			return maxLightWithShadowCount;
		}
		set
		{
			maxLightWithShadowCount = value;
		}
	}

	public int MaxLightWithoutShadowCount
	{
		get
		{
			return maxLightWithoutShadowCount;
		}
		set
		{
			maxLightWithoutShadowCount = value;
		}
	}

	public Vector3 EncodingLightAndSpriteBBoxMin => encodingLightAndSpriteBBoxMin;

	public Vector3 EncodingLightAndSpriteBBoxMax => encodingLightAndSpriteBBoxMax;

	public bool ManualyEnabled
	{
		get
		{
			return manualyEnabled;
		}
		set
		{
			if (manualyEnabled != value)
			{
				manualyEnabled = value;
			}
		}
	}

	public int SecondLightAndBlockerLookupSize
	{
		get
		{
			return secondLightAndBlockerLookupSize;
		}
		set
		{
			if (value == secondLightAndBlockerLookupSize || value < lightAndBlockerLookupSize)
			{
				return;
			}
			int num = 1;
			for (int i = 0; i < 12; i++)
			{
				int num2 = 1 << i;
				if (num2 <= value)
				{
					num = num2;
				}
			}
			if (secondLightAndBlockerLookupSize != num)
			{
				secondLightAndBlockerLookupSize = num;
				int width = secondLightAndBlockerLookupSize * PixelToEncodeLightAndBlockerIndex;
				int height = secondLightAndBlockerLookupSize / 2;
				staticLightAndBlockerIndexLookupTexture.ResizeRenderTexture(width, height);
				dynamicLightAndBlockerIndexLookupTexture.ResizeRenderTexture(width, height);
				fusionLightAndBlockerIndexLookupTexture.ResizeRenderTexture(width, height);
				forceRecomputeStaticContentNextUpdate = true;
			}
		}
	}

	public int LightAndBlockerLookupSize
	{
		get
		{
			return lightAndBlockerLookupSize;
		}
		set
		{
			if (value == lightAndBlockerLookupSize)
			{
				return;
			}
			int num = 1;
			for (int i = 0; i < 12; i++)
			{
				int num2 = 1 << i;
				if (num2 <= value)
				{
					num = num2;
				}
			}
			if (lightAndBlockerLookupSize == num)
			{
				return;
			}
			int num3 = lightAndBlockerLookupSize;
			while (num3 < num)
			{
				num3 *= 2;
				lightAndBlockerIndexBuffers.Add(new LightAndBlockerIndexBuffer());
				for (int j = 0; j < 4; j++)
				{
					lightAndIndexUpdateStackElems.Add(new LightAndIndexUpdateStackElem());
				}
			}
			lightAndBlockerLookupSize = num;
			staticLightAndBlockerIndexLookupTexture.Resize(lightAndBlockerLookupSize * PixelToEncodeLightAndBlockerIndex, lightAndBlockerLookupSize);
			dynamicLightAndBlockerIndexLookupTexture.Resize(lightAndBlockerLookupSize * PixelToEncodeLightAndBlockerIndex, lightAndBlockerLookupSize);
		}
	}

	public int LightAndBlockerLookupFirstPassSize
	{
		get
		{
			return lightAndBlockerLookupFirstPassSize;
		}
		set
		{
			if (lightAndBlockerLookupFirstPassSize == value)
			{
				return;
			}
			int num = 1;
			for (int i = 0; i < 20; i++)
			{
				int num2 = 1 << i;
				if (num2 <= value)
				{
					num = num2;
				}
			}
			lightAndBlockerLookupFirstPassSize = num;
		}
	}

	public event ILightManagerServiceOnUpdateEvent onUpdateEvents;

	public int RegisterLight(Light light, bool castShadow, bool ignoreSmallMove)
	{
		Diagnostics.Assert(light != null);
		Diagnostics.Assert(internalLights != null);
		Diagnostics.Assert(internalLightCount > 0);
		int num = -1;
		Vector3 position = light.transform.position;
		float y = position.y;
		biggestLightRange = Math.Max(biggestLightRange, light.range);
		minLightY = Math.Min(minLightY, y);
		maxLightY = Math.Max(maxLightY, y);
		staticPartDirtyRects.Add(new DirtyRect(new Vector2(position.x, position.z), light.range));
		for (int i = MinValidLightIndex; i < internalLightCount; i++)
		{
			if (internalLights[i].Light == null)
			{
				num = i;
				if (Verbose)
				{
					UnityEngine.Debug.Log($"Reusing light {num}");
				}
				internalLights[i].Reuse(light, castShadow, ignoreSmallMove);
				break;
			}
		}
		if (num == -1)
		{
			num = internalLightCount;
			internalLights[internalLightCount] = new InternalLight(num, light, castShadow, ignoreSmallMove);
			internalLightCount++;
			if (Verbose)
			{
				UnityEngine.Debug.Log($"Adding light {num}");
			}
		}
		return num;
	}

	public void UnregisterLight(int index)
	{
		Diagnostics.Assert(index >= 0);
		Diagnostics.Assert(index < internalLightCount);
		if (Verbose)
		{
			UnityEngine.Debug.Log($"Removing light {index}");
		}
		List<DirtyRect> list = staticPartDirtyRects;
		Vector3 pos = internalLights[index].Pos;
		float x = pos.x;
		Vector3 pos2 = internalLights[index].Pos;
		list.Add(new DirtyRect(new Vector2(x, pos2.z), internalLights[index].Range));
		internalLights[index].Forget();
	}

	public int RegisterSprite(Vector3 pos, Vector3 rightTopCornerDirection, Vector2 texCoord, Vector2 sizeInPixels, bool transparent, bool dynamic)
	{
		bool flag = sizeInPixels.x == 0f && sizeInPixels.y == 0f;
		Diagnostics.Assert(!flag || !dynamic);
		biggestBlockerRange = Math.Max(biggestBlockerRange, Math.Abs(rightTopCornerDirection.x));
		biggestBlockerRange = Math.Max(biggestBlockerRange, Math.Abs(rightTopCornerDirection.z));
		if (!dynamic)
		{
			forceRecomputeStaticContentNextUpdate = true;
		}
		int num = Math.Min(internalSpriteLightBlockers.Length, internalSpriteLightBlockerCount);
		for (int i = MinValidSpriteIndex; i < num; i++)
		{
			if (internalSpriteLightBlockers[i].Unused)
			{
				internalSpriteLightBlockers[i].Reuse(pos, rightTopCornerDirection, texCoord, sizeInPixels, transparent, dynamic, flag);
				Diagnostics.Assert(!internalSpriteLightBlockers[i].Unused);
				if (Verbose)
				{
					UnityEngine.Debug.Log($"Reusing spriteCollider {i}");
				}
				return i;
			}
		}
		if (internalSpriteLightBlockerCount < internalSpriteLightBlockers.Length)
		{
			int num2 = internalSpriteLightBlockerCount;
			internalSpriteLightBlockers[internalSpriteLightBlockerCount] = new InternalSpriteLightBlocker(pos, rightTopCornerDirection, texCoord, sizeInPixels, transparent, dynamic, flag);
			internalSpriteLightBlockerCount++;
			if (Verbose)
			{
				UnityEngine.Debug.Log($"Adding spriteCollider {num2}");
			}
			return num2;
		}
		if (Verbose)
		{
			UnityEngine.Debug.LogWarning("Not enough sprites available to register");
		}
		return -1;
	}

	public void MoveSprite(int index, Vector3 pos, Vector3 rightTopCornerDirection)
	{
		Diagnostics.Assert(index >= 0);
		Diagnostics.Assert(index < internalSpriteLightBlockerCount);
		Diagnostics.Assert(!internalSpriteLightBlockers[index].Unused);
		internalSpriteLightBlockers[index].Move(pos, rightTopCornerDirection);
		if (!internalSpriteLightBlockers[index].Dynamic)
		{
			forceRecomputeStaticContentNextUpdate = true;
		}
	}

	public void UpdateSprite(int index, Vector2 texCoord, Vector2 sizeInPixels, bool transparent)
	{
		Diagnostics.Assert(index >= 0);
		Diagnostics.Assert(index < internalSpriteLightBlockerCount);
		Diagnostics.Assert(!internalSpriteLightBlockers[index].Unused);
		internalSpriteLightBlockers[index].Modify(texCoord, sizeInPixels, transparent);
		if (!internalSpriteLightBlockers[index].Dynamic)
		{
			forceRecomputeStaticContentNextUpdate = true;
		}
	}

	public void UnregisterSprite(int index)
	{
		Diagnostics.Assert(index >= 0);
		Diagnostics.Assert(index < internalSpriteLightBlockerCount);
		Diagnostics.Assert(!internalSpriteLightBlockers[index].Unused);
		if (!internalSpriteLightBlockers[index].Dynamic)
		{
			forceRecomputeStaticContentNextUpdate = true;
		}
		if (Verbose)
		{
			UnityEngine.Debug.Log($"Removing spriteCollider {index}");
		}
		internalSpriteLightBlockers[index].Forget();
	}

	public void Awake()
	{
		if (!GameManager.Preferences.GameGraphicSettings.HxLightTotallyDeactivated)
		{
			internalLights = new InternalLight[255];
			internalSpriteLightBlockers = new InternalSpriteLightBlocker[255];
			for (int i = 0; i < MinValidLightIndex; i++)
			{
				internalLights[i] = default(InternalLight);
			}
			internalLightCount = MinValidLightIndex;
			for (int j = 0; j < MinValidSpriteIndex; j++)
			{
				internalSpriteLightBlockers[j] = default(InternalSpriteLightBlocker);
			}
			internalSpriteLightBlockerCount = MinValidSpriteIndex;
			staticPartDirtyRects = new List<DirtyRect>();
			Services.AddService((ILightManagerService)this);
		}
	}

	public void AddEvent(ILightManagerServiceOnUpdateEvent oneEvent)
	{
		this.onUpdateEvents = (ILightManagerServiceOnUpdateEvent)Delegate.Combine(this.onUpdateEvents, oneEvent);
	}

	public void RemoveEvent(ILightManagerServiceOnUpdateEvent oneEvent)
	{
		this.onUpdateEvents = (ILightManagerServiceOnUpdateEvent)Delegate.Remove(this.onUpdateEvents, oneEvent);
	}

	public void OnPreRenderHook(Camera camera)
	{
		if (fpsPC.Started)
		{
			fpsPC.Stop(50);
		}
		fpsPC.Start();
		if (!loaded || StopUpdateForDebug)
		{
			return;
		}
		int frameCount = Time.frameCount;
		if (frameCount <= lastFrameIndexOnPreRender)
		{
			Diagnostics.LogWarning("Double onPreRender !!");
			return;
		}
		lastFrameIndexOnPreRender = frameCount;
		preRenderTimePC.Start();
		if (DebugAlternateEnable > 0 && Time.frameCount % DebugAlternateEnable == 0)
		{
			ManualyEnabled = !ManualyEnabled;
		}
		bool flag = UpdateBBox(camera) || forceRecomputeStaticContentNextUpdate || AlwaysUpdateStaticContent;
		if (this.onUpdateEvents != null)
		{
			this.onUpdateEvents(camera, encodingLightAndSpriteBBoxMin, encodingLightAndSpriteBBoxMax);
		}
		encodingPC.Start();
		for (int i = MinValidLightIndex; i < internalLightCount; i++)
		{
			Vector3 pos = internalLights[i].Pos;
			if (internalLights[i].Update() && !internalLights[i].IgnoreSmallMove)
			{
				Vector3 pos2 = internalLights[i].Pos;
				float range = internalLights[i].Range;
				if ((pos.x + range >= lookupBBoxMin.x && pos.z + range >= lookupBBoxMin.z && pos.x - range <= lookupBBoxMax.x && pos.z - range <= lookupBBoxMax.z) || (pos2.x + range >= lookupBBoxMin.x && pos2.z + range >= lookupBBoxMin.z && pos2.x - range <= lookupBBoxMax.x && pos2.z - range <= lookupBBoxMax.z))
				{
					Vector2 a = new Vector2(pos.x, pos.z);
					Vector2 b = new Vector2(pos2.x, pos2.z);
					Vector2 vector = (a + b) * 0.5f;
					float magnitude = (a - vector).magnitude;
					staticPartDirtyRects.Add(new DirtyRect(vector, magnitude + range));
				}
			}
			biggestLightRange = Math.Max(biggestLightRange, internalLights[i].Range);
			float val = minLightY;
			Vector3 pos3 = internalLights[i].Pos;
			minLightY = Math.Min(val, pos3.y);
			float val2 = maxLightY;
			Vector3 pos4 = internalLights[i].Pos;
			maxLightY = Math.Max(val2, pos4.y);
			internalLights[i].EncodeTo(lightLookupTexture.ColorBuffer, i * InternalLight.PixelToEncode, encodingLightAndSpriteBBoxMin, max16BitValueOverBBoxExtent);
		}
		lightLookupTexture.MarkAsDirty();
		Color32[] colorBuffer = spriteLightBlockerLookupTexture.ColorBuffer;
		for (int j = MinValidSpriteIndex; j < internalSpriteLightBlockerCount; j++)
		{
			internalSpriteLightBlockers[j].EncodeTo(colorBuffer, j * InternalSpriteLightBlocker.PixelToEncode, encodingLightAndSpriteBBoxMin, max16BitValueOverBBoxExtent, MinSpriteSizeBBox, max16BitValueOverSpriteSizeBBoxExtent);
		}
		spriteLightBlockerLookupTexture.MarkAsDirty();
		encodingPC.Stop(10);
		lightLookupTexture.Update(videoStateService, doBlit: true);
		spriteLightBlockerLookupTexture.Update(videoStateService, doBlit: true);
		UpdateLightAndBlockerIndexLookup(flag, staticPartDirtyRects);
		staticLightAndBlockerIndexLookupTexture.Update(videoStateService, flag || staticPartDirtyRects.Count > 0);
		staticPartDirtyRects.Clear();
		dynamicLightAndBlockerIndexLookupTexture.Update(videoStateService, true && !StopRenderUpdateForDebug);
		fusionLightAndBlockerIndexLookupTexture.Update(videoStateService, true && !StopRenderUpdateForDebug);
		forceRecomputeStaticContentNextUpdate = false;
		preRenderTimePC.Stop(10);
	}

	protected IEnumerator Start()
	{
		if (GameManager.Preferences.GameGraphicSettings.HxLightTotallyDeactivated)
		{
			UnityEngine.Object.DestroyImmediate(this);
			yield break;
		}
		HiPerformanceCounter.InitFreq();
		TextureWrapMode textureWrapMode = TextureWrapMode.Repeat;
		lightLookupTexture = new LookupTextureHandler("LightLookup", InternalLight.LookupTextureName, 16 * InternalLight.PixelToEncode, 16, textureWrapMode);
		lightLookupTexture.Fill(new Color32(0, 0, 0, byte.MaxValue));
		spriteLightBlockerLookupTexture = new LookupTextureHandler("SpriteLightBlockerLookup", InternalSpriteLightBlocker.LookupTextureName, 16 * InternalSpriteLightBlocker.PixelToEncode, 16, textureWrapMode);
		spriteLightBlockerLookupTexture.Fill(new Color32(0, 0, 0, byte.MaxValue));
		staticLightAndBlockerIndexLookupTexture = new LookupTextureHandler("StaticLightAndBlockerIndexLookup", "_StaticFirstPassLightAndBlockerIndexLookup", lightAndBlockerLookupSize * PixelToEncodeLightAndBlockerIndex, lightAndBlockerLookupSize, textureWrapMode);
		staticLightAndBlockerIndexLookupTexture.Fill(new Color32(0, 0, 0, 0));
		dynamicLightAndBlockerIndexLookupTexture = new LookupTextureHandler("DynamicLightAndBlockerIndexLookup", "_DynamicFirstPassLightAndBlockerIndexLookup", lightAndBlockerLookupSize * PixelToEncodeLightAndBlockerIndex, lightAndBlockerLookupSize, textureWrapMode);
		dynamicLightAndBlockerIndexLookupTexture.Fill(new Color32(0, 0, 0, 0));
		int renderTextureWidth = secondLightAndBlockerLookupSize * PixelToEncodeLightAndBlockerIndex;
		int renderTextureHeight = secondLightAndBlockerLookupSize / 2;
		if (upscaleStaticLightAndBlockerLookupRTMaterialNames != null && upscaleStaticLightAndBlockerLookupRTMaterialNames.Length > 0)
		{
			staticLightAndBlockerIndexLookupTexture.AddARenderLookupRenderTexture("_StaticLightAndBlockerIndexLookup", renderTextureWidth, renderTextureHeight, upscaleStaticLightAndBlockerLookupRTMaterialNames, FilterMode.Point, upscaleStaticLightAndBlockerLookupRTMaterialNames.Length > 1);
		}
		if (upscaleDynamicLightAndBlockerLookupRTMaterialNames != null && upscaleDynamicLightAndBlockerLookupRTMaterialNames.Length > 0)
		{
			dynamicLightAndBlockerIndexLookupTexture.AddARenderLookupRenderTexture("_DynamicLightAndBlockerIndexLookup", renderTextureWidth, renderTextureHeight, upscaleDynamicLightAndBlockerLookupRTMaterialNames, FilterMode.Point, upscaleDynamicLightAndBlockerLookupRTMaterialNames.Length > 1);
		}
		fusionLightAndBlockerIndexLookupTexture = new LookupTextureHandler("FusionLightAndBlockerIndexLookup", string.Empty, 4, 4, textureWrapMode);
		if (fusionLightAndBlockerLookupRTMaterialNames != null && fusionLightAndBlockerLookupRTMaterialNames.Length > 0)
		{
			fusionLightAndBlockerIndexLookupTexture.AddARenderLookupRenderTexture("_LightAndBlockerIndexLookup", renderTextureWidth, renderTextureHeight, fusionLightAndBlockerLookupRTMaterialNames, FilterMode.Point, fusionLightAndBlockerLookupRTMaterialNames.Length > 1);
		}
		lightAndBlockerIndexBuffers = new List<LightAndBlockerIndexBuffer>();
		lightAndBlockerIndexBuffers.Add(new LightAndBlockerIndexBuffer());
		lightAndIndexUpdateStackElems = new List<LightAndIndexUpdateStackElem>();
		lightAndIndexUpdateStackElems.Add(new LightAndIndexUpdateStackElem());
		int resolution = 1;
		while (resolution < lightAndBlockerLookupSize)
		{
			resolution *= 2;
			lightAndBlockerIndexBuffers.Add(new LightAndBlockerIndexBuffer());
			for (int i = 0; i < 4; i++)
			{
				lightAndIndexUpdateStackElems.Add(new LightAndIndexUpdateStackElem());
			}
		}
		loaded = true;
		while (videoStateService == null)
		{
			videoStateService = Services.GetService<IVideoStateService>();
			if (videoStateService == null)
			{
				yield return new WaitForEndOfFrame();
			}
		}
		videoStateService.OnDeviceNoLongerLost += VideoStateServiceOnDeviceNoLongerLost;
		yield return null;
	}

	private bool UpdateBBox(Camera camera)
	{
		Vector3 vector = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
		Vector3 vector2 = new Vector3(float.MinValue, float.MinValue, float.MinValue);
		for (int i = 0; i <= 1; i++)
		{
			for (int j = 0; j <= 1; j++)
			{
				Ray ray = camera.ViewportPointToRay(new Vector3(i, j, 0f));
				for (int k = 0; k <= 1; k++)
				{
					float num = (float)k * 50f;
					Vector3 origin = ray.origin;
					float num2 = 0f - (origin.y - num);
					Vector3 direction = ray.direction;
					float d = num2 / direction.y;
					Vector3 lhs = ray.origin + ray.direction * d;
					vector = Vector3.Min(lhs, vector);
					vector2 = Vector3.Max(lhs, vector2);
				}
			}
		}
		Vector3 vector3 = (vector2 - vector) * ((2f + (float)lightAndBlockerLookupSize) / (float)lightAndBlockerLookupSize);
		float num3 = vector3.x / (float)lightAndBlockerLookupSize;
		float num4 = vector3.z / (float)lightAndBlockerLookupSize;
		float num5 = (float)Math.Floor(vector.x / num3);
		float num6 = (float)Math.Floor(vector.z / num4);
		float x = (float)Math.Ceiling(vector3.x / num3) * num3;
		float z = (float)Math.Ceiling(vector3.z / num4) * num4;
		Vector4 lhs2 = new Vector4(num5 * num3, 0f, num6 * num4, 0f);
		Vector4 lhs3 = lookupBBoxMin + new Vector4(x, 1f, z, 1f);
		if (lhs2 == lookupBBoxMin && lhs3 == lookupBBoxMax)
		{
			return false;
		}
		lookupBBoxMin = lhs2;
		lookupBBoxMax = lhs3;
		Shader.SetGlobalVector("_MinLookupBBox", lookupBBoxMin);
		Shader.SetGlobalVector("_MaxLookupBBox", lookupBBoxMax);
		float num7 = biggestLightRange + biggestBlockerRange;
		encodingLightAndSpriteBBoxMin = new Vector4(lookupBBoxMin.x - num7, minLightY - num7, lookupBBoxMin.z - num7, 0f);
		encodingLightAndSpriteBBoxMax = new Vector4(lookupBBoxMax.x + num7, maxLightY + num7, lookupBBoxMax.z + num7, biggestLightRange * 1.05f);
		bboxExtent = encodingLightAndSpriteBBoxMax - encodingLightAndSpriteBBoxMin;
		Shader.SetGlobalVector("_MinBBox", encodingLightAndSpriteBBoxMin);
		Shader.SetGlobalVector("_MaxBBox", encodingLightAndSpriteBBoxMax);
		float num8 = 65535f;
		max16BitValueOverBBoxExtent = new Vector4(num8 / bboxExtent.x, num8 / bboxExtent.y, num8 / bboxExtent.z, num8 / bboxExtent.w);
		spriteSizeBBoxExtent = MaxSpriteSizeBBox - MinSpriteSizeBBox;
		Shader.SetGlobalVector("_MinSpriteSizeBBox", MinSpriteSizeBBox);
		Shader.SetGlobalVector("_MaxSpriteSizeBBox", MaxSpriteSizeBBox);
		max16BitValueOverSpriteSizeBBoxExtent = new Vector4(num8 / spriteSizeBBoxExtent.x, num8 / spriteSizeBBoxExtent.y, num8 / spriteSizeBBoxExtent.z, num8 / spriteSizeBBoxExtent.w);
		return true;
	}

	private void UpdateLightAndBlockerIndexLookup(bool needToRecomputeStaticContent, List<DirtyRect> dirtyRects)
	{
		if (needToRecomputeStaticContent || staticPartDirtyRects.Count > 0)
		{
			staticPartUpdatePC.Start();
			bool flag = dirtyRects.Count > 4 || needToRecomputeStaticContent;
			UpdateStaticOrDynamicLightAndBlockerIndexLookup(dynamic: false, (!flag) ? dirtyRects : null);
			staticPartUpdatePC.Stop(1);
		}
		dynamicPartUpdatePC.Start();
		UpdateStaticOrDynamicLightAndBlockerIndexLookup(dynamic: true, null);
		dynamicPartUpdatePC.Stop(1);
		updateLoopPC.Clear();
		fillLightBufferPC.Clear();
		fillBlockerBufferPC.Clear();
		fillColorBufferPC.Clear();
	}

	private void UpdateStaticOrDynamicLightAndBlockerIndexLookup(bool dynamic, List<DirtyRect> dirtyRects)
	{
		LookupTextureHandler lookupTextureHandler = (!dynamic) ? staticLightAndBlockerIndexLookupTexture : dynamicLightAndBlockerIndexLookupTexture;
		Color32[] colorBuffer = lookupTextureHandler.ColorBuffer;
		for (int i = 0; i < internalSpriteLightBlockerCount; i++)
		{
			internalSpriteLightBlockers[i].TexCoordForNoDoublon = -1;
		}
		lightAndBlockerIndexBuffers[0].Clear();
		FillPrePassLightIndexBuffer(lightAndBlockerIndexBuffers[0], dynamic);
		if (dynamic)
		{
			FillPrePassBlockerIndexBuffer(lightAndBlockerIndexBuffers[0], dynamic, addOccluder: true, addNoOccluder: true);
		}
		else
		{
			FillPrePassBlockerIndexBuffer(lightAndBlockerIndexBuffers[0], dynamic, addOccluder: true, addNoOccluder: false);
			FillPrePassBlockerIndexBuffer(lightAndBlockerIndexBuffers[0], dynamic, addOccluder: false, addNoOccluder: true);
		}
		int num = 0;
		for (int num2 = 1; num2 >= 0; num2--)
		{
			for (int num3 = 1; num3 >= 0; num3--)
			{
				LightAndIndexUpdateStackElem lightAndIndexUpdateStackElem = lightAndIndexUpdateStackElems[num];
				lightAndIndexUpdateStackElem.Level = 1;
				lightAndIndexUpdateStackElem.StartX = num3;
				lightAndIndexUpdateStackElem.StartY = num2;
				num++;
			}
		}
		float num4 = lookupBBoxMax.x - lookupBBoxMin.x;
		float num5 = lookupBBoxMax.z - lookupBBoxMin.z;
		int num6 = 0;
		while (num > 0)
		{
			updateLoopPC.Start();
			LightAndIndexUpdateStackElem lightAndIndexUpdateStackElem2 = lightAndIndexUpdateStackElems[num - 1];
			num--;
			Diagnostics.Assert(lightAndIndexUpdateStackElem2.Level > 0);
			int level = lightAndIndexUpdateStackElem2.Level;
			int startX = lightAndIndexUpdateStackElem2.StartX;
			int startY = lightAndIndexUpdateStackElem2.StartY;
			int num7 = 1 << level;
			lightAndIndexUpdateStackElem2 = null;
			int num8 = lightAndBlockerLookupSize / num7;
			float num9 = num4 / (float)num7;
			float num10 = num5 / (float)num7;
			float num11 = num9 * 0.5f;
			float num12 = num10 * 0.5f;
			float num13 = lookupBBoxMin.x + num9 * ((float)startX + 0.5f);
			float num14 = lookupBBoxMin.z + num10 * ((float)startY + 0.5f);
			if (dirtyRects != null)
			{
				bool flag = false;
				for (int j = 0; j < dirtyRects.Count; j++)
				{
					DirtyRect dirtyRect = dirtyRects[j];
					Vector2 vector = new Vector2(num13, num14) - dirtyRect.Center;
					float sqrMagnitude = new Vector2(Math.Max(vector.x - num11, 0f), Math.Max(vector.y - num12, 0f)).sqrMagnitude;
					flag = (flag || sqrMagnitude < dirtyRect.RangeSq);
				}
				if (!flag)
				{
					updateLoopPC.Stop();
					continue;
				}
			}
			LightAndBlockerIndexBuffer previousLightAndBlockerIndexBuffer = lightAndBlockerIndexBuffers[level - 1];
			LightAndBlockerIndexBuffer lightAndBlockerIndexBuffer = lightAndBlockerIndexBuffers[level];
			num6++;
			lightAndBlockerIndexBuffer.Clear();
			fillLightBufferPC.Start();
			FillLightBuffer(previousLightAndBlockerIndexBuffer, lightAndBlockerIndexBuffer, num13, num14, num11, num12);
			fillLightBufferPC.Stop();
			fillBlockerBufferPC.Start();
			FillBlockerBuffer(previousLightAndBlockerIndexBuffer, lightAndBlockerIndexBuffer, num13, num14, num11, num12, num6);
			fillBlockerBufferPC.Stop();
			if (num8 == 1 || (lightAndBlockerIndexBuffer.BlockerIndexCount <= maxBlockerCount && lightAndBlockerIndexBuffer.LightWithoutShadowCount <= maxLightWithoutShadowCount && lightAndBlockerIndexBuffer.LightWithShadowCount <= maxLightWithShadowCount))
			{
				fillColorBufferPC.Start();
				FillColorBuffer(lightAndBlockerIndexBuffer, startX * num8, startY * num8, num8, colorBuffer);
				fillColorBufferPC.Stop();
			}
			else
			{
				for (int num15 = 1; num15 >= 0; num15--)
				{
					int startY2 = startY * 2 + num15;
					for (int num16 = 1; num16 >= 0; num16--)
					{
						int startX2 = startX * 2 + num16;
						LightAndIndexUpdateStackElem lightAndIndexUpdateStackElem3 = lightAndIndexUpdateStackElems[num];
						lightAndIndexUpdateStackElem3.Level = level + 1;
						lightAndIndexUpdateStackElem3.StartX = startX2;
						lightAndIndexUpdateStackElem3.StartY = startY2;
						num++;
					}
				}
			}
			updateLoopPC.Stop();
		}
		lookupTextureHandler.MarkAsDirty();
	}

	private void FillPrePassLightIndexBuffer(LightAndBlockerIndexBuffer lightAndBlockerIndexBuffer, bool dynamic)
	{
		for (int i = MinValidLightIndex; i < internalLightCount; i++)
		{
			bool castShadow = internalLights[i].CastShadow;
			if (dynamic && !castShadow)
			{
				continue;
			}
			Vector3 pos = internalLights[i].Pos;
			float range = internalLights[i].Range;
			float num = Math.Max(0f, Math.Max(pos.x - lookupBBoxMax.x, lookupBBoxMin.x - pos.x));
			float num2 = Math.Max(0f, Math.Max(pos.z - lookupBBoxMax.z, lookupBBoxMin.z - pos.z));
			float num3 = num * num + num2 * num2;
			float num4 = range * range;
			if (num3 < range * range)
			{
				float num5 = num3 / num4;
				float num6 = internalLights[i].Intensity / (1f + 25f * num5);
				if (castShadow)
				{
					lightAndBlockerIndexBuffer.LightWithShadowIndexBuffer[lightAndBlockerIndexBuffer.LightWithShadowCount] = i;
					lightAndBlockerIndexBuffer.LightWithShadowIndexIntensity[lightAndBlockerIndexBuffer.LightWithShadowCount] = num6;
					lightAndBlockerIndexBuffer.LightWithShadowCount++;
				}
				else
				{
					lightAndBlockerIndexBuffer.LightWithoutShadowIndexBuffer[lightAndBlockerIndexBuffer.LightWithoutShadowCount] = i;
					lightAndBlockerIndexBuffer.LightWithoutShadowIndexIntensity[lightAndBlockerIndexBuffer.LightWithoutShadowCount] = num6;
					lightAndBlockerIndexBuffer.LightWithoutShadowCount++;
				}
			}
		}
	}

	private void FillPrePassBlockerIndexBuffer(LightAndBlockerIndexBuffer lightAndBlockerIndexBuffer, bool dynamic, bool addOccluder, bool addNoOccluder)
	{
		Vector3 vector = (lookupBBoxMin + lookupBBoxMax) * 0.5f;
		Vector2 a = new Vector2(vector.x, vector.z);
		Vector3 vector2 = (lookupBBoxMax - lookupBBoxMin) * 0.5f;
		for (int i = MinValidSpriteIndex; i < internalSpriteLightBlockerCount; i++)
		{
			bool occluder = internalSpriteLightBlockers[i].Occluder;
			if (internalSpriteLightBlockers[i].Useless || internalSpriteLightBlockers[i].Dynamic != dynamic || (!addOccluder && occluder) || (!addNoOccluder && !occluder))
			{
				continue;
			}
			internalSpriteLightBlockers[i].TexCoordForNoDoublon = -1;
			Vector3 pos = internalSpriteLightBlockers[i].Pos;
			if (pos.x < encodingLightAndSpriteBBoxMin.x || pos.z < encodingLightAndSpriteBBoxMin.z || pos.x > encodingLightAndSpriteBBoxMax.x || pos.z > encodingLightAndSpriteBBoxMax.z)
			{
				continue;
			}
			Vector2 a2 = new Vector2(pos.x, pos.z);
			Vector3 rightTopCornerDirection = internalSpriteLightBlockers[i].RightTopCornerDirection;
			for (int j = 0; j < lightAndBlockerIndexBuffer.LightWithShadowCount; j++)
			{
				int num = lightAndBlockerIndexBuffer.LightWithShadowIndexBuffer[j];
				Vector3 pos2 = internalLights[num].Pos;
				Vector2 b = new Vector2(pos2.x, pos2.z);
				Vector3 v = a2 - b;
				Vector3 v2 = a - b;
				InsideBlockerShadow(rightTopCornerDirection, v2, v, vector2.x, vector2.z, out bool inside, out bool _);
				if (inside)
				{
					lightAndBlockerIndexBuffer.BlockerIndexBuffer[lightAndBlockerIndexBuffer.BlockerIndexCount] = i;
					lightAndBlockerIndexBuffer.BlockerIndexCount++;
					break;
				}
			}
		}
	}

	private void FillLightBuffer(LightAndBlockerIndexBuffer previousLightAndBlockerIndexBuffer, LightAndBlockerIndexBuffer lightAndBlockerIndexBuffer, float centerCaseX, float centerCaseY, float halfCaseSizeX, float halfCaseSizeY)
	{
		for (int i = 0; i < previousLightAndBlockerIndexBuffer.LightWithShadowCount; i++)
		{
			int num = previousLightAndBlockerIndexBuffer.LightWithShadowIndexBuffer[i];
			Diagnostics.Assert(internalLights[num].CastShadow);
			if (internalLights[num].Active)
			{
				Vector3 pos = internalLights[num].Pos;
				float range = internalLights[num].Range;
				float num2 = range * range;
				Diagnostics.Assert(internalLights[num].CastShadow);
				float sqrMagnitude = new Vector2(Math.Max(0f, Math.Abs(pos.x - centerCaseX) - halfCaseSizeX), Math.Max(0f, Math.Abs(pos.z - centerCaseY) - halfCaseSizeY)).sqrMagnitude;
				if (sqrMagnitude < num2)
				{
					lightAndBlockerIndexBuffer.LightWithShadowIndexBuffer[lightAndBlockerIndexBuffer.LightWithShadowCount] = num;
					float num3 = sqrMagnitude / num2;
					float num4 = internalLights[num].Intensity / (1f + 25f * num3);
					lightAndBlockerIndexBuffer.LightWithShadowIndexIntensity[lightAndBlockerIndexBuffer.LightWithShadowCount] = num4;
					lightAndBlockerIndexBuffer.LightWithShadowCount++;
				}
			}
		}
		for (int j = 0; j < previousLightAndBlockerIndexBuffer.LightWithoutShadowCount; j++)
		{
			int num5 = previousLightAndBlockerIndexBuffer.LightWithoutShadowIndexBuffer[j];
			if (internalLights[num5].Active)
			{
				Vector3 pos2 = internalLights[num5].Pos;
				float range2 = internalLights[num5].Range;
				float num6 = range2 * range2;
				float sqrMagnitude2 = new Vector2(Math.Max(0f, Math.Abs(pos2.x - centerCaseX) - halfCaseSizeX), Math.Max(0f, Math.Abs(pos2.z - centerCaseY) - halfCaseSizeY)).sqrMagnitude;
				if (sqrMagnitude2 < num6)
				{
					float num7 = sqrMagnitude2 / num6;
					lightAndBlockerIndexBuffer.LightWithoutShadowIndexBuffer[lightAndBlockerIndexBuffer.LightWithoutShadowCount] = num5;
					float num8 = internalLights[num5].Intensity / (1f + 25f * num7);
					lightAndBlockerIndexBuffer.LightWithoutShadowIndexIntensity[lightAndBlockerIndexBuffer.LightWithoutShadowCount] = num8;
					lightAndBlockerIndexBuffer.LightWithoutShadowCount++;
				}
			}
		}
	}

	private void FillBlockerBuffer(LightAndBlockerIndexBuffer previousLightAndBlockerIndexBuffer, LightAndBlockerIndexBuffer lightAndBlockerIndexBuffer, float centerCaseX, float centerCaseY, float halfCaseSizeX, float halfCaseSizeY, int texCoordForNoDoublon)
	{
		lightAndBlockerIndexBuffer.BlockerIndexCount = 0;
		Vector2 a = new Vector2(centerCaseX, centerCaseY);
		bool flag = true;
		for (int i = 0; i < lightAndBlockerIndexBuffer.LightWithShadowCount; i++)
		{
			int num = lightAndBlockerIndexBuffer.LightWithShadowIndexBuffer[i];
			Vector3 pos = internalLights[num].Pos;
			bool flag2 = false;
			bool flag3 = false;
			Vector2 b = new Vector2(pos.x, pos.z);
			Vector2 lightToCenter = a - b;
			for (int j = 0; j < previousLightAndBlockerIndexBuffer.BlockerIndexCount; j++)
			{
				int num2 = previousLightAndBlockerIndexBuffer.BlockerIndexBuffer[j];
				Vector3 pos2 = internalSpriteLightBlockers[num2].Pos;
				Diagnostics.Assert(!internalSpriteLightBlockers[num2].Unused);
				Diagnostics.Assert(!internalSpriteLightBlockers[num2].Transparent);
				Vector2 a2 = new Vector2(pos2.x, pos2.z);
				Vector2 lightToBlocker = a2 - b;
				InsideBlockerShadow(internalSpriteLightBlockers[num2].RightTopCornerDirection, lightToCenter, lightToBlocker, halfCaseSizeX, halfCaseSizeY, out bool inside, out bool fullyInside);
				if (inside)
				{
					flag2 = true;
					bool flag4 = fullyInside && internalSpriteLightBlockers[num2].Occluder && flag;
					flag3 = (flag3 || flag4);
					if (internalSpriteLightBlockers[num2].TexCoordForNoDoublon != texCoordForNoDoublon && !flag4)
					{
						lightAndBlockerIndexBuffer.BlockerIndexBuffer[lightAndBlockerIndexBuffer.BlockerIndexCount] = num2;
						internalSpriteLightBlockers[num2].TexCoordForNoDoublon = texCoordForNoDoublon;
						lightAndBlockerIndexBuffer.BlockerIndexCount++;
					}
				}
			}
			if (!flag2)
			{
				if (lightAndBlockerIndexBuffer.LightWithoutShadowCount < maxLightWithoutShadowCount)
				{
					lightAndBlockerIndexBuffer.LightWithoutShadowIndexBuffer[lightAndBlockerIndexBuffer.LightWithoutShadowCount] = lightAndBlockerIndexBuffer.LightWithShadowIndexBuffer[i];
					lightAndBlockerIndexBuffer.LightWithoutShadowIndexIntensity[lightAndBlockerIndexBuffer.LightWithoutShadowCount] = lightAndBlockerIndexBuffer.LightWithShadowIndexIntensity[i];
					lightAndBlockerIndexBuffer.LightWithShadowIndexBuffer[i] = lightAndBlockerIndexBuffer.LightWithShadowIndexBuffer[lightAndBlockerIndexBuffer.LightWithShadowCount - 1];
					lightAndBlockerIndexBuffer.LightWithShadowIndexIntensity[i] = lightAndBlockerIndexBuffer.LightWithShadowIndexIntensity[lightAndBlockerIndexBuffer.LightWithShadowCount - 1];
					lightAndBlockerIndexBuffer.LightWithoutShadowCount++;
					lightAndBlockerIndexBuffer.LightWithShadowCount--;
					i--;
				}
			}
			else if (flag3)
			{
				lightAndBlockerIndexBuffer.LightWithShadowIndexBuffer[i] = lightAndBlockerIndexBuffer.LightWithShadowIndexBuffer[lightAndBlockerIndexBuffer.LightWithShadowCount - 1];
				lightAndBlockerIndexBuffer.LightWithShadowIndexIntensity[i] = lightAndBlockerIndexBuffer.LightWithShadowIndexIntensity[lightAndBlockerIndexBuffer.LightWithShadowCount - 1];
				lightAndBlockerIndexBuffer.LightWithShadowCount--;
				i--;
			}
		}
	}

	private void FillColorBuffer(LightAndBlockerIndexBuffer lightAndBlockerIndexBuffer, int x, int y, int count, Color32[] colorBuffer)
	{
		int num = Math.Min(PixelToEncodeLightWithShadowIndex * 4, maxLightWithShadowCount);
		if (lightAndBlockerIndexBuffer.LightWithShadowCount > num)
		{
			SortLight(lightAndBlockerIndexBuffer.LightWithShadowCount, lightAndBlockerIndexBuffer.LightWithShadowIndexBuffer, lightAndBlockerIndexBuffer.LightWithShadowIndexIntensity, lightAndBlockerIndexBuffer.LightWithShadowCount - num);
			for (int i = num; i < lightAndBlockerIndexBuffer.LightWithShadowCount; i++)
			{
				lightAndBlockerIndexBuffer.LightWithoutShadowIndexBuffer[lightAndBlockerIndexBuffer.LightWithoutShadowCount] = lightAndBlockerIndexBuffer.LightWithShadowIndexBuffer[i];
				lightAndBlockerIndexBuffer.LightWithoutShadowIndexIntensity[lightAndBlockerIndexBuffer.LightWithoutShadowCount] = lightAndBlockerIndexBuffer.LightWithShadowIndexIntensity[i];
				lightAndBlockerIndexBuffer.LightWithoutShadowCount++;
			}
			lightAndBlockerIndexBuffer.LightWithShadowCount = num;
		}
		int num2 = x * PixelToEncodeLightAndBlockerIndex + y * lightAndBlockerLookupSize * PixelToEncodeLightAndBlockerIndex;
		for (int j = 0; j < PixelToEncodeLightWithoutShadowIndex; j++)
		{
			int num3 = j * 4;
			int lightWithoutShadowCount = lightAndBlockerIndexBuffer.LightWithoutShadowCount;
			Color32 color = new Color32((byte)((lightWithoutShadowCount > num3) ? ((byte)lightAndBlockerIndexBuffer.LightWithoutShadowIndexBuffer[num3]) : 0), (byte)((lightWithoutShadowCount > num3 + 1) ? ((byte)lightAndBlockerIndexBuffer.LightWithoutShadowIndexBuffer[num3 + 1]) : 0), (byte)((lightWithoutShadowCount > num3 + 2) ? ((byte)lightAndBlockerIndexBuffer.LightWithoutShadowIndexBuffer[num3 + 2]) : 0), (byte)((lightWithoutShadowCount > num3 + 3) ? ((byte)lightAndBlockerIndexBuffer.LightWithoutShadowIndexBuffer[num3 + 3]) : 0));
			if (count > 1)
			{
				for (int k = 0; k < count; k++)
				{
					for (int l = 0; l < count; l++)
					{
						colorBuffer[num2 + StartPixelToEncodeLightWithoutShadowIndex + j + (l + k * lightAndBlockerLookupSize) * PixelToEncodeLightAndBlockerIndex] = color;
					}
				}
			}
			else
			{
				colorBuffer[num2 + StartPixelToEncodeLightWithoutShadowIndex + j] = color;
			}
		}
		for (int m = 0; m < PixelToEncodeLightWithShadowIndex; m++)
		{
			int num4 = m * 4;
			int lightWithShadowCount = lightAndBlockerIndexBuffer.LightWithShadowCount;
			Color32 color2 = new Color32((byte)((lightWithShadowCount > num4) ? ((byte)lightAndBlockerIndexBuffer.LightWithShadowIndexBuffer[num4]) : 0), (byte)((lightWithShadowCount > num4 + 1) ? ((byte)lightAndBlockerIndexBuffer.LightWithShadowIndexBuffer[num4 + 1]) : 0), (byte)((lightWithShadowCount > num4 + 2) ? ((byte)lightAndBlockerIndexBuffer.LightWithShadowIndexBuffer[num4 + 2]) : 0), (byte)((lightWithShadowCount > num4 + 3) ? ((byte)lightAndBlockerIndexBuffer.LightWithShadowIndexBuffer[num4 + 3]) : 0));
			if (count > 1)
			{
				for (int n = 0; n < count; n++)
				{
					for (int num5 = 0; num5 < count; num5++)
					{
						colorBuffer[num2 + StartPixelToEncodeLightWithShadowIndex + m + (num5 + n * lightAndBlockerLookupSize) * PixelToEncodeLightAndBlockerIndex] = color2;
					}
				}
			}
			else
			{
				colorBuffer[num2 + StartPixelToEncodeLightWithShadowIndex + m] = color2;
			}
		}
		for (int num6 = 0; num6 < PixelToEncodeBlockerIndex; num6++)
		{
			int num7 = num6 * 4;
			int blockerIndexCount = lightAndBlockerIndexBuffer.BlockerIndexCount;
			Color32 color3 = new Color32((byte)((blockerIndexCount > num7) ? ((byte)lightAndBlockerIndexBuffer.BlockerIndexBuffer[num7]) : 0), (byte)((blockerIndexCount > num7 + 1) ? ((byte)lightAndBlockerIndexBuffer.BlockerIndexBuffer[num7 + 1]) : 0), (byte)((blockerIndexCount > num7 + 2) ? ((byte)lightAndBlockerIndexBuffer.BlockerIndexBuffer[num7 + 2]) : 0), (byte)((blockerIndexCount > num7 + 3) ? ((byte)lightAndBlockerIndexBuffer.BlockerIndexBuffer[num7 + 3]) : 0));
			if (count > 1)
			{
				for (int num8 = 0; num8 < count; num8++)
				{
					for (int num9 = 0; num9 < count; num9++)
					{
						colorBuffer[num2 + StartPixelToEncodeBlockerIndex + num6 + (num9 + num8 * lightAndBlockerLookupSize) * PixelToEncodeLightAndBlockerIndex] = color3;
					}
				}
			}
			else
			{
				colorBuffer[num2 + StartPixelToEncodeBlockerIndex + num6] = color3;
			}
		}
	}

	private void SortLight(int lightCount, int[] lightIndices, float[] lightIntensity, int tooManyLightCount)
	{
		for (int i = 0; i < tooManyLightCount; i++)
		{
			int num = lightCount - 1 - i;
			for (int j = 0; j < num; j++)
			{
				float num2 = lightIntensity[j];
				float num3 = lightIntensity[j + 1];
				if (num2 < num3)
				{
					int num4 = lightIndices[j];
					lightIndices[j] = lightIndices[j + 1];
					lightIndices[j + 1] = num4;
					lightIntensity[j + 1] = num2;
					lightIntensity[j] = num3;
				}
			}
		}
	}

	private void CheckInternalParameter()
	{
		bool flag = false;
		bool flag2 = false;
		for (int i = 0; i < 10; i++)
		{
			if (1 << i == lightAndBlockerLookupSize)
			{
				flag = true;
			}
			if (1 << i == lightAndBlockerLookupFirstPassSize)
			{
				flag2 = true;
			}
		}
		if (!flag)
		{
			UnityEngine.Debug.LogError($"LightAndBlockerLookupSize = {lightAndBlockerLookupSize} should be a power of two. In object {base.name}");
		}
		if (!flag2)
		{
			UnityEngine.Debug.LogError($"LightAndBlockerFistPassSize = {lightAndBlockerLookupFirstPassSize} should be a power of two. In object {base.name}");
		}
	}

	private void VideoStateServiceOnDeviceNoLongerLost(object sender, EventArgs e)
	{
		forceRecomputeStaticContentNextUpdate = true;
	}

	private static void InsideBlockerShadow(Vector3 rightToCornerDirection3d, Vector2 lightToCenter, Vector2 lightToBlocker, float halfCaseSizeX, float halfCaseSizeY, out bool inside, out bool fullyInside)
	{
		Vector2 a = new Vector2(rightToCornerDirection3d.x, rightToCornerDirection3d.z);
		Vector2 vector = lightToCenter - lightToBlocker;
		float num = (0f - a.y) * vector.x + a.x * vector.y;
		float num2 = a.y * lightToBlocker.x - a.x * lightToBlocker.y;
		float num3 = Math.Abs(a.y * halfCaseSizeX) + Math.Abs(a.x * halfCaseSizeY);
		float num4 = (!(num2 < 0f)) ? num : (0f - num);
		if (!(num4 - num3 < 0f))
		{
			inside = false;
			fullyInside = false;
			return;
		}
		Vector2 lhs = lightToBlocker + a * 0.5f;
		Vector2 lhs2 = lightToBlocker - a * 0.5f;
		float num5 = Math.Abs((0f - lhs.y) * halfCaseSizeX) + Math.Abs(lhs.x * halfCaseSizeY);
		float num6 = Math.Abs((0f - lhs2.y) * halfCaseSizeX) + Math.Abs(lhs2.x * halfCaseSizeY);
		float num7 = (0f - lhs.y) * a.x + lhs.x * a.y;
		float num8 = (0f - lhs.y) * lightToCenter.x + lhs.x * lightToCenter.y;
		float num9 = (0f - lhs2.y) * lightToCenter.x + lhs2.x * lightToCenter.y;
		float num10 = (!(num7 <= 0f)) ? (0f - num8) : num8;
		float num11 = (!(num7 <= 0f)) ? (0f - num9) : num9;
		bool flag = inside = (num10 + num5 >= 0f && num11 - num6 <= 0f);
		fullyInside = false;
		if (flag)
		{
			Vector2 normalized = lhs.normalized;
			Vector2 normalized2 = lhs2.normalized;
			Vector2 rhs = normalized + normalized2;
			float val = Vector2.Dot(lhs, rhs);
			float val2 = Vector2.Dot(lhs2, rhs);
			float num12 = Vector2.Dot(lightToCenter, rhs);
			float num13 = Math.Min(val, val2);
			float num14 = Math.Abs(rhs.x * halfCaseSizeX) + Math.Abs(rhs.y * halfCaseSizeY);
			if (!(num13 < num12 + num14))
			{
				inside = false;
				fullyInside = false;
			}
			else
			{
				bool flag2 = num10 - num5 >= 0f && num11 + num6 <= 0f;
				bool flag3 = num4 + num3 < 0f;
				fullyInside = (flag2 && flag3);
			}
		}
	}
}
public class LightManagerDebugger : MonoBehaviour
{
	private float lastFrameDuration;

	private bool showGUI;

	protected IEnumerator Start()
	{
		if (GameManager.Preferences.GameGraphicSettings.HxLightTotallyDeactivated)
		{
			UnityEngine.Object.DestroyImmediate(this);
		}
		else
		{
			yield return null;
		}
	}
}
public class LightShaderExport : MonoBehaviour
{
	public string LightDirectionShaderParamName = "_LightDirection";

	public string LightColorShaderParamName = "_LightColor";

	private int lightDirectionShaderParamId = -1;

	private int lightColorShaderParamId = -1;

	private Light unityLight;

	protected IEnumerator Start()
	{
		unityLight = base.transform.GetComponent<Light>();
		lightDirectionShaderParamId = Shader.PropertyToID(LightDirectionShaderParamName);
		lightColorShaderParamId = Shader.PropertyToID(LightColorShaderParamName);
		yield return null;
	}

	protected void Update()
	{
		if (unityLight != null)
		{
			Shader.SetGlobalVector(lightDirectionShaderParamId, unityLight.transform.forward);
			Color color = unityLight.color;
			color.a = unityLight.intensity * 0.2f;
			Shader.SetGlobalVector(lightColorShaderParamId, color);
		}
	}
}
[RequireComponent(typeof(Light))]
public class LightToLightManager : MonoBehaviour
{
	private int lightIndex = -1;

	private ILightManagerService lightManagerService;

	private LightShadows shadows;

	private Light unityLight;

	private bool shadowTypeApplied;

	[SerializeField]
	private bool ignoreSmallMove;

	public LightShadows Shadows
	{
		get
		{
			return shadows;
		}
		set
		{
			shadows = value;
		}
	}

	public bool IgnoreSmallMove => ignoreSmallMove;

	public void ApplyShadowTypeBackToLightIFN()
	{
		if (unityLight != null && !shadowTypeApplied)
		{
			shadowTypeApplied = true;
			unityLight.shadows = shadows;
		}
	}

	public void RemoveShadowTypeFromLightIFN()
	{
		if (unityLight != null && shadowTypeApplied)
		{
			shadows = unityLight.shadows;
			unityLight.shadows = LightShadows.None;
			shadowTypeApplied = false;
		}
	}

	protected IEnumerator Start()
	{
		if (GameManager.Preferences.GameGraphicSettings.HxLightTotallyDeactivated)
		{
			UnityEngine.Object.DestroyImmediate(this);
			yield break;
		}
		unityLight = GetComponent<Light>();
		if (unityLight != null)
		{
			while (lightManagerService == null)
			{
				lightManagerService = Services.GetService<ILightManagerService>();
				if (lightManagerService == null)
				{
					yield return null;
				}
			}
			shadows = unityLight.shadows;
			unityLight.shadows = LightShadows.None;
			lightIndex = lightManagerService.RegisterLight(unityLight, shadows != LightShadows.None, ignoreSmallMove);
			shadowTypeApplied = true;
			yield return null;
		}
		else
		{
			UnityEngine.Object.DestroyImmediate(this);
		}
	}

	protected void OnDisable()
	{
		if (lightManagerService == null)
		{
			lightManagerService = Services.GetService<ILightManagerService>();
		}
		if (lightManagerService != null && lightIndex >= 0)
		{
			lightManagerService.UnregisterLight(lightIndex);
			lightIndex = -1;
		}
	}

	protected void OnEnable()
	{
		if (lightManagerService != null && lightIndex < 0)
		{
			Light component = GetComponent<Light>();
			lightIndex = lightManagerService.RegisterLight(component, shadows != LightShadows.None, ignoreSmallMove);
		}
	}

	protected void OnDestroy()
	{
		if (lightManagerService != null && lightIndex >= 0)
		{
			lightManagerService.UnregisterLight(lightIndex);
			lightIndex = -1;
		}
		lightManagerService = null;
	}
}
public class LightToLightManagerAdder : MonoBehaviour
{
	private delegate void ApplyToTransform(Transform recursTranform);

	[SerializeField]
	private string[] originalPrefix = new string[2]
	{
		"Amplitude/Full Forward Shadows/",
		"Amplitude/Sprites/Transparent/"
	};

	[SerializeField]
	private string[] replacementPrefix = new string[2]
	{
		"Amplitude/HxLight/",
		"Amplitude/HxLightSprites/Transparent/"
	};

	[SerializeField]
	private Material[] toModifyMaterials;

	[SerializeField]
	public int AutoFindRelatedObjectEveryNTurn;

	[SerializeField]
	public int WaitNTurnToFindRelatedObject = 2;

	public bool AddLightToLightManager = true;

	public bool AddLightBlockerToLightManager = true;

	public bool AddDoorWallToLightManager = true;

	private List<KeyValuePair<Material, Material>> originalToHxMaterial;

	public void LoadFrom(LightToLightManagerAdder other)
	{
		originalPrefix = other.originalPrefix;
		replacementPrefix = other.replacementPrefix;
		toModifyMaterials = other.toModifyMaterials;
	}

	public void ConvertAllMaterialNow()
	{
		ConvertAllMaterial();
	}

	protected void Awake()
	{
		if (GameManager.Preferences.GameGraphicSettings.HxLightTotallyDeactivated)
		{
			UnityEngine.Object.DestroyImmediate(this);
		}
	}

	protected void Update()
	{
	}

	private void AddLightToLightManagerToEveryLightIFN()
	{
		if (!AddLightToLightManager)
		{
			return;
		}
		Light[] componentsInChildren = base.transform.GetComponentsInChildren<Light>(includeInactive: true);
		foreach (Light light in componentsInChildren)
		{
			if (light.type == LightType.Point)
			{
				LightToLightManager component = light.GetComponent<LightToLightManager>();
				if (component == null)
				{
					light.gameObject.AddComponent<LightToLightManager>();
				}
			}
		}
	}

	private void AddLightBlockerToLightManagerToEveryBlockerIFN()
	{
		if (!AddLightBlockerToLightManager && !AddDoorWallToLightManager)
		{
			return;
		}
		MeshFilter[] componentsInChildren = base.transform.GetComponentsInChildren<MeshFilter>(includeInactive: true);
		foreach (MeshFilter meshFilter in componentsInChildren)
		{
			bool flag = AddLightBlockerToLightManager && meshFilter.gameObject.name == "LightBlocker";
			bool flag2 = AddDoorWallToLightManager && meshFilter.gameObject.name == "RightWall";
			bool flag3 = AddDoorWallToLightManager && meshFilter.gameObject.name == "LeftWall";
			bool flag4 = AddDoorWallToLightManager && meshFilter.gameObject.name == "FrontWall";
			if (!flag && !flag2 && !flag3 && !flag4)
			{
				continue;
			}
			LightBlockerToLightManager component = meshFilter.GetComponent<LightBlockerToLightManager>();
			if (component == null)
			{
				component = meshFilter.gameObject.AddComponent<LightBlockerToLightManager>();
				if (flag)
				{
					component.Usage = LightBlockerToLightManager.UsageType.Door;
				}
				else if (flag3 || flag2)
				{
					component.Usage = LightBlockerToLightManager.UsageType.DoorWall;
				}
				else
				{
					component.Usage = LightBlockerToLightManager.UsageType.LightBlocker;
				}
			}
		}
	}

	private void ApplyShadowTypeBackToEveryLight()
	{
		LightToLightManager[] componentsInChildren = base.transform.GetComponentsInChildren<LightToLightManager>(includeInactive: true);
		foreach (LightToLightManager lightToLightManager in componentsInChildren)
		{
			lightToLightManager.ApplyShadowTypeBackToLightIFN();
		}
	}

	private void RemoveShadowTypeFromEveryLight()
	{
		LightToLightManager[] componentsInChildren = base.transform.GetComponentsInChildren<LightToLightManager>(includeInactive: true);
		foreach (LightToLightManager lightToLightManager in componentsInChildren)
		{
			lightToLightManager.RemoveShadowTypeFromLightIFN();
		}
	}

	private void ConvertAllMaterial()
	{
		if (originalToHxMaterial == null)
		{
			originalToHxMaterial = new List<KeyValuePair<Material, Material>>();
		}
		ApplyToHierarchy(ConvertMaterial);
	}

	private void ConvertBackAllMaterial()
	{
		if (originalToHxMaterial == null)
		{
			originalToHxMaterial = new List<KeyValuePair<Material, Material>>();
		}
		ApplyToHierarchy(ConvertBackMaterial);
	}

	private void ApplyToHierarchy(ApplyToTransform tranformation)
	{
		ApplyToHierarchy(tranformation, base.transform);
	}

	private void ApplyToHierarchy(ApplyToTransform tranformation, Transform recursTransform)
	{
		tranformation(recursTransform);
		int childCount = recursTransform.childCount;
		for (int i = 0; i < childCount; i++)
		{
			ApplyToHierarchy(tranformation, recursTransform.GetChild(i));
		}
	}

	private void ConvertMaterial(Transform recursTransform)
	{
		Renderer component = recursTransform.GetComponent<Renderer>();
		if (component != null)
		{
			if (component.sharedMaterials != null && component.sharedMaterials.Length > 1)
			{
				Material[] array = new Material[component.sharedMaterials.Length];
				for (int i = 0; i < component.sharedMaterials.Length; i++)
				{
					array[i] = GetOrCreateNewMaterialIFN(component.sharedMaterials[i]);
				}
				component.sharedMaterials = array;
			}
			else if (component.sharedMaterial != null)
			{
				component.sharedMaterial = GetOrCreateNewMaterialIFN(component.sharedMaterial);
			}
		}
		if (toModifyMaterials != null)
		{
			for (int j = 0; j < toModifyMaterials.Length; j++)
			{
				toModifyMaterials[j].shader = GetReplacementShader(toModifyMaterials[j].shader);
			}
		}
	}

	private void ConvertBackMaterial(Transform recursTransform)
	{
		Renderer component = recursTransform.GetComponent<Renderer>();
		if (component != null)
		{
			if (component.sharedMaterials != null && component.sharedMaterials.Length > 1)
			{
				Material[] array = new Material[component.sharedMaterials.Length];
				for (int i = 0; i < component.sharedMaterials.Length; i++)
				{
					array[i] = GetOriginalMaterialIFN(component.sharedMaterials[i]);
				}
				component.sharedMaterials = array;
			}
			else if (component.sharedMaterial != null)
			{
				component.sharedMaterial = GetOriginalMaterialIFN(component.sharedMaterial);
			}
		}
		if (toModifyMaterials != null)
		{
			for (int j = 0; j < toModifyMaterials.Length; j++)
			{
				toModifyMaterials[j].shader = GetOriginalShader(toModifyMaterials[j].shader);
			}
		}
	}

	private Material GetOrCreateNewMaterialIFN(Material material)
	{
		Diagnostics.Assert(originalPrefix != null);
		Diagnostics.Assert(replacementPrefix != null);
		Diagnostics.Assert(originalPrefix.Length == replacementPrefix.Length);
		for (int i = 0; i < originalToHxMaterial.Count; i++)
		{
			if (originalToHxMaterial[i].Key.name == material.name)
			{
				return originalToHxMaterial[i].Value;
			}
		}
		if (material.shader != null)
		{
			Shader replacementShader = GetReplacementShader(material.shader);
			if (replacementShader == material.shader)
			{
				return material;
			}
			Material material2 = new Material(material);
			material2.shader = replacementShader;
			originalToHxMaterial.Add(new KeyValuePair<Material, Material>(material, material2));
			return material2;
		}
		return material;
	}

	private Shader GetReplacementShader(Shader toReplace)
	{
		string name = toReplace.name;
		for (int i = 0; i < originalPrefix.Length; i++)
		{
			if (name.StartsWith(originalPrefix[i]))
			{
				string text = replacementPrefix[i] + name.Substring(originalPrefix[i].Length);
				Shader shader = Shader.Find(text);
				if (shader != null)
				{
					return shader;
				}
				UnityEngine.Debug.LogError($"Unable to find shader {text}");
			}
		}
		return toReplace;
	}

	private Shader GetOriginalShader(Shader toReplace)
	{
		string name = toReplace.name;
		for (int i = 0; i < replacementPrefix.Length; i++)
		{
			if (name.StartsWith(replacementPrefix[i]))
			{
				string text = originalPrefix[i] + name.Substring(replacementPrefix[i].Length);
				Shader shader = Shader.Find(text);
				if (shader != null)
				{
					return shader;
				}
				UnityEngine.Debug.LogError($"Unable to find shader {text}");
			}
		}
		return toReplace;
	}

	private Material GetOriginalMaterialIFN(Material material)
	{
		for (int i = 0; i < originalToHxMaterial.Count; i++)
		{
			if (originalToHxMaterial[i].Value.name == material.name)
			{
				return originalToHxMaterial[i].Key;
			}
		}
		return material;
	}

	private void OnDisable()
	{
		ConvertBackAllMaterial();
	}

	private void OnDestroy()
	{
		if (originalToHxMaterial != null)
		{
			foreach (KeyValuePair<Material, Material> item in originalToHxMaterial)
			{
				UnityEngine.Object.DestroyImmediate(item.Value, allowDestroyingAssets: true);
			}
			originalToHxMaterial.Clear();
			originalToHxMaterial = null;
		}
	}
}
public class LookupTextureHandler
{
	private static Texture2D whiteTexture;

	private string name = string.Empty;

	private string textureShaderName = string.Empty;

	private int textureWidth;

	private int textureHeight;

	private string renderTextureShaderName = string.Empty;

	private int renderTextureWidth;

	private int renderTextureHeight;

	private FilterMode renderTextureFilterMode;

	private Texture2D texture;

	private Color32[] colorBuffer;

	private RenderTexture renderTexture0;

	private RenderTexture renderTexture1;

	private int renderTextureIndex;

	private bool doubleBufferRenderTexture;

	private string[] updateRenderTextureMaterialNames = new string[0];

	private Material[] updateRenderTextureMaterials;

	private bool dirty;

	private bool materialIsCopied;

	private bool loaded;

	private TextureWrapMode textureWrapMode;

	public Color32[] ColorBuffer => colorBuffer;

	public int TextureWidth => textureWidth;

	public int TextureHeight => textureHeight;

	public Texture2D Texture => texture;

	public RenderTexture RenderTexture => (renderTextureIndex != 0) ? renderTexture1 : renderTexture0;

	public bool Loaded => loaded;

	public LookupTextureHandler(string name, string textureShaderName, int width, int height, TextureWrapMode textureWrapMode = TextureWrapMode.Repeat)
	{
		Diagnostics.Assert(width > 0);
		Diagnostics.Assert(height > 0);
		this.name = name;
		this.textureShaderName = textureShaderName;
		textureWidth = width;
		textureHeight = height;
		loaded = true;
		this.textureWrapMode = textureWrapMode;
		renderTextureFilterMode = FilterMode.Point;
		CreateTexture();
		if (!(whiteTexture == null))
		{
			return;
		}
		whiteTexture = new Texture2D(2, 2);
		whiteTexture.name = "LookupTextureHandlerWhiteTexture";
		for (int i = 0; i < whiteTexture.width; i++)
		{
			for (int j = 0; j < whiteTexture.height; j++)
			{
				whiteTexture.SetPixel(i, j, Color.white);
			}
		}
		whiteTexture.Apply();
	}

	public void Fill(Color32 color)
	{
		for (int i = 0; i < colorBuffer.Length; i++)
		{
			colorBuffer[i] = color;
		}
	}

	public void Resize(int width, int height)
	{
		if (textureShaderName.Length > 0)
		{
			Shader.SetGlobalTexture(textureShaderName, whiteTexture);
		}
		UnityEngine.Object.DestroyImmediate(texture, allowDestroyingAssets: true);
		texture = null;
		colorBuffer = null;
		textureWidth = width;
		textureHeight = height;
		CreateTexture();
	}

	public void ResizeRenderTexture(int width, int height)
	{
		Diagnostics.Assert(renderTexture0 != null);
		renderTextureWidth = width;
		renderTextureHeight = height;
		if (renderTexture0 != null)
		{
			Shader.SetGlobalTexture(renderTextureShaderName, whiteTexture);
			UnityEngine.Object.DestroyImmediate(renderTexture0, allowDestroyingAssets: true);
			renderTexture0 = null;
		}
		if (renderTexture1 != null)
		{
			UnityEngine.Object.DestroyImmediate(renderTexture1, allowDestroyingAssets: true);
			renderTexture1 = null;
		}
		CreateRenderTexture();
	}

	public void AddARenderLookupRenderTexture(string renderTextureShaderName, int width, int height, string materialName, FilterMode filterMode, bool doubleBufferRenderTexture)
	{
		AddARenderLookupRenderTexture(renderTextureShaderName, width, height, new string[1]
		{
			materialName
		}, filterMode, doubleBufferRenderTexture);
	}

	public void AddARenderLookupRenderTexture(string renderTextureShaderName, int width, int height, string[] materialNames, FilterMode filterMode, bool doubleBufferRenderTexture)
	{
		Diagnostics.Assert(renderTexture0 == null);
		Diagnostics.Assert(renderTexture1 == null);
		Diagnostics.Assert(renderTextureShaderName.Length > 0);
		Diagnostics.Assert(width > 0);
		Diagnostics.Assert(height > 0);
		Diagnostics.Assert(materialNames.Length > 0);
		Diagnostics.Assert(materialNames.Length == 1 || doubleBufferRenderTexture);
		renderTextureWidth = width;
		renderTextureHeight = height;
		this.renderTextureShaderName = renderTextureShaderName;
		renderTextureFilterMode = filterMode;
		updateRenderTextureMaterialNames = new string[materialNames.Length];
		for (int i = 0; i < updateRenderTextureMaterialNames.Length; i++)
		{
			updateRenderTextureMaterialNames[i] = materialNames[i];
		}
		this.doubleBufferRenderTexture = doubleBufferRenderTexture;
		CreateRenderTexture();
	}

	public void MarkAsDirty()
	{
		dirty = true;
	}

	public void Apply()
	{
		texture.SetPixels32(colorBuffer);
		texture.Apply();
		dirty = false;
	}

	public void Update(IVideoStateService videoStateService, bool doBlit)
	{
		Diagnostics.Assert(loaded);
		if (dirty)
		{
			Apply();
		}
		if (!(renderTexture0 != null))
		{
			return;
		}
		if (!renderTexture0.IsCreated())
		{
			videoStateService?.OnDeviceLostDetected();
			renderTexture0.Create();
		}
		if (renderTexture1 != null && !renderTexture1.IsCreated())
		{
			videoStateService?.OnDeviceLostDetected();
			renderTexture1.Create();
		}
		if (!doBlit)
		{
			return;
		}
		for (int i = 0; i < updateRenderTextureMaterials.Length; i++)
		{
			Diagnostics.Assert(renderTexture0 != null);
			Texture2D source = texture;
			if (doubleBufferRenderTexture)
			{
				Diagnostics.Assert(renderTexture1 != null);
				RenderTexture renderTexture = (renderTextureIndex != 0) ? renderTexture0 : renderTexture1;
				RenderTexture tex = (renderTextureIndex != 0) ? renderTexture1 : renderTexture0;
				Shader.SetGlobalTexture("_PreviousTex", tex);
				Blit(source, renderTexture, updateRenderTextureMaterials[i]);
				Shader.SetGlobalTexture(renderTextureShaderName, renderTexture);
				renderTextureIndex = 1 - renderTextureIndex;
			}
			else
			{
				RenderTexture destination = renderTexture0;
				Blit(source, destination, updateRenderTextureMaterials[i]);
			}
		}
	}

	public void Unload()
	{
		if (textureShaderName.Length > 0)
		{
			Shader.SetGlobalTexture(textureShaderName, whiteTexture);
		}
		UnityEngine.Object.DestroyImmediate(texture, allowDestroyingAssets: true);
		texture = null;
		colorBuffer = null;
		if (renderTexture0 != null)
		{
			Shader.SetGlobalTexture(renderTextureShaderName, whiteTexture);
			UnityEngine.Object.DestroyImmediate(renderTexture0, allowDestroyingAssets: true);
			renderTexture0 = null;
		}
		if (renderTexture1 != null)
		{
			UnityEngine.Object.DestroyImmediate(renderTexture1, allowDestroyingAssets: true);
			renderTexture1 = null;
		}
		if (materialIsCopied && updateRenderTextureMaterials != null)
		{
			for (int i = 0; i < updateRenderTextureMaterials.Length; i++)
			{
				UnityEngine.Object.DestroyImmediate(updateRenderTextureMaterials[i], allowDestroyingAssets: true);
				updateRenderTextureMaterials[i] = null;
			}
			updateRenderTextureMaterials = null;
		}
		loaded = false;
	}

	public void Reload()
	{
		Diagnostics.Assert(!loaded);
		CreateTexture();
		if (renderTextureShaderName.Length > 0)
		{
			CreateRenderTexture();
		}
	}

	private void Blit(Texture source, RenderTexture destination, Material updateRenderTextureMaterial)
	{
		RenderTexture active = RenderTexture.active;
		Graphics.SetRenderTarget(destination);
		GL.PushMatrix();
		GL.LoadPixelMatrix(0f, destination.width, destination.height, 0f);
		Graphics.DrawTexture(new Rect(0f, 0f, destination.width, destination.height), source, new Rect(0f, 0f, 1f, 1f), 0, 0, 0, 0, updateRenderTextureMaterial);
		GL.PopMatrix();
		Graphics.SetRenderTarget(active);
	}

	private void CreateTexture()
	{
		Diagnostics.Assert(texture == null);
		Color32 color = new Color32(0, 0, 0, 0);
		texture = new Texture2D(textureWidth, textureHeight, TextureFormat.RGBA32, mipmap: false);
		texture.name = name + ".texture";
		colorBuffer = new Color32[textureWidth * textureHeight];
		for (int i = 0; i < colorBuffer.Length; i++)
		{
			colorBuffer[i] = color;
		}
		texture.SetPixels32(colorBuffer);
		texture.filterMode = FilterMode.Point;
		texture.wrapMode = textureWrapMode;
		texture.Apply();
		if (textureShaderName.Length > 0)
		{
			Shader.SetGlobalTexture(textureShaderName, texture);
		}
	}

	private void CreateRenderTexture()
	{
		Diagnostics.Assert(renderTexture0 == null);
		Diagnostics.Assert(renderTexture1 == null);
		RenderTextureFormat format = RenderTextureFormat.ARGB32;
		renderTexture0 = new RenderTexture(renderTextureWidth, renderTextureHeight, 0, format);
		renderTexture0.name = name + ".renderTexture0";
		renderTexture0.filterMode = renderTextureFilterMode;
		renderTexture0.useMipMap = false;
		renderTexture0.wrapMode = textureWrapMode;
		renderTexture0.Create();
		if (doubleBufferRenderTexture)
		{
			renderTexture1 = new RenderTexture(renderTextureWidth, renderTextureHeight, 0, format);
			renderTexture1.name = name + ".renderTexture1";
			renderTexture1.filterMode = renderTextureFilterMode;
			renderTexture1.useMipMap = false;
			renderTexture1.wrapMode = textureWrapMode;
			renderTexture1.Create();
		}
		Shader.SetGlobalTexture(renderTextureShaderName, renderTexture0);
		updateRenderTextureMaterials = new Material[updateRenderTextureMaterialNames.Length];
		for (int i = 0; i < updateRenderTextureMaterials.Length; i++)
		{
			updateRenderTextureMaterials[i] = (Resources.Load(updateRenderTextureMaterialNames[i], typeof(Material)) as Material);
			Diagnostics.Assert(updateRenderTextureMaterials[i] != null);
		}
	}
}
public class RunTimeSpritePacker : Manager, IRunTimeSpritePackerService, IService
{
	public class Slot
	{
		public int NextSlotIndex = -1;

		public int PreviousSlotIndex = -1;

		private int lastUsageIndex;

		public int StartX
		{
			get;
			private set;
		}

		public int StartY
		{
			get;
			private set;
		}

		public int Width
		{
			get;
			private set;
		}

		public int Height
		{
			get;
			private set;
		}

		public Vector2 HotSpotIn01
		{
			get;
			private set;
		}

		public Vector2 TexCoordIn01
		{
			get;
			set;
		}

		public Vector2 SizeInPixels
		{
			get;
			set;
		}

		public Vector2 SizeInWorld
		{
			get;
			set;
		}

		public Vector2 CenterPosRelativeToHotSpot
		{
			get;
			set;
		}

		public Sprite Sprite
		{
			get;
			private set;
		}

		public Shader Shader
		{
			get;
			private set;
		}

		public bool Empty => Sprite == null;

		public int Index
		{
			get;
			private set;
		}

		public int LastUsageIndex => lastUsageIndex;

		public Slot(int index, int startX, int startY, int width, int height)
		{
			Index = index;
			StartX = startX;
			StartY = startY;
			Width = width;
			Height = height;
			Sprite = null;
			HotSpotIn01 = Vector2.zero;
		}

		public void Use(int usageIndex)
		{
			lastUsageIndex = usageIndex;
		}

		public void SetSprite(Sprite sprite, Shader shader, Vector2 hotSpotIn01)
		{
			Sprite = sprite;
			Shader = shader;
			HotSpotIn01 = hotSpotIn01;
		}

		public void Forget()
		{
			Sprite = null;
			Shader = null;
		}

		public void Reset()
		{
			NextSlotIndex = -1;
			PreviousSlotIndex = -1;
			lastUsageIndex = 0;
		}
	}

	[SerializeField]
	public bool Verbose;

	[SerializeField]
	public bool DoCheckConsistency;

	[SerializeField]
	private int slotW = 64;

	[SerializeField]
	private int slotH = 64;

	[SerializeField]
	private int atlasSize = 1024;

	[SerializeField]
	private Material copyAtlasMaterial;

	[SerializeField]
	private Material clearAtlasMaterial;

	[SerializeField]
	private Shader[] overrideCopyAtlasShaders;

	[SerializeField]
	private Material[] overrideCopyAtlasMaterials;

	private Dictionary<Shader, Material> overrideCopyAtlasShaderToMaterial;

	[SerializeField]
	private string atlasGlobalTextureName = "_OccluderTex";

	private RenderTexture atlas;

	private Texture2D blackTransparentTexture;

	private Texture2D blackOpaqueTexture;

	private Slot[] slots;

	private Dictionary<Sprite, int> spriteToSlotIndex;

	private int usageIndex;

	private bool loaded;

	private int firstFreeSlot = -1;

	private int firstNotFreeSlot = -1;

	private int lastNotFreeSlot = -1;

	private int allocatedSlotCount;

	private IVideoStateService videoStateService;

	private IGameEventService gameEventManager;

	public RenderTexture Atlas => atlas;

	public bool Loaded => loaded;

	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		SetLastError(0, "Waiting for service dependencies...");
		if (!GameManager.Preferences.GameGraphicSettings.HxLightTotallyDeactivated)
		{
			yield return BindService(delegate(IGameEventService service)
			{
				gameEventManager = service;
			});
			gameEventManager.OnGameStopped += OnGameStopped;
			Diagnostics.Assert(loaded);
			Services.AddService((IRunTimeSpritePackerService)this);
		}
	}

	protected override void Awake()
	{
		base.Awake();
		if (GameManager.Preferences.GameGraphicSettings.HxLightTotallyDeactivated)
		{
			return;
		}
		spriteToSlotIndex = new Dictionary<Sprite, int>();
		CreateOrResetSlots();
		atlas = new RenderTexture(atlasSize, atlasSize, 0, RenderTextureFormat.ARGB32);
		atlas.name = "RunTimeSpritePacker.RenderTexture";
		atlas.antiAliasing = 1;
		atlas.useMipMap = false;
		atlas.wrapMode = TextureWrapMode.Clamp;
		atlas.filterMode = FilterMode.Point;
		bool condition = atlas.Create();
		Shader.SetGlobalTexture(atlasGlobalTextureName, atlas);
		Diagnostics.Assert(condition);
		blackTransparentTexture = new Texture2D(1, 1, TextureFormat.ARGB32, mipmap: true);
		blackOpaqueTexture = new Texture2D(1, 1, TextureFormat.ARGB32, mipmap: true);
		Color color = new Color(0f, 0f, 0f, 0f);
		Color color2 = new Color(1f, 0f, 0f, 1f);
		for (int i = 0; i < blackTransparentTexture.height; i++)
		{
			for (int j = 0; j < blackTransparentTexture.width; j++)
			{
				blackTransparentTexture.SetPixel(j, i, color);
				blackOpaqueTexture.SetPixel(j, i, color2);
			}
		}
		blackTransparentTexture.Apply();
		blackOpaqueTexture.Apply();
		ClearAtlas();
		if (overrideCopyAtlasShaders != null || overrideCopyAtlasMaterials != null)
		{
			Diagnostics.Assert(overrideCopyAtlasShaders != null);
			Diagnostics.Assert(overrideCopyAtlasMaterials != null);
			Diagnostics.Assert(overrideCopyAtlasShaders.Length == overrideCopyAtlasMaterials.Length);
			overrideCopyAtlasShaderToMaterial = new Dictionary<Shader, Material>();
			for (int k = 0; k < overrideCopyAtlasMaterials.Length; k++)
			{
				if (overrideCopyAtlasShaders[k] != null)
				{
					overrideCopyAtlasShaderToMaterial.Add(overrideCopyAtlasShaders[k], overrideCopyAtlasMaterials[k]);
				}
				else
				{
					Diagnostics.LogError("In object {0} property overrideCopyAtlasShaders[{1}] should be different than null.", base.name, k);
				}
			}
		}
		Diagnostics.Assert(!DoCheckConsistency || CheckConsistency());
		loaded = true;
	}

	protected override IEnumerator Start()
	{
		yield return base.Start();
		if (GameManager.Preferences.GameGraphicSettings.HxLightTotallyDeactivated)
		{
			UnityEngine.Object.DestroyImmediate(this);
			yield break;
		}
		while (videoStateService == null)
		{
			videoStateService = Services.GetService<IVideoStateService>();
			if (videoStateService == null)
			{
				yield return new WaitForEndOfFrame();
			}
		}
		videoStateService.OnDeviceNoLongerLost += VideoStateServiceOnDeviceNoLongerLost;
	}

	public void OnDestroy()
	{
		if (atlas != null)
		{
			UnityEngine.Object.DestroyImmediate(atlas, allowDestroyingAssets: true);
			UnityEngine.Object.DestroyImmediate(blackTransparentTexture, allowDestroyingAssets: true);
			UnityEngine.Object.DestroyImmediate(blackOpaqueTexture, allowDestroyingAssets: true);
			atlas = null;
			blackTransparentTexture = null;
			blackOpaqueTexture = null;
		}
	}

	public void Update()
	{
		usageIndex++;
	}

	public void GetBlackOpaqueSpriteInfo(out Vector2 texCoord, out Vector2 sizeInPixels, out Vector2 centerPosRelativeToHotSpot)
	{
		texCoord = new Vector2((float)slots[1].StartX / (float)atlasSize, (float)slots[1].StartY / (float)atlasSize);
		sizeInPixels = new Vector2(0f, 0f);
		centerPosRelativeToHotSpot = new Vector2((float)slotW * 0.5f, (float)slotH * 0.5f);
	}

	public int UseSprite(Sprite sprite, Shader shader, Vector2 hotSpotIn01, out Vector2 texCoord, out Vector2 sizeInPixels, out Vector2 centerPosRelativeToHotSpot, out bool transparent)
	{
		Diagnostics.Assert(!DoCheckConsistency || CheckConsistency());
		int value = -1;
		if (spriteToSlotIndex.TryGetValue(sprite, out value) && value >= 0)
		{
			Slot slot = slots[value];
			slot.Use(usageIndex);
			texCoord = slot.TexCoordIn01;
			sizeInPixels = slot.SizeInPixels;
			centerPosRelativeToHotSpot = slot.CenterPosRelativeToHotSpot;
			transparent = (value < 1);
			if (!transparent)
			{
				Diagnostics.Assert(firstNotFreeSlot != -1);
				if (firstNotFreeSlot != value)
				{
					if (lastNotFreeSlot == value)
					{
						lastNotFreeSlot = slots[value].PreviousSlotIndex;
					}
					if (slots[value].NextSlotIndex != -1)
					{
						slots[slots[value].NextSlotIndex].PreviousSlotIndex = slots[value].PreviousSlotIndex;
					}
					if (slots[value].PreviousSlotIndex != -1)
					{
						slots[slots[value].PreviousSlotIndex].NextSlotIndex = slots[value].NextSlotIndex;
					}
					slots[firstNotFreeSlot].PreviousSlotIndex = value;
					slots[value].NextSlotIndex = firstNotFreeSlot;
					slots[value].PreviousSlotIndex = -1;
					firstNotFreeSlot = value;
				}
			}
			Diagnostics.Assert(!DoCheckConsistency || CheckConsistency());
			return value;
		}
		Material value2 = null;
		if (overrideCopyAtlasShaderToMaterial.TryGetValue(shader, out value2) && value2 == null)
		{
			spriteToSlotIndex[sprite] = 0;
			texCoord = slots[0].TexCoordIn01;
			sizeInPixels = slots[0].SizeInPixels;
			centerPosRelativeToHotSpot = slots[0].CenterPosRelativeToHotSpot;
			transparent = true;
			return 0;
		}
		if (firstFreeSlot == -1)
		{
			Diagnostics.Assert(lastNotFreeSlot > 0);
			if (Verbose)
			{
				Diagnostics.Log("Deallocating slot {0}", lastNotFreeSlot);
			}
			value = lastNotFreeSlot;
			spriteToSlotIndex[slots[value].Sprite] = -1;
			slots[value].Forget();
			lastNotFreeSlot = slots[lastNotFreeSlot].PreviousSlotIndex;
			slots[lastNotFreeSlot].NextSlotIndex = -1;
			slots[value].NextSlotIndex = -1;
			slots[value].PreviousSlotIndex = -1;
			firstFreeSlot = value;
			allocatedSlotCount--;
			if (slots[value].LastUsageIndex == usageIndex)
			{
				Diagnostics.LogError("Atlas too small, there is more differents sprites used this turn than there is sprite slots.");
			}
		}
		value = firstFreeSlot;
		if (value > 0)
		{
			Slot slot2 = slots[value];
			Diagnostics.Assert(slots[value].Empty);
			slots[value].SetSprite(sprite, shader, hotSpotIn01);
			Diagnostics.Assert(slots[value].HotSpotIn01 == hotSpotIn01);
			spriteToSlotIndex[sprite] = value;
			slots[value].Use(usageIndex);
			RenderSlot(slots[value]);
			texCoord = slot2.TexCoordIn01;
			sizeInPixels = slot2.SizeInPixels;
			centerPosRelativeToHotSpot = slot2.CenterPosRelativeToHotSpot;
			transparent = false;
			firstFreeSlot = slots[value].NextSlotIndex;
			Diagnostics.Assert(slots[value].PreviousSlotIndex == -1);
			firstFreeSlot = slots[value].NextSlotIndex;
			if (firstFreeSlot > 0)
			{
				slots[firstFreeSlot].PreviousSlotIndex = -1;
			}
			slots[value].NextSlotIndex = firstNotFreeSlot;
			if (firstNotFreeSlot > 0)
			{
				slots[firstNotFreeSlot].PreviousSlotIndex = value;
			}
			firstNotFreeSlot = value;
			if (lastNotFreeSlot == -1)
			{
				Diagnostics.Assert(allocatedSlotCount == 0);
				lastNotFreeSlot = value;
			}
			allocatedSlotCount++;
			Diagnostics.Assert(!DoCheckConsistency || CheckConsistency());
			return value;
		}
		Diagnostics.LogError("No more place in RunTimeSpritePacker Atlas");
		texCoord = Vector2.zero;
		sizeInPixels = Vector2.zero;
		centerPosRelativeToHotSpot = Vector2.zero;
		transparent = true;
		return 0;
	}

	public void ReRenderAllSlot()
	{
		ClearAtlas();
		for (int i = 0; i < slots.Length; i++)
		{
			if (!slots[i].Empty)
			{
				RenderSlot(slots[i]);
			}
		}
	}

	private void ClearAtlas()
	{
		RenderTexture active = RenderTexture.active;
		Graphics.SetRenderTarget(atlas);
		GL.PushMatrix();
		GL.LoadPixelMatrix(0f, atlasSize, atlasSize, 0f);
		Graphics.DrawTexture(new Rect(0f, 0f, atlasSize, atlasSize), blackTransparentTexture, new Rect(0f, 0f, 1f, 1f), 0, 0, 0, 0, clearAtlasMaterial);
		Graphics.DrawTexture(new Rect(slotW, 0f, slotW, slotH), blackOpaqueTexture, new Rect(0f, 0f, 1f, 1f), 0, 0, 0, 0, copyAtlasMaterial);
		GL.PopMatrix();
		Graphics.SetRenderTarget(active);
	}

	private void RenderSlot(Slot slot)
	{
		Diagnostics.Assert(!slot.Empty);
		Diagnostics.Assert(slot.Shader != null);
		Sprite sprite = slot.Sprite;
		if (Verbose)
		{
			UnityEngine.Debug.Log($"RunTimeSpritePacker.RenderSlot {sprite.textureRect} {sprite.texture.name}");
		}
		Texture texture = sprite.texture;
		Rect textureRect = sprite.textureRect;
		textureRect.xMin = (float)Math.Round(textureRect.xMin);
		textureRect.xMax = (float)Math.Round(textureRect.xMax);
		textureRect.yMin = (float)Math.Round(textureRect.yMin);
		textureRect.yMax = (float)Math.Round(textureRect.yMax);
		Rect rect = sprite.rect;
		if (Verbose && (textureRect.width > (float)slot.Width || textureRect.height > (float)slot.Height))
		{
			Diagnostics.LogWarning("(spriteRect.width({0}) > slot.Width({1})) || (spriteRect.height({2}) > slot.Height({3})).", textureRect.width, slot.Width, textureRect.height, slot.Height);
		}
		Rect screenRect = new Rect(slot.StartX, slot.StartY, Math.Min(slot.Width, textureRect.width), Math.Min(slot.Height, textureRect.height));
		float num = 1f / (float)atlasSize;
		Rect sourceRect = new Rect(textureRect.xMin / (float)texture.width, textureRect.yMin / (float)texture.height, textureRect.width / (float)texture.width, textureRect.height / (float)texture.height);
		RenderTexture active = RenderTexture.active;
		Graphics.SetRenderTarget(atlas);
		GL.PushMatrix();
		GL.LoadPixelMatrix(0f, atlasSize, atlasSize, 0f);
		Graphics.DrawTexture(new Rect(slot.StartX, slot.StartY, slot.Width, slot.Height), blackTransparentTexture, new Rect(0f, 0f, 1f, 1f), 0, 0, 0, 0, clearAtlasMaterial);
		Material material = null;
		if (overrideCopyAtlasShaderToMaterial != null)
		{
			Material value = null;
			if (overrideCopyAtlasShaderToMaterial.TryGetValue(slot.Shader, out value))
			{
				material = value;
			}
		}
		if (material == null)
		{
			if (Verbose)
			{
				Diagnostics.LogWarning("RunTimeSpritePacker : No override for shader {0}", slot.Shader.name);
			}
			material = copyAtlasMaterial;
		}
		Diagnostics.Assert(material != null);
		Graphics.DrawTexture(screenRect, texture, sourceRect, 0, 0, 0, 0, material);
		GL.PopMatrix();
		Graphics.SetRenderTarget(active);
		Vector2 textureRectOffset = sprite.textureRectOffset;
		textureRectOffset.x = (float)Math.Round(textureRectOffset.x);
		textureRectOffset.y = (float)Math.Round(textureRectOffset.y);
		float num2 = textureRectOffset.x + textureRect.width * 0.5f;
		float width = rect.width;
		Vector2 hotSpotIn = slot.HotSpotIn01;
		float x = num2 - width * hotSpotIn.x;
		float num3 = textureRectOffset.y + textureRect.height * 0.5f;
		float height = rect.height;
		Vector2 hotSpotIn2 = slot.HotSpotIn01;
		Vector2 vector = new Vector2(x, num3 - height * hotSpotIn2.y);
		slot.TexCoordIn01 = new Vector2(screenRect.xMin * num, screenRect.yMin * num);
		slot.SizeInPixels = new Vector2(screenRect.width, screenRect.height);
		slot.SizeInWorld = new Vector2(textureRect.width, textureRect.height);
		slot.CenterPosRelativeToHotSpot = new Vector2(vector.x, vector.y);
	}

	private bool CheckConsistency()
	{
		if (firstFreeSlot != -1)
		{
			Diagnostics.Assert(slots[firstFreeSlot].Empty);
		}
		Diagnostics.Assert(allocatedSlotCount == 0 || firstNotFreeSlot > 0);
		Diagnostics.Assert(allocatedSlotCount > 0 || firstNotFreeSlot == -1);
		Diagnostics.Assert(slots[0].Empty);
		Diagnostics.Assert(slots[0].PreviousSlotIndex == -1);
		Diagnostics.Assert(slots[0].NextSlotIndex == -1);
		Diagnostics.Assert(lastNotFreeSlot != 0);
		Diagnostics.Assert(firstFreeSlot != 0);
		Diagnostics.Assert(firstNotFreeSlot != 0);
		if (lastNotFreeSlot != -1)
		{
			Diagnostics.Assert(slots[lastNotFreeSlot].NextSlotIndex == -1);
			Diagnostics.Assert(slots[lastNotFreeSlot].PreviousSlotIndex != -1 || allocatedSlotCount == 1);
		}
		if (firstFreeSlot != -1)
		{
			Diagnostics.Assert(slots[firstFreeSlot].PreviousSlotIndex == -1);
		}
		if (firstNotFreeSlot != -1)
		{
			Diagnostics.Assert(slots[firstNotFreeSlot].PreviousSlotIndex == -1);
			Diagnostics.Assert(slots[firstNotFreeSlot].NextSlotIndex != -1 || allocatedSlotCount == 1);
		}
		int num = 0;
		for (int i = 1; i < slots.Length; i++)
		{
			if (!slots[i].Empty)
			{
				num++;
			}
			Diagnostics.Assert(slots[i].PreviousSlotIndex != 0);
			Diagnostics.Assert(slots[i].PreviousSlotIndex != i);
			Diagnostics.Assert(slots[i].NextSlotIndex != 0);
			Diagnostics.Assert(slots[i].PreviousSlotIndex != i);
			if (slots[i].PreviousSlotIndex != -1)
			{
				Diagnostics.Assert(slots[slots[i].PreviousSlotIndex].Empty == slots[i].Empty);
				Diagnostics.Assert(slots[slots[i].PreviousSlotIndex].NextSlotIndex == i);
			}
			else
			{
				Diagnostics.Assert(i == 1 || i == firstFreeSlot || !slots[i].Empty);
				Diagnostics.Assert(i == firstNotFreeSlot || slots[i].Empty);
			}
			if (slots[i].NextSlotIndex != -1)
			{
				Diagnostics.Assert(slots[slots[i].NextSlotIndex].Empty == slots[i].Empty);
				Diagnostics.Assert(slots[slots[i].NextSlotIndex].PreviousSlotIndex == i);
			}
			else
			{
				Diagnostics.Assert(i == lastNotFreeSlot || slots[i].Empty);
			}
		}
		Diagnostics.Assert(num == allocatedSlotCount);
		return true;
	}

	private void VideoStateServiceOnDeviceNoLongerLost(object sender, EventArgs e)
	{
		ReRenderAllSlot();
	}

	private void OnGameStopped(bool killAutoSave)
	{
		CreateOrResetSlots();
		spriteToSlotIndex.Clear();
		CheckConsistency();
	}

	private void CreateOrResetSlots()
	{
		int num = atlasSize / slotW;
		int num2 = atlasSize / slotH;
		if (slots == null)
		{
			slots = new Slot[num2 * num];
			for (int i = 0; i < num2; i++)
			{
				for (int j = 0; j < num; j++)
				{
					int num3 = j + i * num;
					slots[num3] = new Slot(num3, j * slotW, i * slotH, slotW, slotH);
				}
			}
		}
		else
		{
			for (int k = 0; k < slots.Length; k++)
			{
				slots[k].Forget();
				slots[k].Reset();
			}
		}
		for (int l = 2; l < slots.Length; l++)
		{
			if (l > 2)
			{
				slots[l].PreviousSlotIndex = l - 1;
			}
			if (l + 1 < slots.Length)
			{
				slots[l].NextSlotIndex = l + 1;
			}
		}
		firstFreeSlot = 2;
		firstNotFreeSlot = -1;
		lastNotFreeSlot = -1;
		allocatedSlotCount = 0;
	}
}
[RequireComponent(typeof(SpriteRenderer))]
public class SpriteRendererToLightManager : MonoBehaviour
{
	public enum Usage
	{
		Hero,
		Mob,
		Module,
		Props,
		Stele,
		Crystal,
		Artifact,
		NPC,
		AnimatedProps
	}

	private int spriteIndex = -1;

	private ILightManagerService lightManagerService;

	private IRunTimeSpritePackerService runTimeSpritePackerService;

	private SpriteRenderer spriteRenderer;

	private SpriteAnimationRuntime2 spriteAnimationRuntime2;

	private bool dynamic;

	private bool eventRegistered;

	[SerializeField]
	private Usage usage = Usage.Props;

	protected IEnumerator Start()
	{
		if (GameManager.Preferences.GameGraphicSettings.HxLightTotallyDeactivated)
		{
			UnityEngine.Object.DestroyImmediate(this);
			yield break;
		}
		dynamic = GetDynamic();
		spriteAnimationRuntime2 = base.transform.GetComponent<SpriteAnimationRuntime2>();
		spriteRenderer = GetComponent<SpriteRenderer>();
		while (lightManagerService == null)
		{
			lightManagerService = Services.GetService<ILightManagerService>();
			if (lightManagerService == null)
			{
				yield return new WaitForEndOfFrame();
			}
		}
		Diagnostics.Assert(lightManagerService != null);
		while (runTimeSpritePackerService == null)
		{
			runTimeSpritePackerService = Services.GetService<IRunTimeSpritePackerService>();
			if (runTimeSpritePackerService == null)
			{
				yield return new WaitForEndOfFrame();
			}
		}
		AddAndUpdateSprite(firstTime: true);
		if (!eventRegistered)
		{
			lightManagerService.AddEvent(OnUpdateEvent);
			eventRegistered = true;
		}
		yield return null;
	}

	protected void OnUpdateEvent(Camera camera, Vector3 minBBox, Vector3 maxBBox)
	{
		AddAndUpdateSprite(firstTime: false);
	}

	protected void AddAndUpdateSprite(bool firstTime)
	{
		Diagnostics.Assert(dynamic == GetDynamic());
		if (!(spriteRenderer != null) || runTimeSpritePackerService == null)
		{
			return;
		}
		Sprite sprite = spriteRenderer.sprite;
		if (sprite != null)
		{
			runTimeSpritePackerService.UseSprite(sprite, spriteRenderer.sharedMaterial.shader, GetHotSpotIn01(), out Vector2 texCoord, out Vector2 sizeInPixels, out Vector2 centerPosRelativeToHotSpot, out bool transparent);
			Vector3 a;
			if (spriteAnimationRuntime2 != null)
			{
				a = new Vector3((spriteAnimationRuntime2.CurrentAnimDirection != SpriteAnimDir.Left) ? (-1f) : 1f, 0f, 0f);
			}
			else
			{
				Vector3 localScale = base.transform.localScale;
				a = new Vector3(0f - localScale.x, 0f, 0f);
			}
			Vector3 a2 = new Vector3(0f, 2f, 0f);
			Vector3 pos = base.transform.position + (a * centerPosRelativeToHotSpot.x + a2 * centerPosRelativeToHotSpot.y);
			Vector3 rightTopCornerDirection = a * sizeInPixels.x + a2 * sizeInPixels.y;
			if (spriteIndex == -1)
			{
				spriteIndex = lightManagerService.RegisterSprite(pos, rightTopCornerDirection, texCoord, sizeInPixels, transparent, dynamic);
			}
			else if (dynamic)
			{
				lightManagerService.MoveSprite(spriteIndex, pos, rightTopCornerDirection);
				lightManagerService.UpdateSprite(spriteIndex, texCoord, sizeInPixels, transparent);
			}
		}
	}

	protected void OnDisable()
	{
		if (lightManagerService != null && spriteIndex >= 0)
		{
			lightManagerService.UnregisterSprite(spriteIndex);
			spriteIndex = -1;
			if (eventRegistered)
			{
				lightManagerService.RemoveEvent(OnUpdateEvent);
				eventRegistered = false;
			}
		}
	}

	protected void OnEnable()
	{
		if (lightManagerService == null)
		{
			lightManagerService = Services.GetService<ILightManagerService>();
		}
		if (runTimeSpritePackerService == null)
		{
			runTimeSpritePackerService = Services.GetService<IRunTimeSpritePackerService>();
		}
		if (spriteRenderer == null)
		{
			dynamic = GetDynamic();
			spriteAnimationRuntime2 = base.transform.GetComponent<SpriteAnimationRuntime2>();
			spriteRenderer = GetComponent<SpriteRenderer>();
		}
		if (lightManagerService != null && spriteIndex < 0)
		{
			AddAndUpdateSprite(firstTime: true);
			if (!eventRegistered)
			{
				lightManagerService.AddEvent(OnUpdateEvent);
				eventRegistered = true;
			}
		}
	}

	protected void OnDestroy()
	{
		if (lightManagerService != null)
		{
			if (spriteIndex >= 0)
			{
				lightManagerService.UnregisterSprite(spriteIndex);
				spriteIndex = -1;
			}
			if (eventRegistered)
			{
				lightManagerService.RemoveEvent(OnUpdateEvent);
				eventRegistered = false;
			}
		}
		lightManagerService = null;
		spriteRenderer = null;
	}

	private Vector2 GetHotSpotIn01()
	{
		switch (usage)
		{
		case Usage.Hero:
			return new Vector2(0.5f, 0f);
		case Usage.Mob:
			return new Vector2(0.5f, 0f);
		case Usage.Module:
			return new Vector2(0.5f, 0f);
		case Usage.Props:
			return new Vector2(0.5f, 0.5f);
		case Usage.NPC:
			return new Vector2(0.5f, 0f);
		case Usage.Stele:
			return new Vector2(0.5f, 0f);
		case Usage.Crystal:
			return new Vector2(0.5f, 0f);
		case Usage.Artifact:
			return new Vector2(0.5f, 0f);
		case Usage.AnimatedProps:
			return new Vector2(0.5f, 0.5f);
		default:
			Diagnostics.Assert(condition: false);
			return new Vector2(0.5f, 0.5f);
		}
	}

	private bool GetDynamic()
	{
		switch (usage)
		{
		case Usage.Hero:
			return true;
		case Usage.Mob:
			return true;
		case Usage.Module:
			return false;
		case Usage.Props:
			return false;
		case Usage.NPC:
			return true;
		case Usage.Stele:
			return true;
		case Usage.Crystal:
			return true;
		case Usage.Artifact:
			return false;
		case Usage.AnimatedProps:
			return true;
		default:
			Diagnostics.Assert(condition: false);
			return false;
		}
	}
}
public class VideoStateManager : MonoBehaviour, IVideoStateService, IService
{
	private static readonly string DefaultRendererShaderKeyword = "DEFAULT_RENDERER";

	private static readonly string InGameRendererShaderKeyword = "INGAME_RENDERER";

	private bool lastFrameDeviceLostDetected;

	private bool thisFrameDeviceLostDetected;

	private bool operatingSystemIsSuspended;

	private RenderTexture renderTexture;

	public bool DeviceLost => thisFrameDeviceLostDetected || lastFrameDeviceLostDetected;

	public bool OsIsSuspended => operatingSystemIsSuspended;

	public event EventHandler<EventArgs> OnDeviceLost;

	public event EventHandler<EventArgs> OnDeviceNoLongerLost;

	public void Awake()
	{
		SystemEvents.PowerModeChanged += OnPowerModeChangedEvent;
		Services.AddService((IVideoStateService)this);
	}

	public void OnEnable()
	{
		EnableInGameRenderer();
	}

	public void OnDisable()
	{
		DisableInGameRenderer();
	}

	public void OnDeviceLostDetected()
	{
		thisFrameDeviceLostDetected = true;
	}

	public void LateUpdate()
	{
		if (renderTexture == null)
		{
			renderTexture = new RenderTexture(16, 16, 0, RenderTextureFormat.ARGB32);
			renderTexture.name = "VideoStateManager.renderTexture";
			renderTexture.Create();
		}
		if (!renderTexture.IsCreated())
		{
			OnDeviceLostDetected();
			renderTexture.Create();
		}
		bool flag = lastFrameDeviceLostDetected;
		lastFrameDeviceLostDetected = thisFrameDeviceLostDetected;
		if (flag != lastFrameDeviceLostDetected)
		{
			if (lastFrameDeviceLostDetected)
			{
				Diagnostics.Log("VideoStateManager : Device lost");
				if (this.OnDeviceLost != null)
				{
					this.OnDeviceLost(this, new EventArgs());
				}
			}
			else
			{
				Diagnostics.Log("VideoStateManager : Device is no longer lost");
				if (this.OnDeviceNoLongerLost != null)
				{
					this.OnDeviceNoLongerLost(this, new EventArgs());
				}
			}
		}
		thisFrameDeviceLostDetected = false;
	}

	private void OnPowerModeChangedEvent(object sender, PowerModeChangedEventArgs e)
	{
		switch (e.Mode)
		{
		case PowerModes.StatusChange:
			break;
		case PowerModes.Resume:
			operatingSystemIsSuspended = false;
			Diagnostics.Log("OnPowerModeChangedEvent : OS Is Resumed");
			break;
		case PowerModes.Suspend:
			operatingSystemIsSuspended = true;
			Diagnostics.Log("OnPowerModeChangedEvent : OS Is Suspended");
			break;
		}
	}

	private static void EnableInGameRenderer()
	{
		Shader.DisableKeyword(DefaultRendererShaderKeyword);
		Shader.EnableKeyword(InGameRendererShaderKeyword);
		Diagnostics.Log("Enable InGame renderer");
	}

	private static void DisableInGameRenderer()
	{
		Shader.EnableKeyword(DefaultRendererShaderKeyword);
		Shader.DisableKeyword(InGameRendererShaderKeyword);
		Diagnostics.Log("Disable InGame renderer");
	}
}
public static class LogResourceHelper
{
	public static void LogAllTexture2D(string logFilename, HashSet<string> toFillHashSet = null, HashSet<string> toExcludeHashSet = null)
	{
		object[] textures = Resources.FindObjectsOfTypeAll<Texture2D>();
		using (TextWriter textWriter = File.CreateText(logFilename))
		{
			LogTexture2D(textWriter, textures, drawHeader: true, toFillHashSet, toExcludeHashSet);
		}
	}

	public static void LogAllRenderTexture(string logFilename, HashSet<string> toFillHashSet = null, HashSet<string> toExcludeHashSet = null)
	{
		object[] textures = Resources.FindObjectsOfTypeAll<RenderTexture>();
		using (TextWriter textWriter = File.CreateText(logFilename))
		{
			LogRenderTextures(textWriter, textures, drawHeader: true, toFillHashSet, toExcludeHashSet);
		}
	}

	public static void LogAllMaterials(string logFilename, HashSet<string> toFillHashSet = null, HashSet<string> toExcludeHashSet = null)
	{
		object[] materials = Resources.FindObjectsOfTypeAll<Material>();
		using (TextWriter textWriter = File.CreateText(logFilename))
		{
			LogMaterials(textWriter, materials, drawHeader: true, toFillHashSet, toExcludeHashSet);
		}
	}

	public static void LogAllSprites(string logFilename, HashSet<string> toFillHashSet = null, HashSet<string> toExcludeHashSet = null)
	{
		object[] sprites = Resources.FindObjectsOfTypeAll<Sprite>();
		using (TextWriter textWriter = File.CreateText(logFilename))
		{
			LogSprites(textWriter, sprites, drawHeader: true, toFillHashSet, toExcludeHashSet);
		}
	}

	public static void LogTexture2D(TextWriter textWriter, object[] textures, bool drawHeader, HashSet<string> toFillHashSet, HashSet<string> toExcludeHashSet)
	{
		if (drawHeader)
		{
			textWriter.WriteLine(GetTexture2DHeader());
		}
		if (textures == null)
		{
			return;
		}
		for (int i = 0; i < textures.Length; i++)
		{
			Texture2D texture2D = textures[i] as Texture2D;
			if (!(texture2D == null))
			{
				string texture2DDescription = GetTexture2DDescription(texture2D);
				toFillHashSet?.Add(texture2DDescription);
				if (toExcludeHashSet == null || !toExcludeHashSet.Contains(texture2DDescription))
				{
					textWriter.WriteLine(texture2DDescription);
				}
			}
		}
	}

	public static void LogRenderTextures(TextWriter textWriter, object[] textures, bool drawHeader, HashSet<string> toFillHashSet, HashSet<string> toExcludeHashSet)
	{
		if (drawHeader)
		{
			textWriter.WriteLine(GetRenderTextureHeader());
		}
		if (textures == null)
		{
			return;
		}
		for (int i = 0; i < textures.Length; i++)
		{
			RenderTexture renderTexture = textures[i] as RenderTexture;
			if (!(renderTexture == null))
			{
				string renderTextureDescription = GetRenderTextureDescription(renderTexture);
				toFillHashSet?.Add(renderTextureDescription);
				if (toExcludeHashSet == null || !toExcludeHashSet.Contains(renderTextureDescription))
				{
					textWriter.WriteLine(renderTextureDescription);
				}
			}
		}
	}

	public static void LogMaterials(TextWriter textWriter, object[] materials, bool drawHeader, HashSet<string> toFillHashSet, HashSet<string> toExcludeHashSet)
	{
		if (drawHeader)
		{
			textWriter.WriteLine(GetMaterialHeader());
		}
		if (materials == null)
		{
			return;
		}
		for (int i = 0; i < materials.Length; i++)
		{
			Material material = materials[i] as Material;
			if (!(material == null))
			{
				string materialDescription = GetMaterialDescription(material);
				toFillHashSet?.Add(materialDescription);
				if (toExcludeHashSet == null || !toExcludeHashSet.Contains(materialDescription))
				{
					textWriter.WriteLine(materialDescription);
				}
			}
		}
	}

	public static void LogSprites(TextWriter textWriter, object[] sprites, bool drawHeader, HashSet<string> toFillHashSet, HashSet<string> toExcludeHashSet)
	{
		if (drawHeader)
		{
			textWriter.WriteLine(GetSpriteHeader());
		}
		if (sprites == null)
		{
			return;
		}
		for (int i = 0; i < sprites.Length; i++)
		{
			Sprite sprite = sprites[i] as Sprite;
			if (!(sprite == null))
			{
				string spriteDescription = GetSpriteDescription(sprite);
				toFillHashSet?.Add(spriteDescription);
				if (toExcludeHashSet == null || !toExcludeHashSet.Contains(spriteDescription))
				{
					textWriter.WriteLine(spriteDescription);
				}
			}
		}
	}

	private static string GetTexture2DHeader()
	{
		return "Texture name; width; height;mipmap;format;size in Kb;readable";
	}

	private static string GetTexture2DDescription(Texture2D texture)
	{
		string name = texture.name;
		int width = texture.width;
		int height = texture.height;
		int mipmapCount = texture.mipmapCount;
		TextureFormat format = texture.format;
		int textureSizeInByte = GetTextureSizeInByte(width, height, mipmapCount, format);
		string text = (textureSizeInByte <= 0) ? "?" : textureSizeInByte.ToString();
		bool flag = false;
		try
		{
			texture.GetPixel(0, 0);
			flag = true;
		}
		catch (Exception)
		{
		}
		return $"{name};{width};{height};{mipmapCount};{format.ToString()};{text};{flag.ToString()}";
	}

	private static string GetRenderTextureHeader()
	{
		return "Texture name; width; height;mipmap;format;size in Kb;created";
	}

	private static string GetRenderTextureDescription(RenderTexture renderTexture)
	{
		string name = renderTexture.name;
		int width = renderTexture.width;
		int height = renderTexture.height;
		bool useMipMap = renderTexture.useMipMap;
		RenderTextureFormat format = renderTexture.format;
		int num = 1;
		if (useMipMap)
		{
			int num2 = renderTexture.width;
			int num3 = renderTexture.height;
			while (num2 / 2 > 0 && num3 / 2 > 0)
			{
				num++;
				num3 /= 2;
				num2 /= 2;
			}
		}
		int renderTextureSizeInByte = GetRenderTextureSizeInByte(width, height, num, format);
		string text = (renderTextureSizeInByte <= 0) ? "?" : renderTextureSizeInByte.ToString();
		bool flag = renderTexture.IsCreated();
		return string.Format("{0};{1};{2};{3};{4};{5}", name, width, height, num, format.ToString(), text, flag.ToString());
	}

	private static string GetMaterialHeader()
	{
		return "Material name; shader; supported";
	}

	private static string GetMaterialDescription(Material material)
	{
		string name = material.name;
		string arg = (!(material.shader != null)) ? "null" : material.shader.name;
		string arg2 = (!(material.shader != null)) ? "n/a" : material.shader.isSupported.ToString();
		return $"{name};{arg};{arg2}";
	}

	private static string GetSpriteHeader()
	{
		return "Sprite name;" + GetTexture2DHeader();
	}

	private static string GetSpriteDescription(Sprite sprite)
	{
		string name = sprite.name;
		string empty = string.Empty;
		Texture2D texture = sprite.texture;
		empty = ((!(texture != null)) ? ((!(sprite.texture != null)) ? "null" : sprite.texture.name) : GetTexture2DDescription(texture));
		return $"{name};{empty}";
	}

	private static int GetTextureSizeInByte(int width, int height, int mipmapCount, TextureFormat format)
	{
		int result = -1;
		switch (format)
		{
		case TextureFormat.Alpha8:
			result = GetPixelCount(width, height, mipmapCount);
			break;
		case TextureFormat.ARGB4444:
		case TextureFormat.RGB565:
			result = GetPixelCount(width, height, mipmapCount) * 2;
			break;
		case TextureFormat.RGB24:
		case TextureFormat.RGBA32:
		case TextureFormat.ARGB32:
			result = GetPixelCount(width, height, mipmapCount) * 4;
			break;
		case TextureFormat.DXT1:
			result = GetPixelCount(width / 4, height / 4, mipmapCount) * 4;
			break;
		case TextureFormat.DXT5:
			result = GetPixelCount(width / 4, height / 4, mipmapCount) * 8;
			break;
		}
		return result;
	}

	private static int GetRenderTextureSizeInByte(int width, int height, int mipmapCount, RenderTextureFormat format)
	{
		int result = 1;
		switch (format)
		{
		case RenderTextureFormat.R8:
			result = GetPixelCount(width, height, mipmapCount);
			break;
		case RenderTextureFormat.ARGB32:
		case RenderTextureFormat.Default:
			result = GetPixelCount(width, height, mipmapCount) * 4;
			break;
		}
		return result;
	}

	private static int GetPixelCount(int width, int height, int mipmapCount)
	{
		int num = 0;
		for (int i = 0; i <= mipmapCount; i++)
		{
			num += width * height;
			width /= 2;
			height /= 2;
		}
		return num;
	}
}
public class MainMenuCamera : MonoBehaviour
{
}
[ExecuteInEditMode]
public class MaterialConfigHelper : MonoBehaviour
{
	private string[] textureNames;

	[SerializeField]
	private int tileWidth;

	[SerializeField]
	private int tileHeight;

	[SerializeField]
	private int tileX;

	[SerializeField]
	private int tileY;

	[SerializeField]
	private int xOffset;

	[SerializeField]
	private int yOffset;

	[SerializeField]
	private bool autoApply;

	public void ApplyConfig()
	{
		string propertyName = "_MainTex";
		Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
		Texture texture = sharedMaterial.GetTexture(propertyName);
		int num = texture.width / tileWidth;
		int num2 = texture.height / tileHeight;
		tileX = (tileX + num) % num;
		tileY = (tileY + num2) % num2;
		sharedMaterial.SetTextureScale(propertyName, new Vector2((float)tileWidth / (float)texture.width, (float)tileHeight / (float)texture.height));
		sharedMaterial.SetTextureOffset(propertyName, new Vector2((float)xOffset + (float)tileX * (float)tileWidth / (float)texture.width, (float)yOffset + (float)tileY * (float)tileHeight / (float)texture.height));
	}
}
public class OperateSubVfxController : SubVfxController
{
}
public class OrthoProjMatrix : MonoBehaviour
{
	[SerializeField]
	private float near = 0.3f;

	[SerializeField]
	private float far = 1000f;

	[SerializeField]
	private float orthographicSize = 50f;

	private Camera cam;

	private void Awake()
	{
		cam = GetComponent<Camera>();
	}

	private void Update()
	{
		float num = (float)Screen.width / (float)Screen.height;
		cam.projectionMatrix = Matrix4x4.Ortho((0f - orthographicSize) * num, orthographicSize * num, 0f - orthographicSize, orthographicSize, near, far);
	}
}
public class Rotator : MonoBehaviour
{
	[SerializeField]
	private float rotationSpeed;

	[SerializeField]
	private Vector3 axis = Vector3.up;

	private void Update()
	{
		base.transform.RotateAround(base.transform.position, axis, rotationSpeed * DungeonsApplication.GetRealtimeDelta());
	}
}
public class ScaleOnStart : MonoBehaviour
{
	[SerializeField]
	private Vector3 scale;

	private void Start()
	{
		base.transform.localScale = scale;
	}
}
public class SpriteAnimation : ScriptableObject
{
	public SpriteAnimationConfig Config;

	public float GetDuration()
	{
		float num = (float)Config.FrameCount * Config.FrameDuration;
		SpriteAnimationFrameTiming[] frameTimings = Config.FrameTimings;
		for (int i = 0; i < frameTimings.Length; i++)
		{
			SpriteAnimationFrameTiming spriteAnimationFrameTiming = frameTimings[i];
			if (spriteAnimationFrameTiming.FrameIndex >= 0 && spriteAnimationFrameTiming.FrameIndex <= Config.FrameCount - 1)
			{
				num += (float)(spriteAnimationFrameTiming.KeyFrameCount - 1) * Config.FrameDuration;
			}
		}
		return num;
	}
}
[Serializable]
public class SpriteAnimationConfig
{
	[HideInInspector]
	public Texture Texture;

	public Material Mat;

	public int TileWidth;

	public int TileHeight;

	public int FirstTileX;

	public int FirstTileY;

	public int XPixelOffset;

	public int YPixelOffset;

	public float FrameDuration;

	public int FrameCount;

	public SpriteAnimationFrameTiming[] FrameTimings;

	public SpriteAnimationFrameEvent[] FrameEvents;

	public SpriteAnimationFrameSFX[] FrameSFXs;

	public SpriteAnimationConfig GetCopy()
	{
		SpriteAnimationConfig spriteAnimationConfig = new SpriteAnimationConfig();
		spriteAnimationConfig.Mat = Mat;
		spriteAnimationConfig.TileWidth = TileWidth;
		spriteAnimationConfig.TileHeight = TileHeight;
		spriteAnimationConfig.FirstTileX = FirstTileX;
		spriteAnimationConfig.FirstTileY = FirstTileY;
		spriteAnimationConfig.XPixelOffset = XPixelOffset;
		spriteAnimationConfig.YPixelOffset = YPixelOffset;
		spriteAnimationConfig.FrameDuration = FrameDuration;
		spriteAnimationConfig.FrameCount = FrameCount;
		spriteAnimationConfig.FrameTimings = FrameTimings;
		spriteAnimationConfig.FrameEvents = FrameEvents;
		spriteAnimationConfig.FrameSFXs = FrameSFXs;
		return spriteAnimationConfig;
	}
}
public class SpriteAnimationDefaultSetter : MonoBehaviour
{
	[SerializeField]
	private RuntimeAnimatorController controller;

	[SerializeField]
	[FormerlySerializedAs("animation")]
	private AnimationClip animClip;

	private void Awake()
	{
		SetDefaultAnimation();
	}

	public void SetDefaultAnimation()
	{
		Animator component = GetComponent<Animator>();
		AnimatorOverrideController animatorOverrideController = new AnimatorOverrideController();
		animatorOverrideController.runtimeAnimatorController = controller;
		animatorOverrideController["Default"] = animClip;
		component.runtimeAnimatorController = animatorOverrideController;
	}

	private void AnimEnd()
	{
	}
}
[Serializable]
public struct SpriteAnimationFrameEvent
{
	public int FrameIndex;

	public string EventName;
}
[Serializable]
public struct SpriteAnimationFrameSFX
{
	public int FrameIndex;

	public string SFXPath;
}
[Serializable]
public struct SpriteAnimationFrameTiming
{
	public int FrameIndex;

	public int KeyFrameCount;
}
public enum SpriteAnimDir
{
	Down,
	Up,
	Left,
	Right
}
[RequireComponent(typeof(SpriteController))]
public class SpriteAnimationRuntime : MonoBehaviour
{
	public delegate void AnimEventHandler(string eventName);

	public delegate void MaterialChangedEventHandler();

	public delegate void AnimationEndHandler();

	public delegate void AnimationInterruptionHandler();

	[SerializeField]
	private SpriteAnimation[] anims;

	[SerializeField]
	private float virtualRotationSpeed;

	[SerializeField]
	private bool playOnStart;

	[SerializeField]
	private AudioEmitter audioEmitter;

	[SerializeField]
	private bool debug;

	private string currentAnimBaseName;

	private string nextAnimName;

	private Dictionary<StaticString, SpriteAnimation> indexedAnims = new Dictionary<StaticString, SpriteAnimation>();

	private int frameIndex;

	private float nextFrameTime;

	private Dictionary<int, int> indexedFrameTimings;

	private Dictionary<int, string> indexedFrameEvents;

	private Dictionary<int, string> indexedFrameSFXs;

	private bool loop;

	private bool flipX;

	private bool isPlaying;

	private Vector3 refLocalPos;

	private float animSpeedModifier;

	private SpriteController sprite;

	private Transform tfm;

	private SpriteAnimDir currentAnimDirection;

	private AnimationEndHandler onCurrentAnimEnd;

	private AnimationInterruptionHandler onCurrentAnimInterruption;

	public SpriteAnimation CurrentAnim
	{
		get;
		private set;
	}

	public bool IsPlaying => isPlaying;

	public SpriteAnimDir CurrentAnimDirection => currentAnimDirection;

	public event AnimEventHandler OnAnimEvent;

	public event MaterialChangedEventHandler OnMaterialChanged;

	public void ClearAnimations()
	{
		anims = new SpriteAnimation[0];
		indexedAnims.Clear();
	}

	public void AddAnimation(SpriteAnimation anim)
	{
		if (anim == null)
		{
			Diagnostics.LogError(base.name + " > AddAnimation: anim is null");
			return;
		}
		List<SpriteAnimation> list = new List<SpriteAnimation>(anims);
		list.Add(anim);
		anims = list.ToArray();
		indexedAnims.Add(anim.name, anim);
	}

	public float GetAnimDuration(string animBaseName)
	{
		GetFullAnimName(animBaseName, out string animFullName, out bool _);
		if (!indexedAnims.ContainsKey(animFullName))
		{
			Diagnostics.LogError(base.gameObject.name + " has no animation: " + animFullName);
		}
		return indexedAnims[animFullName].GetDuration();
	}

	public void PlayOnceThenStop(string animBaseName, float animSpeedModifier = 1f, AnimationEndHandler onAnimEnd = null, AnimationInterruptionHandler onAnimInterruption = null)
	{
		Play(animBaseName, loop: false, null, forceRestart: false, animSpeedModifier, onAnimEnd, onAnimInterruption);
	}

	public void PlayOnceThenResume(string animBaseName, float animSpeedModifier = 1f, AnimationEndHandler onAnimEnd = null, AnimationInterruptionHandler onAnimInterruption = null)
	{
		Play(animBaseName, loop: false, string.Empty, forceRestart: false, animSpeedModifier, onAnimEnd, onAnimInterruption);
	}

	public void PlayOnceThen(string animBaseName, string nextAnimBaseName, bool forceRestart = false, float animSpeedModifier = 1f, AnimationEndHandler onAnimEnd = null, AnimationInterruptionHandler onAnimInterruption = null)
	{
		Play(animBaseName, loop: false, nextAnimBaseName, forceRestart, animSpeedModifier, onAnimEnd, onAnimInterruption);
	}

	public void PlayLoop(string animBaseName, bool forceRestart = false, float animSpeedModifier = 1f, AnimationInterruptionHandler onAnimInterruption = null)
	{
		Play(animBaseName, loop: true, null, forceRestart, animSpeedModifier, null, onAnimInterruption);
	}

	public void Play(string animBaseName = null, bool loop = true, string nextAnimName = "", bool forceRestart = false, float animSpeedModifier = 1f, AnimationEndHandler onAnimEnd = null, AnimationInterruptionHandler onAnimInterruption = null)
	{
		if (debug)
		{
			Diagnostics.LogWarning(base.name + " > Play animBaseName=" + animBaseName + " loop=" + loop + " nextAnimName=" + nextAnimName + " forceRestart=" + forceRestart + " animSpeedModifier=" + animSpeedModifier);
		}
		if (animBaseName == null && anims.Length == 1)
		{
			animBaseName = anims[0].name;
		}
		GetFullAnimName(animBaseName, out string animFullName, out bool flag);
		if (isPlaying && CurrentAnim.name == animFullName && flipX == flag && !forceRestart)
		{
			return;
		}
		if (!loop)
		{
			if (nextAnimName == null)
			{
				this.nextAnimName = null;
			}
			else if (nextAnimName.Length < 1)
			{
				this.nextAnimName = currentAnimBaseName;
			}
			else
			{
				this.nextAnimName = nextAnimName;
			}
		}
		if (!indexedAnims.ContainsKey(animFullName))
		{
			Diagnostics.LogError(base.name + " > Play: Unable to find \"" + animFullName + "\" sprite animation!", base.gameObject);
			return;
		}
		if (onCurrentAnimInterruption != null)
		{
			onCurrentAnimInterruption();
			onCurrentAnimInterruption = null;
		}
		currentAnimBaseName = animBaseName;
		CurrentAnim = indexedAnims[animFullName];
		this.loop = loop;
		flipX = flag;
		ApplyAnimConfig();
		nextFrameTime = Time.time;
		frameIndex = -1;
		this.animSpeedModifier = animSpeedModifier;
		onCurrentAnimEnd = onAnimEnd;
		onCurrentAnimInterruption = onAnimInterruption;
		isPlaying = true;
		UpdateAnimationToNextFrame();
	}

	public void SetAnimDirection(Vector3 direction)
	{
		if (direction.sqrMagnitude <= 0f)
		{
			return;
		}
		direction = direction.DivideBy(SingletonManager.Get<Dungeon>().ContainerScale);
		Vector3 eulerAngles = Quaternion.FromToRotation(Vector3.forward, direction).eulerAngles;
		float y = eulerAngles.y;
		float num = (y + 360f) % 360f;
		SpriteAnimDir spriteAnimDir = currentAnimDirection;
		float num2 = Mathf.Abs(direction.x);
		float num3 = Mathf.Abs(direction.z);
		bool flag = false;
		flag = ((num2 > num3) ? (((currentAnimDirection == SpriteAnimDir.Up || currentAnimDirection == SpriteAnimDir.Down) && num2 < 1.1f * num3) ? true : false) : (((currentAnimDirection != SpriteAnimDir.Left && currentAnimDirection != SpriteAnimDir.Right) || !(num3 < 1.1f * num2)) ? true : false));
		spriteAnimDir = ((!flag) ? ((!(direction.x > 0f)) ? SpriteAnimDir.Right : SpriteAnimDir.Left) : ((!(direction.z > 0f)) ? SpriteAnimDir.Up : SpriteAnimDir.Down));
		if (spriteAnimDir != currentAnimDirection)
		{
			if (debug)
			{
				Diagnostics.LogWarning(tfm.parent.name + " > SetAnimDirection: direction=" + direction + " angle=" + y + " positiveAngle=" + num + " => FROM this.currentAnimDir=" + currentAnimDirection + " TO newAnimDir=" + spriteAnimDir);
			}
			currentAnimDirection = spriteAnimDir;
			Play(currentAnimBaseName, loop, nextAnimName, forceRestart: false, animSpeedModifier);
		}
		if (debug)
		{
			Diagnostics.LogWarning(base.name + " > SetAnimDirection direction=" + direction + " angle=" + y);
		}
	}

	public void PlayRandomAnim()
	{
		PlayLoop(anims[RandomGenerator.RangeInt(0, anims.Length)].name);
	}

	public void Stop()
	{
		isPlaying = false;
	}

	private void Awake()
	{
		Diagnostics.LogError(this.GetScenePath() + " > SpriteAnimationRuntime SHOULDN'T BE USED ANYMORE!!!");
		sprite = GetComponent<SpriteController>();
		tfm = base.transform;
		if (audioEmitter == null)
		{
			audioEmitter = GetComponent<AudioEmitter>();
		}
		refLocalPos = tfm.localPosition;
		LoadAnimations();
	}

	private void Start()
	{
		if (playOnStart)
		{
			PlayLoop(anims[0].name);
		}
	}

	private void GetFullAnimName(string animBaseName, out string animFullName, out bool flipX)
	{
		animFullName = animBaseName + string.Empty;
		flipX = false;
		string str = animFullName;
		if (currentAnimDirection == SpriteAnimDir.Left)
		{
			str = str + "_" + SpriteAnimDir.Right.ToString();
			flipX = true;
		}
		else
		{
			str = str + "_" + currentAnimDirection.ToString();
		}
		if (indexedAnims.ContainsKey(str))
		{
			animFullName = str;
		}
	}

	private void LoadAnimations()
	{
		indexedAnims.Clear();
		SpriteAnimation[] array = anims;
		foreach (SpriteAnimation spriteAnimation in array)
		{
			indexedAnims.Add(spriteAnimation.name, spriteAnimation);
		}
	}

	private void Update()
	{
		if (isPlaying && Time.time >= nextFrameTime)
		{
			UpdateAnimationToNextFrame();
		}
	}

	private void ApplyAnimConfig()
	{
		if (debug)
		{
			Diagnostics.Log(base.name + " > ApplyAnimConfig this.CurrentAnim=" + CurrentAnim.name);
		}
		indexedFrameTimings = new Dictionary<int, int>();
		if (CurrentAnim.Config.FrameTimings != null)
		{
			SpriteAnimationFrameTiming[] frameTimings = CurrentAnim.Config.FrameTimings;
			for (int i = 0; i < frameTimings.Length; i++)
			{
				SpriteAnimationFrameTiming spriteAnimationFrameTiming = frameTimings[i];
				if (spriteAnimationFrameTiming.FrameIndex >= 0 && spriteAnimationFrameTiming.FrameIndex <= CurrentAnim.Config.FrameCount - 1)
				{
					indexedFrameTimings.Add(spriteAnimationFrameTiming.FrameIndex, spriteAnimationFrameTiming.KeyFrameCount);
				}
			}
		}
		indexedFrameEvents = new Dictionary<int, string>();
		if (CurrentAnim.Config.FrameEvents != null)
		{
			SpriteAnimationFrameEvent[] frameEvents = CurrentAnim.Config.FrameEvents;
			for (int j = 0; j < frameEvents.Length; j++)
			{
				SpriteAnimationFrameEvent spriteAnimationFrameEvent = frameEvents[j];
				if (spriteAnimationFrameEvent.FrameIndex >= 0 && spriteAnimationFrameEvent.FrameIndex <= CurrentAnim.Config.FrameCount - 1)
				{
					indexedFrameEvents.Add(spriteAnimationFrameEvent.FrameIndex, spriteAnimationFrameEvent.EventName);
				}
			}
		}
		indexedFrameSFXs = new Dictionary<int, string>();
		if (CurrentAnim.Config.FrameSFXs != null)
		{
			SpriteAnimationFrameSFX[] frameSFXs = CurrentAnim.Config.FrameSFXs;
			for (int k = 0; k < frameSFXs.Length; k++)
			{
				SpriteAnimationFrameSFX spriteAnimationFrameSFX = frameSFXs[k];
				if (spriteAnimationFrameSFX.FrameIndex >= 0 && spriteAnimationFrameSFX.FrameIndex <= CurrentAnim.Config.FrameCount - 1)
				{
					indexedFrameSFXs.Add(spriteAnimationFrameSFX.FrameIndex, spriteAnimationFrameSFX.SFXPath);
				}
			}
		}
		if (CurrentAnim.Config.Mat == null)
		{
			Diagnostics.LogError(CurrentAnim.name + " animation material is not defined!");
		}
		GetComponent<Renderer>().material = CurrentAnim.Config.Mat;
		sprite.SetTileSize(CurrentAnim.Config.TileWidth, CurrentAnim.Config.TileHeight);
		if (this.OnMaterialChanged != null)
		{
			this.OnMaterialChanged();
		}
	}

	private void UpdateSprite()
	{
		if (debug)
		{
			Diagnostics.Log(base.name + " > UpdateSprite this.frameIndex=" + frameIndex);
		}
		sprite.SetSpriteTile(CurrentAnim.Config.FirstTileX + frameIndex, CurrentAnim.Config.FirstTileY, flipX);
		tfm.localPosition = refLocalPos;
		Transform transform = tfm;
		Vector3 position = transform.position;
		float num = CurrentAnim.Config.XPixelOffset;
		Vector3 lossyScale = tfm.lossyScale;
		transform.position = position + num * (lossyScale.x / (float)CurrentAnim.Config.TileWidth) * tfm.right;
		Transform transform2 = tfm;
		Vector3 position2 = transform2.position;
		float num2 = CurrentAnim.Config.YPixelOffset;
		Vector3 localScale = tfm.localScale;
		transform2.position = position2 + num2 * (localScale.y / (float)CurrentAnim.Config.TileHeight) * tfm.up;
	}

	private void UpdateAnimationToNextFrame()
	{
		frameIndex++;
		if (debug)
		{
			Diagnostics.Log(base.name + " > UpdateAnimationToNextFrame this.frameIndex=" + frameIndex + " anim frame count=" + CurrentAnim.Config.FrameCount);
		}
		if (frameIndex >= CurrentAnim.Config.FrameCount)
		{
			if (debug)
			{
				Diagnostics.Log(base.name + " > UpdateAnimationToNextFrame: Previous frame was the last one of current animation");
			}
			if (!loop)
			{
				if (nextAnimName == null)
				{
					if (debug)
					{
						Diagnostics.Log(base.name + " > UpdateAnimationToNextFrame: No more animation");
					}
					frameIndex--;
					isPlaying = false;
					if (onCurrentAnimEnd != null)
					{
						AnimationEndHandler d = onCurrentAnimEnd;
						onCurrentAnimEnd();
						if (onCurrentAnimEnd == d)
						{
							onCurrentAnimEnd = null;
						}
					}
					return;
				}
				if (debug)
				{
					Diagnostics.Log(base.name + " > UpdateAnimationToNextFrame: Play next animation");
				}
				if (onCurrentAnimEnd != null)
				{
					AnimationEndHandler d2 = onCurrentAnimEnd;
					onCurrentAnimEnd();
					if (onCurrentAnimEnd == d2)
					{
						onCurrentAnimEnd = null;
					}
				}
				PlayLoop(nextAnimName);
				return;
			}
			if (debug)
			{
				Diagnostics.Log(base.name + " > UpdateAnimationToNextFrame: Loop back to the start");
			}
			frameIndex = 0;
		}
		UpdateSprite();
		if (indexedFrameEvents.ContainsKey(frameIndex) && this.OnAnimEvent != null)
		{
			if (debug)
			{
				Diagnostics.Log(base.name + " > UpdateAnimationToNextFrame: " + indexedFrameEvents[frameIndex] + " EVENT!");
			}
			this.OnAnimEvent(indexedFrameEvents[frameIndex]);
		}
		if (indexedFrameSFXs.ContainsKey(frameIndex) && audioEmitter != null)
		{
			if (debug)
			{
				Diagnostics.Log(base.name + " > UpdateAnimationToNextFrame: " + indexedFrameSFXs[frameIndex] + " SFX!");
			}
			audioEmitter.PlayEvent(indexedFrameSFXs[frameIndex]);
		}
		int num = 1;
		if (indexedFrameTimings.ContainsKey(frameIndex))
		{
			num = indexedFrameTimings[frameIndex];
		}
		float num2 = CurrentAnim.Config.FrameDuration * (float)num / animSpeedModifier;
		if (num2 > 0f)
		{
			nextFrameTime += num2;
			if (Time.time >= nextFrameTime)
			{
				UpdateAnimationToNextFrame();
			}
		}
		else
		{
			UnityEngine.Debug.LogError(base.name + " > " + CurrentAnim.name + " sprite anim config error: current anim frame has no duration! Check frame duration config (must be > 0)", CurrentAnim);
			UnityEngine.Debug.Log("this.frameIndex=" + frameIndex);
			UnityEngine.Debug.Log("this.CurrentAnim.Config.FrameDuration=" + CurrentAnim.Config.FrameDuration);
			UnityEngine.Debug.Log("framesLeft=" + num);
			UnityEngine.Debug.Log("this.animSpeedModifier=" + animSpeedModifier);
			nextFrameTime = Time.time;
		}
	}
}
public class SpriteAnimationRuntime2 : MonoBehaviour
{
	public delegate void StateEnterHandler();

	public delegate void StateExitHandler();

	public delegate void AnimEventHandler();

	private static Dictionary<StaticString, Dictionary<RuntimeAnimatorController, AnimatorOverrideController>> animOverrideControllersCache;

	[SerializeField]
	private Renderer[] renderers;

	[SerializeField]
	private AudioEmitter audioEmitter;

	[SerializeField]
	private bool autoPlayOnStart = true;

	[SerializeField]
	private bool ignoreScale;

	[SerializeField]
	private bool monitorStates;

	[SerializeField]
	private bool debug;

	[SerializeField]
	private bool debugStates;

	[SerializeField]
	private bool debugEvents;

	private Transform tfm;

	private SpriteAnimDir currentAnimDirection;

	private int layerIndex;

	private int currentStateHash;

	private Dictionary<int, StateEnterHandler> stateEnterMonitors = new Dictionary<int, StateEnterHandler>();

	private Dictionary<int, StateExitHandler> stateExitMonitors = new Dictionary<int, StateExitHandler>();

	private Dictionary<int, StateExitHandler> oneShotStateExitMonitors = new Dictionary<int, StateExitHandler>();

	private Dictionary<StaticString, AnimEventHandler> animEventMonitors = new Dictionary<StaticString, AnimEventHandler>();

	private string speedResetStateName;

	private List<SpriteAnimationTrigger> triggers;

	private RuntimeAnimatorController originalController;

	private string _animRightDirectionSuffix = "_Right";

	private string _animDownDirectionSuffix = "_Down";

	private string _animUpDirectionSuffix = "_Up";

	public Animator Animator
	{
		get;
		private set;
	}

	public SpriteAnimDir CurrentAnimDirection => currentAnimDirection;

	public bool IsPlaying
	{
		get;
		private set;
	}

	private void AnimEnd()
	{
	}

	private void SpriteAnimEvent(string eventName)
	{
		if (debugEvents)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.SpriteAnimEvent eventName=" + eventName);
		}
		StaticString key = new StaticString(eventName);
		if (animEventMonitors != null && animEventMonitors.ContainsKey(key) && animEventMonitors[key] != null)
		{
			animEventMonitors[key]();
		}
		else if (debugEvents)
		{
			Diagnostics.LogWarning(base.name + " > No one listening to the " + eventName + " anim event!");
		}
	}

	private void PlaySFX(string sfxPath)
	{
		if (debugEvents)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.PlaySFX sfxPath=" + sfxPath);
		}
		if (audioEmitter != null)
		{
			audioEmitter.PlayEvent(sfxPath);
		}
		else
		{
			Diagnostics.LogError(base.name + " > SpriteAnimationRuntime2.PlaySFX: No audio emitter to play the " + sfxPath + " SFX!");
		}
	}

	private void PlayUniqueSFX(string sfxPath)
	{
		if (debugEvents)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.AssertPlaySFX sfxPath=" + sfxPath);
		}
		if (audioEmitter != null)
		{
			audioEmitter.PlayAndStoreEvent(sfxPath, true);
		}
		else
		{
			Diagnostics.LogError(base.name + " > SpriteAnimationRuntime2.AssertPlaySFX: No audio emitter to play the " + sfxPath + " SFX!");
		}
	}

	private void PlaySFXUntilStateExit(string sfxPath)
	{
		if (debugEvents)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.PlaySFXUntilStateExit sfxPath=" + sfxPath + " state=" + GetCurrentStateHash());
		}
		if (audioEmitter != null)
		{
			audioEmitter.PlayAndStoreEvent(sfxPath, false);
			MonitorStateExit(GetCurrentStateHash(), delegate
			{
				if (debugEvents)
				{
					Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.PlaySFXUntilStateExit > STOP sfxPath=" + sfxPath);
				}
				audioEmitter.StopStoredEvents(sfxPath);
			}, oneShot: true);
		}
		else
		{
			Diagnostics.LogError(base.name + " > SpriteAnimationRuntime2.PlaySFXUntilStateExit: No audio emitter to play the " + sfxPath + " SFX!");
		}
	}

	private void PlayUniqueSFXUntilStateExit(string sfxPath)
	{
		if (debugEvents)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.PlayUniqueSFXUntilStateExit sfxPath=" + sfxPath + " state=" + GetCurrentStateHash());
		}
		if (audioEmitter != null)
		{
			audioEmitter.PlayAndStoreEvent(sfxPath, true);
			MonitorStateExit(GetCurrentStateHash(), delegate
			{
				if (debugEvents)
				{
					Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.PlayUniqueSFXUntilStateExit > STOP sfxPath=" + sfxPath);
				}
				audioEmitter.StopStoredEvents(sfxPath);
			}, oneShot: true);
		}
		else
		{
			Diagnostics.LogError(base.name + " > SpriteAnimationRuntime2.PlayUniqueSFXUntilStateExit: No audio emitter to play the " + sfxPath + " SFX!");
		}
	}

	private void PlaySFXOnStateExit(string sfxPath)
	{
		if (debugEvents)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.PlaySFXOnStateExit sfxPath=" + sfxPath + " state=" + GetCurrentStateHash());
		}
		MonitorStateExit(GetCurrentStateHash(), delegate
		{
			if (debugEvents)
			{
				Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.PlaySFXOnStateExit > PLAY sfxPath=" + sfxPath);
			}
			PlaySFX(sfxPath);
		}, oneShot: true);
	}

	private void PlayUniqueSFXOnStateExit(string sfxPath)
	{
		if (debugEvents)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.PlaySFXOnStateExit sfxPath=" + sfxPath + " state=" + GetCurrentStateHash());
		}
		MonitorStateExit(GetCurrentStateHash(), delegate
		{
			if (debugEvents)
			{
				Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.PlaySFXOnStateExit > PLAY sfxPath=" + sfxPath);
			}
			audioEmitter.PlayAndStoreEvent(sfxPath, true);
		}, oneShot: true);
	}

	private void StopSFX(string sfxPath)
	{
		if (debugEvents)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.StopSFX sfxPath=" + sfxPath);
		}
		if (audioEmitter != null)
		{
			audioEmitter.StopStoredEvents(sfxPath);
		}
		else
		{
			Diagnostics.LogError(base.name + " > SpriteAnimationRuntime2.StopSFX: No audio emitter to stop the " + sfxPath + " SFX!");
		}
	}

	public void MonitorAnimEvent(StaticString eventName, AnimEventHandler onAnimEvent)
	{
		if (debug)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.MonitorAnimEvent eventName=" + eventName);
		}
		if (animEventMonitors == null)
		{
			animEventMonitors = new Dictionary<StaticString, AnimEventHandler>();
		}
		if (!animEventMonitors.ContainsKey(eventName))
		{
			animEventMonitors.Add(eventName, null);
		}
		Dictionary<StaticString, AnimEventHandler> dictionary;
		Dictionary<StaticString, AnimEventHandler> dictionary2 = dictionary = animEventMonitors;
		StaticString key;
		StaticString key2 = key = eventName;
		AnimEventHandler a = dictionary[key];
		dictionary2[key2] = (AnimEventHandler)Delegate.Combine(a, onAnimEvent);
	}

	public void UnmonitorAnimEvent(StaticString eventName, AnimEventHandler onAnimEvent)
	{
		if (animEventMonitors == null || !animEventMonitors.ContainsKey(eventName))
		{
			Diagnostics.LogError("No monitor set for " + eventName + " event!");
			return;
		}
		Dictionary<StaticString, AnimEventHandler> dictionary;
		Dictionary<StaticString, AnimEventHandler> dictionary2 = dictionary = animEventMonitors;
		StaticString key;
		StaticString key2 = key = eventName;
		AnimEventHandler source = dictionary[key];
		dictionary2[key2] = (AnimEventHandler)Delegate.Remove(source, onAnimEvent);
	}

	private void MonitorStateEnter(string stateName, StateEnterHandler onStateEnter)
	{
		stateName = GetMecanimInternalStateName(stateName);
		if (debug)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.MonitorStateEnter stateName=" + stateName + " (#" + Animator.StringToHash(stateName) + ")");
		}
		int num = Animator.StringToHash(stateName);
		if (stateEnterMonitors == null)
		{
			stateEnterMonitors = new Dictionary<int, StateEnterHandler>();
		}
		if (!stateEnterMonitors.ContainsKey(num))
		{
			stateEnterMonitors.Add(num, null);
		}
		Dictionary<int, StateEnterHandler> dictionary;
		Dictionary<int, StateEnterHandler> dictionary2 = dictionary = stateEnterMonitors;
		int key;
		int key2 = key = num;
		StateEnterHandler a = dictionary[key];
		dictionary2[key2] = (StateEnterHandler)Delegate.Combine(a, onStateEnter);
	}

	private void UnmonitorStateEnter(string stateName, StateEnterHandler onStateEnter)
	{
		stateName = GetMecanimInternalStateName(stateName);
		int num = Animator.StringToHash(stateName);
		if (stateEnterMonitors == null || !stateEnterMonitors.ContainsKey(num))
		{
			Diagnostics.LogError("No monitor set for " + stateName + " state start!");
			return;
		}
		Dictionary<int, StateEnterHandler> dictionary;
		Dictionary<int, StateEnterHandler> dictionary2 = dictionary = stateEnterMonitors;
		int key;
		int key2 = key = num;
		StateEnterHandler source = dictionary[key];
		dictionary2[key2] = (StateEnterHandler)Delegate.Remove(source, onStateEnter);
	}

	private void MonitorStateExit(string stateName, StateExitHandler onStateExit, bool oneShot = false)
	{
		stateName = GetMecanimInternalStateName(stateName);
		if (debug)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.MonitorStateExit stateName=" + stateName + " (#" + Animator.StringToHash(stateName) + ")");
		}
		int stateNameHash = Animator.StringToHash(stateName);
		MonitorStateExit(stateNameHash, onStateExit, oneShot);
	}

	private void MonitorStateExit(int stateNameHash, StateExitHandler onStateExit, bool oneShot = false)
	{
		Dictionary<int, StateExitHandler> dictionary = (!oneShot) ? stateExitMonitors : oneShotStateExitMonitors;
		if (dictionary == null)
		{
			dictionary = new Dictionary<int, StateExitHandler>();
		}
		if (!dictionary.ContainsKey(stateNameHash))
		{
			dictionary.Add(stateNameHash, null);
		}
		Dictionary<int, StateExitHandler> dictionary2;
		Dictionary<int, StateExitHandler> dictionary3 = dictionary2 = dictionary;
		int key;
		int key2 = key = stateNameHash;
		StateExitHandler a = dictionary2[key];
		dictionary3[key2] = (StateExitHandler)Delegate.Combine(a, onStateExit);
	}

	private void UnmonitorStateExit(string stateName, StateExitHandler onStateExit)
	{
		stateName = GetMecanimInternalStateName(stateName);
		int stateNameHash = Animator.StringToHash(stateName);
		UnmonitorStateExit(stateNameHash, onStateExit);
	}

	private void UnmonitorStateExit(int stateNameHash, StateExitHandler onStateExit)
	{
		if (stateExitMonitors == null || !stateExitMonitors.ContainsKey(stateNameHash))
		{
			Diagnostics.LogError("No monitor set for " + stateNameHash + " state end!");
			return;
		}
		Dictionary<int, StateExitHandler> dictionary;
		Dictionary<int, StateExitHandler> dictionary2 = dictionary = stateExitMonitors;
		int key;
		int key2 = key = stateNameHash;
		StateExitHandler source = dictionary[key];
		dictionary2[key2] = (StateExitHandler)Delegate.Remove(source, onStateExit);
	}

	private void Update()
	{
		if (IsPlaying && monitorStates)
		{
			int num = GetCurrentStateHash();
			if (num != currentStateHash)
			{
				OnAnimStateExit(currentStateHash);
				OnAnimStateEnter(num);
				currentStateHash = num;
			}
		}
	}

	private void OnAnimStateEnter(int stateNameHash)
	{
		if (debugStates)
		{
			Diagnostics.Log("{0} > OnStateEnter stateNameHash={1}", this.GetScenePath(), stateNameHash);
		}
		if (stateEnterMonitors != null && stateEnterMonitors.TryGetValue(stateNameHash, out StateEnterHandler value))
		{
			value?.Invoke();
		}
	}

	private void OnAnimStateExit(int stateNameHash)
	{
		if (debugStates)
		{
			Diagnostics.Log("{0} > OnStateExit stateNameHash={1}", this.GetScenePath(), stateNameHash);
		}
		StateExitHandler value = null;
		if (stateExitMonitors != null && stateExitMonitors.TryGetValue(stateNameHash, out value))
		{
			value?.Invoke();
		}
		value = null;
		if (oneShotStateExitMonitors != null && oneShotStateExitMonitors.TryGetValue(stateNameHash, out value) && value != null)
		{
			value();
			oneShotStateExitMonitors.Remove(stateNameHash);
		}
	}

	public string GetCurrentAnimDirectionSuffix()
	{
		switch (currentAnimDirection)
		{
		case SpriteAnimDir.Left:
		case SpriteAnimDir.Right:
			return _animRightDirectionSuffix;
		case SpriteAnimDir.Up:
			return _animUpDirectionSuffix;
		default:
			return _animDownDirectionSuffix;
		}
	}

	private void Awake()
	{
		tfm = base.transform;
		Animator = GetComponent<Animator>();
		if (renderers == null || renderers.Length == 0)
		{
			Diagnostics.LogWarning("{0} > SpriteAnimationRuntime2: no renderer defined", this.GetScenePath());
			renderers = GetComponentsInChildren<Renderer>();
		}
		if (audioEmitter == null)
		{
			audioEmitter = GetComponent<AudioEmitter>();
		}
	}

	private void Start()
	{
		if (monitorStates)
		{
			currentStateHash = GetCurrentStateHash();
		}
		if (!IsPlaying)
		{
			if (autoPlayOnStart)
			{
				Play();
			}
			else
			{
				Stop();
			}
		}
	}

	private int GetCurrentStateHash()
	{
		AnimatorStateInfo currentAnimatorStateInfo = Animator.GetCurrentAnimatorStateInfo(layerIndex);
		return currentAnimatorStateInfo.GetNameHash();
	}

	public void OverrideClipsFromPath(string clipsPath, bool restoreOriginalControllerFirst = false)
	{
		if (debug)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.OverrideClipsFromPath clipsPath=" + clipsPath);
		}
		if (Animator == null)
		{
			Animator = GetComponent<Animator>();
		}
		if (restoreOriginalControllerFirst)
		{
			RestoreOriginalController();
		}
		if (animOverrideControllersCache == null)
		{
			animOverrideControllersCache = new Dictionary<StaticString, Dictionary<RuntimeAnimatorController, AnimatorOverrideController>>();
		}
		StaticString key = new StaticString(clipsPath);
		Dictionary<RuntimeAnimatorController, AnimatorOverrideController> value = null;
		if (!animOverrideControllersCache.TryGetValue(key, out value))
		{
			value = new Dictionary<RuntimeAnimatorController, AnimatorOverrideController>();
			animOverrideControllersCache.Add(key, value);
		}
		AnimatorOverrideController value2 = null;
		if (!value.TryGetValue(Animator.runtimeAnimatorController, out value2))
		{
			UnityEngine.Object[] array = Resources.LoadAll(clipsPath, typeof(AnimationClip));
			value2 = new AnimatorOverrideController();
			value2.runtimeAnimatorController = Animator.runtimeAnimatorController;
			UnityEngine.Object[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				AnimationClip animationClip = (AnimationClip)array2[i];
				if (debug)
				{
					Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.OverrideClipsFromPath clip=" + animationClip.name);
				}
				if (debug)
				{
					Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.OverrideClipsFromPath override for clip.name=" + animationClip.name);
				}
				value2[animationClip.name] = animationClip;
				if (animationClip.name.Contains("_AllDirs"))
				{
					string text = animationClip.name.Replace("_AllDirs", "_Down");
					if (debug)
					{
						Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.OverrideClipsFromPath override for clipName=" + text);
					}
					value2[text] = animationClip;
					text = animationClip.name.Replace("_AllDirs", "_Up");
					if (debug)
					{
						Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.OverrideClipsFromPath override for clipName=" + text);
					}
					value2[text] = animationClip;
					text = animationClip.name.Replace("_AllDirs", "_Right");
					if (debug)
					{
						Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.OverrideClipsFromPath override for clipName=" + text);
					}
					value2[text] = animationClip;
				}
			}
			value.Add(Animator.runtimeAnimatorController, value2);
		}
		if (originalController == null)
		{
			originalController = Animator.runtimeAnimatorController;
		}
		Animator.runtimeAnimatorController = value2;
	}

	public void OverrideClip(string clipName, AnimationClip clip, bool restoreOriginalControllerFirst = false)
	{
		if (debug)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.OverrideClip clipName=" + clipName + " clip=" + clip);
		}
		if (restoreOriginalControllerFirst)
		{
			RestoreOriginalController();
		}
		AnimatorOverrideController animatorOverrideController = new AnimatorOverrideController();
		if (Animator == null)
		{
			Animator = GetComponent<Animator>();
		}
		animatorOverrideController.runtimeAnimatorController = Animator.runtimeAnimatorController;
		animatorOverrideController[clipName] = clip;
		if (originalController == null)
		{
			originalController = Animator.runtimeAnimatorController;
		}
		Animator.runtimeAnimatorController = animatorOverrideController;
	}

	public void RestoreOriginalController()
	{
		if (originalController != null)
		{
			Animator.runtimeAnimatorController = originalController;
		}
	}

	public void SetAnimDirection(Vector3 direction)
	{
		if (debug)
		{
		}
		if (direction.sqrMagnitude <= 0f)
		{
			return;
		}
		Dungeon x = SingletonManager.Get<Dungeon>();
		if (x != null)
		{
			direction = direction.DivideBy(SingletonManager.Get<Dungeon>().ContainerScale);
		}
		SpriteAnimDir spriteAnimDir = currentAnimDirection;
		float num = Mathf.Abs(direction.x);
		float num2 = Mathf.Abs(direction.z);
		bool flag = false;
		flag = ((num > num2) ? (((currentAnimDirection == SpriteAnimDir.Up || currentAnimDirection == SpriteAnimDir.Down) && num < 1.1f * num2) ? true : false) : (((currentAnimDirection != SpriteAnimDir.Left && currentAnimDirection != SpriteAnimDir.Right) || !(num2 < 1.1f * num)) ? true : false));
		spriteAnimDir = ((!flag) ? ((!(direction.x > 0f)) ? SpriteAnimDir.Right : SpriteAnimDir.Left) : ((!(direction.z > 0f)) ? SpriteAnimDir.Up : SpriteAnimDir.Down));
		if (debug)
		{
		}
		if (spriteAnimDir != currentAnimDirection)
		{
			currentAnimDirection = spriteAnimDir;
			switch (currentAnimDirection)
			{
			case SpriteAnimDir.Down:
				SetFloat(SpriteAnimationFloat.Direction, 0f);
				break;
			case SpriteAnimDir.Up:
				SetFloat(SpriteAnimationFloat.Direction, 1f);
				break;
			case SpriteAnimDir.Left:
			case SpriteAnimDir.Right:
				SetFloat(SpriteAnimationFloat.Direction, 2f);
				break;
			}
		}
	}

	public void Stop(bool disableRenderers = true)
	{
		if (debug)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.Stop");
		}
		if (Animator == null)
		{
			Animator = GetComponent<Animator>();
		}
		Animator.speed = 0f;
		Animator.enabled = false;
		IsPlaying = false;
		if (disableRenderers)
		{
			Hide();
		}
	}

	public void Play(bool forceShow = true)
	{
		if (debug)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.Play");
		}
		if (Animator == null)
		{
			Animator = GetComponent<Animator>();
		}
		Animator.enabled = true;
		Animator.speed = 1f;
		IsPlaying = true;
		if (forceShow)
		{
			Show();
		}
	}

	public void Hide()
	{
		if (debug)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.Hide");
		}
		if (renderers == null)
		{
			return;
		}
		for (int i = 0; i < renderers.Length; i++)
		{
			Renderer renderer = renderers[i];
			if (renderer != null)
			{
				renderer.enabled = false;
			}
		}
	}

	public void Show()
	{
		if (debug)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.Show");
		}
		for (int i = 0; i < renderers.Length; i++)
		{
			Renderer renderer = renderers[i];
			if (renderer != null)
			{
				renderer.enabled = true;
			}
		}
	}

	public void SetSpeed(float speed, string resetStateName = null)
	{
		if (debug)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.SetSpeed speed=" + speed + " resetStateName=" + resetStateName);
		}
		if (Animator.speed != speed)
		{
			Animator.speed = speed;
			if (resetStateName != null)
			{
				speedResetStateName = resetStateName;
				MonitorStateExit(speedResetStateName, OnSpeedResetStateExit, oneShot: true);
			}
		}
	}

	private void OnSpeedResetStateExit()
	{
		SetSpeed(1f);
	}

	public void Trigger(SpriteAnimationTrigger trigger, bool autoPlayIfStopped = true, bool forceShow = true)
	{
		if (debug)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.Trigger trigger=" + trigger.ToString());
		}
		if (autoPlayIfStopped && !IsPlaying)
		{
			Play(forceShow);
		}
		else if (forceShow)
		{
			Show();
		}
		Animator.SetTrigger(trigger.ToString());
		if (triggers == null)
		{
			triggers = new List<SpriteAnimationTrigger>();
		}
		if (!triggers.Contains(trigger))
		{
			triggers.Add(trigger);
		}
	}

	public void ResetTrigger(SpriteAnimationTrigger trigger)
	{
		if (debug)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.ResetTrigger trigger=" + trigger.ToString());
		}
		Animator.ResetTrigger(trigger.ToString());
	}

	public void ResetAllTriggers()
	{
		if (debug)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.ResetAllTriggers");
		}
		if (triggers != null)
		{
			for (int i = 0; i < triggers.Count; i++)
			{
				ResetTrigger(triggers[i]);
			}
		}
	}

	public void SetFloat(SpriteAnimationFloat name, float value)
	{
		if (debug)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.SetFloat name=" + name + " value=" + value);
		}
		Animator.SetFloat(name.ToString(), value);
	}

	public void SetBool(SpriteAnimationBool name, bool value)
	{
		if (debug)
		{
			Diagnostics.Log(this.GetScenePath() + " > SpriteAnimationRuntime2.SetBool name=" + name + " value=" + value);
		}
		Animator.SetBool(name.ToString(), value);
	}

	public float GetAnimLength(string animName)
	{
		AnimatorOverrideController animatorOverrideController = (AnimatorOverrideController)Animator.runtimeAnimatorController;
		AnimationClip animationClip = animatorOverrideController[animName];
		if (animationClip == null)
		{
			return -1f;
		}
		return animationClip.length;
	}

	private string GetMecanimInternalStateName(string stateName)
	{
		return "Base Layer." + stateName;
	}

	private void LateUpdate()
	{
		if (ignoreScale)
		{
			return;
		}
		if (currentAnimDirection == SpriteAnimDir.Left)
		{
			Vector3 localScale = tfm.localScale;
			if (localScale.x > 0f)
			{
				Transform transform = tfm;
				Vector3 localScale2 = transform.localScale;
				Vector3 localScale3 = tfm.localScale;
				transform.localScale = localScale2 - 2f * Mathf.Abs(localScale3.x) * Vector3.right;
			}
		}
		else
		{
			Vector3 localScale4 = tfm.localScale;
			if (localScale4.x < 0f)
			{
				Transform transform2 = tfm;
				Vector3 localScale5 = transform2.localScale;
				Vector3 localScale6 = tfm.localScale;
				transform2.localScale = localScale5 + 2f * Mathf.Abs(localScale6.x) * Vector3.right;
			}
		}
	}

	private void OnDestroy()
	{
		OnAnimStateExit(GetCurrentStateHash());
	}
}
public enum SpriteAnimationTrigger
{
	OnDeath,
	OnAttack,
	OnLevelUp,
	OnRespawn,
	OnMultiDoor,
	OnIdle,
	OnOperateBonus,
	OnOperate,
	OnRepair,
	OnLoot,
	OnKamikaze,
	OnLevelUpDone,
	OnAppear,
	OnActivation,
	OnDeactivation,
	OnOpen,
	OnClose,
	OnUsage,
	OnDisappear,
	OnUnplug,
	OnPlug,
	OnInteraction,
	OnInteractionStart,
	OnInteractionEnd,
	OnSalute,
	OnTeleportOut,
	OnTeleportIn,
	OnRandom,
	OnLocked,
	OnUnlocked,
	OnNotDiscovered,
	OnSelected,
	OnGatheringStart,
	OnGatheringStop,
	OnGathered,
	OnConfirm,
	OnSelect,
	OnUnselect
}
public enum SpriteAnimationFloat
{
	Direction,
	DoorBonus,
	FIDSType
}
public enum SpriteAnimationBool
{
	IsMoving,
	IsActionning,
	IsPowered,
	IsOccupiedByHeroes,
	HasModules,
	IsSelected,
	NextOrPrevious
}
public class SpriteAnimationTest : MonoBehaviour
{
	private SpriteAnimationRuntime2 anim;

	private void Awake()
	{
		anim = GetComponent<SpriteAnimationRuntime2>();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			Diagnostics.Log("TEST1");
			anim.SetFloat(SpriteAnimationFloat.Direction, 0f);
			anim.Trigger(SpriteAnimationTrigger.OnAttack);
		}
		if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			Diagnostics.Log("TEST2");
			anim.SetFloat(SpriteAnimationFloat.Direction, 1f);
			anim.Trigger(SpriteAnimationTrigger.OnAttack);
		}
		if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			Diagnostics.Log("TEST3");
			anim.SetFloat(SpriteAnimationFloat.Direction, 2f);
			anim.Trigger(SpriteAnimationTrigger.OnAttack);
		}
	}
}
[RequireComponent(typeof(Renderer))]
public class SpriteController : MonoBehaviour
{
	[SerializeField]
	private int tileWidth = 32;

	[SerializeField]
	private int tileHeight = 32;

	[SerializeField]
	private int tileX;

	[SerializeField]
	private int tileY;

	[SerializeField]
	private bool flipX;

	[SerializeField]
	private bool setOnAwake = true;

	[SerializeField]
	private bool updateScaleToTile;

	public int TileX
	{
		get
		{
			return tileX;
		}
		set
		{
			tileX = value;
		}
	}

	public int TileY
	{
		get
		{
			return tileY;
		}
		set
		{
			tileY = value;
		}
	}

	public void SetTileSize(int width, int height)
	{
		tileWidth = width;
		tileHeight = height;
		if (updateScaleToTile)
		{
			base.transform.localScale = new Vector3(tileWidth, tileHeight, 1f);
		}
	}

	[ContextMenu("SetSpriteTile")]
	public void SetSpriteTile()
	{
		if (GetComponent<Renderer>().sharedMaterial == null)
		{
			Diagnostics.LogError("No material assigned to the sprite container!");
			return;
		}
		if (GetComponent<Renderer>().sharedMaterial.mainTexture == null)
		{
			Diagnostics.LogError("Invalid texture for " + GetComponent<Renderer>().sharedMaterial.name + " material on " + base.gameObject.name + " game object");
			return;
		}
		float num = (float)tileWidth / (float)GetComponent<Renderer>().sharedMaterial.mainTexture.width;
		float num2 = (float)tileHeight / (float)GetComponent<Renderer>().sharedMaterial.mainTexture.height;
		float num3 = (float)tileX * num;
		float num4 = (float)tileY * num2;
		MeshFilter component = GetComponent<MeshFilter>();
		if (component.mesh.vertexCount != 4)
		{
			component.mesh = (Mesh)Resources.Load("Models/Quad", typeof(Mesh));
		}
		component.mesh.uv = new Vector2[4]
		{
			new Vector2(num3, num4),
			new Vector2(num3 + num, num4),
			new Vector2(num3, num4 + num2),
			new Vector2(num3 + num, num4 + num2)
		};
		if (flipX)
		{
			Vector3 localScale = base.transform.localScale;
			if (localScale.x > 0f)
			{
				Transform transform = base.transform;
				Vector3 localScale2 = transform.localScale;
				Vector3 localScale3 = base.transform.localScale;
				float num5 = 0f - Mathf.Abs(localScale3.x);
				Vector3 localScale4 = base.transform.localScale;
				transform.localScale = localScale2 + (num5 - localScale4.x) * Vector3.right;
				return;
			}
		}
		if (!flipX)
		{
			Vector3 localScale5 = base.transform.localScale;
			if (localScale5.x < 0f)
			{
				Transform transform2 = base.transform;
				Vector3 localScale6 = transform2.localScale;
				Vector3 localScale7 = base.transform.localScale;
				float num6 = Mathf.Abs(localScale7.x);
				Vector3 localScale8 = base.transform.localScale;
				transform2.localScale = localScale6 + (num6 - localScale8.x) * Vector3.right;
			}
		}
	}

	public void SetSpriteTile(int tileX, int tileY, bool flipX)
	{
		this.tileX = tileX;
		this.tileY = tileY;
		this.flipX = flipX;
		SetSpriteTile();
	}

	private void Awake()
	{
		if (setOnAwake)
		{
			SetSpriteTile();
		}
	}
}
public class SpriteController2 : MonoBehaviour
{
	[SerializeField]
	private Sprite spriteData;

	[SerializeField]
	private Vector2 spriteOffset;

	[SerializeField]
	private Rect textureZone;
}
public class SpriteVariance : MonoBehaviour
{
	[SerializeField]
	private GameObject[] spriteVariants;

	[SerializeField]
	private GameObject spriteContainer;

	public void Init(int spriteIndex)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(spriteVariants[spriteIndex % spriteVariants.Length]);
		gameObject.transform.parent = spriteContainer.transform;
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.transform.localRotation = Quaternion.identity;
	}
}
public class SubVfxController : MonoBehaviour
{
	protected enum ActionType
	{
		Nothing,
		Play,
		Stop
	}

	[SerializeField]
	protected bool applyOnChildren;

	[SerializeField]
	protected ActionType onStart;

	[SerializeField]
	protected ParticleSystem[] particleSystems;

	public void Play()
	{
		for (int i = 0; i < particleSystems.Length; i++)
		{
			Diagnostics.Assert(particleSystems[i] != null);
			particleSystems[i].Play(applyOnChildren);
		}
	}

	public void Stop()
	{
		for (int i = 0; i < particleSystems.Length; i++)
		{
			Diagnostics.Assert(particleSystems[i] != null);
			particleSystems[i].Stop(applyOnChildren);
		}
	}

	private void Start()
	{
		switch (onStart)
		{
		case ActionType.Nothing:
			break;
		case ActionType.Play:
			Play();
			break;
		case ActionType.Stop:
			Stop();
			break;
		}
	}
}
[RequireComponent(typeof(SpriteController))]
public class TextureVariance : MonoBehaviour
{
	[SerializeField]
	private int xVarCount = 1;

	[SerializeField]
	private int yVarCount = 1;

	[SerializeField]
	private bool applyRandomVarOnStart;

	[SerializeField]
	private bool applyVarOnStart;

	public int XVarianceCount
	{
		get
		{
			return xVarCount;
		}
		set
		{
			xVarCount = value;
		}
	}

	public int YVarianceCount
	{
		get
		{
			return yVarCount;
		}
		set
		{
			yVarCount = value;
		}
	}

	public int YVarIndex
	{
		get
		{
			SpriteController component = GetComponent<SpriteController>();
			return component.TileY;
		}
		set
		{
			SpriteController component = GetComponent<SpriteController>();
			component.TileY = value;
		}
	}

	[ContextMenu("ApplyRandomVariance")]
	public void ApplyRandomVariance()
	{
		ApplyRandomVariance(randomizeX: true, randomizeY: true);
	}

	[ContextMenu("ApplyRandomXVariance")]
	public void ApplyRandomXVariance()
	{
		ApplyRandomVariance(randomizeX: true, randomizeY: false);
	}

	[ContextMenu("ApplyRandomYVariance")]
	public void ApplyRandomYVariance()
	{
		ApplyRandomVariance(randomizeX: false, randomizeY: true);
	}

	public void ApplyRandomVariance(bool randomizeX, bool randomizeY)
	{
		SpriteController component = GetComponent<SpriteController>();
		if (randomizeX)
		{
			component.TileX = RandomGenerator.RangeInt(0, xVarCount);
		}
		if (randomizeY)
		{
			component.TileY = RandomGenerator.RangeInt(0, yVarCount);
		}
		ApplyVariance();
	}

	public void ApplyVariance(int forcedXVarIndex, int forcedYVarIndex)
	{
		SpriteController component = GetComponent<SpriteController>();
		component.TileX = forcedXVarIndex;
		component.TileY = forcedYVarIndex;
		ApplyVariance();
	}

	public void ApplyVariance()
	{
		SpriteController component = GetComponent<SpriteController>();
		component.SetSpriteTile();
	}

	private void AssertQuadMesh()
	{
		MeshFilter component = GetComponent<MeshFilter>();
		if (component.mesh.vertexCount != 4)
		{
			component.mesh = (Mesh)Resources.Load("Models/Quad", typeof(Mesh));
			ApplyVariance();
		}
	}

	private void Awake()
	{
		AssertQuadMesh();
	}

	private void Start()
	{
		if (applyRandomVarOnStart)
		{
			ApplyRandomVariance();
		}
		else if (applyVarOnStart)
		{
			ApplyVariance();
		}
	}
}
public class VFXOptimizer : MonoBehaviour
{
	private const string HIDDEN_LAYER_NAME = "MobRepulsiveCollider";

	[SerializeField]
	private bool isMandatory;

	private int originalLayer = -1;

	private GameObject go;

	private bool isVisible;

	private bool isHidden;

	private Transform tfm;

	private Camera gameCamera;

	private VFXOptimizerManager manager;

	private int hiddenLayer;

	private void Awake()
	{
		go = base.gameObject;
		tfm = base.transform;
		originalLayer = go.layer;
		manager = SingletonManager.Get<VFXOptimizerManager>();
		hiddenLayer = LayerMask.NameToLayer("MobRepulsiveCollider");
		IGameCameraService service = Services.GetService<IGameCameraService>();
		gameCamera = service.GameCamera;
		manager.RegisterVFX(this);
	}

	public void CheckVisibility()
	{
		bool flag = go.activeInHierarchy;
		if (flag)
		{
			Vector3 vector = gameCamera.WorldToScreenPoint(tfm.position);
			flag = (vector.x >= 0f && vector.x <= (float)gameCamera.pixelWidth && vector.y >= 0f && vector.y <= (float)gameCamera.pixelHeight);
		}
		if (!isVisible && flag)
		{
			OnVisible();
		}
		else if (isVisible && !flag)
		{
			OnInvisible();
		}
	}

	private void OnVisible()
	{
		SetIsVisible(isVisible: true);
		int visibleShownVFXCount = manager.VisibleShownVFXCount;
		int maxVisibleVFXCount = manager.MaxVisibleVFXCount;
		if (!isHidden && visibleShownVFXCount >= maxVisibleVFXCount && !isMandatory)
		{
			Hide();
		}
		else if (isHidden && visibleShownVFXCount < maxVisibleVFXCount)
		{
			Show();
		}
	}

	private void OnInvisible()
	{
		SetIsVisible(isVisible: false);
	}

	private void Show()
	{
		if (!isHidden)
		{
			Diagnostics.LogWarning("{0} > VFXOptimizer.Show: not hidden!", base.transform.GetScenePath());
			return;
		}
		if (originalLayer < 0)
		{
			Diagnostics.LogError("{0} > VFXOptimizer.Show: original layer never saved!", base.transform.GetScenePath());
			return;
		}
		go.SetLayerRecursively(originalLayer);
		SetIsHidden(isHidden: false);
	}

	private void Hide()
	{
		if (isHidden)
		{
			Diagnostics.LogWarning("{0} > VFXOptimizer.Hide: already hidden!", base.transform.GetScenePath());
			return;
		}
		go.SetLayerRecursively(hiddenLayer);
		SetIsHidden(isHidden: true);
	}

	private void SetIsVisible(bool isVisible)
	{
		SetFlags(isVisible, isHidden);
	}

	private void SetIsHidden(bool isHidden)
	{
		SetFlags(isVisible, isHidden);
	}

	private void SetFlags(bool isVisible, bool isHidden)
	{
		bool flag = this.isVisible && !this.isHidden;
		this.isVisible = isVisible;
		this.isHidden = isHidden;
		bool flag2 = this.isVisible && !this.isHidden;
		if (flag2 && !flag)
		{
			manager.VisibleShownVFXCount++;
		}
		else if (!flag2 && flag)
		{
			manager.VisibleShownVFXCount--;
		}
	}

	private void OnDestroy()
	{
		if (isVisible && !isHidden)
		{
			manager.VisibleShownVFXCount--;
		}
		manager.UnregisterVFX(this);
	}
}
public class VFXOptimizerManager : MonoBehaviour
{
	[SerializeField]
	private int maxVisibleVFXCount;

	[SerializeField]
	private float visibilityCheckPeriod;

	private List<VFXOptimizer> vfxs = new List<VFXOptimizer>();

	public int MaxVisibleVFXCount => maxVisibleVFXCount;

	public int VisibleShownVFXCount
	{
		get;
		set;
	}

	private void Start()
	{
		InvokeRepeating("CheckVFXsVisibility", visibilityCheckPeriod, visibilityCheckPeriod);
	}

	public void RegisterVFX(VFXOptimizer vfx)
	{
		vfxs.Add(vfx);
	}

	public void UnregisterVFX(VFXOptimizer vfx)
	{
		vfxs.Remove(vfx);
	}

	private void CheckVFXsVisibility()
	{
		for (int i = 0; i < vfxs.Count; i++)
		{
			VFXOptimizer vFXOptimizer = vfxs[i];
			vFXOptimizer.CheckVisibility();
		}
	}
}
public class AgeControlToggleInput : AgeControlToggle
{
	private IInputService inputService;

	public override bool Hovered
	{
		get
		{
			if (inputService == null)
			{
				inputService = Services.GetService<IInputService>();
			}
			return inputService.CurrentControlScheme != ControlScheme.XBoxOneController && base.Hovered;
		}
		protected set
		{
			if (inputService == null)
			{
				inputService = Services.GetService<IInputService>();
			}
			if (inputService.CurrentControlScheme != ControlScheme.XBoxOneController)
			{
				base.Hovered = value;
			}
		}
	}
}
public class ChatManager : MonoBehaviour
{
	public const string PlayerChatMessagePrefix = "PC:/";

	public const string LocalMessagePrefix = "LM:/";

	public const string TalkingHeroCategoryPrefix = "HCAT:/";

	public const string TalkingHeroIDPrefix = "HID:/";

	public const string PlayerColor = "#BBBBBB#";

	public const string OthersColor = "#FFFFFF#";

	public const string NotificationColor = "#FFB43F#";

	public const int MaxLines = 50;

	public const int MaxHistory = 20;

	public const float ChatBubbleDuration = 6f;

	public static string[] MessageSeparators = new string[2]
	{
		"HCAT:/",
		"HID:/"
	};

	private List<string> chatLines = new List<string>();

	private ReadOnlyCollection<string> chatLinesReadOnly;

	private MainGameScreen mainGameScreen;

	private EndLevelPanel endLevelPanel;

	private GameNetworkManager gameNetManager;

	private IAudioEventService audioEventService;

	private Session session;

	private Lift lift;

	private StoryDialogPanel storyDialogPanel;

	public ReadOnlyCollection<string> ChatLines
	{
		get
		{
			if (chatLinesReadOnly == null)
			{
				chatLinesReadOnly = chatLines.AsReadOnly();
			}
			return chatLinesReadOnly;
		}
	}

	private Session Session
	{
		get
		{
			return session;
		}
		set
		{
			if (session != null)
			{
				session.LobbyChatMessage -= Session_LobbyChatMessage;
			}
			session = value;
			if (session != null)
			{
				session.LobbyChatMessage += Session_LobbyChatMessage;
			}
		}
	}

	public event EventHandler OnNewChatMessage;

	public void SendChatMessage(string message)
	{
		if (Session == null)
		{
			return;
		}
		if (mainGameScreen == null)
		{
			mainGameScreen = SingletonManager.Get<MainGameScreen>();
		}
		if (endLevelPanel == null)
		{
			endLevelPanel = SingletonManager.Get<EndLevelPanel>();
		}
		string text = string.Empty;
		int num = -1;
		if (((mainGameScreen != null && mainGameScreen.IsVisible) || (endLevelPanel != null && endLevelPanel.IsVisible)) && Hero.SelectedHeroes.Count > 0)
		{
			Hero hero = Hero.SelectedHeroes[0];
			if (hero != null)
			{
				text = hero.UniqueID.GetCategory();
				num = hero.UniqueID.ID;
			}
		}
		message = "PC:/" + message + "HCAT:/" + text + "HID:/" + num;
		Session.SendLobbyChatMessage(message);
	}

	public void WriteLocalMessage(string message)
	{
		if (Session != null)
		{
			Session.SendLocalChatMessage("LM:/" + message);
		}
	}

	public void ClearHistory()
	{
		chatLines.Clear();
	}

	protected IEnumerator Start()
	{
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
		while (Services.GetService<ISessionService>() == null)
		{
			yield return null;
		}
		Services.GetService<ISessionService>().SessionChange += SessionManager_SessionChange;
		while (Services.GetService<IAudioEventService>() == null)
		{
			yield return null;
		}
		audioEventService = Services.GetService<IAudioEventService>();
		yield return null;
	}

	private void SessionManager_SessionChange(object sender, SessionChangeEventArgs e)
	{
		Session = (e.Session as Session);
	}

	private void Session_LobbyChatMessage(object sender, LobbyChatMessageEventArgs e)
	{
		OnChatMessageReceived(e.Message, (!(e.SteamIDUser != null)) ? 0 : e.SteamIDUser.UInt64AccountID);
	}

	private void OnChatMessageReceived(string message, ulong playerID)
	{
		if (Session == null)
		{
			return;
		}
		if (mainGameScreen == null)
		{
			mainGameScreen = SingletonManager.Get<MainGameScreen>();
		}
		if (endLevelPanel == null)
		{
			endLevelPanel = SingletonManager.Get<EndLevelPanel>();
		}
		if (message.StartsWith("PC:/"))
		{
			message = message.Substring("PC:/".Length);
			string[] array = message.Split(MessageSeparators, StringSplitOptions.None);
			if (array.Length != MessageSeparators.Length + 1)
			{
				Diagnostics.LogError("The chat message {0} doesn't have {1} parts", message, MessageSeparators.Length + 1);
				return;
			}
			string text = array[0];
			string talkingHeroCategory = array[1];
			int result = -1;
			int.TryParse(array[2], out result);
			if (Session.UserID == playerID)
			{
				AddChatLine("#BBBBBB#" + gameNetManager.GetPlayerName(playerID) + " > " + text + "#REVERT#");
			}
			else
			{
				AddChatLine("#FFFFFF#" + gameNetManager.GetPlayerName(playerID) + " > " + text + "#REVERT#");
			}
			if (result >= 0)
			{
				DisplayHeroBubble(text, talkingHeroCategory, result, playerID);
			}
			audioEventService.Play2DEvent("Master/GUI/Chat");
		}
		else
		{
			if (!message.StartsWith("LM:/"))
			{
				return;
			}
			AddChatLine("#FFB43F#" + message.Substring("LM:/".Length) + "#REVERT#");
		}
		if (this.OnNewChatMessage != null)
		{
			this.OnNewChatMessage(this, new EventArgs());
		}
	}

	private void AddChatLine(string message)
	{
		if (chatLines.Count >= 50)
		{
			chatLines.RemoveAt(0);
		}
		chatLines.Add(message);
	}

	private void DisplayHeroBubble(string message, string talkingHeroCategory, int talkingHeroID, ulong playerID = 0)
	{
		if (!endLevelPanel.IsVisible)
		{
			List<Hero> allPlayersActiveRecruitedHeroes = Hero.GetAllPlayersActiveRecruitedHeroes();
			int num = 0;
			while (true)
			{
				if (num < allPlayersActiveRecruitedHeroes.Count)
				{
					if (allPlayersActiveRecruitedHeroes[num] != null && allPlayersActiveRecruitedHeroes[num].UniqueID.GetCategory() == talkingHeroCategory && allPlayersActiveRecruitedHeroes[num].UniqueID.ID == talkingHeroID)
					{
						break;
					}
					num++;
					continue;
				}
				return;
			}
			allPlayersActiveRecruitedHeroes[num].DisplayDialogPanel(message, 6f);
		}
		else
		{
			if (lift == null)
			{
				lift = SingletonManager.Get<Lift>();
			}
			if (storyDialogPanel == null)
			{
				storyDialogPanel = SingletonManager.Get<StoryDialogPanel>();
			}
			LiftHero liftHero = lift.LiftHeroes.FirstOrDefault((LiftHero hero) => hero.OwnerPlayerId == playerID && hero.SpriteAnimation.GetComponent<Renderer>().enabled);
			if (liftHero != null)
			{
				storyDialogPanel.Display(message, liftHero.transform, lift.LiftCamera, 6f);
			}
		}
	}
}
public class DLCIcon : MonoBehaviour
{
	[SerializeField]
	private AgeTooltip tooltip;

	[SerializeField]
	private AgePrimitiveImage img;

	[SerializeField]
	private Color unavailableColor;

	public void Init(DLC dlc)
	{
		IGuiService service = Services.GetService<IGuiService>();
		if (service.GuiPanelHelper.TryGetGuiElement(dlc.Name, out GuiElement guiElement))
		{
			tooltip.Content = AgeLocalizer.Instance.LocalizeString(guiElement.Description);
			if (service.GuiPanelHelper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Small, out Texture2D texture))
			{
				img.Image = texture;
			}
		}
		if (!dlc.IsAvailable())
		{
			img.TintColor = unavailableColor;
		}
	}
}
public class DungeonStatisticsElement : MonoBehaviour
{
	[SerializeField]
	private AgePrimitiveLabel statisticsTitle;

	[SerializeField]
	private AgePrimitiveLabel statisticsValue;

	public void SetContent(StaticString statName, float value)
	{
		IGuiService service = Services.GetService<IGuiService>();
		Diagnostics.Assert(service != null);
		IGuiPanelHelper guiPanelHelper = service.GuiPanelHelper;
		Diagnostics.Assert(guiPanelHelper != null);
		GuiElement guiElement = null;
		guiPanelHelper.TryGetGuiElement(statName, out guiElement);
		Diagnostics.Assert(guiElement != null);
		statisticsTitle.Text = guiElement.Title;
		if (string.IsNullOrEmpty(guiElement.Description))
		{
			statisticsValue.Text = GenericUtilities.RoundHalfAwayFromZeroToInt(value).ToString();
			return;
		}
		string text = AgeLocalizer.Instance.LocalizeString(guiElement.Description);
		if (text.Contains("$Value"))
		{
			statisticsValue.Text = text.Replace("$Value", GenericUtilities.RoundHalfAwayFromZeroToInt(value).ToString());
		}
		else if (guiElement.Description.StartsWith("FORMAT/TIME"))
		{
			statisticsValue.Text = $"{TimeSpan.FromSeconds(GenericUtilities.RoundHalfAwayFromZeroToInt(value)):HH:mm:ss}";
		}
	}
}
public class DynamicTextureLoader : MonoBehaviour
{
	[SerializeField]
	private string texturePath;

	[SerializeField]
	private bool autoLoadOnVisible;

	private AgeTransform ageTfm;

	private AgePrimitiveImage img;

	private bool isLoaded;

	private void Awake()
	{
		ageTfm = GetComponent<AgeTransform>();
		img = GetComponent<AgePrimitiveImage>();
	}

	public void Load(string texturePath = null, bool forceReload = false)
	{
		if (isLoaded && !forceReload)
		{
			Diagnostics.LogWarning("{0} > DynamicTextureAutoLoader.AutoLoad: already loaded!", this.GetScenePath());
			return;
		}
		if (string.IsNullOrEmpty(texturePath))
		{
			texturePath = this.texturePath;
		}
		img.Image = AgeManager.Instance.FindDynamicTexture(texturePath);
		if (img.Image == null)
		{
			img.Image = GuiManager.GetTransparentTexture();
		}
		isLoaded = true;
	}

	private void Update()
	{
		if (autoLoadOnVisible && !isLoaded && ageTfm.IsGloballyVisible())
		{
			Load();
			ageTfm.Visible = false;
			ageTfm.Visible = true;
		}
	}
}
public class FullscreenSetter : MonoBehaviour
{
	[SerializeField]
	private bool fullscreen;

	private void Awake()
	{
		Screen.fullScreen = fullscreen;
	}
}
public class GUIComparingLabel : AgePrimitiveLabel
{
	[SerializeField]
	private bool reverseColor;

	private Color defaultColor;

	public new string Text
	{
		get
		{
			return base.Text;
		}
		set
		{
			SetText(value);
		}
	}

	protected override void Awake()
	{
		base.Awake();
		defaultColor = base.TintColor;
	}

	public void SetText(string text)
	{
		if (float.TryParse(text, out float result))
		{
			if (result == 0f)
			{
				text = string.Empty;
			}
			else if (result > 0f)
			{
				text = "+" + result;
				base.TintColor = ((!reverseColor) ? Color.green : Color.red);
			}
			else
			{
				base.TintColor = ((!reverseColor) ? Color.red : Color.green);
			}
		}
		else
		{
			base.TintColor = defaultColor;
		}
		base.Text = text;
	}
}
public struct GuiError : IComparable, IComparable<GuiError>
{
	public string Key;

	public string Subject;

	public GuiError(string key)
	{
		Key = key;
		Subject = string.Empty;
	}

	public GuiError(string key, string subject)
	{
		Key = key;
		Subject = subject;
	}

	public static void Add(List<GuiError> guiErrors, string key)
	{
		guiErrors?.Add(new GuiError(key));
	}

	public static void Add(List<GuiError> guiErrors, string key, string subject)
	{
		guiErrors?.Add(new GuiError(key, subject));
	}

	public static string FirstLocalizedMessage(List<GuiError> guiErrors, string suffix = null)
	{
		if (guiErrors.Count > 0)
		{
			return guiErrors[0].LocalizedMessage(suffix);
		}
		return string.Empty;
	}

	public string LocalizedMessage(string suffix = null)
	{
		string text = Key;
		if (suffix != null)
		{
			text += suffix;
		}
		if (text[0] != '%')
		{
			text = "%" + text;
		}
		string text2 = AgeLocalizer.Instance.LocalizeString(text);
		if (text2.Contains("{0}"))
		{
			return string.Format(text2, Subject);
		}
		return text2;
	}

	public int CompareTo(GuiError other)
	{
		if (Key != other.Key)
		{
			return Key.CompareTo(other.Key);
		}
		return Subject.CompareTo(other.Subject);
	}

	public int CompareTo(object obj)
	{
		return CompareTo((GuiError)obj);
	}

	public override string ToString()
	{
		return LocalizedMessage();
	}
}
public class GuiItemHeroEffectPanel : GuiPanel
{
	public AgePrimitiveLabel EffectName;

	public AgePrimitiveLabel EffectValue;

	private Dungeon dungeon;

	public SimulationProperty CurrentProperty
	{
		get;
		private set;
	}

	public void Bind(SimulationProperty property)
	{
		CurrentProperty = property;
		dungeon = SingletonManager.Get<Dungeon>();
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		float f = SimMonoBehaviour.ApplyDescModifier(CurrentProperty.Value, CurrentProperty.Name, dungeon.ShipDesc, "Dungeon/Room/Hero");
		if (CurrentProperty.Name == SimulationProperties.SellingCost)
		{
			f = Mathf.CeilToInt(f);
		}
		EffectName.Text = AgeLocalizer.Instance.LocalizeString("%" + CurrentProperty.Name + "StatTitle");
		EffectValue.Text = f.ToString();
	}
}
[Serializable]
public class GuiManager : Amplitude.Unity.Gui.GuiManager, IService, IGuiSettingsService
{
	public static readonly string ResolutionTooSmall = "HighDefinitionUI_ResolutionTooSmall";

	public static readonly int MinimumResolutionWidthForHighDefinitionUI = 1920;

	public static readonly int MinimumResolutionHeightForHighDefinitionUI = 1080;

	private readonly StaticString RegistryHighDefinitionUIKey = "Settings/GUI/HighDefinitionUI";

	public AgeRenderer BackgroundRenderer;

	public bool HighDefinitionUI
	{
		get
		{
			return AgeUtils.HighDefinition;
		}
		set
		{
			if (AgeUtils.HighDefinition != value)
			{
				value &= CanUseHighDefinitionUI();
				if (base.AgeManager != null)
				{
					base.AgeManager.SwitchHighDefinition(value);
					return;
				}
				Diagnostics.LogError("Can't switch high definition (switch: '{0}') because the age manager is null.", value);
				AgeUtils.HighDefinition = value;
			}
		}
	}

	public static Texture2D GetTransparentTexture()
	{
		return AgeManager.Instance.FindDynamicTexture("transparent");
	}

	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		while (Services.GetService<IGameResolutionService>() == null)
		{
			yield return null;
		}
		Services.AddService((IGuiSettingsService)this);
		RestoreSavedHighDefinitionUI();
	}

	public void RestoreSavedHighDefinitionUI()
	{
		if (Amplitude.Unity.Framework.Application.Registry.TryGetValue(RegistryHighDefinitionUIKey, out bool value))
		{
			HighDefinitionUI = value;
		}
		else
		{
			HighDefinitionUI = CanUseHighDefinitionUI();
		}
	}

	public void SaveCurrentGameResolution()
	{
		Amplitude.Unity.Framework.Application.Registry.SetValue(RegistryHighDefinitionUIKey, HighDefinitionUI);
	}

	public bool CanUseHighDefinitionUI(List<GuiError> guiErrors = null)
	{
		IGameResolutionService service = Services.GetService<IGameResolutionService>();
		ScreenResolution currentDisplayResolution = service.GetCurrentDisplayResolution();
		if (currentDisplayResolution.Width < MinimumResolutionWidthForHighDefinitionUI || currentDisplayResolution.Height < MinimumResolutionHeightForHighDefinitionUI)
		{
			GuiError.Add(guiErrors, ResolutionTooSmall, currentDisplayResolution.Width + "x" + currentDisplayResolution.Height);
			return false;
		}
		return true;
	}

	protected override void InitModal()
	{
		modalManager = new GuiModalManager();
		modalManager.Init(blurComponents);
		GuiModalPanel.GuiModalManager = modalManager;
	}
}
public class GuiModalManager : Amplitude.Unity.Gui.GuiModalManager
{
}
public class GuiPanel : Amplitude.Unity.Gui.GuiPanel
{
	public static class IconSize
	{
		public static StaticString Large = new StaticString("Large");

		public static StaticString Small = new StaticString("Small");

		public static StaticString Tiny = new StaticString("Tiny");
	}

	private bool needRefresh;

	private float refreshDelay;

	private float elapsedTimeSinceLastRefresh;

	protected bool NeedRefresh
	{
		get
		{
			return needRefresh;
		}
		set
		{
			if (needRefresh != value)
			{
				needRefresh = (value && base.IsVisible);
			}
		}
	}

	protected float RefreshDelay
	{
		get
		{
			return refreshDelay;
		}
		set
		{
			if (refreshDelay != value)
			{
				refreshDelay = value;
			}
		}
	}

	protected bool UseRefreshLoop
	{
		get;
		set;
	}

	public virtual void RefreshContent()
	{
	}

	protected void RefreshAtThisFrame()
	{
		NeedRefresh = true;
		elapsedTimeSinceLastRefresh = RefreshDelay + 1f;
	}

	public void ToggleVisibility(bool instantHide = false, params object[] showParameters)
	{
		if (base.IsVisible)
		{
			Hide(instantHide);
		}
		else
		{
			Show(showParameters);
		}
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		if (UseRefreshLoop)
		{
			StartCoroutine(RefreshLoop());
		}
	}

	private IEnumerator RefreshLoop()
	{
		while (base.IsVisible)
		{
			if (NeedRefresh)
			{
				elapsedTimeSinceLastRefresh += Time.realtimeSinceStartup - AgeManager.LastRealtimeSinceStartup;
				if (elapsedTimeSinceLastRefresh > RefreshDelay)
				{
					elapsedTimeSinceLastRefresh = 0f;
					NeedRefresh = false;
					RefreshContent();
				}
			}
			yield return null;
		}
	}
}
public class GuiScreen : Amplitude.Unity.Gui.GuiScreen
{
	private bool needRefresh;

	private float refreshDelay;

	private float elapsedTimeSinceLastRefresh;

	protected bool NeedRefresh
	{
		get
		{
			return needRefresh;
		}
		set
		{
			if (needRefresh != value)
			{
				needRefresh = (value && base.IsVisible);
			}
		}
	}

	protected float RefreshDelay
	{
		get
		{
			return refreshDelay;
		}
		set
		{
			if (refreshDelay != value)
			{
				refreshDelay = value;
			}
		}
	}

	protected bool UseRefreshLoop
	{
		get;
		set;
	}

	public virtual void RefreshContent()
	{
	}

	protected void RefreshAtThisFrame()
	{
		NeedRefresh = true;
		elapsedTimeSinceLastRefresh = RefreshDelay + 1f;
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		if (UseRefreshLoop)
		{
			StartCoroutine(RefreshLoop());
		}
	}

	private IEnumerator RefreshLoop()
	{
		while (base.IsVisible)
		{
			if (NeedRefresh)
			{
				elapsedTimeSinceLastRefresh += Time.realtimeSinceStartup - AgeManager.LastRealtimeSinceStartup;
				if (elapsedTimeSinceLastRefresh > RefreshDelay)
				{
					elapsedTimeSinceLastRefresh = 0f;
					NeedRefresh = false;
					RefreshContent();
				}
			}
			yield return null;
		}
	}
}
public class GuiSkillLevelLabel : AgePrimitiveLabel
{
	[SerializeField]
	private float previewRightMargin;

	private Color initialColor;

	protected override void Awake()
	{
		base.Awake();
		initialColor = base.TintColor;
	}

	public void SetText(string text, bool previewMode)
	{
		base.TintColor = ((!previewMode) ? initialColor : Color.green);
		base.Text = text;
	}
}
public class GuiTooltipManager : Amplitude.Unity.Gui.GuiTooltipManager
{
}
public interface IGuiEntity
{
	GuiElement Gui
	{
		get;
	}
}
public interface IGuiSettingsService : IService
{
	bool HighDefinitionUI
	{
		get;
		set;
	}

	bool CanUseHighDefinitionUI(List<GuiError> guiErrors = null);

	void RestoreSavedHighDefinitionUI();

	void SaveCurrentGameResolution();
}
public class InputModeHider : MonoBehaviour
{
	[SerializeField]
	private InputMode inputMode;

	private IInputService inputManager;

	private void Start()
	{
		inputManager = Services.GetService<IInputService>();
		inputManager.OnInputModeSelected += OnInputModeSelected;
	}

	private void OnInputModeSelected()
	{
		if (inputManager.GetInputMode() == inputMode)
		{
			GetComponent<AgeTransform>().Visible = false;
		}
	}
}
public class OrderedGuiElement : GuiElement
{
	[XmlElement("Order")]
	public int Order
	{
		get;
		set;
	}
}
public class ActiveSkillItem : SkillItem
{
	[SerializeField]
	private AgeModifierSector activitySector;

	[SerializeField]
	private AgeTransform cooldownBackground;

	[SerializeField]
	private AgeModifier cooldownEndModifier;

	[SerializeField]
	private AgePrimitiveLabel cooldownTurnsLeftLabel;

	[SerializeField]
	private AgeTransform controlIcon1;

	[SerializeField]
	private AgeTransform controlIcon2;

	private int index;

	private AGESelectable selectable;

	private IInputService inputService;

	protected override void Awake()
	{
		base.Awake();
		selectable = GetComponent<AGESelectable>();
		inputService = Services.GetService<IInputService>();
	}

	public void Bind(Hero hero, ActiveSkill activeSkill, int index, bool registerSelectable = false)
	{
		if (skill != null)
		{
			activeSkill.OnActivated -= OnSkillActivated;
			activeSkill.OnDeactivated -= OnSkillDeactivated;
			activeSkill.OnCooldownEnded -= OnSkillCooldownEnded;
		}
		Bind(hero, activeSkill);
		this.index = index;
		activeSkill.OnActivated += OnSkillActivated;
		activeSkill.OnDeactivated += OnSkillDeactivated;
		activeSkill.OnCooldownEnded += OnSkillCooldownEnded;
		IGameEventService service = Services.GetService<IGameEventService>();
		service.OnDungeonTurnChanged += OnDungeonTurnChanged;
		if (registerSelectable && selectable != null && !selectable.IsSelected)
		{
			selectable.Register();
		}
	}

	public override void Unbind()
	{
		ActiveSkill activeSkill = skill as ActiveSkill;
		if (activeSkill != null)
		{
			activeSkill.OnActivated -= OnSkillActivated;
			activeSkill.OnDeactivated -= OnSkillDeactivated;
			activeSkill.OnCooldownEnded -= OnSkillCooldownEnded;
		}
		base.Unbind();
		IGameEventService service = Services.GetService<IGameEventService>();
		service.OnDungeonTurnChanged -= OnDungeonTurnChanged;
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		bool flag = controlIcon1 == null || controlIcon2 == null;
		ActiveSkill activeSkill = (ActiveSkill)skill;
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		if (activeSkill.IsActivated)
		{
			if (activitySector.IsStarted())
			{
				activitySector.Reset();
			}
			activitySector.Duration = activeSkill.Config.Duration - (Time.time - activeSkill.LastActivityStartTime);
			activitySector.StartMinAngle = (Time.time - activeSkill.LastActivityStartTime) * (360f / activeSkill.Config.Duration);
			activitySector.StartAnimation();
			activitySector.AgeTransform.Visible = true;
		}
		else
		{
			activitySector.Reset();
			activitySector.AgeTransform.Visible = false;
		}
		if (!hero.HasCrystal && (activeSkill.IsActivated || dungeon.Turn >= activeSkill.LastActivityTurn + activeSkill.Config.CooldownTurnsCount))
		{
			cooldownBackground.Visible = false;
			cooldownTurnsLeftLabel.Text = string.Empty;
			GetComponent<AgeTransform>().Enable = !activeSkill.IsActivated;
		}
		else
		{
			cooldownBackground.Visible = !activeSkill.IsActivated;
			if (hero.HasCrystal)
			{
				cooldownTurnsLeftLabel.Text = string.Empty;
			}
			else
			{
				cooldownTurnsLeftLabel.Text = AgeLocalizer.Instance.LocalizeString("%SkillCooldownValueFormat").Replace("$CooldownTurnsLeftValue", activeSkill.GetRemainingTurns().ToString());
			}
			GetComponent<AgeTransform>().Enable = false;
		}
		if (flag)
		{
			GetComponent<AgeTransform>().Enable = true;
		}
		if (!flag)
		{
			IInputService service = Services.GetService<IInputService>();
			controlIcon1.Visible = (service.CurrentControlScheme == ControlScheme.XBoxOneController && index == 0);
			controlIcon2.Visible = (service.CurrentControlScheme == ControlScheme.XBoxOneController && index == 1);
		}
	}

	private void OnSkillActivated()
	{
		RefreshContent();
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			if (controlIcon1 != null)
			{
				controlIcon1.StartAllModifiers();
			}
			else
			{
				Diagnostics.LogError("{0} > ActiveSkillItem.OnSkillActivated: controlIcon1 is null!", this.GetScenePath());
			}
			if (controlIcon2 != null)
			{
				controlIcon2.StartAllModifiers();
			}
			else
			{
				Diagnostics.LogError("{0} > ActiveSkillItem.OnSkillActivated: controlIcon2 is null!", this.GetScenePath());
			}
		}
	}

	private void OnSkillDeactivated()
	{
		RefreshContent();
	}

	private void OnSkillCooldownEnded()
	{
		RefreshContent();
		if (cooldownEndModifier != null)
		{
			cooldownEndModifier.StartAnimation();
		}
		else
		{
			Diagnostics.LogError("{0} > ActiveSkillItem.OnSkillCooldownEnded: cooldownEndModifier is null!", this.GetScenePath());
		}
	}

	private void OnDungeonTurnChanged()
	{
		RefreshContent();
	}

	private void OnClick()
	{
		hero.ActivateActiveSkill(index);
		RefreshContent();
	}
}
public class AlbumPanel : PopupMenuPanel
{
	public AgeTransform previousButton;

	public AgeTransform nextButton;

	private Album album;

	private IInputService inputManager;

	protected override IEnumerator Start()
	{
		yield return StartCoroutine(base.Start());
		album = SingletonManager.Get<Album>(mandatory: false);
	}

	public void PreviousPage()
	{
		if (album != null)
		{
			album.PreviousPage();
		}
	}

	public void NextPage()
	{
		if (album != null)
		{
			album.NextPage();
		}
	}

	public void OnExitButtonCB()
	{
		Hide();
	}

	public override void Hide(bool instant = false)
	{
		base.Hide(instant);
		album.Focus(display: false);
	}

	private void Update()
	{
		if (base.AgeTransform.Visible)
		{
			if (inputManager == null)
			{
				inputManager = Services.GetService<IInputService>();
			}
			if (inputManager.GetControlDown(Control.AlbumNextPage))
			{
				NextPage();
			}
			else if (inputManager.GetControlDown(Control.AlbumPreviousPage))
			{
				PreviousPage();
			}
		}
	}
}
public class AutoCloseGuiPanel : GuiPanel
{
	protected IGameEventService gameEventManager;

	protected bool closeOnRightClick = true;

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		gameEventManager = Services.GetService<IGameEventService>();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		gameEventManager.OnInGameClickDown += OnInGameClickDown;
	}

	protected override IEnumerator OnHide(bool instant)
	{
		yield return base.OnHide(instant);
		if (gameEventManager != null)
		{
			gameEventManager.OnInGameClickDown -= OnInGameClickDown;
		}
	}

	public virtual void ClosePanel()
	{
		Hide();
	}

	private void OnInGameClickDown(MouseButton mouseButton)
	{
		if (closeOnRightClick && mouseButton == MouseButton.Right)
		{
			ClosePanel();
		}
	}
}
public class ChatPanel : GuiPanel
{
	public Transform ChatLineLabelPrefab;

	public AgeControlTextField InputTextField;

	public AgePrimitiveImage InputFrame;

	public AgeTransform ChatLineLabelsContainer;

	public AgeControlScrollView ChatLineLabelsScrollView;

	public AgePrimitiveLabel FirstTimeDescription;

	protected GameNetworkManager gameNetManager;

	protected ChatManager chatManager;

	private IInputService inputManager;

	private List<string> inputHistory = new List<string>();

	private int historyCarret;

	private AgeTransform.RefreshTableItem<string> setupChatLineDelegate;

	private bool isFocused;

	public override void RefreshContent()
	{
		ChatLineLabelsContainer.RefreshChildrenIList(chatManager.ChatLines, setupChatLineDelegate);
		ChatLineLabelsContainer.Height = 0f;
		List<AgeTransform> children = ChatLineLabelsContainer.GetChildren<AgeTransform>();
		for (int i = 0; i < children.Count; i++)
		{
			AgeTransform ageTransform = children[i];
			ageTransform.Y = ChatLineLabelsContainer.Height;
			ChatLineLabelsContainer.Height += ageTransform.Height;
		}
		ChatLineLabelsScrollView.AgeTransform.UpdateHierarchy(new Rect(base.AgeTransform.X, base.AgeTransform.Y, base.AgeTransform.Width, base.AgeTransform.Height));
		ChatLineLabelsScrollView.ResetDown();
	}

	public void Focus()
	{
		if (!isFocused && IsChatSystemAvailable() && !SingletonManager.Get<GameLoadingScreen>().IsVisible)
		{
			AgeManager.Instance.FocusedControl = InputTextField;
			InputTextField.OnValidateObject = null;
			StartCoroutine("ActivateChatAtNextFrame");
			OnFocus();
		}
	}

	public void Unfocus()
	{
		if (isFocused)
		{
			AgeManager.Instance.FocusedControl = null;
			OnUnfocus();
		}
	}

	public void OnResized()
	{
		ChatLineLabelsScrollView.AgeTransform.UpdateHierarchy(new Rect(base.AgeTransform.X, base.AgeTransform.Y, base.AgeTransform.Width, base.AgeTransform.Height));
		ChatLineLabelsScrollView.ResetDown();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		FirstTimeDescription.AgeTransform.Visible = true;
		InputTextField.ReplaceInputText(string.Empty);
		RefreshContent();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		yield return base.OnHide(instant);
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		setupChatLineDelegate = SetupChatLine;
		InputTextField.ValidChars = AgeLocalizer.Instance.LocalizeString("%ChatValidChars");
		ChatLineLabelsContainer.ReserveChildren(50, ChatLineLabelPrefab, "ChatLineLabel");
		chatManager.OnNewChatMessage += ChatManager_OnNewChatMessage;
	}

	protected override void OnUnload()
	{
		setupChatLineDelegate = null;
		base.OnUnload();
	}

	protected override IEnumerator Start()
	{
		yield return base.Start();
		inputManager = Services.GetService<IInputService>();
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
		chatManager = SingletonManager.Get<ChatManager>();
		Load();
	}

	private void ChatManager_OnNewChatMessage(object sender, EventArgs e)
	{
		if (base.IsVisible)
		{
			RefreshContent();
		}
	}

	private void SetupChatLine(AgeTransform tableItem, string chatLine, int index)
	{
		AgePrimitiveLabel component = tableItem.GetComponent<AgePrimitiveLabel>();
		if (!(component == null))
		{
			component.AgeTransform.Height = 0f;
			component.ForceText(chatLine);
		}
	}

	private void OnChatFieldValidate(GameObject caller)
	{
		if (!string.IsNullOrEmpty(InputTextField.AgePrimitiveLabel.Text))
		{
			chatManager.SendChatMessage(InputTextField.AgePrimitiveLabel.Text);
			StoreInHistory(InputTextField.AgePrimitiveLabel.Text);
			InputTextField.AgePrimitiveLabel.Text = string.Empty;
		}
		if (!Input.GetKey(KeyCode.LeftShift) && !Input.GetKey(KeyCode.RightShift) && !Input.GetKey(KeyCode.LeftControl) && !Input.GetKey(KeyCode.RightControl))
		{
			Unfocus();
		}
	}

	private void OnChatFieldGainFocus(GameObject caller)
	{
		if (inputManager != null)
		{
			OnFocus();
		}
	}

	private void OnChatFieldLoseFocus(GameObject caller)
	{
		if (inputManager != null)
		{
			OnUnfocus();
		}
	}

	private void OnFocus()
	{
		FirstTimeDescription.AgeTransform.Visible = false;
		inputManager.DisableKeyboardShortcuts();
		isFocused = true;
	}

	private void OnUnfocus()
	{
		inputManager.EnableKeyboardShortcuts();
		isFocused = false;
	}

	private void OnKeyDown()
	{
		if (!(AgeManager.Instance.FocusedControl != InputTextField))
		{
			if (Input.GetKeyDown(KeyCode.DownArrow))
			{
				OnHistoryDown();
			}
			else if (Input.GetKeyDown(KeyCode.UpArrow))
			{
				OnHistoryUp();
			}
			else if (inputManager.GetControlDown(Control.EscapeBehavior))
			{
				Unfocus();
			}
		}
	}

	private void OnHistoryDown()
	{
		if (historyCarret < inputHistory.Count - 1)
		{
			historyCarret++;
			InputTextField.ReplaceInputText(inputHistory[historyCarret]);
		}
	}

	private void OnHistoryUp()
	{
		if (historyCarret > 0)
		{
			historyCarret--;
			InputTextField.ReplaceInputText(inputHistory[historyCarret]);
		}
	}

	private void StoreInHistory(string inputText)
	{
		if (inputHistory.Count >= 20)
		{
			inputHistory.RemoveAt(0);
		}
		int num = inputHistory.FindIndex((string command) => command == inputText);
		if (num != -1)
		{
			inputHistory.RemoveAt(num);
		}
		inputHistory.Add(inputText);
		historyCarret = inputHistory.Count;
	}

	private IEnumerator ActivateChatAtNextFrame()
	{
		yield return null;
		InputTextField.OnValidateObject = base.gameObject;
	}

	protected virtual bool IsChatSystemAvailable()
	{
		return gameNetManager.IsMultiplayerSession();
	}

	public void ShowIfAvailable()
	{
		if (IsChatSystemAvailable())
		{
			Show();
		}
		else
		{
			Hide(instant: true);
		}
	}

	public override void Show(params object[] parameters)
	{
		if (IsChatSystemAvailable())
		{
			base.Show(parameters);
		}
	}
}
public class ChatPanelGameOver : ChatPanel
{
}
public class ChatPanelInGame : ChatPanel
{
	public const float ChatBubbleDuration = 6f;

	public const float MaximizedHeight = 574f;

	public const float MinimizedHeight = 120f;

	public AgeControlToggle MaximizeToggle;

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		OnSwitchMaximizeToggle();
	}

	private void OnSwitchMaximizeToggle()
	{
		if (MaximizeToggle.State)
		{
			base.AgeTransform.Height = 574f * AgeUtils.CurrentUpscaleFactor();
		}
		else
		{
			base.AgeTransform.Height = 120f * AgeUtils.CurrentUpscaleFactor();
		}
		OnResized();
	}

	private void OnApplyHighDefinition(float scale)
	{
		OnSwitchMaximizeToggle();
	}
}
public class ChatPanelLift : ChatPanel
{
}
public class ChatPanelLobby : ChatPanel
{
	protected override bool IsChatSystemAvailable()
	{
		GameSelectionPanel gameSelectionPanel = SingletonManager.Get<GameSelectionPanel>();
		if (gameSelectionPanel.IsMultiplayer)
		{
			return true;
		}
		return base.IsChatSystemAvailable();
	}
}
public class ChatPanelVictory : ChatPanel
{
}
public class CompetitorSlot : MonoBehaviour
{
	private static bool heroesMaxStatsComputed;

	private static float maxDamagesStat;

	private static float maxLifeStat;

	private static float maxSpeedStat;

	private static float maxWitStat;

	private static int pageHeroCount;

	[SerializeField]
	private AgePrimitiveImage heroPortrait;

	[SerializeField]
	private AgePrimitiveLabel playerNameLabel;

	[SerializeField]
	private AgeControlToggle playerReadyToggle;

	[SerializeField]
	private AgeTransform[] slotNumbers;

	[SerializeField]
	private AgeTransform heroStats;

	[SerializeField]
	private AgePrimitiveLabel heroNameLbl;

	[SerializeField]
	private AgePrimitiveLabel heroArchetypeLbl;

	[SerializeField]
	private AgeTransform damagesStatBar;

	[SerializeField]
	private AgeTransform lifeStatBar;

	[SerializeField]
	private AgeTransform speedStatBar;

	[SerializeField]
	private AgeTransform witStatBar;

	[SerializeField]
	private AgePrimitiveLabel recruitCountLbl;

	[SerializeField]
	private AgePrimitiveLabel deathCountLbl;

	[SerializeField]
	private AgePrimitiveLabel victoryCountLbl;

	[SerializeField]
	private AgeTransform imageAnim;

	[SerializeField]
	private AgeControlButton kickButton;

	[SerializeField]
	private AgeControlButton inviteButton;

	[SerializeField]
	private AgePrimitiveImage weaponCategoryIcon;

	[SerializeField]
	private Texture2D transparentImage;

	private GameSelectionPanel gameSelectionPanel;

	private ulong playerID = ulong.MaxValue;

	private string _playerName;

	private bool competitorIsHuman;

	private ISessionService sessionService;

	private IXboxUserService xboxUserService;

	private IXboxNetworkService xboxNetworkService;

	private StaticString heroName;

	private string playerName
	{
		get
		{
			return _playerName;
		}
		set
		{
			_playerName = value;
			if (playerNameLabel != null)
			{
				string str = XboxOneManager.FormatGamertag(_playerName, playerNameLabel.Font);
				playerNameLabel.Text = str + ((sessionService.Session.GetOwnerId() != playerID) ? string.Empty : "*");
			}
		}
	}

	public bool CompetitorIsHuman
	{
		get
		{
			return competitorIsHuman;
		}
		private set
		{
			if (value != competitorIsHuman)
			{
				competitorIsHuman = value;
			}
			if (this.OnOwnerHumanityChanged != null)
			{
				this.OnOwnerHumanityChanged(competitorIsHuman);
			}
		}
	}

	public bool CompetitorIsLocalOwner
	{
		get;
		private set;
	}

	public int SlotIndex
	{
		get;
		private set;
	}

	public event Action<bool> OnOwnerHumanityChanged;

	private static void AssetHeroesMaxStatsComputed()
	{
		if (!heroesMaxStatsComputed)
		{
			IDatabase<HeroConfig> database = Databases.GetDatabase<HeroConfig>();
			HeroGameStatsData[] selectableHeroes = UserProfile.GetSelectableHeroes();
			HeroGameStatsData[] array = selectableHeroes;
			for (int i = 0; i < array.Length; i++)
			{
				HeroGameStatsData heroGameStatsData = array[i];
				HeroConfig value = database.GetValue(heroGameStatsData.ConfigName);
				maxDamagesStat = Mathf.Max(maxDamagesStat, value.GetDamagesStat());
				maxLifeStat = Mathf.Max(maxLifeStat, value.GetLifeStat());
				maxSpeedStat = Mathf.Max(maxSpeedStat, value.GetSpeedStat());
				maxWitStat = Mathf.Max(maxWitStat, value.GetWitStat());
			}
			heroesMaxStatsComputed = true;
		}
	}

	private void Awake()
	{
		sessionService = Services.GetService<ISessionService>();
	}

	public void SetSlotIndex(int slotIndex)
	{
		SlotIndex = slotIndex;
		for (int i = 0; i < slotNumbers.Length; i++)
		{
			slotNumbers[i].Visible = (i == slotIndex);
		}
		if (kickButton != null)
		{
			kickButton.AgeTransform.Visible = false;
		}
		if (inviteButton != null)
		{
			inviteButton.AgeTransform.Visible = false;
		}
	}

	public void RefreshContent(int slotIndex)
	{
		if (gameSelectionPanel == null)
		{
			gameSelectionPanel = SingletonManager.Get<GameSelectionPanel>();
		}
		if (playerNameLabel != null)
		{
			playerNameLabel.AgeTransform.Visible = false;
		}
		if (playerReadyToggle != null)
		{
			playerReadyToggle.AgeTransform.Visible = false;
			playerReadyToggle.AgeTransform.Enable = false;
		}
		CompetitorIsLocalOwner = false;
		SetSlotIndex(slotIndex);
		string empty = string.Empty;
		string empty2 = string.Empty;
		bool state = false;
		if (sessionService == null)
		{
			Diagnostics.LogError("Session service is null!");
			return;
		}
		if (sessionService.Session == null)
		{
			Diagnostics.LogError("Session is null!");
			return;
		}
		if (!sessionService.Session.IsOpened)
		{
			Diagnostics.LogWarning("Session is not opened!");
			return;
		}
		empty = sessionService.Session.GetPlayerIdFromSlotIndex(slotIndex);
		if (string.IsNullOrEmpty(empty))
		{
			CompetitorIsHuman = false;
			CompetitorIsLocalOwner = false;
			if (playerNameLabel != null)
			{
				playerNameLabel.AgeTransform.Visible = false;
			}
			heroNameLbl.Text = "%CompetitorSlotOpen";
			heroArchetypeLbl.AgeTransform.Visible = false;
			heroPortrait.AgeTransform.Visible = false;
			heroStats.Visible = false;
			slotNumbers[slotIndex].Visible = false;
			if (!string.IsNullOrEmpty(heroName))
			{
				gameSelectionPanel.HeroSelectionItemsByHeroName[heroName].ConfirmUnselect(SlotIndex);
			}
			if (inviteButton != null)
			{
				inviteButton.AgeTransform.Visible = true;
			}
			return;
		}
		CompetitorIsHuman = true;
		CompetitorIsLocalOwner = false;
		if (playerNameLabel != null)
		{
			playerNameLabel.AgeTransform.Visible = true;
		}
		heroArchetypeLbl.AgeTransform.Visible = true;
		try
		{
			ulong num = playerID = Convert.ToUInt64(empty);
			if (playerID == sessionService.Session.UserID)
			{
				CompetitorIsLocalOwner = true;
			}
			state = sessionService.Session.GetLobbyMemberData(playerID, Session.MEMBERDATA_IS_READY, defaultValue: false);
			playerName = sessionService.Session.GetPlayerName(playerID);
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Exception raised while retrieving player name: {0}\n{1}", ex.Message, ex.StackTrace);
		}
		if (gameSelectionPanel.IsSavedMPGame)
		{
			string x = string.Format(Session.LOBBYDATA_HERO_BY_PLAYER_ID, playerID);
			empty2 = sessionService.Session.GetLobbyDataString(x);
		}
		else
		{
			empty2 = sessionService.Session.GetLobbyMemberData<string>(playerID, Session.MEMBERDATA_HERO);
		}
		if (string.IsNullOrEmpty(empty2))
		{
			empty2 = GameSelectionPanel.RandomHeroName;
		}
		if (!CompetitorIsLocalOwner || string.IsNullOrEmpty(heroName))
		{
			UpdateHero(gameSelectionPanel.GetHeroStats(empty2));
		}
		if (playerReadyToggle != null)
		{
			playerReadyToggle.AgeTransform.Visible = true;
			playerReadyToggle.State = state;
		}
		if (kickButton != null)
		{
			kickButton.AgeTransform.Visible = (sessionService.Session.IsHosting && !CompetitorIsLocalOwner);
		}
	}

	public void UpdateHero(HeroGameStatsData heroStats, bool tooltipMode = false)
	{
		if (!tooltipMode)
		{
			if (heroName == heroStats.ConfigName)
			{
				heroPortrait.AgeTransform.Visible = true;
				return;
			}
			if (gameSelectionPanel == null)
			{
				gameSelectionPanel = SingletonManager.Get<GameSelectionPanel>();
			}
			StaticString key = (!string.IsNullOrEmpty(heroName)) ? heroName : GameSelectionPanel.RandomHeroName;
			gameSelectionPanel.HeroSelectionItemsByHeroName[key].ConfirmUnselect(SlotIndex);
		}
		heroName = heroStats.ConfigName;
		IGuiService service = Services.GetService<IGuiService>();
		if (service != null && heroName != null && service.GuiPanelHelper.TryGetGuiElement(heroName, out GuiElement guiElement))
		{
			if (imageAnim != null)
			{
				imageAnim.StartAllModifiers();
			}
			heroNameLbl.Text = AgeLocalizer.Instance.LocalizeString(guiElement.Title);
			if (service.GuiPanelHelper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Large, out Texture2D texture))
			{
				heroPortrait.Image = texture;
			}
		}
		heroPortrait.AgeTransform.Visible = true;
		weaponCategoryIcon.Image = transparentImage;
		if (!tooltipMode && heroName == GameSelectionPanel.RandomHeroName)
		{
			this.heroStats.Visible = false;
			heroArchetypeLbl.Text = string.Empty;
		}
		else
		{
			if (heroName == null)
			{
				return;
			}
			HeroConfig value = Databases.GetDatabase<HeroConfig>().GetValue(heroName);
			heroArchetypeLbl.Text = AgeLocalizer.Instance.LocalizeString(value.Archetype);
			AssetHeroesMaxStatsComputed();
			damagesStatBar.PercentRight = 100f * value.GetDamagesStat() / maxDamagesStat;
			lifeStatBar.PercentRight = 100f * value.GetLifeStat() / maxLifeStat;
			speedStatBar.PercentRight = 100f * value.GetSpeedStat() / maxSpeedStat;
			witStatBar.PercentRight = 100f * value.GetWitStat() / maxWitStat;
			lifeStatBar.GetComponent<AgePrimitiveImage>().TintColor = new Color(0.707f, 0.679f, 0.324f, 1f);
			speedStatBar.GetComponent<AgePrimitiveImage>().TintColor = new Color(0.574f, 0.632f, 0.597f, 1f);
			damagesStatBar.GetComponent<AgePrimitiveImage>().TintColor = new Color(0.808f, 0.328f, 0.246f, 1f);
			witStatBar.GetComponent<AgePrimitiveImage>().TintColor = new Color(0.441f, 0.351f, 0.507f, 1f);
			recruitCountLbl.Text = heroStats.RecruitCount.ToString();
			deathCountLbl.Text = heroStats.DeathCount.ToString();
			victoryCountLbl.Text = heroStats.VictoryCount.ToString();
			if (value.EquipmentSlots != null)
			{
				for (int i = 0; i < value.EquipmentSlots.Length; i++)
				{
					EquipmentSlotConfig equipmentSlotConfig = value.EquipmentSlots[i];
					if (equipmentSlotConfig.CategoryName == ItemHeroConfig.ItemHeroCategoryParameters.WeaponCategory && !string.IsNullOrEmpty(equipmentSlotConfig.TypeName))
					{
						if (service != null && service.GuiPanelHelper.TryGetGuiElement(equipmentSlotConfig.TypeName, out guiElement) && service.GuiPanelHelper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Tiny, out Texture2D texture2))
						{
							weaponCategoryIcon.Image = texture2;
						}
						break;
					}
				}
			}
			this.heroStats.Visible = true;
		}
		if (!tooltipMode)
		{
			if (gameSelectionPanel.HeroSelectionItemsByHeroName.TryGetValue(heroName, out HeroSelectionItem value2))
			{
				value2.ConfirmSelect(SlotIndex);
			}
			gameSelectionPanel.SetSelectedHero(SlotIndex, heroName);
		}
	}

	private void OnKickButtonClick(GameObject gameObject)
	{
		ISessionService service = Services.GetService<ISessionService>();
		if (service != null && service.Session.IsHosting && playerID != ulong.MaxValue && !gameSelectionPanel.IsGameReadyToLaunch())
		{
			SingletonManager.Get<RequesterPanel>().Display(AgeLocalizer.Instance.LocalizeString("%KickPlayerFromLobbyConfirmationMessage").Replace("$PlayerName", playerName), OnPlayerKickConfirm, RequesterPanel.ButtonsMode.YesNo);
		}
	}

	private void OnPlayerKickConfirm(RequesterPanel.Result result)
	{
		if (result == RequesterPanel.Result.Yes)
		{
			GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
			if (playerID != ulong.MaxValue && gameNetworkManager != null && gameNetworkManager.IsServer() && !gameSelectionPanel.IsGameReadyToLaunch())
			{
				gameNetworkManager.KickPlayer(playerID, PlayerKickReason.Lobby);
			}
		}
	}

	private void OnInviteButtonClick(GameObject gameObject)
	{
		IMatchMakingService service = Services.GetService<IMatchMakingService>();
		service.InviteToGame();
	}

	private void OnTitleMouseEnter()
	{
		if (!string.IsNullOrEmpty(heroName) && heroName != GameSelectionPanel.RandomHeroName)
		{
			IGuiService service = Services.GetService<IGuiService>();
			Diagnostics.Assert(service != null);
			SingletonManager.Get<HeroBiographyPanel>().ShowWhenFinishedHiding(heroName, GetComponent<AgeTransform>());
		}
	}

	private void OnTitleMouseLeave()
	{
		if (!string.IsNullOrEmpty(heroName) && heroName != GameSelectionPanel.RandomHeroName)
		{
			IGuiService service = Services.GetService<IGuiService>();
			Diagnostics.Assert(service != null);
			SingletonManager.Get<HeroBiographyPanel>().Hide();
		}
	}
}
public class ConstructibleModuleItem : MonoBehaviour
{
	public delegate void OnSelectedHandler(ConstructibleModuleItem panel);

	public OnSelectedHandler OnSelected;

	[SerializeField]
	private AgeControlToggle toggle;

	[SerializeField]
	private AgePrimitiveImage icon;

	[SerializeField]
	private AgePrimitiveLabel okCostLabel;

	[SerializeField]
	private AgePrimitiveLabel koCostLabel;

	[SerializeField]
	private AgePrimitiveLabel title;

	[SerializeField]
	private AgePrimitiveLabel description;

	[SerializeField]
	private AgeTransform newIcon;

	private BluePrintConfig bpConfig;

	private AgeTooltip tooltip;

	public BluePrintConfig BPConfig => bpConfig;

	public void Bind(BluePrintConfig bpConfig)
	{
		this.bpConfig = bpConfig;
	}

	public void Unbind()
	{
		bpConfig = null;
		if (tooltip != null)
		{
			tooltip.ClientData = null;
		}
	}

	public void RefreshCost()
	{
		if (okCostLabel != null && koCostLabel != null)
		{
			float industryCost = bpConfig.GetModuleConfig().GetIndustryCost();
			okCostLabel.Text = industryCost.ToString() + "#REVERT# \\7701\\";
			koCostLabel.Text = industryCost.ToString() + "#REVERT# \\7701\\";
			if (Player.LocalPlayer.IndustryStock < industryCost)
			{
				okCostLabel.AgeTransform.Visible = false;
				koCostLabel.AgeTransform.Visible = true;
			}
			else
			{
				okCostLabel.AgeTransform.Visible = true;
				koCostLabel.AgeTransform.Visible = false;
			}
		}
	}

	public void RefreshContent(IGuiPanelHelper helper, bool isNew)
	{
		if (toggle != null)
		{
			toggle.State = false;
			toggle.OnSwitchData = bpConfig.Name;
		}
		RefreshCost();
		if (newIcon != null)
		{
			newIcon.Visible = isNew;
		}
		if (helper.TryGetGuiElement(bpConfig.Name, out GuiElement guiElement))
		{
			if (title != null)
			{
				title.Text = guiElement.Title;
			}
			if (description != null)
			{
				description.Text = guiElement.Description;
			}
			if (icon != null)
			{
				if (helper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Small, out Texture2D texture))
				{
					icon.Image = texture;
				}
				else
				{
					Diagnostics.LogError("Unable to find small icon for \"" + bpConfig.Name + "\"");
				}
			}
		}
		else
		{
			Diagnostics.LogError("Unable to find GUI element for \"" + bpConfig.Name + "\"");
		}
		if (tooltip != null)
		{
			tooltip.Class = "BluePrint";
			tooltip.Content = bpConfig.Name;
			tooltip.ClientData = bpConfig;
		}
	}

	public void RefreshDestructionItem(IGuiPanelHelper helper)
	{
		koCostLabel.AgeTransform.Visible = false;
		okCostLabel.AgeTransform.Visible = false;
		newIcon.Visible = false;
		if (!helper.TryGetGuiElement("DestructionItem", out GuiElement guiElement))
		{
			return;
		}
		if (icon != null)
		{
			if (helper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Small, out Texture2D texture))
			{
				icon.Image = texture;
			}
			else
			{
				Diagnostics.LogError("Unable to find small icon for \"" + bpConfig.Name + "\"");
			}
		}
		if (tooltip != null)
		{
			tooltip.Class = string.Empty;
			tooltip.Content = guiElement.Description;
		}
	}

	public void HideNewIcon()
	{
		if (newIcon != null)
		{
			newIcon.Visible = false;
		}
	}

	public void Select()
	{
		if (OnSelected != null)
		{
			OnSelected(this);
		}
	}

	protected void Awake()
	{
		tooltip = GetComponent<AgeTooltip>();
	}

	private void OnClick()
	{
		Select();
	}
}
public class ConstructionCategoryItem : MonoBehaviour
{
	public delegate void OnSelectedHandler(ConstructionCategoryItem panel);

	[SerializeField]
	private AgeTransform newIcon;

	public AgeTransform AgeTransform
	{
		get;
		private set;
	}

	public AgeControlToggle Toggle
	{
		get;
		private set;
	}

	public void SetNewIcon(bool isNew)
	{
		newIcon.Visible = isNew;
	}

	private void Awake()
	{
		AgeTransform = GetComponent<AgeTransform>();
		Toggle = GetComponent<AgeControlToggle>();
	}
}
public class ConstructionControlPanel : GuiPanel
{
	[SerializeField]
	private ConstructionModeInitialPane constructionModeInitialPane;

	[SerializeField]
	private ConstructionModeSelectionPane constructionModeSelectionPane;

	[SerializeField]
	private ConstructionModePlacementPane constructionModePlacementPane;

	[SerializeField]
	private ConstructionModeDestructionPane constructionModeDestructionPane;

	private AgeTransform worldPosGuiContainer;

	private Dictionary<SelectionCategory, GuiPanel> panelBySelectionCategory;

	private Dictionary<SelectionCategory, bool> allowTooltipsBySelectionCategory;

	private IGameEventService gameEventManager;

	private SelectableManager selectableManager;

	private bool doUpdate;

	public ConstructionModeInitialPane ConstructionModeInitialPane
	{
		get
		{
			return constructionModeInitialPane;
		}
		private set
		{
		}
	}

	public ConstructionModeSelectionPane ConstructionModeSelectionPane
	{
		get
		{
			return constructionModeSelectionPane;
		}
		private set
		{
		}
	}

	public ConstructionModePlacementPane ConstructionModePlacementPane
	{
		get
		{
			return constructionModePlacementPane;
		}
		private set
		{
		}
	}

	public ConstructionModeDestructionPane ConstructionModeDestructionPane
	{
		get
		{
			return constructionModeDestructionPane;
		}
		private set
		{
		}
	}

	protected override void Awake()
	{
		base.Awake();
		gameEventManager = Services.GetService<IGameEventService>();
		selectableManager = SingletonManager.Get<SelectableManager>();
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		foreach (KeyValuePair<SelectionCategory, GuiPanel> item in panelBySelectionCategory)
		{
			if (item.Value.IsVisible)
			{
				item.Value.RefreshContent();
			}
		}
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		gameEventManager.OnDungeonFIDSChanged += OnDungeonFIDSChanged;
		selectableManager.OnSelectionCategoryChanged += OnSelectionCategoryChanged;
		StartCoroutine(DoUpdate());
		OnSelectionCategoryChanged(selectableManager.CurrentCategory);
		RefreshContent();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		selectableManager.OnSelectionCategoryChanged -= OnSelectionCategoryChanged;
		gameEventManager.OnDungeonFIDSChanged -= OnDungeonFIDSChanged;
		doUpdate = false;
		yield return base.OnHide(instant);
	}

	protected override IEnumerator OnLoad()
	{
		gameEventManager.OnRoomSelectionChanged += OnRoomSelectionChanged;
		worldPosGuiContainer = SingletonManager.Get<MainGameScreen>().WorldPosGUIContainer.GetComponent<AgeTransform>();
		panelBySelectionCategory = new Dictionary<SelectionCategory, GuiPanel>();
		panelBySelectionCategory.Add(SelectionCategory.RoomForMove, constructionModeInitialPane);
		panelBySelectionCategory.Add(SelectionCategory.BuildMenu, constructionModeSelectionPane);
		panelBySelectionCategory.Add(SelectionCategory.RoomForBuild, constructionModePlacementPane);
		panelBySelectionCategory.Add(SelectionCategory.Module, constructionModeDestructionPane);
		allowTooltipsBySelectionCategory = new Dictionary<SelectionCategory, bool>();
		allowTooltipsBySelectionCategory.Add(SelectionCategory.RoomForMove, value: false);
		allowTooltipsBySelectionCategory.Add(SelectionCategory.BuildMenu, value: true);
		allowTooltipsBySelectionCategory.Add(SelectionCategory.RoomForBuild, value: false);
		allowTooltipsBySelectionCategory.Add(SelectionCategory.Module, value: false);
		foreach (KeyValuePair<SelectionCategory, GuiPanel> kvp in panelBySelectionCategory)
		{
			if (kvp.Value.IsVisible)
			{
				kvp.Value.Hide(instant: true);
			}
		}
		yield return base.OnLoad();
	}

	private void OnSelectionCategoryChanged(SelectionCategoryData newCategoryData)
	{
		if (allowTooltipsBySelectionCategory.ContainsKey(newCategoryData.Category))
		{
			base.AgeTransform.NoOverroll = !allowTooltipsBySelectionCategory[newCategoryData.Category];
		}
		else
		{
			base.AgeTransform.NoOverroll = true;
		}
		foreach (KeyValuePair<SelectionCategory, GuiPanel> item in panelBySelectionCategory)
		{
			if (item.Key == newCategoryData.Category)
			{
				if (!item.Value.IsVisible && !item.Value.IsHiding)
				{
					item.Value.Show();
				}
			}
			else if (item.Value.IsVisible)
			{
				if (item.Value.IsShowing)
				{
					item.Value.Hide();
				}
				else
				{
					item.Value.HideWhenFinishedShowing();
				}
			}
		}
		if (worldPosGuiContainer != null)
		{
			if (newCategoryData.Category == SelectionCategory.BuildMenu || newCategoryData.Category == SelectionCategory.RoomForBuild || newCategoryData.Category == SelectionCategory.Module)
			{
				worldPosGuiContainer.Visible = false;
			}
			else
			{
				worldPosGuiContainer.Visible = true;
			}
		}
	}

	private void OnRoomSelectionChanged(Room selectedRoom)
	{
		RefreshContent();
	}

	private void OnDungeonFIDSChanged()
	{
		RefreshContent();
	}

	private IEnumerator DoUpdate()
	{
		doUpdate = true;
		while (doUpdate)
		{
			SelectionCategoryData currentCategory = selectableManager.CurrentCategory;
			if (currentCategory.Category == SelectionCategory.RoomForMove && !constructionModeInitialPane.IsVisible)
			{
				OnSelectionCategoryChanged(selectableManager.CurrentCategory);
			}
			yield return null;
		}
	}
}
public class ConstructionModeDestructionPane : GuiPanel
{
	[SerializeField]
	private AgeTransform destructionIcon;

	private bool doUpdate;

	private IInputService inputService;

	private SelectableManager selectableManager;

	public AgeTransform DestructionIcon => destructionIcon;

	protected override void Awake()
	{
		base.Awake();
		inputService = Services.GetService<IInputService>();
		selectableManager = SingletonManager.Get<SelectableManager>();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		doUpdate = false;
		yield return base.OnHide(instant);
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		doUpdate = true;
		StartCoroutine(UpdateLoop());
	}

	private IEnumerator UpdateLoop()
	{
		while (doUpdate)
		{
			SelectionCategoryData currentCategory = selectableManager.CurrentCategory;
			if (currentCategory.Category == SelectionCategory.Module)
			{
				if (inputService.GetControlDown(Control.EscapeBehavior) && !base.IsShowing && !base.IsHiding)
				{
					selectableManager.SetCategory(SelectionCategory.RoomForMove);
				}
				else if (inputService.GetControlDown(Control.BuildMenuToggle) && !base.IsShowing && !base.IsHiding)
				{
					selectableManager.SetCategory(SelectionCategory.BuildMenu);
				}
			}
			yield return null;
		}
	}
}
public class ConstructionModeInitialPane : GuiPanel
{
	[SerializeField]
	private AgeTransform heroesPanelIcon;

	public AgeTransform HeroesPanelIcon => heroesPanelIcon;
}
public class ConstructionModePlacementPane : GuiPanel
{
	public const float AutoCloseDuration = 2f;

	[SerializeField]
	private ConstructibleModuleItem currentModuleItem;

	private bool doUpdate;

	private IInputService inputService;

	private SelectableManager selectableManager;

	private bool firstModuleBuilt;

	private float autoCloseRemainingTime;

	public override void RefreshContent()
	{
		base.RefreshContent();
		string constructionBPName = Services.GetService<IGameControlService>().ConstructionBPName;
		BluePrintConfig value = Databases.GetDatabase<BluePrintConfig>().GetValue(constructionBPName);
		currentModuleItem.Bind(value);
		currentModuleItem.RefreshContent(base.GuiService.GuiPanelHelper, isNew: false);
	}

	protected override void Awake()
	{
		base.Awake();
		inputService = Services.GetService<IInputService>();
		selectableManager = SingletonManager.Get<SelectableManager>();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		Services.GetService<IGameEventService>().OnModuleBuilt -= ConstructionModePlacementPane_OnModuleBuilt;
		currentModuleItem.Unbind();
		doUpdate = false;
		yield return base.OnHide(instant);
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		firstModuleBuilt = false;
		string bpCfgName = Services.GetService<IGameControlService>().ConstructionBPName;
		BluePrintConfig bpConfig = Databases.GetDatabase<BluePrintConfig>().GetValue(bpCfgName);
		currentModuleItem.Bind(bpConfig);
		currentModuleItem.RefreshContent(base.GuiService.GuiPanelHelper, isNew: false);
		Services.GetService<IGameEventService>().OnModuleBuilt += ConstructionModePlacementPane_OnModuleBuilt;
		doUpdate = true;
		StartCoroutine(UpdateLoop());
	}

	private void ConstructionModePlacementPane_OnModuleBuilt(BluePrintConfig bpConfig)
	{
		firstModuleBuilt = true;
		autoCloseRemainingTime = 2f;
	}

	private IEnumerator UpdateLoop()
	{
		while (doUpdate)
		{
			SelectionCategoryData currentCategory = selectableManager.CurrentCategory;
			if (currentCategory.Category == SelectionCategory.RoomForBuild)
			{
				if (inputService.GetControlDown(Control.EscapeBehavior) && !base.IsShowing && !base.IsHiding)
				{
					selectableManager.SetCategory(SelectionCategory.RoomForMove);
				}
				else if (inputService.GetControlDown(Control.BuildMenuToggle) && !base.IsShowing && !base.IsHiding)
				{
					selectableManager.SetCategory(SelectionCategory.BuildMenu);
				}
				else if (firstModuleBuilt)
				{
					if (autoCloseRemainingTime > 0f)
					{
						autoCloseRemainingTime -= Time.deltaTime;
					}
					else
					{
						selectableManager.SetCategory(SelectionCategory.RoomForMove);
					}
				}
			}
			yield return null;
		}
	}
}
public class ConstructionModeSelectionPane : GuiPanel
{
	[SerializeField]
	private AgeTransform selectionWheel;

	[SerializeField]
	private ConstructionCategoryItem[] constructionCategoryItems;

	[SerializeField]
	private AgeTransform constructionOptionsContainer;

	[SerializeField]
	private AgePrimitiveLabel currentCategoryLabel;

	[SerializeField]
	private Transform constructionOptionPrefab;

	[SerializeField]
	private Transform destructionOptionPrefab;

	[SerializeField]
	private AgeTransform thumbStickGroup;

	[SerializeField]
	private AgeTransform selectIcon;

	[SerializeField]
	private float moduleAngleSpread = 30f;

	[SerializeField]
	private AgeTransform tooltipDock;

	[SerializeField]
	private float thumbRange = 30f;

	private AgeTransform DestructionItem;

	private List<ModuleCategory> moduleCategories;

	private int currentCategoryIndex;

	private int currentModuleIndex;

	private List<string> checkedModuleNames = new List<string>();

	private bool doUpdate;

	private int totalItems;

	private float moduleInitialAngle;

	private IGameControlService gameControlManager;

	private IGameEventService gameEventManager;

	private IInputService inputService;

	private SelectableManager selectableManager;

	private Vector2 vector = default(Vector2);

	public override void RefreshContent()
	{
		base.RefreshContent();
		RefreshNewIconInCategoryItems();
		RefreshAvailableModules();
	}

	protected override void Awake()
	{
		base.Awake();
		gameControlManager = Services.GetService<IGameControlService>();
		gameEventManager = Services.GetService<IGameEventService>();
		inputService = Services.GetService<IInputService>();
		selectableManager = SingletonManager.Get<SelectableManager>();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		doUpdate = false;
		gameEventManager.OnDungeonFIDSChanged -= OnDungeonFIDSChanged;
		yield return base.OnHide(instant);
	}

	protected override IEnumerator OnLoad()
	{
		currentCategoryIndex = -1;
		currentModuleIndex = -1;
		moduleCategories = new List<ModuleCategory>();
		moduleCategories.Add(ModuleCategory.MajorModule);
		moduleCategories.Add(ModuleCategory.MinorModule_Support);
		moduleCategories.Add(ModuleCategory.MinorModule_Offense);
		moduleCategories.Add(ModuleCategory.MinorModule_Debuff);
		yield return base.OnLoad();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		SingletonManager.Get<StelePanel>().Hide(instant: true);
		gameEventManager.OnDungeonFIDSChanged += OnDungeonFIDSChanged;
		if (currentCategoryIndex < 0)
		{
			currentCategoryIndex = 0;
		}
		SelectCategoryByIndex(currentCategoryIndex);
		doUpdate = true;
		StartCoroutine(UpdateLoop());
		RefreshContent();
		selectionWheel.StartAllModifiers();
	}

	private int GetCurrentCategoryModuleCount()
	{
		return constructionOptionsContainer.ComputeVisibleChildren();
	}

	private void OnDungeonFIDSChanged()
	{
		RefreshContent();
	}

	private void OnModuleSelected(ConstructibleModuleItem selectedModulePanel)
	{
		int currentCategoryModuleCount = GetCurrentCategoryModuleCount();
		for (int i = 0; i < currentCategoryModuleCount; i++)
		{
			if (constructionOptionsContainer.GetChildren()[i].GetComponent<ConstructibleModuleItem>() == selectedModulePanel)
			{
				currentModuleIndex = i;
				break;
			}
		}
		List<AgeTransform> children = constructionOptionsContainer.GetChildren();
		if (children.Count > 0 && currentModuleIndex >= 0)
		{
			AgeControlToggle component = children[currentModuleIndex].GetComponent<AgeControlToggle>();
			checkedModuleNames.Add(component.OnSwitchData);
			children[currentModuleIndex].GetComponent<ConstructibleModuleItem>().HideNewIcon();
			RefreshNewIconInCategoryItems();
		}
	}

	private void RefreshAvailableModules()
	{
		UnbindConstructibleModuleItems();
		constructionOptionsContainer.DestroyAllChildren();
		if (currentCategoryIndex < moduleCategories.Count)
		{
			List<BluePrintConfig> categoryUnlockedBluePrints = SingletonManager.Get<Dungeon>().GetCategoryUnlockedBluePrints(moduleCategories[currentCategoryIndex]);
			totalItems = categoryUnlockedBluePrints.Count;
			if (totalItems <= 1)
			{
				moduleInitialAngle = 0f;
			}
			else
			{
				moduleInitialAngle = 0f - moduleAngleSpread;
			}
			constructionOptionsContainer.ReserveChildren(categoryUnlockedBluePrints.Count, constructionOptionPrefab, "Module");
			constructionOptionsContainer.RefreshChildrenIList(categoryUnlockedBluePrints, SetupModuleItem);
		}
		else
		{
			List<BluePrintConfig> list = new List<BluePrintConfig>();
			list.Add(null);
			moduleInitialAngle = 0f;
			constructionOptionsContainer.ReserveChildren(1, destructionOptionPrefab, "Module");
			constructionOptionsContainer.RefreshChildrenIList(list, SetupModuleItem);
		}
	}

	private void SetupModuleItem(AgeTransform tableItem, BluePrintConfig bpConfig, int index)
	{
		ConstructibleModuleItem component = tableItem.GetComponent<ConstructibleModuleItem>();
		component.Bind(bpConfig);
		if (component.OnSelected != null)
		{
			component.OnSelected = (ConstructibleModuleItem.OnSelectedHandler)Delegate.Remove(component.OnSelected, new ConstructibleModuleItem.OnSelectedHandler(OnModuleSelected));
		}
		component.OnSelected = (ConstructibleModuleItem.OnSelectedHandler)Delegate.Combine(component.OnSelected, new ConstructibleModuleItem.OnSelectedHandler(OnModuleSelected));
		if (bpConfig != null)
		{
			component.RefreshContent(base.GuiService.GuiPanelHelper, !checkedModuleNames.Contains(component.BPConfig.Name));
		}
		else
		{
			component.RefreshDestructionItem(base.GuiService.GuiPanelHelper);
		}
		float num = moduleInitialAngle + (float)index * moduleAngleSpread;
		float f = (float)Math.PI / 180f * (90f - num);
		float num2 = constructionOptionsContainer.X + 0.5f * constructionOptionsContainer.Width;
		float num3 = constructionOptionsContainer.Y + 0.5f * constructionOptionsContainer.Height;
		float num4 = constructionOptionsContainer.Width * 0.5f;
		float num5 = constructionOptionsContainer.Height * 0.5f;
		tableItem.X = num2 + num4 * Mathf.Cos(f) - 0.5f * tableItem.Width;
		tableItem.Y = num3 - num5 * Mathf.Sin(f) - 0.5f * tableItem.Height;
		AgeTooltip ageTooltip = tableItem.AgeTooltip;
		if (ageTooltip != null)
		{
			ageTooltip.Anchor = tooltipDock;
			ageTooltip.AnchorMode = AgeTooltipAnchorMode.RIGHT_CENTER;
		}
	}

	private void RefreshNewIconInCategoryItems()
	{
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		int num = 0;
		ConstructionCategoryItem[] array = constructionCategoryItems;
		foreach (ConstructionCategoryItem constructionCategoryItem in array)
		{
			if (moduleCategories == null)
			{
				Diagnostics.LogError("null module categories");
			}
			if (num < moduleCategories.Count)
			{
				List<BluePrintConfig> categoryUnlockedBluePrints = dungeon.GetCategoryUnlockedBluePrints(moduleCategories[num]);
				bool newIcon = false;
				foreach (BluePrintConfig item in categoryUnlockedBluePrints)
				{
					if (!checkedModuleNames.Contains(item.Name))
					{
						newIcon = true;
						break;
					}
				}
				constructionCategoryItem.GetComponent<ConstructionCategoryItem>().SetNewIcon(newIcon);
				num++;
			}
			else
			{
				constructionCategoryItem.GetComponent<ConstructionCategoryItem>().SetNewIcon(isNew: false);
			}
		}
	}

	public void SelectCategoryByIndex(int categoryIndex)
	{
		UnselectCategoryByIndex(currentCategoryIndex);
		currentCategoryIndex = categoryIndex;
		constructionCategoryItems[currentCategoryIndex].Toggle.State = true;
		string x = (currentCategoryIndex >= moduleCategories.Count) ? "BluePrintCategoryDestruction" : moduleCategories[currentCategoryIndex].ToString();
		if (base.GuiService.GuiPanelHelper.TryGetGuiElement(x, out GuiElement guiElement))
		{
			currentCategoryLabel.Text = guiElement.Title;
		}
		if (categoryIndex == 0)
		{
			gameControlManager.IsMajorModuleCategorySelected = true;
			gameControlManager.IsMinorModuleCategorySelected = false;
			gameEventManager.TriggerMajorModuleCategorySelectedEvent();
		}
		else if (categoryIndex < moduleCategories.Count)
		{
			gameControlManager.IsMajorModuleCategorySelected = false;
			gameControlManager.IsMinorModuleCategorySelected = true;
			gameEventManager.TriggerMinorModuleCategorySelectedEvent();
		}
		else
		{
			gameControlManager.IsMajorModuleCategorySelected = false;
			gameControlManager.IsMinorModuleCategorySelected = false;
		}
		RefreshAvailableModules();
	}

	private void UnbindConstructibleModuleItems()
	{
		List<ConstructibleModuleItem> children = constructionOptionsContainer.GetChildren<ConstructibleModuleItem>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
		}
	}

	private void UnselectCategoryByIndex(int categoryIndex)
	{
		if (currentCategoryIndex != -1)
		{
			constructionCategoryItems[currentCategoryIndex].Toggle.State = false;
			currentCategoryIndex = -1;
			if (categoryIndex == 0)
			{
				gameEventManager.TriggerMajorModuleCategoryUnselectedEvent();
				gameControlManager.IsMajorModuleCategorySelected = false;
			}
			else if (categoryIndex < moduleCategories.Count)
			{
				gameEventManager.TriggerMinorModuleCategoryUnselectedEvent();
				gameControlManager.IsMinorModuleCategorySelected = false;
			}
		}
	}

	private IEnumerator UpdateLoop()
	{
		while (doUpdate)
		{
			SelectionCategoryData currentCategory = selectableManager.CurrentCategory;
			if (currentCategory.Category == SelectionCategory.BuildMenu && (inputService.GetControlDown(Control.EscapeBehavior) || inputService.GetControlDown(Control.BuildMenuToggle)) && !base.IsShowing && !base.IsHiding)
			{
				selectableManager.SetCategory(SelectionCategory.RoomForMove);
			}
			else if (inputService.GetControlDown(Control.SelectNextModuleCategory))
			{
				int newModuleCategory2 = (currentCategoryIndex + 1) % constructionCategoryItems.Length;
				SelectCategoryByIndex(newModuleCategory2);
			}
			else if (inputService.GetControlDown(Control.SelectPreviousModuleCategory))
			{
				int newModuleCategory = (currentCategoryIndex + constructionCategoryItems.Length - 1) % constructionCategoryItems.Length;
				SelectCategoryByIndex(newModuleCategory);
			}
			thumbStickGroup.PixelOffsetLeft = thumbRange * inputService.GetAxisValue(InputAxis.LeftStickX);
			thumbStickGroup.PixelOffsetTop = (0f - thumbRange) * inputService.GetAxisValue(InputAxis.LeftStickY);
			vector.Set(thumbStickGroup.PixelOffsetLeft, thumbStickGroup.PixelOffsetTop);
			selectIcon.Alpha = ((!(vector.magnitude > 0f)) ? 0.5f : 1f);
			yield return null;
		}
	}
}
public class ConstructionPanel : GuiPanel, IPopupMenuPanel
{
	[SerializeField]
	private AgeTransform constructionInfos;

	[SerializeField]
	private AgePrimitiveLabel moduleDescriptionLabel;

	[SerializeField]
	private ConstructionCategoryItem[] constructionCategoryItems;

	[SerializeField]
	private AgeTransform constructionOptionsTable;

	[SerializeField]
	private Transform constructionOptionPrefab;

	[SerializeField]
	private AgeTransform displayTransform;

	[SerializeField]
	private Texture2D buildCursorTexture;

	[SerializeField]
	private AgeControlToggle moduleDestructionToggle;

	[SerializeField]
	private Texture2D moduleDestructionCursorTexture;

	private List<ModuleCategory> moduleCategories;

	private int currentCategoryIndex;

	private int currentModuleIndex;

	private bool constructionActive;

	private List<string> checkedModuleNames = new List<string>();

	private IGuiService guiManager;

	private IGameControlService gameControlManager;

	private IGameEventService gameEventManager;

	private IInputService inputService;

	private SelectableManager selectableManager;

	public bool ConstructionActive
	{
		get
		{
			return constructionActive;
		}
		private set
		{
			if (constructionActive == value)
			{
				return;
			}
			constructionActive = value;
			constructionInfos.Visible = value;
			constructionOptionsTable.StartAllModifiers(value);
			if (!constructionActive)
			{
				for (int i = 0; i < constructionCategoryItems.Length; i++)
				{
					constructionCategoryItems[i].Toggle.State = false;
				}
				guiManager.SetDefaultCursor(null);
				guiManager.ChangeCursorToDefault();
				gameControlManager.ConstructionBPName = null;
			}
			else
			{
				UpdateSelectedCategory();
				UpdateHighlightedModule();
			}
			IAudioEventService service = Services.GetService<IAudioEventService>();
			if (constructionActive)
			{
				service.Play2DEvent("Master/GUI/OpenActionMenu");
			}
			else
			{
				service.Play2DEvent("Master/GUI/CloseActionMenu");
			}
		}
	}

	protected override void Awake()
	{
		base.Awake();
		guiManager = Services.GetService<IGuiService>();
		gameControlManager = Services.GetService<IGameControlService>();
		gameEventManager = Services.GetService<IGameEventService>();
		inputService = Services.GetService<IInputService>();
		selectableManager = SingletonManager.Get<SelectableManager>();
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		RefreshNewIconInCategoryItems();
		if (ConstructionActive)
		{
			UnbindConstructibleModuleItems();
			List<BluePrintConfig> categoryUnlockedBluePrints = SingletonManager.Get<Dungeon>().GetCategoryUnlockedBluePrints(moduleCategories[currentCategoryIndex]);
			constructionOptionsTable.Height = 0f;
			constructionOptionsTable.ReserveChildren(categoryUnlockedBluePrints.Count, constructionOptionPrefab, "Module");
			constructionOptionsTable.RefreshChildrenIList(categoryUnlockedBluePrints, RefreshConstructibleItem);
			constructionOptionsTable.ArrangeChildren();
			int currentCategoryModuleCount = GetCurrentCategoryModuleCount();
			constructionOptionsTable.Visible = (currentCategoryModuleCount > 0);
			constructionInfos.Visible = (currentCategoryModuleCount > 0);
			if (currentCategoryModuleCount > 0)
			{
				base.AgeTransform.ComputeGlobalPosition(out Rect globalPosition);
				constructionCategoryItems[currentCategoryIndex].AgeTransform.ComputeGlobalPosition(out Rect globalPosition2);
				globalPosition2.x -= globalPosition.x;
				globalPosition2.y -= globalPosition.y;
				constructionOptionsTable.X = globalPosition2.x + 0.5f * globalPosition2.width - 0.5f * constructionOptionsTable.Width;
				constructionOptionsTable.Y = globalPosition2.y + globalPosition2.height;
				constructionInfos.X = constructionOptionsTable.X + constructionOptionsTable.Width;
				UpdateHighlightedModule();
			}
		}
	}

	public void ToggleCategoryByIndex(int categoryIndex)
	{
		if (currentCategoryIndex == categoryIndex)
		{
			UnselectCategoryByIndex(categoryIndex);
		}
		else
		{
			SelectCategoryByIndex(categoryIndex);
		}
	}

	public void RotateCategoryModuleSelection(int categoryIndex)
	{
		if (currentCategoryIndex != categoryIndex)
		{
			SelectCategoryByIndex(categoryIndex);
		}
		HighlightNextModule();
		SelectCurrentModule();
	}

	public void SelectCategoryByIndex(int categoryIndex)
	{
		gameControlManager.SetHeroStatsPanelDisplay(on: false, displayInventory: false);
		UnselectCurrentCategory();
		SetModuleDestructionMode(on: false);
		currentCategoryIndex = categoryIndex;
		ConstructionActive = true;
		if (categoryIndex == 0)
		{
			gameControlManager.IsMajorModuleCategorySelected = true;
			gameControlManager.IsMinorModuleCategorySelected = false;
			gameEventManager.TriggerMajorModuleCategorySelectedEvent();
		}
		else
		{
			gameControlManager.IsMajorModuleCategorySelected = false;
			gameControlManager.IsMinorModuleCategorySelected = true;
			gameEventManager.TriggerMinorModuleCategorySelectedEvent();
		}
		PopupMenuPanel.RegisterPopupMenuPanel(this);
	}

	public void UnselectCurrentCategory()
	{
		if (ConstructionActive)
		{
			UnselectCategoryByIndex(currentCategoryIndex);
		}
	}

	public void SetModuleDestructionMode(bool on)
	{
		if (gameControlManager != null)
		{
			gameControlManager.ModuleDestructionMode = on;
		}
		if (moduleDestructionToggle != null)
		{
			moduleDestructionToggle.State = on;
		}
		if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			if (on)
			{
				if (guiManager != null)
				{
					guiManager.SetDefaultCursor(moduleDestructionCursorTexture);
					guiManager.ChangeCursor(moduleDestructionCursorTexture);
				}
				UnselectCurrentCategory();
			}
			else if (guiManager != null)
			{
				guiManager.SetDefaultCursor(null);
				guiManager.ChangeCursorToDefault();
			}
		}
		else if (selectableManager.SelectedRoom != null && on)
		{
			if (selectableManager.SelectedRoom.Room.HasDestructibleModules())
			{
				selectableManager.SetCategory(SelectionCategory.Module, selectableManager.SelectedRoom.Room.UniqueID.ID);
			}
			else
			{
				SingletonManager.Get<NotificationPanel>().EnqueueNotification("%NoDestructibleModules", NotificationType.Error);
			}
		}
	}

	private void Update()
	{
		if (inputService != null && inputService.CurrentControlScheme == ControlScheme.XBoxOneController && selectableManager != null && moduleDestructionToggle.State)
		{
			SelectionCategoryData currentCategory = selectableManager.CurrentCategory;
			if (currentCategory.Category == SelectionCategory.Module && (inputService.GetControlDown(Control.EscapeBehavior) || (selectableManager.SelectedRoom != null && selectableManager.GetCurrentCategorySelectedElement() == null && !selectableManager.SelectedRoom.Room.HasDestructibleModules())))
			{
				moduleDestructionToggle.State = false;
				selectableManager.SetCategory(SelectionCategory.RoomForMove);
			}
		}
	}

	public void ToggleModuleDestructionMode()
	{
		SetModuleDestructionMode(!moduleDestructionToggle.State);
	}

	public virtual void OnEscapeBehavior()
	{
		UnselectCurrentCategory();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		gameEventManager.OnDungeonFIDSChanged += OnDungeonFIDSChanged;
		RefreshContent();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		gameEventManager.OnDungeonFIDSChanged -= OnDungeonFIDSChanged;
		yield return base.OnHide(instant);
	}

	protected override IEnumerator OnLoad()
	{
		currentCategoryIndex = -1;
		currentModuleIndex = -1;
		ConstructionActive = false;
		constructionOptionsTable.Alpha = 0f;
		moduleCategories = new List<ModuleCategory>();
		moduleCategories.Add(ModuleCategory.MajorModule);
		moduleCategories.Add(ModuleCategory.MinorModule_Support);
		moduleCategories.Add(ModuleCategory.MinorModule_Offense);
		moduleCategories.Add(ModuleCategory.MinorModule_Debuff);
		gameEventManager.OnRoomSelectionChanged += OnRoomSelectionChanged;
		gameEventManager.OnModuleBuilt += OnModuleBuilt;
		gameEventManager.OnInGameClickDown += OnInGameClickDown;
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			moduleDestructionToggle.GetComponent<Selectable>().OnSelected += DestroyToggle_OnSelected;
		}
		yield return base.OnLoad();
	}

	private void HighlightNextModule()
	{
		int currentCategoryModuleCount = GetCurrentCategoryModuleCount();
		if (currentCategoryModuleCount > 0)
		{
			currentModuleIndex = (currentModuleIndex + 1) % currentCategoryModuleCount;
			UpdateHighlightedModule();
		}
	}

	private int GetCurrentCategoryModuleCount()
	{
		return constructionOptionsTable.ComputeVisibleChildren();
	}

	private void RefreshNewIconInCategoryItems()
	{
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		int num = 0;
		ConstructionCategoryItem[] array = constructionCategoryItems;
		foreach (ConstructionCategoryItem constructionCategoryItem in array)
		{
			List<BluePrintConfig> categoryUnlockedBluePrints = dungeon.GetCategoryUnlockedBluePrints(moduleCategories[num]);
			bool newIcon = false;
			foreach (BluePrintConfig item in categoryUnlockedBluePrints)
			{
				if (!checkedModuleNames.Contains(item.Name))
				{
					newIcon = true;
					break;
				}
			}
			constructionCategoryItem.GetComponent<ConstructionCategoryItem>().SetNewIcon(newIcon);
			num++;
		}
	}

	private void OnToggleConstructionCategoryCB(GameObject obj)
	{
		ConstructionCategoryItem component = obj.GetComponent<ConstructionCategoryItem>();
		ToggleCategoryByIndex(Array.IndexOf(constructionCategoryItems, component));
	}

	private void UnselectCategoryByIndex(int categoryIndex)
	{
		ConstructionActive = false;
		constructionCategoryItems[currentCategoryIndex].Toggle.State = false;
		currentCategoryIndex = -1;
		if (categoryIndex == 0)
		{
			gameEventManager.TriggerMajorModuleCategoryUnselectedEvent();
			gameControlManager.IsMajorModuleCategorySelected = false;
		}
		else
		{
			gameEventManager.TriggerMinorModuleCategoryUnselectedEvent();
			gameControlManager.IsMinorModuleCategorySelected = false;
		}
		PopupMenuPanel.UnregisterPopupMenuPanel(this);
	}

	private void OnModuleSelected(ConstructibleModuleItem selectedModulePanel)
	{
		int currentCategoryModuleCount = GetCurrentCategoryModuleCount();
		for (int i = 0; i < currentCategoryModuleCount; i++)
		{
			if (constructionOptionsTable.GetChildren()[i].GetComponent<ConstructibleModuleItem>() == selectedModulePanel)
			{
				currentModuleIndex = i;
				break;
			}
		}
		UpdateHighlightedModule();
		SelectCurrentModule(selectedModulePanel);
	}

	private void SelectCurrentModule(ConstructibleModuleItem selectedModulePanel = null)
	{
		if (currentModuleIndex >= 0)
		{
			if (selectedModulePanel == null)
			{
				List<AgeTransform> children = constructionOptionsTable.GetChildren();
				selectedModulePanel = children[currentModuleIndex].GetComponent<ConstructibleModuleItem>();
			}
			guiManager.SetDefaultCursor(buildCursorTexture);
			guiManager.ChangeCursor(buildCursorTexture);
			gameControlManager.ConstructionBPName = selectedModulePanel.BPConfig.Name;
		}
	}

	private void OnRoomSelectionChanged(Room selectedRoom)
	{
		RefreshContent();
	}

	private void OnDungeonFIDSChanged()
	{
		RefreshContent();
	}

	private void UnbindConstructibleModuleItems()
	{
		List<ConstructibleModuleItem> children = constructionOptionsTable.GetChildren<ConstructibleModuleItem>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
		}
	}

	private void RefreshConstructibleItem(AgeTransform tableItem, BluePrintConfig bpConfig, int index)
	{
		ConstructibleModuleItem component = tableItem.GetComponent<ConstructibleModuleItem>();
		component.Bind(bpConfig);
		if (component.OnSelected != null)
		{
			component.OnSelected = (ConstructibleModuleItem.OnSelectedHandler)Delegate.Remove(component.OnSelected, new ConstructibleModuleItem.OnSelectedHandler(OnModuleSelected));
		}
		component.OnSelected = (ConstructibleModuleItem.OnSelectedHandler)Delegate.Combine(component.OnSelected, new ConstructibleModuleItem.OnSelectedHandler(OnModuleSelected));
		component.RefreshContent(base.GuiService.GuiPanelHelper, !checkedModuleNames.Contains(component.BPConfig.Name));
	}

	private void UpdateSelectedCategory()
	{
		for (int i = 0; i < constructionCategoryItems.Length; i++)
		{
			constructionCategoryItems[i].Toggle.State = (i == currentCategoryIndex);
		}
		currentModuleIndex = -1;
		RefreshContent();
	}

	private void UpdateHighlightedModule()
	{
		constructionInfos.Y = constructionOptionsTable.Y + constructionOptionsTable.VerticalMargin + constructionOptionsTable.ChildHeight * (float)currentModuleIndex;
		if (currentModuleIndex > 0)
		{
			constructionInfos.Y += (float)currentModuleIndex * constructionOptionsTable.VerticalSpacing;
		}
		constructionInfos.Y += constructionOptionsTable.ChildHeight * 0.5f - constructionInfos.Height * 0.5f;
		int currentCategoryModuleCount = GetCurrentCategoryModuleCount();
		for (int i = 0; i < currentCategoryModuleCount; i++)
		{
			AgeControlToggle component = constructionOptionsTable.GetChildren()[i].GetComponent<AgeControlToggle>();
			component.State = (i == currentModuleIndex);
		}
		List<AgeTransform> children = constructionOptionsTable.GetChildren();
		if (children.Count > 0 && currentModuleIndex >= 0)
		{
			AgeControlToggle component2 = children[currentModuleIndex].GetComponent<AgeControlToggle>();
			checkedModuleNames.Add(component2.OnSwitchData);
			children[currentModuleIndex].GetComponent<ConstructibleModuleItem>().HideNewIcon();
			RefreshNewIconInCategoryItems();
			if (base.GuiService.GuiPanelHelper.TryGetGuiElement(component2.OnSwitchData, out GuiElement guiElement))
			{
				moduleDescriptionLabel.Text = guiElement.Description;
			}
			else
			{
				moduleDescriptionLabel.Text = "<<UNABLE TO FIND MODULE DESCRIPTION>>";
			}
		}
	}

	private void OnModuleBuilt(BluePrintConfig bpConfig)
	{
		if (gameControlManager != null && !gameControlManager.MultipleModuleConstructionsMode)
		{
			UnselectCurrentCategory();
		}
	}

	private void OnInGameClickDown(MouseButton mouseButton)
	{
		if (mouseButton == MouseButton.Right)
		{
			UnselectCurrentCategory();
			SetModuleDestructionMode(on: false);
		}
	}

	private void OnModuleDestructionButtonClick()
	{
		SetModuleDestructionMode(moduleDestructionToggle.State);
	}

	private void OnApplyHighDefinition(float scale)
	{
		UnbindConstructibleModuleItems();
		constructionOptionsTable.DestroyAllChildren();
	}

	private void DestroyToggle_OnSelected()
	{
		UnselectCurrentCategory();
	}
}
public class ControlBindingLine : MonoBehaviour
{
	public AgePrimitiveLabel BindingTitle;

	public KeyBindingTextField[] BindingTextFields;

	private StaticString controlRegistryPath;

	private List<string> bindings;

	private OptionsPanel parent;

	private int bindingIndex;

	private RequesterPanel requesterPanel;

	public void RefreshContent(StaticString controlRegistryPath, List<string> bindings, OptionsPanel parent)
	{
		Diagnostics.Assert(!StaticString.IsNullOrEmpty(controlRegistryPath));
		Diagnostics.Assert(bindings != null);
		Diagnostics.Assert(bindings.Count == BindingTextFields.Length);
		this.controlRegistryPath = controlRegistryPath;
		this.bindings = new List<string>(bindings);
		this.parent = parent;
		string[] array = this.controlRegistryPath.ToString().Split('/');
		if (array.Length == 0)
		{
			Diagnostics.LogError("The registry path {0} is empty", this.controlRegistryPath);
			return;
		}
		BindingTitle.Text = "%ControlBindings" + array[array.Length - 1];
		for (int i = 0; i < this.bindings.Count; i++)
		{
			BindingTextFields[i].ReplaceInputText(LocalizeKeyCodeCombination(this.bindings[i]));
		}
	}

	private void OnBindingGainFocus(GameObject caller)
	{
		int num = Array.IndexOf(BindingTextFields, caller.GetComponent<KeyBindingTextField>());
		bindings[num] = KeyCode.None.ToString();
		BindingTextFields[num].ReplaceInputText("???");
	}

	private void OnBindingLooseFocus(GameObject caller)
	{
		if (!(parent == null) && BindingTextFields != null && BindingTextFields.Length != 0)
		{
			bindingIndex = Array.IndexOf(BindingTextFields, caller.GetComponent<KeyBindingTextField>());
			parent.ChangeControlBinding(controlRegistryPath, bindings, bindingIndex, this);
		}
	}

	public void UpdateBindingText(List<string> bindings)
	{
		BindingTextFields[bindingIndex].ReplaceInputText(LocalizeKeyCodeCombination(bindings[bindingIndex]));
	}

	private void OnBindingKeyDown(GameObject caller)
	{
		int num = Array.IndexOf(BindingTextFields, caller.GetComponent<KeyBindingTextField>());
		KeyCode keyCode = BindingTextFields[num].KeysCurrentlyPressed[0];
		if (BindingTextFields[num].KeysCurrentlyPressed.Count == 1 && (keyCode == KeyCode.LeftControl || keyCode == KeyCode.RightControl || keyCode == KeyCode.LeftAlt || keyCode == KeyCode.RightAlt || keyCode == KeyCode.LeftCommand || keyCode == KeyCode.RightCommand))
		{
			bindings[num] = keyCode.ToString();
			BindingTextFields[num].ReplaceInputText(LocalizeKeyCode(bindings[num]) + "+???");
			return;
		}
		if (BindingTextFields[num].KeysCurrentlyPressed.Count == 1 || (BindingTextFields[num].KeysCurrentlyPressed.Count == 2 && BindingTextFields[num].KeysCurrentlyPressed[1] == KeyCode.Escape))
		{
			bindings[num] = keyCode.ToString();
		}
		else
		{
			KeyCode keyCode2 = BindingTextFields[num].KeysCurrentlyPressed[1];
			List<string> list;
			List<string> list2 = list = bindings;
			int index;
			int index2 = index = num;
			string str = list[index];
			list2[index2] = str + "+" + keyCode2.ToString();
		}
		AgeManager.Instance.FocusedControl = null;
	}

	private string LocalizeKeyCodeCombination(string combinedKeyCodes)
	{
		string[] array = combinedKeyCodes.Split('+');
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = LocalizeKeyCode(array[i]);
		}
		return string.Join(" + ", array);
	}

	private string LocalizeKeyCode(string keyCode)
	{
		if (string.IsNullOrEmpty(keyCode) || keyCode.ToEnum<KeyCode>() == KeyCode.None)
		{
			return string.Empty;
		}
		string text = "%KeyCode" + keyCode;
		string text2 = AgeLocalizer.Instance.LocalizeString(text);
		if (text2 != text)
		{
			return text2;
		}
		return keyCode;
	}
}
public class ControlsOverviewPanel : PopupMenuPanel
{
	[SerializeField]
	private AgePrimitiveImage backgroundImage;

	[SerializeField]
	private Texture2D backgroundImageTexture;

	private bool doUpdate;

	protected override IEnumerator OnHide(bool instant)
	{
		doUpdate = false;
		yield return base.OnHide(instant);
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		backgroundImage.Image = backgroundImageTexture;
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		StartCoroutine(UpdateLoop());
	}

	private IEnumerator UpdateLoop()
	{
		doUpdate = true;
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		while (doUpdate)
		{
			if (dungeon != null && dungeon.IsLevelOver)
			{
				Hide();
			}
			yield return null;
		}
	}
}
public class CreditsPanel : PopupMenuPanel
{
	private void OnQuitButtonClick(GameObject obj)
	{
		Hide();
	}

	private void OnOverlayClick()
	{
	}
}
public class CryoCapsulePanel : PopupMenuPanelRoom
{
	[SerializeField]
	private AgePrimitiveLabel industryCostLabel;

	private CryoCapsule cryoCapsule;

	private IInputService inputManager;

	private CryoCapsule CryoCapsule
	{
		get
		{
			return cryoCapsule;
		}
		set
		{
			if (cryoCapsule != null)
			{
				cryoCapsule.HealthCpnt.OnDeath -= OnCryoCapsuleDeath;
			}
			cryoCapsule = value;
			if (cryoCapsule != null)
			{
				cryoCapsule.HealthCpnt.OnDeath += OnCryoCapsuleDeath;
			}
		}
	}

	protected override Room GetRoom()
	{
		return cryoCapsule.RoomElement.ParentRoom;
	}

	public void Display(CryoCapsule cryoCapsule)
	{
		CryoCapsule = cryoCapsule;
		SingletonManager.Get<DialogPanel>().Display(AgeLocalizer.Instance.LocalizeString("%CryoCapsuleActivationDialog"), CryoCapsule.transform, new Vector2(0f, -170f), GetRoom().CenterPosition, -1f);
		GetComponent<GameToScreenPositionSync>().GameEntityTfm = CryoCapsule.transform;
		ShowWhenFinishedHiding();
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		float cryoCapsuleActivationIndustryCost = GameConfig.GetGameConfig().CryoCapsuleActivationIndustryCost;
		industryCostLabel.Text = cryoCapsuleActivationIndustryCost.ToString();
		if (Player.LocalPlayer.IndustryStock < cryoCapsuleActivationIndustryCost)
		{
			industryCostLabel.TintColor = Color.red;
		}
		else
		{
			industryCostLabel.TintColor = Color.green;
		}
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		gameEventManager.OnDungeonFIDSChanged += OnDungeonFIDSChanged;
		RefreshContent();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		GetComponent<GameToScreenPositionSync>().GameEntityTfm = null;
		gameEventManager.OnDungeonFIDSChanged -= OnDungeonFIDSChanged;
		yield return base.OnHide(instant);
		PopupMenuPanel.UnregisterPopupMenuPanel(this);
	}

	private void OnActivateButtonClick()
	{
		CryoCapsule.Activate();
		Hide();
		SingletonManager.Get<DialogPanel>().Hide(instant: true);
	}

	private void OnIgnoreButtonClick()
	{
		ClosePanel();
	}

	private void OnCryoCapsuleDeath(ulong attackerOwnerPlayerID = 0)
	{
		ClosePanel();
	}

	private void OnDungeonFIDSChanged()
	{
		RefreshContent();
	}

	public override void ClosePanel()
	{
		base.ClosePanel();
		if (CryoCapsule != null)
		{
			CryoCapsule.EndInteraction();
			CryoCapsule = null;
		}
		SingletonManager.Get<DialogPanel>().Hide();
	}

	public override void OnEscapeBehavior()
	{
		ClosePanel();
	}

	private void Update()
	{
		if (base.IsVisible)
		{
			if (inputManager == null)
			{
				inputManager = Services.GetService<IInputService>();
			}
			if (inputManager.GetControlDown(Control.ConfirmSelectable))
			{
				OnActivateButtonClick();
			}
		}
	}
}
public class CrystalLiftPanel : GuiPanel
{
	[SerializeField]
	private AgePrimitiveLabel heroesCountLabel;

	[SerializeField]
	private AgeControlToggleRadial exitToggle;

	[SerializeField]
	private AgePrimitiveImage buttonImage;

	[SerializeField]
	private AgePrimitiveImage buttonHightlightImage;

	[SerializeField]
	private AgeModifierColor buttonColorModifier;

	[SerializeField]
	private AgeModifierScale buttonScaleModifier;

	[SerializeField]
	private AgePrimitiveImage arrowImage;

	[SerializeField]
	private AgeModifierPosition arrowPositionModifier;

	[SerializeField]
	private Color allHeroesPresentBrightColor;

	[SerializeField]
	private Color missingHeroesBrightColor;

	[SerializeField]
	private Color allHeroesPresentDarkColor;

	[SerializeField]
	private Color missingHeroesDarkColor;

	private Dungeon dungeon;

	private int activeHeroCount;

	private IInputService inputManager;

	public override void RefreshContent()
	{
		base.RefreshContent();
		if (dungeon.ExitRoom == null)
		{
			return;
		}
		int count = dungeon.ExitRoom.Heroes.Count;
		activeHeroCount = Hero.LocalPlayerActiveRecruitedHeroes.Count + Hero.RemotePlayersActiveRecruitedHeroes.Count;
		bool flag = false;
		bool flag2 = false;
		for (int i = 0; i < count; i++)
		{
			Hero hero = dungeon.ExitRoom.Heroes[i];
			if (hero.HasCrystal)
			{
				flag = true;
				flag2 = (hero.IsRecruited && hero.NetSyncElement.IsOwnedByLocalPlayer());
				break;
			}
		}
		if (flag && !base.IsVisible)
		{
			Show();
		}
		else if (!flag)
		{
			if (base.IsVisible)
			{
				Hide();
			}
			return;
		}
		exitToggle.AgeTransform.Visible = flag2;
		arrowImage.AgeTransform.Alpha = ((!flag2) ? 0f : 1f);
		heroesCountLabel.Text = AgeLocalizer.Instance.LocalizeString("%CrystalLiftHeroesReady").Replace("$exitRoomHeroCount", count.ToString()).Replace("$activeHeroCount", activeHeroCount.ToString());
		if (count == activeHeroCount)
		{
			buttonColorModifier.StartColor = allHeroesPresentDarkColor;
			buttonColorModifier.EndColor = allHeroesPresentBrightColor;
			heroesCountLabel.TintColor = allHeroesPresentBrightColor;
			if (!buttonColorModifier.IsStarted())
			{
				buttonImage.TintColor = allHeroesPresentBrightColor;
			}
		}
		else if (count != activeHeroCount)
		{
			buttonColorModifier.StartColor = missingHeroesDarkColor;
			buttonColorModifier.EndColor = missingHeroesBrightColor;
			heroesCountLabel.TintColor = missingHeroesBrightColor;
			if (!buttonColorModifier.IsStarted())
			{
				buttonImage.TintColor = missingHeroesBrightColor;
			}
		}
	}

	protected override void Awake()
	{
		base.Awake();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		exitToggle.AgeTransform.Enable = true;
		exitToggle.State = false;
		buttonColorModifier.StartAnimation();
		arrowPositionModifier.StartAnimation();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		buttonColorModifier.Reset();
		arrowPositionModifier.Reset();
		buttonHightlightImage.AgeTransform.Alpha = 0f;
		yield return base.OnHide(instant);
	}

	protected override IEnumerator OnLoadGame()
	{
		yield return base.OnLoadGame();
		dungeon = SingletonManager.Get<Dungeon>();
	}

	protected override void OnUnloadGame(IGame game)
	{
		dungeon = null;
		base.OnUnloadGame(game);
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		Room.OnHeroEnteredOrExitedExitRoom += OnHeroEnteredOrExitedExitRoom;
		Hero.OnActiveHeroDeath += OnActiveHeroDeath;
		Hero.OnHeroRecruited += OnHeroRecruited;
		buttonImage.GetComponent<DynamicTextureLoader>().Load();
		buttonHightlightImage.GetComponent<DynamicTextureLoader>().Load();
		buttonHightlightImage.AgeTransform.Alpha = 0f;
	}

	protected override void OnUnload()
	{
		base.OnUnload();
		Room.OnHeroEnteredOrExitedExitRoom -= OnHeroEnteredOrExitedExitRoom;
		Hero.OnActiveHeroDeath -= OnActiveHeroDeath;
		Hero.OnHeroRecruited -= OnHeroRecruited;
	}

	private void OnHeroEnteredOrExitedExitRoom(Hero hero, bool enter)
	{
		RefreshContent();
	}

	private void OnActiveHeroDeath()
	{
		RefreshContent();
	}

	private void OnHeroRecruited()
	{
		RefreshContent();
	}

	private void ExitDungeon()
	{
		dungeon.LevelOver(victory: true);
	}

	private void OnExitToggleClick()
	{
		exitToggle.AgeTransform.Enable = false;
		buttonColorModifier.Reset();
		buttonHightlightImage.AgeTransform.Alpha = 1f;
		arrowImage.AgeTransform.Alpha = 0f;
		ExitDungeon();
	}

	private void OnMouseEnter()
	{
		int count = dungeon.ExitRoom.Heroes.Count;
		activeHeroCount = Hero.LocalPlayerActiveRecruitedHeroes.Count + Hero.RemotePlayersActiveRecruitedHeroes.Count;
		buttonColorModifier.Reset();
		if (count == activeHeroCount)
		{
			buttonImage.TintColor = allHeroesPresentBrightColor;
		}
		else if (count != activeHeroCount)
		{
			buttonImage.TintColor = missingHeroesBrightColor;
		}
		buttonHightlightImage.AgeTransform.Alpha = 0.4f;
	}

	private void OnMouseLeave()
	{
		if (!exitToggle.State)
		{
			buttonColorModifier.StartAnimation();
			arrowPositionModifier.StartAnimation();
			buttonHightlightImage.AgeTransform.Alpha = 0f;
		}
	}

	private void Update()
	{
		if (dungeon == null)
		{
			return;
		}
		if (base.IsVisible && exitToggle.AgeTransform.Visible && Time.timeScale > 0f)
		{
			if (inputManager == null)
			{
				inputManager = Services.GetService<IInputService>();
			}
			if (inputManager.GetControlDown(Control.ExitFloor))
			{
				ExitDungeon();
			}
		}
		if (activeHeroCount != Hero.LocalPlayerActiveRecruitedHeroes.Count + Hero.RemotePlayersActiveRecruitedHeroes.Count)
		{
			RefreshContent();
		}
	}
}
public class CrystalPanel : AutoCloseGuiPanel
{
	[SerializeField]
	public AgeTransform UnplugGroup;

	[SerializeField]
	public AgeTransform PlugGroup;

	private MajorModule module;

	public void DisplayForModule(MajorModule module)
	{
		if (Hero.SelectedHeroes.Count > 0)
		{
			this.module = module;
			GetComponent<GameToScreenPositionSync>().GameEntityTfm = module.transform;
			UnplugGroup.Visible = true;
			PlugGroup.Visible = false;
			Show();
		}
	}

	public void DisplayForSlot(ModuleSlot slot)
	{
		if (Hero.SelectedHeroes.Count > 0)
		{
			GetComponent<GameToScreenPositionSync>().GameEntityTfm = slot.transform;
			UnplugGroup.Visible = false;
			PlugGroup.Visible = true;
			Show();
		}
	}

	protected override IEnumerator OnHide(bool instant)
	{
		module = null;
		GetComponent<GameToScreenPositionSync>().GameEntityTfm = null;
		yield return base.OnHide(instant);
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		IGameEventService gameEventManager = Services.GetService<IGameEventService>();
		gameEventManager.OnHeroSelectionChanged += OnHeroSelectionChanged;
	}

	private void OnUnplugButtonClicked()
	{
		Diagnostics.Assert(module != null);
		Diagnostics.Assert(Hero.SelectedHeroes.Count > 0, "No selected hero");
		foreach (Hero selectedHero in Hero.SelectedHeroes)
		{
			selectedHero.MoveToCrystal(module);
		}
		Hide();
	}

	private void OnHeroSelectionChanged()
	{
		Hide();
	}
}
public class DialogPanel : AutoCloseGuiPanel
{
	[SerializeField]
	private AgePrimitiveLabel textLabel;

	private Transform anchor;

	private Vector2 offset;

	private Vector3 worldPosition;

	private IGameCameraService gameCameraService;

	private IInputService inputService;

	protected override void Awake()
	{
		base.Awake();
		gameCameraService = Services.GetService<IGameCameraService>();
		inputService = Services.GetService<IInputService>();
	}

	public void Display(string text, Transform tfm, Vector2 offset, float duration = -1f)
	{
		Hide(instant: true);
		if (!gameCameraService.IsTacticalMapActive() && !gameCameraService.IsSwitchingCamera)
		{
			textLabel.Text = text;
			anchor = tfm;
			this.offset = offset;
			ShowWhenFinishedHiding();
			if (duration >= 0f)
			{
				Invoke("HideDialog", duration);
			}
		}
	}

	public void Display(string text, Transform tfm, Vector2 offset, Vector3 worldPosition, float duration = -1f)
	{
		this.worldPosition = worldPosition;
		Display(text, tfm, offset, duration);
	}

	private void HideDialog()
	{
		Hide();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		GetComponent<GameToScreenPositionSync>().GameEntityTfm = anchor;
		GetComponent<GameToScreenPositionSync>().ScreenOffset = offset;
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			gameCameraService.Focus(worldPosition, LerpType.Linear, -1f);
		}
	}

	protected override IEnumerator OnHide(bool instant)
	{
		GetComponent<GameToScreenPositionSync>().GameEntityTfm = null;
		GetComponent<GameToScreenPositionSync>().ScreenOffset = Vector2.zero;
		anchor = null;
		yield return base.OnHide(instant);
	}
}
public class DisclaimerPanel : GuiPanel
{
	[SerializeField]
	private AgePrimitiveLabel titleLabel;

	[SerializeField]
	private AgePrimitiveLabel messageLabel;

	[SerializeField]
	private AgeTransform moreInfoButton;

	private string moreInfoURL;

	public void Display(string title, string message, string moreInfoURL = null)
	{
		this.moreInfoURL = moreInfoURL;
		titleLabel.Text = title;
		messageLabel.Text = message;
		moreInfoButton.Visible = !string.IsNullOrEmpty(this.moreInfoURL);
		Show();
	}

	private void OnOKButtonClick()
	{
		Hide();
	}

	private void OnMoreInfoButtonClick()
	{
		if (!string.IsNullOrEmpty(moreInfoURL))
		{
			UnityEngine.Application.OpenURL(moreInfoURL);
		}
	}
}
public class DustBarPanel : GuiPanel
{
	[SerializeField]
	private AgeTransform dustBar;

	[SerializeField]
	private AgeTransform dustBarMeter;

	[SerializeField]
	private DynamicTextureLoader roomEnergyBackground;

	[SerializeField]
	private AgeTransform roomEnergyTable;

	[SerializeField]
	private Transform roomEnergyPfb;

	[SerializeField]
	private AgeModifier crystalAttackAlertMod;

	[SerializeField]
	private float crystalAttackAlertDuration;

	private AgeControlToggle toggle;

	private IGameControlService gameControlManager;

	private IAudioEventService audioEventService;

	private FMOD.Event crystalAttackAlertSFXEvent;

	public override void RefreshContent()
	{
		base.RefreshContent();
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		dustBar.Width = dustBarMeter.Width * (dungeon.DustStock / dungeon.GetMaxDustStock());
		roomEnergyTable.ReserveChildren(dungeon.GetMaxPoweredRoomCount(), roomEnergyPfb, "RoomEnergyItem");
		roomEnergyTable.RefreshChildrenArray(new object[dungeon.GetMaxPoweredRoomCount()], RefreshRoomEnergy);
	}

	public void PlayCrystalAttackAlert()
	{
		CancelInvoke("StopCrystalAttackAlert");
		if (!crystalAttackAlertMod.IsStarted() || !crystalAttackAlertMod.Repeating)
		{
			crystalAttackAlertMod.StartAnimation();
		}
		crystalAttackAlertMod.Repeating = true;
		Invoke("StopCrystalAttackAlert", crystalAttackAlertDuration);
		if (crystalAttackAlertSFXEvent == null)
		{
			crystalAttackAlertSFXEvent = audioEventService.Play2DEvent("Master/Environment/CrystalAlarm");
		}
	}

	protected override void Awake()
	{
		base.Awake();
		toggle = GetComponent<AgeControlToggle>();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		roomEnergyBackground.Load();
		RefreshContent();
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		gameControlManager = Services.GetService<IGameControlService>();
		audioEventService = Services.GetService<IAudioEventService>();
		IGameEventService gameEventManager = Services.GetService<IGameEventService>();
		gameEventManager.OnDungeonFIDSChanged += OnDungeonFIDSChanged;
		gameControlManager.OnRoomPowerToggleModeChanged += OnRoomPowerToggleModeChanged;
	}

	private void StopCrystalAttackAlert()
	{
		crystalAttackAlertMod.Repeating = false;
		if (crystalAttackAlertSFXEvent != null)
		{
			audioEventService.StopEvent(crystalAttackAlertSFXEvent);
			crystalAttackAlertSFXEvent = null;
		}
	}

	private void RefreshRoomEnergy(AgeTransform tableItem, object obj, int index)
	{
		tableItem.GetComponent<RoomEnergyItem>().SetState(index + 1 <= SingletonManager.Get<Dungeon>().GetPoweredRoomCount());
	}

	private void OnDungeonFIDSChanged()
	{
		RefreshContent();
	}

	private void OnRoomPowerToggleModeChanged(bool on)
	{
		if (toggle != null)
		{
			toggle.State = on;
		}
	}

	private void OnDustBarClick()
	{
		gameControlManager.SetRoomPowerToggleMode(toggle.State);
	}
}
public class DustFactoryPanel : PopupMenuPanelRoom
{
	[SerializeField]
	private AgePrimitiveLabel industryCostLabel;

	private DustFactory dustFactory;

	private IInputService inputManager;

	private DustFactory DustFactory
	{
		get
		{
			return dustFactory;
		}
		set
		{
			if (dustFactory != null)
			{
				dustFactory.HealthCpnt.OnDeath -= OnDustFactoryDeath;
			}
			dustFactory = value;
			if (dustFactory != null)
			{
				dustFactory.HealthCpnt.OnDeath += OnDustFactoryDeath;
			}
		}
	}

	protected override Room GetRoom()
	{
		return dustFactory.RoomElement.ParentRoom;
	}

	public void Display(DustFactory dustFactory)
	{
		Diagnostics.Assert(dustFactory != null);
		DustFactory = dustFactory;
		SingletonManager.Get<DialogPanel>().Display(AgeLocalizer.Instance.LocalizeString("%DustFactoryActivationDialog"), DustFactory.transform, new Vector2(0f, -150f), GetRoom().CenterPosition, -1f);
		GetComponent<GameToScreenPositionSync>().GameEntityTfm = DustFactory.transform;
		ShowWhenFinishedHiding();
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		float dustFactoryActivationIndustryCost = GameConfig.GetGameConfig().DustFactoryActivationIndustryCost;
		industryCostLabel.Text = dustFactoryActivationIndustryCost.ToString();
		if (Player.LocalPlayer.IndustryStock < dustFactoryActivationIndustryCost)
		{
			industryCostLabel.TintColor = Color.red;
		}
		else
		{
			industryCostLabel.TintColor = Color.green;
		}
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		gameEventManager.OnDungeonFIDSChanged += OnDungeonFIDSChanged;
		RefreshContent();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		GetComponent<GameToScreenPositionSync>().GameEntityTfm = null;
		gameEventManager.OnDungeonFIDSChanged -= OnDungeonFIDSChanged;
		yield return base.OnHide(instant);
		PopupMenuPanel.UnregisterPopupMenuPanel(this);
	}

	private void OnActivateButtonClick()
	{
		DustFactory.Activate();
		Hide();
		SingletonManager.Get<DialogPanel>().Hide();
	}

	private void OnIgnoreButtonClick()
	{
		ClosePanel();
	}

	private void OnDustFactoryDeath(ulong attackerOwnerPlayerID = 0)
	{
		ClosePanel();
	}

	private void OnDungeonFIDSChanged()
	{
		RefreshContent();
	}

	public override void ClosePanel()
	{
		if (DustFactory != null)
		{
			DustFactory.EndInteraction();
			DustFactory = null;
		}
		base.ClosePanel();
		SingletonManager.Get<DialogPanel>().Hide();
	}

	public override void OnEscapeBehavior()
	{
		ClosePanel();
	}

	private void Update()
	{
		if (base.IsVisible)
		{
			if (inputManager == null)
			{
				inputManager = Services.GetService<IInputService>();
			}
			if (inputManager.GetControlDown(Control.ConfirmSelectable))
			{
				OnActivateButtonClick();
			}
		}
	}
}
public class EndLevelPanel : GuiPanel
{
	[SerializeField]
	private AgePrimitiveLabel levelTimeLabel;

	[SerializeField]
	private AgePrimitiveLabel totalTimeLabel;

	[SerializeField]
	private AgePrimitiveLabel mobCountLabel;

	[SerializeField]
	private AgePrimitiveLabel doorCountLabel;

	[SerializeField]
	private AgePrimitiveLabel scoreLabel;

	[SerializeField]
	private AgeTransform widget;

	[SerializeField]
	private DynamicTextureLoader[] backgroundsAutoLoaders;

	[SerializeField]
	private AgePrimitiveLabel foodStockLabel;

	[SerializeField]
	private AgePrimitiveLabel industryStockLabel;

	[SerializeField]
	private AgePrimitiveLabel scienceStockLabel;

	[SerializeField]
	private AgeControlButton globalButton;

	[SerializeField]
	private AgeControlButtonRadial nextButton;

	[SerializeField]
	private AgePrimitiveLabel nextButtonLabel;

	[SerializeField]
	private AgeTransform portraitTable;

	[SerializeField]
	private Transform portraitPfb;

	[SerializeField]
	private AgeTransform progressBar;

	[SerializeField]
	private AgeTransform floorCursor;

	[SerializeField]
	private AgePrimitiveLabel previousFloorLabel;

	[SerializeField]
	private AgePrimitiveLabel nextFloorLabel;

	[SerializeField]
	private AgeTransform[] floorMarkers;

	[SerializeField]
	private AgeTransform infiniteProgressBar;

	[SerializeField]
	private AgeTransform infiniteFloorCursor;

	[SerializeField]
	private AgePrimitiveLabel infinitePreviousFloorLabel;

	[SerializeField]
	private AgePrimitiveLabel infiniteNextFloorLabel;

	[SerializeField]
	private AgeTransform[] infiniteFloorMarkers;

	[SerializeField]
	private AgeTransform mainTitleToAnimate;

	[SerializeField]
	private AgeTransform heroesToAnimate;

	[SerializeField]
	private AgeTransform floorTimeToAnimate;

	[SerializeField]
	private AgeTransform totalTimeToAnimate;

	[SerializeField]
	private AgeTransform mobsKilledToAnimate;

	[SerializeField]
	private AgeTransform openedDoorsToAnimate;

	[SerializeField]
	private AgeTransform fidsToAnimate;

	[SerializeField]
	private AgeTransform scoreTitleToAnimate;

	[SerializeField]
	private ChatPanelLift chatPanelLift;

	private GameNetworkManager gameNetManager;

	private StoryDialogManager storyDialogManager;

	private IInputService inputManager;

	private IAudioEventService audioManager;

	private StoryDialogPanel dialogPanel;

	private Dungeon dungeon;

	private Lift lift;

	private FMOD.Event ambianceSFX;

	private IAudioEventService audioEventService;

	private TutorialInteractivePanel tutorialPanel;

	private Control nextDialogControl;

	public AgePrimitiveLabel NextButtonLabel => nextButtonLabel;

	protected override void Awake()
	{
		base.Awake();
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
		storyDialogManager = SingletonManager.Get<StoryDialogManager>();
		nextDialogControl = ((Services.GetService<IInputService>().CurrentControlScheme != ControlScheme.XBoxOneController) ? Control.NextDialog : Control.ConfirmSelectable);
	}

	public override void Show(params object[] parameters)
	{
		base.Show(parameters);
		SingletonManager.Get<MainGameScreen>().MerchantPanel.Hide();
		bool flag = gameNetManager.IsServerOrSinglePlayer();
		globalButton.AgeTransform.Enable = flag;
		nextButton.AgeTransform.Visible = flag;
		dungeon = SingletonManager.Get<Dungeon>();
		DungeonStatistics statistics = dungeon.Statistics;
		lift = SingletonManager.Get<Lift>();
		if (dialogPanel == null)
		{
			dialogPanel = SingletonManager.Get<StoryDialogPanel>();
		}
		if (tutorialPanel == null)
		{
			tutorialPanel = SingletonManager.Get<TutorialInteractivePanel>();
		}
		tutorialPanel.Hide();
		levelTimeLabel.Text = statistics.GetStat(DungeonStatistics.Stat_LevelTime).DurationToString();
		totalTimeLabel.Text = statistics.GetStat(DungeonStatistics.Stat_GameTime).DurationToString();
		mobCountLabel.Text = statistics.GetStat(DungeonStatistics.Stat_KilledMobs).ToString();
		foodStockLabel.Text = Mathf.Floor(Player.LocalPlayer.FoodStock).ToString();
		industryStockLabel.Text = Mathf.Floor(Player.LocalPlayer.IndustryStock).ToString();
		scienceStockLabel.Text = Mathf.Floor(Player.LocalPlayer.ScienceStock).ToString();
		scoreLabel.Text = Mathf.Floor(dungeon.GetScore()).ToString();
		doorCountLabel.Text = AgeLocalizer.Instance.LocalizeString("%TurnCount").Replace("$Turn", (statistics.GetStat(DungeonStatistics.Stat_OpenedDoors) + statistics.GetStat(DungeonStatistics.Stat_ActionOpenedDoors)).ToString());
		widget.Visible = (gameNetManager == null || gameNetManager.IsServerOrSinglePlayer());
		NextButtonLabel.Text = "%LiftNextDialogTitle";
		List<Hero> levelWinningHeroes = Hero.GetLevelWinningHeroes();
		portraitTable.ReserveChildren(levelWinningHeroes.Count, portraitPfb);
		portraitTable.RefreshChildrenIList(levelWinningHeroes, RefreshHeroPortrait);
		if (dungeon.ShipConfig.LevelCount < 999)
		{
			ShowLevelCursor();
		}
		else
		{
			ShowInfiniteLevelCursor();
		}
		StartSpecificModifiers();
		SingletonManager.Get<AchievementManagerDOTE>().Commit();
		if (audioManager == null)
		{
			audioManager = Services.GetService<IAudioEventService>();
		}
		ambianceSFX = audioManager.Play2DEvent("Master/Ambiances/Ambiance_Elevator");
		chatPanelLift.ShowIfAvailable();
	}

	public override void Hide(bool instant = false)
	{
		if (lift != null)
		{
			lift.Hide();
			lift = null;
		}
		chatPanelLift.Hide(instant: true);
		if (ambianceSFX != null)
		{
			ambianceSFX.stop();
			ambianceSFX = null;
		}
		dungeon = null;
		base.Hide(instant);
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		audioEventService = Services.GetService<IAudioEventService>();
		for (int i = 0; i < backgroundsAutoLoaders.Length; i++)
		{
			backgroundsAutoLoaders[i].Load();
		}
	}

	protected override void OnUnload()
	{
		audioEventService = null;
		base.OnUnload();
	}

	private void RefreshHeroPortrait(AgeTransform portraitSlot, Hero hero, int index)
	{
		if (base.GuiService.GuiPanelHelper.TryGetGuiElement(hero.Config.Name, out GuiElement guiElement) && base.GuiService.GuiPanelHelper.TryGetTextureFromIcon(guiElement, IconSize.Small, out Texture2D texture))
		{
			portraitSlot.GetComponent<AgePrimitiveImage>().Image = texture;
		}
	}

	private void OnClickContinue()
	{
		if (!(gameNetManager == null) && !gameNetManager.IsServerOrSinglePlayer())
		{
			return;
		}
		if (storyDialogManager.EnableDialog)
		{
			storyDialogManager.DisplayDialog();
			if (!storyDialogManager.EnableDialog)
			{
				dialogPanel.OnFinished += OnDialogFinished;
			}
			return;
		}
		if (dialogPanel != null && dialogPanel.IsVisible)
		{
			dialogPanel.Hide();
			OnDialogFinished();
			return;
		}
		storyDialogManager.enabled = false;
		int levelCount = dungeon.ShipConfig.LevelCount;
		if (dungeon.Level + 1 > levelCount)
		{
			dungeon.NetSyncElement.SendRPCToAll(SingletonRPC.Dungeon_ShowVictoryPanel);
		}
		else
		{
			GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
			if (gameNetworkManager.IsMultiplayerSession())
			{
				if (!gameNetworkManager.IsServer())
				{
					Diagnostics.LogError("EndLevelPanel continue button should only be accessible to server in multiplayer mode!");
					return;
				}
				Services.GetService<IGameControlService>().StartNextLevelMultiplayerGame();
			}
			else
			{
				Services.GetService<IGameControlService>().StartNextLevelSinglePlayerGame();
			}
		}
		SingletonManager.Get<StoryDialogPanel>().Hide();
		SingletonManager.Get<Lift>().Hide();
		Hide();
	}

	public void OnDialogFinished()
	{
		if (lift != null)
		{
			lift.OnDialogFinished();
		}
		NextButtonLabel.Text = ((dungeon.ShipConfig.LevelCount != dungeon.Level) ? "%LiftNextLevelTitle" : "%LiftLastLevelTitle");
		if (dialogPanel != null)
		{
			dialogPanel.OnFinished -= OnDialogFinished;
		}
	}

	private void Update()
	{
		if (inputManager == null)
		{
			inputManager = Services.GetService<IInputService>();
		}
		if (base.IsVisible && inputManager.KeyboardShortcutEnabled)
		{
			if (inputManager.GetControlDown(nextDialogControl))
			{
				OnClickContinue();
			}
			else if (inputManager.GetControlDown(Control.Chat))
			{
				chatPanelLift.Focus();
			}
		}
	}

	private void ShowLevelCursor()
	{
		progressBar.Visible = true;
		infiniteProgressBar.Visible = false;
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		previousFloorLabel.Text = AgeLocalizer.Instance.LocalizeString("%LevelNumberTitle") + " " + this.dungeon.Level.ToString();
		previousFloorLabel.GetComponent<AgeModifierPosition>().StartY = floorMarkers[dungeon.Level - 1].Y;
		previousFloorLabel.GetComponent<AgeModifierPosition>().EndY = floorMarkers[dungeon.Level].Y;
		previousFloorLabel.AgeTransform.StartAllModifiers();
		if (this.dungeon.Level + 1 <= this.dungeon.ShipConfig.LevelCount)
		{
			nextFloorLabel.Text = AgeLocalizer.Instance.LocalizeString("%LevelNumberTitle") + " " + (this.dungeon.Level + 1).ToString();
		}
		else
		{
			nextFloorLabel.Text = AgeLocalizer.Instance.LocalizeString("%DungeonExitTitle");
		}
		nextFloorLabel.GetComponent<AgeModifierPosition>().StartY = floorMarkers[this.dungeon.Level - 1].Y;
		nextFloorLabel.GetComponent<AgeModifierPosition>().EndY = floorMarkers[this.dungeon.Level].Y;
		nextFloorLabel.AgeTransform.StartAllModifiers();
		floorCursor.GetComponent<AgeModifierPosition>().StartY = floorMarkers[this.dungeon.Level - 1].Y;
		floorCursor.GetComponent<AgeModifierPosition>().EndY = floorMarkers[this.dungeon.Level].Y;
		floorCursor.GetComponent<AgeModifierPosition>().StartAnimation();
	}

	private void ShowInfiniteLevelCursor()
	{
		progressBar.Visible = false;
		infiniteProgressBar.Visible = true;
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		infinitePreviousFloorLabel.Text = AgeLocalizer.Instance.LocalizeString("%LevelNumberTitle") + " " + dungeon.Level.ToString();
		infinitePreviousFloorLabel.GetComponent<AgeModifierPosition>().StartY = infiniteFloorMarkers[0].Y;
		infinitePreviousFloorLabel.GetComponent<AgeModifierPosition>().EndY = infiniteFloorMarkers[1].Y;
		infinitePreviousFloorLabel.AgeTransform.StartAllModifiers();
		infiniteNextFloorLabel.Text = AgeLocalizer.Instance.LocalizeString("%LevelNumberTitle") + " " + (dungeon.Level + 1).ToString();
		infiniteNextFloorLabel.GetComponent<AgeModifierPosition>().StartY = infiniteFloorMarkers[0].Y;
		infiniteNextFloorLabel.GetComponent<AgeModifierPosition>().EndY = infiniteFloorMarkers[1].Y;
		infiniteNextFloorLabel.AgeTransform.StartAllModifiers();
		infiniteFloorCursor.GetComponent<AgeModifierPosition>().StartY = infiniteFloorMarkers[0].Y;
		infiniteFloorCursor.GetComponent<AgeModifierPosition>().EndY = infiniteFloorMarkers[1].Y;
		infiniteFloorCursor.GetComponent<AgeModifierPosition>().StartAnimation();
	}

	private void StartSpecificModifiers()
	{
		mainTitleToAnimate.Visible = false;
		heroesToAnimate.Visible = false;
		floorTimeToAnimate.Visible = false;
		totalTimeToAnimate.Visible = false;
		mobsKilledToAnimate.Visible = false;
		openedDoorsToAnimate.Visible = false;
		fidsToAnimate.Visible = false;
		scoreTitleToAnimate.Visible = false;
		Invoke("ShowMainTitle", 0.3f);
		Invoke("ShowHeroes", 0.8f);
		Invoke("ShowFloorTime", 1.3f);
		Invoke("ShowTotalTime", 1.5f);
		Invoke("ShowMobsKilled", 1.7f);
		Invoke("ShowOpenedDoors", 1.9f);
		Invoke("ShowFIDS", 2.1f);
		Invoke("ShowScore", 2.4f);
	}

	private void ShowMainTitle()
	{
		if (base.IsVisible && !base.IsHiding)
		{
			mainTitleToAnimate.Visible = true;
			mainTitleToAnimate.StartAllModifiers(forward: true, recursive: true);
			audioEventService.Play2DEvent("Master/GUI/ScoreScreen/FloorCleared");
		}
	}

	private void ShowHeroes()
	{
		if (base.IsVisible && !base.IsHiding)
		{
			heroesToAnimate.Visible = true;
			heroesToAnimate.StartAllModifiers(forward: true, recursive: true);
			audioEventService.Play2DEvent("Master/GUI/ScoreScreen/BigScore");
		}
	}

	private void ShowFloorTime()
	{
		if (base.IsVisible && !base.IsHiding)
		{
			floorTimeToAnimate.Visible = true;
			floorTimeToAnimate.StartAllModifiers(forward: true, recursive: true);
			audioEventService.Play2DEvent("Master/GUI/ScoreScreen/SmallScore");
		}
	}

	private void ShowTotalTime()
	{
		if (base.IsVisible && !base.IsHiding)
		{
			totalTimeToAnimate.Visible = true;
			totalTimeToAnimate.StartAllModifiers(forward: true, recursive: true);
			audioEventService.Play2DEvent("Master/GUI/ScoreScreen/SmallScore");
		}
	}

	private void ShowMobsKilled()
	{
		if (base.IsVisible && !base.IsHiding)
		{
			mobsKilledToAnimate.Visible = true;
			mobsKilledToAnimate.StartAllModifiers(forward: true, recursive: true);
			audioEventService.Play2DEvent("Master/GUI/ScoreScreen/SmallScore");
		}
	}

	private void ShowOpenedDoors()
	{
		if (base.IsVisible && !base.IsHiding)
		{
			openedDoorsToAnimate.Visible = true;
			openedDoorsToAnimate.StartAllModifiers(forward: true, recursive: true);
			audioEventService.Play2DEvent("Master/GUI/ScoreScreen/SmallScore");
		}
	}

	private void ShowFIDS()
	{
		if (base.IsVisible && !base.IsHiding)
		{
			fidsToAnimate.Visible = true;
			fidsToAnimate.StartAllModifiers(forward: true, recursive: true);
			audioEventService.Play2DEvent("Master/GUI/ScoreScreen/SmallScore");
		}
	}

	private void ShowScore()
	{
		if (base.IsVisible && !base.IsHiding)
		{
			scoreTitleToAnimate.Visible = true;
			scoreTitleToAnimate.StartAllModifiers(forward: true, recursive: true);
			audioEventService.Play2DEvent("Master/GUI/ScoreScreen/FinalScore");
		}
	}
}
public class EndingPanel : GuiPanel
{
	[SerializeField]
	private float timeBeforeFade;

	[SerializeField]
	private float fadeDuration;

	private float currentTimeBeforeFade;

	private float currentFadeDuration;

	private bool doUpdate;

	private IInputService inputService;

	public override void Show(params object[] parameters)
	{
		base.Show(parameters);
		if (inputService == null)
		{
			inputService = Services.GetService<IInputService>();
		}
		currentTimeBeforeFade = timeBeforeFade;
		base.AgeTransform.Enable = false;
		doUpdate = true;
		base.AgeTransform.Alpha = 0f;
	}

	public override void Hide(bool instant = false)
	{
		doUpdate = false;
		base.Hide(instant);
	}

	private void OnClickContinue()
	{
		SingletonManager.Get<Ending>().Terminate();
	}

	private void Update()
	{
		if (!base.IsVisible)
		{
			return;
		}
		if (doUpdate)
		{
			if (currentTimeBeforeFade > 0f)
			{
				currentTimeBeforeFade -= Time.deltaTime;
				if (currentTimeBeforeFade <= 0f)
				{
					currentFadeDuration = fadeDuration;
					base.AgeTransform.Enable = true;
				}
			}
			else if (currentFadeDuration > 0f)
			{
				currentFadeDuration -= Time.deltaTime;
				base.AgeTransform.Alpha = 1f - currentFadeDuration / fadeDuration;
				if (currentFadeDuration <= 0f)
				{
					doUpdate = false;
				}
			}
		}
		if (base.AgeTransform.Enable && inputService.GetControlDown(Control.NextDialog))
		{
			OnClickContinue();
		}
	}
}
public class EquipmentSlotItem : GuiItem
{
	public AgeTransform SlotHover;

	private AgeTooltip tooltip;

	private IInputService inputService;

	private AGESelectable selectable;

	public EquipmentSlot Slot
	{
		get;
		private set;
	}

	public int Index
	{
		get;
		private set;
	}

	public override InventoryItem GetItem()
	{
		if (Slot == null || Slot.EquippedItem == null)
		{
			return null;
		}
		return Slot.EquippedItem;
	}

	public void Bind(EquipmentSlot slot, AgeTransform tooltipDock, int index)
	{
		Slot = slot;
		Slot.OnItemChanged += EquipmentSlot_OnItemEquipped;
		Index = index;
		if (selectable != null)
		{
			selectable.Register();
		}
		AgeTooltip component = GetComponent<AgeTooltip>();
		if (component != null && tooltipDock != null)
		{
			tooltip.Anchor = tooltipDock;
			tooltip.AnchorMode = AgeTooltipAnchorMode.RIGHT_CENTER;
		}
	}

	public void Unbind()
	{
		if (Slot != null)
		{
			Slot.OnItemChanged -= EquipmentSlot_OnItemEquipped;
		}
		Slot = null;
		if (selectable != null)
		{
			selectable.Unregister();
		}
	}

	public override void RefreshContent(IGuiPanelHelper helper = null, bool active = true, bool enabled = true, StaticString costPropertyName = null, bool isBuyable = true)
	{
		base.RefreshContent(helper, active, enabled, costPropertyName, isBuyable);
		IGuiPanelHelper guiPanelHelper = helper ?? Services.GetService<IGuiService>().GuiPanelHelper;
		Diagnostics.Assert(guiPanelHelper != null, "Unable to access GuiPanelHelper");
		Color tintColor = DefaultBackgroundColor;
		GuiElement guiElement = null;
		if (guiPanelHelper != null)
		{
			bool flag = true;
			bool flag2 = false;
			if (Slot.CategoryParameters.TypeName != null)
			{
				guiPanelHelper.TryGetGuiElement(Slot.CategoryParameters.TypeName, out guiElement);
			}
			else
			{
				guiPanelHelper.TryGetGuiElement(Slot.CategoryParameters.CategoryName, out guiElement);
			}
			if (guiElement != null && guiPanelHelper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Tiny, out Texture2D texture))
			{
				ItemCategoryIcon.Image = texture;
			}
			if (Slot.EquippedItem != null)
			{
				guiPanelHelper.TryGetGuiElement(Slot.EquippedItem.ItemConfig.Name, out guiElement);
				if (Slot.EquippedItem.RarityCfg != null)
				{
					tintColor = Slot.EquippedItem.RarityCfg.GetItemHeroRarityConfig().ColorValue;
				}
				UnequipButton.Visible = !Slot.EquippedItem.ItemConfig.CannotBeUnequipped;
				flag2 = true;
			}
			else
			{
				UnequipButton.Visible = false;
			}
			ItemName.AgeTransform.Visible = (Slot.EquippedItem != null);
			flag = false;
			if (InventoryListPanel.SelectedGuiItem != null && InventoryListPanel.SelectedGuiItem.GetItem() != null && Slot.CanHoldItem(InventoryListPanel.SelectedGuiItem.GetItem()))
			{
				flag = true;
				flag2 = true;
				ItemHighlight.Visible = true;
			}
			else
			{
				ItemHighlight.Visible = false;
			}
			if (flag2)
			{
				GetComponent<AgeTransform>().Alpha = 1f;
			}
			else
			{
				GetComponent<AgeTransform>().Alpha = 0.5f;
			}
			SlotHover.Visible = flag;
		}
		if (guiElement != null)
		{
			if (guiPanelHelper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Small, out Texture2D texture2))
			{
				ItemIcon.Image = texture2;
			}
			ItemName.Text = AgeLocalizer.Instance.LocalizeString(guiElement.Title);
		}
		tintColor.a = DefaultBackgroundColor.a;
		ItemBackground.TintColor = tintColor;
		if (tooltip != null)
		{
			if (Slot.EquippedItem != null)
			{
				tooltip.Content = Slot.EquippedItem.ItemConfig.Name;
				tooltip.ClientData = Slot.EquippedItem;
				tooltip.Class = "ItemHero";
			}
			else
			{
				tooltip.Content = string.Empty;
				tooltip.Class = string.Empty;
			}
		}
		if (inputService == null)
		{
			inputService = Services.GetService<IInputService>();
		}
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			ItemHighlight.Visible = false;
		}
		ItemTransferMarker.Visible = false;
	}

	protected override void Awake()
	{
		base.Awake();
		tooltip = GetComponent<AgeTooltip>();
		selectable = GetComponent<AGESelectable>();
	}

	private void EquipmentSlot_OnItemEquipped(EquipmentSlot sender, InventoryItem item, bool equipped)
	{
		RefreshContent();
	}

	public void UnequipCurrentItem()
	{
		if (Slot.EquippedItem != null)
		{
			Slot.UnequipItem();
		}
	}

	private void OnUnequipButtonClick()
	{
		UnequipCurrentItem();
	}

	private void OnSlotButtonClick()
	{
		if (!(InventoryListPanel.SelectedGuiItem == null) && InventoryListPanel.SelectedGuiItem.GetItem() != null && Slot.CanHoldItem(InventoryListPanel.SelectedGuiItem.GetItem()))
		{
			Slot.OnSlotPanelClick();
		}
	}

	public void OnSlotButtonDoubleClick()
	{
		if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			UnequipCurrentItem();
		}
	}
}
public class EventNotificationData
{
	public StaticString EventType;

	public string Message;

	public EventNotificationData(StaticString eventType, string message)
	{
		EventType = eventType;
		Message = message;
	}
}
public class FIDSLootFeedbackItem : MonoBehaviour
{
	[SerializeField]
	private AgePrimitiveLabel amountLabel;

	[SerializeField]
	private AgePrimitiveImage icon;

	[SerializeField]
	private Color foodColor;

	[SerializeField]
	private Color industryColor;

	[SerializeField]
	private Color dustColor;

	[SerializeField]
	private Color scienceColor;

	[SerializeField]
	private Texture2D foodTexture;

	[SerializeField]
	private Texture2D industryTexture;

	[SerializeField]
	private Texture2D dustTexture;

	[SerializeField]
	private Texture2D scienceTexture;

	[SerializeField]
	private AgeTransform modifiersTfm;

	[SerializeField]
	private float autoDestroyDelay;

	public void Init(string amountStr, StaticString fidsType, Transform gameTfm)
	{
		amountLabel.Text = amountStr;
		if (fidsType == SimulationProperties.Food)
		{
			icon.Image = foodTexture;
			amountLabel.TintColor = foodColor;
		}
		else if (fidsType == SimulationProperties.Industry)
		{
			icon.Image = industryTexture;
			amountLabel.TintColor = industryColor;
		}
		else if (fidsType == SimulationProperties.Dust)
		{
			icon.Image = dustTexture;
			amountLabel.TintColor = dustColor;
		}
		else if (fidsType == SimulationProperties.Science)
		{
			icon.Image = scienceTexture;
			amountLabel.TintColor = scienceColor;
		}
		GetComponent<GameToScreenPositionSync>().GameEntityTfm = gameTfm;
		modifiersTfm.StartAllModifiers();
		UnityEngine.Object.Destroy(base.gameObject, autoDestroyDelay);
	}

	protected virtual void OnDestroy()
	{
		GetComponent<GameToScreenPositionSync>().GameEntityTfm = null;
	}
}
public class GameDifficultySelectionPanel : PopupMenuPanel
{
	public delegate void GameDifficultySelectionFinishedHandler(bool selectionConfirmed);

	private event GameDifficultySelectionFinishedHandler OnGameDifficultySelectionFinished;

	public void StartSelection(GameDifficultySelectionFinishedHandler onHeroesSelectionFinished = null)
	{
		this.OnGameDifficultySelectionFinished = onHeroesSelectionFinished;
		RefreshContent();
		Show();
	}

	private void OnDifficultyButtonClick(GameObject eventSender)
	{
		Dungeon.SetGameDifficulty(eventSender.GetComponent<AgeControlButton>().OnActivateData.ToEnum<GameDifficulty>());
		if (this.OnGameDifficultySelectionFinished != null)
		{
			this.OnGameDifficultySelectionFinished(selectionConfirmed: true);
		}
		Hide();
	}

	private void OnOverlayClick()
	{
	}

	private void OnCancelButtonClick()
	{
		if (this.OnGameDifficultySelectionFinished != null)
		{
			this.OnGameDifficultySelectionFinished(selectionConfirmed: false);
		}
		Hide();
	}
}
public class GameMenuPanel : GuiPanel
{
	[SerializeField]
	private AgeControlToggle gameMenuToggle;

	[SerializeField]
	private AgeControlButton saveQuitButton;

	[SerializeField]
	private AgeControlButton tutorialButton;

	[SerializeField]
	private AgePrimitiveLabel xboxCurrentUserLabel;

	[SerializeField]
	private AgeTooltip switchUserTooltip;

	private GameControlManager gameControlManager;

	private IGameControlService gameControlService;

	private IInputService inputService;

	protected override void Awake()
	{
		base.Awake();
		gameControlService = Services.GetService<IGameControlService>();
		inputService = Services.GetService<IInputService>();
		gameControlManager = (gameControlService as GameControlManager);
	}

	public void OnResumeButtonClick(GameObject gameObject)
	{
		Hide();
	}

	public void OnSaveQuitButtonClick(GameObject gameObject)
	{
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		dungeon.SaveAndQuit();
		Hide();
	}

	public void OnOptionsButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<OptionsPanel>().Show();
	}

	public void OnTutorialButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<TutorialManager>().TriggerTutorial();
		Hide();
	}

	public void OnControlsButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<ShortcutsPanel>().Show();
	}

	public void OnMainMenuButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<RequesterPanel>().Display("%GoToMainMenuConfirm", OnMainMenuConfirmResult, RequesterPanel.ButtonsMode.YesNo);
	}

	public void OnAlbumButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<Album>().Focus(display: true);
	}

	public override void Show(params object[] parameters)
	{
		if (gameControlService.CanPauseGame(null, ignoreShipConfig: true))
		{
			gameControlService.SetGamePause(paused: true, inputService.CurrentControlScheme == ControlScheme.XBoxOneController);
		}
		gameControlManager.enabled = false;
		if (gameMenuToggle != null)
		{
			gameMenuToggle.State = true;
		}
		if (saveQuitButton != null)
		{
			List<GuiError> guiErrors = new List<GuiError>();
			if (SingletonManager.Get<Dungeon>().CanSaveDungeon(guiErrors))
			{
				saveQuitButton.AgeTransform.Enable = true;
				saveQuitButton.GetComponent<AgeTooltip>().Content = "%SaveQuitOKTooltip";
			}
			else
			{
				saveQuitButton.AgeTransform.Enable = false;
				saveQuitButton.GetComponent<AgeTooltip>().Content = GuiError.FirstLocalizedMessage(guiErrors, "Tooltip");
			}
		}
		if (SingletonManager.Get<GameNetworkManager>().IsMultiplayerSession())
		{
			tutorialButton.AgeTransform.Enable = false;
			tutorialButton.AgeTransform.AgeTooltip.Content = "%TutorialForbiddenInMultiplayerTooltip";
		}
		else
		{
			tutorialButton.AgeTransform.Enable = true;
			tutorialButton.AgeTransform.AgeTooltip.Content = "%TutorialTooltip";
		}
		base.Show(parameters);
	}

	public override void Hide(bool instant = false)
	{
		gameControlService.SetGamePause(paused: false);
		gameControlManager.enabled = true;
		if (gameMenuToggle != null)
		{
			gameMenuToggle.State = false;
		}
		base.Hide(instant);
	}

	public void OnEscapeBehavior()
	{
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			SingletonManager.Get<HeroPanel>().Hide();
		}
		else
		{
			Hide();
		}
	}

	private void OnMainMenuConfirmResult(RequesterPanel.Result result)
	{
		if (result == RequesterPanel.Result.Yes)
		{
			Hide();
			gameControlService.GoBackToMainMenu();
		}
	}
}
public class GameOverPanel : GuiPanel
{
	[SerializeField]
	private AgePrimitiveLabel scoreLabel;

	[SerializeField]
	private AgePrimitiveLabel totalTimeLabel;

	[SerializeField]
	private AgePrimitiveLabel mobCountLabel;

	[SerializeField]
	private AgePrimitiveLabel doorCountLabel;

	[SerializeField]
	private ChatPanelGameOver chatPanelGameOver;

	private GameNetworkManager gameNetManager;

	private IInputService inputManager;

	public override void Show(params object[] parameters)
	{
		base.Show(parameters);
		SingletonManager.Get<GameMenuPanel>().Hide();
		SingletonManager.Get<RequesterPanel>().Hide();
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		DungeonStatistics statistics = dungeon.Statistics;
		if (gameNetManager == null)
		{
			gameNetManager = SingletonManager.Get<GameNetworkManager>();
		}
		chatPanelGameOver.ShowIfAvailable();
		scoreLabel.Text = Mathf.Floor(dungeon.GetScore()).ToString();
		totalTimeLabel.Text = statistics.GetStat(DungeonStatistics.Stat_GameTime).DurationToString();
		mobCountLabel.Text = statistics.GetStat(DungeonStatistics.Stat_KilledMobs).ToString();
		doorCountLabel.Text = AgeLocalizer.Instance.LocalizeString("%TurnCount").Replace("$Turn", (statistics.GetStat(DungeonStatistics.Stat_OpenedDoors) + statistics.GetStat(DungeonStatistics.Stat_ActionOpenedDoors)).ToString());
		DynamicTextureLoader[] componentsInChildren = GetComponentsInChildren<DynamicTextureLoader>();
		DynamicTextureLoader[] array = componentsInChildren;
		foreach (DynamicTextureLoader dynamicTextureLoader in array)
		{
			dynamicTextureLoader.Load();
		}
		IAudioLayeredMusicService service = Services.GetService<IAudioLayeredMusicService>();
		service.StopAllMusics();
		service.PlayLayeredMusic("MusicGameOver", "MusicGameOver", 0);
		SingletonManager.Get<AchievementManagerDOTE>().Commit();
	}

	public override void Hide(bool instant = false)
	{
		base.Hide(instant);
		chatPanelGameOver.Hide(instant);
	}

	private void OnClickContinue()
	{
		Services.GetService<IGameControlService>().GoBackToMainMenu();
		if (UserProfile.CurrentGameIsNewHighscore && gameNetManager != null)
		{
			SingletonManager.Get<JournalPanel>().Show(gameNetManager.IsMultiplayerSession());
		}
	}

	private void Update()
	{
		if (inputManager == null)
		{
			inputManager = Services.GetService<IInputService>();
		}
		if (base.IsVisible && inputManager.KeyboardShortcutEnabled && inputManager.GetControlDown(Control.Chat))
		{
			chatPanelGameOver.Focus();
		}
	}
}
public class GamePausePanel : GuiPanel
{
}
public class GameSelectionPanel : PopupMenuPanel
{
	public delegate void GameSelectionFinishedHandler(bool selectionConfirmed);

	public delegate void HeroUnselectedHandler();

	public delegate void HeroSelectedHandler();

	public delegate void HeroesSelectionFinishedHandler(bool selectionConfirmed, StaticString selectedHero);

	private Dictionary<ulong, bool> readinessByPlayerID = new Dictionary<ulong, bool>();

	private AgeTransform.RefreshTableItem<int> refreshCompetitorSlotDelegate;

	private GameNetworkManager gameNetManager;

	public static readonly StaticString RandomHeroName = "_Random_";

	[SerializeField]
	private AgeTransform shipGroup;

	[SerializeField]
	private AgePrimitiveLabel shipTitleLabel;

	[SerializeField]
	private AgePrimitiveImage shipTitleUnderline;

	[SerializeField]
	private AgePrimitiveLabel shipDescriptionLabel;

	[SerializeField]
	private AgeTransform difficultyGroup;

	[SerializeField]
	private AgeTransform lobbyTypeGroup;

	[SerializeField]
	private AgeTransform competitorsTable;

	[SerializeField]
	private GameObject competitorSlotPrefab;

	[SerializeField]
	private AgeControlButton[] shipSelectButtons;

	[SerializeField]
	private DynamicTextureLoader shipPreviousIconAutoLoader;

	[SerializeField]
	private DynamicTextureLoader shipNextIconAutoLoader;

	[SerializeField]
	private AgeTransform shipLockedGroup;

	[SerializeField]
	private DynamicTextureLoader shipLockedIconAutoLoader;

	[SerializeField]
	private AgePrimitiveLabel shipUnlockDescriptionLabel;

	[SerializeField]
	private AgeControlButton startButton;

	[SerializeField]
	private AgeControlButton cancelButton;

	[SerializeField]
	private AgeControlToggle startReadyToggle;

	[SerializeField]
	private GameDifficultyToggle[] gameDifficultyToggles;

	[SerializeField]
	private LobbyTypeToggle[] lobbyTypeToggles;

	[SerializeField]
	private int maxHeroCount = 4;

	[SerializeField]
	private AgeTransform heroesTable;

	[SerializeField]
	private Transform heroSelectionPfb;

	[SerializeField]
	private AgePrimitiveImage lockedShipImg;

	[SerializeField]
	private ChatPanelLobby chatPanelLobby;

	[SerializeField]
	private AgeTransform xboxDifficultyIcon;

	[SerializeField]
	private AgeTransform xboxLobbyIcon;

	[SerializeField]
	private LobbyType defaultLobbyType;

	private ShipConfig[] allShipConfigs;

	private List<StaticString> availableShips;

	private List<StaticString> lockedShips;

	private StaticString selectedShipName;

	private List<CompetitorSlot> competitorSlots = new List<CompetitorSlot>();

	private int previousHeroCount;

	private Session session;

	private HeroGameStatsData[] selectableHeroes;

	private HeroGameStatsData[] selectableHeroesHidden;

	private List<HeroGameStatsData> selectableHeroesStats;

	private PrivateGameConfigManager privateGameConfigManager;

	private AchievementManagerDOTE achievementManager;

	private ShipSelectionCamera shipSelectionCamera;

	private MainMenuPanel mainMenuPanel;

	private IAudioEventService audioEventManager;

	private IAudioLayeredMusicService musicManager;

	private FMOD.Event ambiantSFX;

	private LayeredEvent musicEvent;

	private FMOD.Event currentShipSFX;

	private int lastUsedSlotIndex;

	private IInputService inputManager;

	private int shipMaxHeroCount;

	private int slotCount;

	private LobbyType currentLobbyType;

	private bool isShipLocked;

	private SelectableManager selectableManager;

	private RequesterPanel requesterPanel;

	private DungeonGenerationSaveData mpSaveData;

	private IDatabase<ShipConfig> shipConfigDB;

	private DLCController dlcController;

	private bool LobbyDataChanged
	{
		get;
		set;
	}

	private Session Session
	{
		get
		{
			return session;
		}
		set
		{
			if (value != session)
			{
				if (session != null)
				{
					session.LobbyDataChange -= Session_LobbyDataChange;
					session.LobbyMemberDataChange -= Session_LobbyMemberDataChange;
					readinessByPlayerID.Clear();
				}
				session = ((value == null || value.IsAborted) ? null : value);
				if (Session != null)
				{
					session.LobbyDataChange += Session_LobbyDataChange;
					session.LobbyMemberDataChange += Session_LobbyMemberDataChange;
				}
				RefreshCompetitorSlots();
			}
		}
	}

	[Service]
	private ISessionService SessionService
	{
		get;
		set;
	}

	[Service]
	private ISteamMatchMakingService SteamMatchMakingService
	{
		get;
		set;
	}

	[Service]
	private INetworkingService NetworkingService
	{
		get;
		set;
	}

	public bool IsMultiplayer
	{
		get;
		private set;
	}

	public bool IsSavedMPGame
	{
		get;
		private set;
	}

	public int MPMinPlayerCount
	{
		get;
		private set;
	}

	public HeroSelectionItem RandomHeroItem
	{
		get;
		set;
	}

	public StaticString[] SelectedHeroes
	{
		get;
		private set;
	}

	public Dictionary<StaticString, HeroSelectionItem> HeroSelectionItemsByHeroName
	{
		get;
		private set;
	}

	private bool isRunningShipTransition
	{
		get;
		set;
	}

	private event GameSelectionFinishedHandler OnGameSelectionFinished;

	public bool IsGameReadyToLaunch()
	{
		if (!base.IsVisible || Session == null)
		{
			return false;
		}
		if (NetworkingService != null && !NetworkingService.IsMultiplayerAvailable)
		{
			return false;
		}
		if (!gameNetManager.IsMultiplayerSession())
		{
			return true;
		}
		if (gameNetManager.GetPlayerCount() < MPMinPlayerCount)
		{
			return false;
		}
		bool[] lobbyMemberDataOfEveryone = Session.GetLobbyMemberDataOfEveryone(Session.MEMBERDATA_IS_READY, defaultValue: false);
		if (lobbyMemberDataOfEveryone != null)
		{
			return lobbyMemberDataOfEveryone.Length >= MPMinPlayerCount && lobbyMemberDataOfEveryone.All((bool b) => b);
		}
		return false;
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		ISteamClientService steamClientService = Services.GetService<ISteamClientService>();
		Diagnostics.Assert(steamClientService != null);
		steamClientService.ClientPersonaStateChanged += ISteamClientService_ClientPersonaStateChanged;
		competitorsTable.DestroyAllChildren();
		refreshCompetitorSlotDelegate = RefreshCompetitorSlot;
		shipLockedIconAutoLoader.Load();
		shipPreviousIconAutoLoader.Load();
		shipNextIconAutoLoader.Load();
		closeOnRightClick = false;
	}

	protected override void OnUnload()
	{
		ISteamClientService service = Services.GetService<ISteamClientService>();
		Diagnostics.Assert(service != null);
		service.ClientPersonaStateChanged -= ISteamClientService_ClientPersonaStateChanged;
		competitorsTable.DestroyAllChildren();
		refreshCompetitorSlotDelegate = null;
		base.OnUnload();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		SessionService = Services.GetService<ISessionService>();
		if (SessionService != null)
		{
			SessionService.SessionChange += SessionService_SessionChange;
			Session = (SessionService.Session as Session);
			startReadyToggle.State = false;
		}
		if (NetworkingService == null)
		{
			NetworkingService = Services.GetService<INetworkingService>();
		}
		shipSelectionCamera.Camera.enabled = true;
		mainMenuPanel.Hide(instant: true);
		SingletonManager.Get<HeroBiographyPanel>().Hide(instant: true);
		SingletonManager.Get<ControlsOverviewPanel>().Hide(instant: true);
		ambiantSFX = audioEventManager.Play2DEvent("Master/GUI/SpaceShip/ShipMenu_Ambiance");
		musicEvent = musicManager.PlayLayeredMusic("SpaceShipSelectionMenu_Music", "SpaceShipSelectionMenu_Music", 0);
		if (chatPanelLobby != null)
		{
			SingletonManager.Get<ChatManager>().ClearHistory();
			chatPanelLobby.ShowIfAvailable();
		}
		if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController && HeroSelectionItemsByHeroName != null && HeroSelectionItemsByHeroName.Count > 0)
		{
			HeroSelectionItem item = HeroSelectionItemsByHeroName.First().Value;
			AGESelectable selectable = item.GetComponentInChildren<AGESelectable>();
			selectableManager.Select(selectable, silent: true);
			selectable.KeepDisplayOnStart = true;
		}
	}

	protected override IEnumerator OnHide(bool instant)
	{
		if (SessionService != null)
		{
			SessionService.SessionChange -= SessionService_SessionChange;
			Session = null;
			SessionService = null;
		}
		shipSelectionCamera.Camera.enabled = false;
		mainMenuPanel.Show();
		LaunchSelectedShipOutAnimation(nextOrPrevious: true, playOutSFX: false);
		selectedShipName = null;
		if (currentShipSFX != null)
		{
			currentShipSFX.stop();
			currentShipSFX = null;
		}
		if (ambiantSFX != null)
		{
			ambiantSFX.stop();
			ambiantSFX = null;
		}
		if (musicEvent != null)
		{
			musicManager.StopMusic(musicEvent.Name);
			musicEvent = null;
		}
		if (chatPanelLobby != null)
		{
			chatPanelLobby.Hide(instant: true);
		}
		allShipConfigs = null;
		availableShips = null;
		lockedShips = null;
		selectableHeroes = null;
		selectableHeroesStats = null;
		yield return base.OnHide(instant);
	}

	private void OnLobbyDataChanged()
	{
		if (Session == null)
		{
			return;
		}
		if (IsGameReadyToLaunch())
		{
			gameNetManager.OnPlayerLeft -= OnPlayerLeftAfterLaunch;
			gameNetManager.OnPlayerLeft += OnPlayerLeftAfterLaunch;
		}
		if (IsGameReadyToLaunch() || IsSavedMPGame)
		{
			gameNetManager.OnServerLeft -= OnServerLeftAfterLaunch;
			gameNetManager.OnServerLeft += OnServerLeftAfterLaunch;
		}
		RefreshCompetitorSlots();
		UpdateInteractivity();
		if (!Session.IsHosting)
		{
			object lobbyDataObject = Session.GetLobbyDataObject(Session.LOBBYDATA_GAME_DIFFICULTY);
			if (lobbyDataObject != null)
			{
				SelectGameDifficulty((lobbyDataObject as string).ToEnum<GameDifficulty>(), syncOverNetwork: false, checkChangeRights: false);
			}
			object lobbyDataObject2 = Session.GetLobbyDataObject(Session.LOBBYDATA_LOBBY_TYPE);
			if (lobbyDataObject2 != null)
			{
				SelectLobbyType((lobbyDataObject2 as string).ToEnum<LobbyType>(), syncOverNetwork: false, checkChangeRights: false);
			}
			object lobbyDataObject3 = Session.GetLobbyDataObject(Session.LOBBYDATA_GAME_SHIP);
			if (lobbyDataObject3 != null)
			{
				UpdateShip((string)lobbyDataObject3, nextOrPrevious: false, syncOverNetwork: false);
			}
		}
	}

	private void OnPlayerLeftAfterLaunch(ulong playerID, StaticString playerLeftName)
	{
		string newValue = playerLeftName ?? ((StaticString)gameNetManager.GetPlayerName(playerID));
		string message = AgeLocalizer.Instance.LocalizeString("%PlayerLeftMessage").Replace("$PlayerName", newValue);
		SingletonManager.Get<RequesterPanel>().Display(message);
	}

	private void OnServerLeftAfterLaunch(ulong playerID, StaticString serverPlayerName)
	{
		Services.GetService<IGameControlService>().GoBackToMainMenu();
		string newValue = serverPlayerName ?? ((StaticString)gameNetManager.GetPlayerName(playerID));
		string message = AgeLocalizer.Instance.LocalizeString("%HostLeftMessage").Replace("$PlayerName", newValue);
		SingletonManager.Get<RequesterPanel>().Display(message);
	}

	private void ISteamClientService_ClientPersonaStateChanged(object sender, PersonaStateChangedEventArgs e)
	{
		Steamworks.PersonaStateChange message = e.Message;
		if ((message.m_nChangeFlags & 1) > 0)
		{
			RefreshCompetitorSlots();
		}
	}

	private void QuitLobbyIfPossible()
	{
		if (CanQuitLobby())
		{
			if (IsMultiplayer)
			{
				SingletonManager.Get<RequesterPanel>().Display("%QuitLobbyConfirm", OnQuitConfirmResult, RequesterPanel.ButtonsMode.YesNo);
			}
			else
			{
				SingletonManager.Get<RequesterPanel>().Display("%QuitSingleConfirm", OnQuitConfirmResult, RequesterPanel.ButtonsMode.YesNo);
			}
		}
	}

	public void QuitLobby(bool instantHide = false)
	{
		Services.GetService<IRuntimeService>()?.Runtime.FiniteStateMachine.PostStateChange(typeof(RuntimeState_OutGame));
		if (this.OnGameSelectionFinished != null)
		{
			this.OnGameSelectionFinished(selectionConfirmed: false);
		}
		gameNetManager.StopMonitorPlayerLeft();
		gameNetManager.StopMonitorServerLeft();
		Hide(instantHide);
	}

	private void UpdateReadinessByPlayerID(ulong playerID)
	{
		if (Session == null)
		{
			return;
		}
		if (!readinessByPlayerID.ContainsKey(playerID))
		{
			readinessByPlayerID.Add(playerID, value: false);
		}
		bool lobbyMemberData = Session.GetLobbyMemberData(playerID, Session.MEMBERDATA_IS_READY, defaultValue: false);
		if (readinessByPlayerID[playerID] != lobbyMemberData)
		{
			readinessByPlayerID[playerID] = lobbyMemberData;
			if (readinessByPlayerID.Values.All((bool ready) => ready))
			{
				audioEventManager.Play2DEvent("Master/GUI/Lobby/AllReady");
			}
			else if (lobbyMemberData)
			{
				audioEventManager.Play2DEvent("Master/GUI/Lobby/Ready");
			}
			else
			{
				audioEventManager.Play2DEvent("Master/GUI/Lobby/UnReady");
			}
		}
	}

	private void OnGameDifficultyButtonClick()
	{
		SingletonManager.Get<GameDifficultySelectionPanel>().StartSelection();
	}

	private void OnStartReadyToggleCB()
	{
		SetLocalPlayerReadyState(startReadyToggle.State);
	}

	private void SetLocalPlayerReadyState(bool ready)
	{
		if (!IsGameReadyToLaunch())
		{
			startReadyToggle.State = ready;
			Session.LocalPlayerReady = ready;
			startReadyToggle.AgeTransform.Enable = false;
			if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController)
			{
				RefreshContent();
			}
		}
	}

	private void RefreshCompetitorSlots()
	{
		if (Session == null)
		{
			competitorsTable.DestroyAllChildren();
			return;
		}
		competitorSlots.Clear();
		List<int> list = new List<int>(slotCount);
		for (int i = 0; i < slotCount; i++)
		{
			list.Add(i);
		}
		competitorsTable.ReserveChildren(slotCount, competitorSlotPrefab.transform);
		competitorsTable.RefreshChildrenIList(list, refreshCompetitorSlotDelegate, enableTheVisible: true, strictVisibility: true);
	}

	private void RefreshCompetitorSlot(AgeTransform tableItem, int title, int index)
	{
		if (tableItem == null)
		{
			throw new InvalidOperationException();
		}
		CompetitorSlot component = tableItem.GetComponent<CompetitorSlot>();
		if (component != null)
		{
			component.RefreshContent(index);
			competitorSlots.Add(component);
		}
	}

	private void Session_LobbyDataChange(object sender, LobbyDataChangeEventArgs e)
	{
		LobbyDataChanged = true;
	}

	private void Session_LobbyMemberDataChange(object sender, LobbyMemberDataChangeEventArgs e)
	{
		UpdateReadinessByPlayerID(e.MemberID);
		LobbyDataChanged = true;
	}

	private void SessionService_SessionChange(object sender, SessionChangeEventArgs e)
	{
		switch (e.Action)
		{
		case SessionChangeAction.Opening:
		case SessionChangeAction.Closed:
		case SessionChangeAction.Reopening:
			break;
		case SessionChangeAction.Reopened:
			break;
		case SessionChangeAction.Releasing:
		case SessionChangeAction.Released:
			Session = null;
			break;
		case SessionChangeAction.Opened:
			Session = (e.Session as Session);
			break;
		case SessionChangeAction.OwnerChanged:
			RefreshContent();
			break;
		}
	}

	private void LobbyPingUpdate()
	{
		if (base.IsVisible && IsMultiplayer && gameNetManager.IsServer())
		{
			session.PushAllLobbyData();
		}
	}

	public override void OnEscapeBehavior()
	{
		QuitLobbyIfPossible();
	}

	public override void ClosePanel()
	{
		QuitLobbyIfPossible();
	}

	protected override void Awake()
	{
		base.Awake();
		inputManager = Services.GetService<IInputService>();
		selectableManager = SingletonManager.Get<SelectableManager>();
	}

	protected override IEnumerator Start()
	{
		yield return StartCoroutine(base.Start());
		privateGameConfigManager = SingletonManager.Get<PrivateGameConfigManager>();
		achievementManager = SingletonManager.Get<AchievementManagerDOTE>();
		audioEventManager = Services.GetService<IAudioEventService>();
		musicManager = Services.GetService<IAudioLayeredMusicService>();
		dlcController = SingletonManager.Get<DLCController>();
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
		shipSelectionCamera = SingletonManager.Get<ShipSelectionCamera>();
		mainMenuPanel = SingletonManager.Get<MainMenuPanel>();
	}

	public void Display(bool isMultiplayer = false, string mpSaveKey = null, int slotCount = -1, GameSelectionFinishedHandler onGameSelectionFinished = null)
	{
		if (base.IsVisible)
		{
			Diagnostics.LogWarning("GameSelectionPanel.Display: already displayed!");
			return;
		}
		if (shipConfigDB == null)
		{
			shipConfigDB = Databases.GetDatabase<ShipConfig>();
		}
		IsMultiplayer = isMultiplayer;
		Session session = gameNetManager.GetSession();
		IsSavedMPGame = !string.IsNullOrEmpty(mpSaveKey);
		mpSaveData = null;
		if (IsSavedMPGame && gameNetManager.IsServer())
		{
			mpSaveData = GameSave.GetBestSaveData(mpSaveKey, multiplayer: true, reportErrors: false);
		}
		MPMinPlayerCount = gameNetManager.GetMultiplayerMinPlayerCount();
		if (mpSaveData != null)
		{
			int stillConnectedPlayerCount = mpSaveData.GetStillConnectedPlayerCount();
			if (stillConnectedPlayerCount < MPMinPlayerCount)
			{
				MPMinPlayerCount = stillConnectedPlayerCount;
			}
		}
		int num = 0;
		while (true)
		{
			DungeonGenerationParams nextDungeonGenerationParams = Dungeon.NextDungeonGenerationParams;
			if (nextDungeonGenerationParams.NewGame_SelectedHeroes == null)
			{
				break;
			}
			int num2 = num;
			DungeonGenerationParams nextDungeonGenerationParams2 = Dungeon.NextDungeonGenerationParams;
			if (num2 >= nextDungeonGenerationParams2.NewGame_SelectedHeroes.Length)
			{
				break;
			}
			DungeonGenerationParams nextDungeonGenerationParams3 = Dungeon.NextDungeonGenerationParams;
			nextDungeonGenerationParams3.NewGame_SelectedHeroes[num] = RandomHeroName;
			num++;
		}
		if (competitorsTable != null)
		{
			competitorsTable.DestroyAllChildren();
			competitorSlots.Clear();
		}
		this.OnGameSelectionFinished = onGameSelectionFinished;
		allShipConfigs = shipConfigDB.GetValues();
		availableShips = new List<StaticString>();
		for (int i = 0; i < allShipConfigs.Length; i++)
		{
			ShipConfig shipConfig = allShipConfigs[i];
			if (dlcController.IsObjectAvailable(DLCObjectType.Ship, shipConfig.Name) && (!IsMultiplayer || !shipConfig.ForbidMultiplayer))
			{
				availableShips.Add(shipConfig.Name);
			}
		}
		selectedShipName = null;
		if (mpSaveData != null)
		{
			UpdateShip(mpSaveData.ShipName, nextOrPrevious: true, syncOverNetwork: true, refreshContent: false);
		}
		else
		{
			UpdateShip(shipConfigDB.GetValues()[0].Name, nextOrPrevious: true, syncOverNetwork: true, refreshContent: false);
		}
		selectableHeroes = UserProfile.GetSelectableHeroes();
		selectableHeroesStats = new List<HeroGameStatsData>(selectableHeroes);
		selectableHeroesStats.Add(new HeroGameStatsData
		{
			ConfigName = RandomHeroName,
			Status = HeroStatus.Unlocked
		});
		selectableHeroesHidden = UserProfile.GetSelectableHeroes(hiddenHeroesOnly: true);
		this.slotCount = ((slotCount <= 0) ? maxHeroCount : slotCount);
		SelectedHeroes = new StaticString[this.slotCount];
		for (int j = 0; j < this.slotCount; j++)
		{
			SelectedHeroes[j] = RandomHeroName;
			if (!IsSavedMPGame || mpSaveData == null)
			{
				continue;
			}
			ulong iD = mpSaveData.Players[j].ID;
			StaticString staticString = RandomHeroName;
			if (mpSaveData is GameSaveData)
			{
				GameSaveData gameSaveData = mpSaveData as GameSaveData;
				for (int k = 0; k < gameSaveData.Heroes.Length; k++)
				{
					if (gameSaveData.Heroes[k].OwnerPlayerID == iD)
					{
						staticString = gameSaveData.Heroes[k].SimDescName;
						break;
					}
				}
			}
			else
			{
				for (int l = 0; l < mpSaveData.HeroesPersistent.Length; l++)
				{
					if (mpSaveData.HeroesPersistent[l].OwnerPlayerID == iD)
					{
						staticString = mpSaveData.HeroesPersistent[l].HeroDescName;
						break;
					}
				}
			}
			string x = string.Format(Session.LOBBYDATA_HERO_BY_PLAYER_ID, iD);
			session.SetLobbyData(x, staticString.ToString());
		}
		competitorSlots.Clear();
		for (int m = 0; m < SelectedHeroes.Length; m++)
		{
			SelectHero(m, SelectedHeroes[m]);
		}
		Dungeon.SetSelectedHeroes(SelectedHeroes);
		lockedShips = new List<StaticString>();
		if (gameNetManager.IsServerOrSinglePlayer())
		{
			ShipUnlockData[] shipUnlocks = privateGameConfigManager.ShipUnlocks;
			foreach (StaticString availableShip in availableShips)
			{
				bool flag = false;
				try
				{
					bool flag2 = false;
					ShipUnlockData shipUnlockData = default(ShipUnlockData);
					for (int n = 0; n < shipUnlocks.Length; n++)
					{
						if (shipUnlocks[n].ShipName == availableShip)
						{
							shipUnlockData = shipUnlocks[n];
							flag2 = true;
							break;
						}
					}
					if (flag2)
					{
						foreach (AchievementName item in shipUnlockData.UnlockingAchievement)
						{
							if (achievementManager.GetAchievement(item))
							{
								flag = true;
								Diagnostics.Log("Ship {0} is unlocked thanks to {1}", availableShip, item.ToString());
								break;
							}
						}
					}
					else
					{
						flag = true;
					}
					if (!flag)
					{
						lockedShips.Add(availableShip);
					}
				}
				catch (Exception ex)
				{
					Diagnostics.LogError("Exception raised while retrieving ShipUnlockData for ship name {0}: {1}\n{2}", availableShip, ex.Message, ex.StackTrace);
				}
			}
		}
		if (mpSaveData != null)
		{
			SelectGameDifficulty(mpSaveData.GameDifficulty, syncOverNetwork: true, checkChangeRights: false);
		}
		else if (gameNetManager.IsServerOrSinglePlayer())
		{
			SelectGameDifficulty(GameDifficulty.Normal, syncOverNetwork: true, checkChangeRights: false);
		}
		if (gameNetManager.IsServer())
		{
			SelectLobbyType((!IsSavedMPGame) ? defaultLobbyType : LobbyType.Private, syncOverNetwork: true, checkChangeRights: false);
		}
		List<HeroGameStatsData> list = new List<HeroGameStatsData>(UserProfile.Data.HeroesGameStats);
		foreach (HeroGameStatsData item2 in list)
		{
			if (Databases.GetDatabase<HeroConfig>().GetValue(item2.ConfigName) == null)
			{
				Diagnostics.LogWarning(item2.ConfigName + " was found in profile but not in config");
				UserProfile.Data.HeroesGameStats.Remove(item2);
			}
		}
		GoogleAnalyticsManager googleAnalyticsManager = SingletonManager.Get<GoogleAnalyticsManager>();
		if (googleAnalyticsManager != null && !googleAnalyticsManager.SentUnlockAnalytics)
		{
			googleAnalyticsManager.SendUnlockAnalytics(allShipConfigs.Length - lockedShips.Count, selectableHeroes.Count((HeroGameStatsData hero) => hero.Status == HeroStatus.Unlocked));
		}
		LaunchSelectedShipInAnimation();
		RefreshContent();
		Steamworks.SteamAPI.SteamFriends.SetRichPresence("status", AgeLocalizer.Instance.LocalizeString((!IsMultiplayer) ? "%RichPresenceInSinglePlayerLobby" : "%RichPresenceInMultiplayerLobby"));
		Show();
		GuiPanel guiPanel = SingletonManager.Get<CreditsPanel>();
		if (guiPanel != null)
		{
			guiPanel.Hide(instant: true);
		}
		guiPanel = SingletonManager.Get<JournalPanel>();
		if (guiPanel != null)
		{
			guiPanel.Hide(instant: true);
		}
		guiPanel = SingletonManager.Get<OptionsPanel>();
		if (guiPanel != null)
		{
			guiPanel.Hide(instant: true);
		}
		guiPanel = SingletonManager.Get<SessionListPanel>();
		if (guiPanel != null)
		{
			guiPanel.Hide(instant: true);
		}
		guiPanel = SingletonManager.Get<AlbumPanel>();
		if (guiPanel != null)
		{
			guiPanel.Hide(instant: true);
		}
		guiPanel = SingletonManager.Get<SituationDialogPanel>();
		if (guiPanel != null)
		{
			guiPanel.Hide(instant: true);
		}
		guiPanel = SingletonManager.Get<StoryDialogPanel>();
		if (guiPanel != null)
		{
			guiPanel.Hide(instant: true);
		}
		GuiModalPanel guiModalPanel = SingletonManager.Get<RequesterPanel>();
		if (guiModalPanel != null)
		{
			guiModalPanel.Hide(instant: true);
		}
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		isShipLocked = IsSelectedShipLocked();
		ShipConfig value = shipConfigDB.GetValue(selectedShipName);
		shipTitleLabel.Text = value.GetLocalizedName(isShipLocked);
		shipTitleLabel.AgeTransform.Width = shipTitleLabel.Font.ComputeTextWidth(shipTitleLabel.Text);
		shipTitleUnderline.AgeTransform.Width = shipTitleLabel.AgeTransform.Width;
		shipDescriptionLabel.AgeTransform.Height = 0f;
		shipDescriptionLabel.ForceText(value.GetLocalizedDescription());
		if (isShipLocked)
		{
			shipLockedGroup.Visible = true;
			shipUnlockDescriptionLabel.Text = value.GetLocalizedUnlockDescription();
		}
		else
		{
			shipLockedGroup.Visible = false;
			shipUnlockDescriptionLabel.Text = string.Empty;
		}
		shipGroup.Height = shipDescriptionLabel.AgeTransform.Y + shipDescriptionLabel.AgeTransform.Height;
		float num = shipGroup.Y + shipGroup.Height;
		difficultyGroup.Y = num + difficultyGroup.PixelMarginTop;
		num = difficultyGroup.Y + difficultyGroup.Height;
		lobbyTypeGroup.Visible = IsMultiplayer;
		if (IsMultiplayer)
		{
			lobbyTypeGroup.Y = num + lobbyTypeGroup.PixelMarginTop;
			num = lobbyTypeGroup.Y + lobbyTypeGroup.Height;
		}
		if (chatPanelLobby != null)
		{
			chatPanelLobby.AgeTransform.PixelMarginTop = num + chatPanelLobby.InputTextField.AgeTransform.Height;
			chatPanelLobby.OnResized();
		}
		lockedShipImg.AgeTransform.Visible = (isShipLocked && mpSaveData == null && gameNetManager.IsServerOrSinglePlayer());
		int num2 = shipMaxHeroCount;
		shipMaxHeroCount = (int)GameConfig.GetGameConfig().PlayerInitHeroCount.GetValue();
		DungeonGenerationParams nextDungeonGenerationParams = Dungeon.NextDungeonGenerationParams;
		if (nextDungeonGenerationParams.NewGame_SelectedHeroes != null)
		{
			int i = num2;
			while (true)
			{
				int num3 = i;
				int a = shipMaxHeroCount;
				DungeonGenerationParams nextDungeonGenerationParams2 = Dungeon.NextDungeonGenerationParams;
				if (num3 >= Mathf.Min(a, nextDungeonGenerationParams2.NewGame_SelectedHeroes.Length))
				{
					break;
				}
				DungeonGenerationParams nextDungeonGenerationParams3 = Dungeon.NextDungeonGenerationParams;
				if (nextDungeonGenerationParams3.NewGame_SelectedHeroes.Count(delegate(StaticString hero)
				{
					DungeonGenerationParams nextDungeonGenerationParams5 = Dungeon.NextDungeonGenerationParams;
					return hero == nextDungeonGenerationParams5.NewGame_SelectedHeroes[i];
				}) > 1)
				{
					DungeonGenerationParams nextDungeonGenerationParams4 = Dungeon.NextDungeonGenerationParams;
					nextDungeonGenerationParams4.NewGame_SelectedHeroes[i] = RandomHeroName;
				}
				i++;
			}
		}
		UnbindHeroSelectionItems();
		if (HeroSelectionItemsByHeroName == null)
		{
			HeroSelectionItemsByHeroName = new Dictionary<StaticString, HeroSelectionItem>();
		}
		else
		{
			HeroSelectionItemsByHeroName.Clear();
		}
		heroesTable.ReserveChildren(selectableHeroesStats.Count, heroSelectionPfb, "HeroSelectionItem");
		heroesTable.RefreshChildrenArray(selectableHeroesStats.ToArray(), RefreshHeroSelectionItem);
		if (IsMultiplayer)
		{
			return;
		}
		competitorSlots.Clear();
		competitorsTable.DestroyAllChildren();
		int num4 = (mpSaveData == null) ? shipMaxHeroCount : mpSaveData.GetStillConnectedPlayerCount();
		for (int j = 0; j < num4; j++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(competitorSlotPrefab);
			gameObject.name = j.ToString() + "-HeroSlot";
			gameObject.transform.parent = competitorsTable.transform;
			CompetitorSlot component = gameObject.GetComponent<CompetitorSlot>();
			component.SetSlotIndex(j);
			if (SelectedHeroes.Length > j && !string.IsNullOrEmpty(SelectedHeroes[j]))
			{
				component.UpdateHero(GetHeroStats(SelectedHeroes[j]));
			}
			competitorSlots.Add(component);
		}
		competitorsTable.ArrangeChildren();
		competitorsTable.Enable = !IsSelectedShipLocked();
	}

	private SpriteAnimationRuntime2 GetShipAnimation(StaticString shipName)
	{
		return shipSelectionCamera.GetShipAnimation(shipName);
	}

	private void LaunchSelectedShipInAnimation()
	{
		SpriteAnimationRuntime2 shipAnimation = GetShipAnimation(selectedShipName);
		shipAnimation.MonitorAnimEvent("OnShipArrived", OnShipArrivedAnimEvent);
		shipAnimation.SetBool(SpriteAnimationBool.IsSelected, value: true);
		ShipConfig value = shipConfigDB.GetValue(selectedShipName);
		currentShipSFX = audioEventManager.Play2DEvent("Master/GUI/SpaceShip/SpaceShip_" + value.Name);
		isRunningShipTransition = true;
		UpdateInteractivity();
	}

	private void LaunchSelectedShipOutAnimation(bool nextOrPrevious, bool playOutSFX = true)
	{
		SpriteAnimationRuntime2 shipAnimation = GetShipAnimation(selectedShipName);
		shipAnimation.SetBool(SpriteAnimationBool.NextOrPrevious, nextOrPrevious);
		shipAnimation.SetBool(SpriteAnimationBool.IsSelected, value: false);
		if (currentShipSFX != null)
		{
			currentShipSFX.stop();
		}
		if (playOutSFX)
		{
			ShipConfig value = shipConfigDB.GetValue(selectedShipName);
			audioEventManager.Play2DEvent("Master/GUI/SpaceShip/SpaceShip_Start_" + value.Name);
		}
	}

	private void LaunchSelectedShipConfirmAnimation()
	{
		isRunningShipTransition = true;
		UpdateInteractivity();
		SpriteAnimationRuntime2 shipAnimation = GetShipAnimation(selectedShipName);
		shipAnimation.MonitorAnimEvent("OnConfirmEnd", OnConfirmEndAnimEvent);
		shipAnimation.Trigger(SpriteAnimationTrigger.OnConfirm);
		if (currentShipSFX != null)
		{
			currentShipSFX.stop();
		}
		ShipConfig value = shipConfigDB.GetValue(selectedShipName);
		audioEventManager.Play2DEvent("Master/GUI/SpaceShip/SpaceShip_Start_" + value.Name);
	}

	private void OnShipArrivedAnimEvent()
	{
		SpriteAnimationRuntime2 shipAnimation = GetShipAnimation(selectedShipName);
		shipAnimation.UnmonitorAnimEvent("OnShipArrived", OnShipArrivedAnimEvent);
		isRunningShipTransition = false;
		UpdateInteractivity();
	}

	private void OnConfirmBackToMainMenu(RequesterPanel.Result result)
	{
		if (result == RequesterPanel.Result.Yes)
		{
			QuitLobbyIfPossible();
		}
	}

	private void OnConfirmEndAnimEvent()
	{
		SpriteAnimationRuntime2 shipAnimation = GetShipAnimation(selectedShipName);
		shipAnimation.UnmonitorAnimEvent("OnConfirmEnd", OnConfirmEndAnimEvent);
		if (this.OnGameSelectionFinished != null)
		{
			this.OnGameSelectionFinished(selectionConfirmed: true);
		}
		Hide();
		mainMenuPanel.Hide(instant: true);
	}

	private void OnNextShipButtonClick()
	{
		SelectNextShip();
	}

	private void SelectNextShip()
	{
		if (CanChangeShip())
		{
			Services.GetService<IGuiTooltipService>().HideTooltip();
			int num = availableShips.IndexOf(selectedShipName);
			num = ((num < availableShips.Count - 1) ? (num + 1) : 0);
			GetShipAnimation(selectedShipName).SetBool(SpriteAnimationBool.NextOrPrevious, value: true);
			UpdateShip(availableShips[num]);
		}
	}

	private void OnPreviousShipButtonClick()
	{
		SelectPreviousShip();
	}

	private void SelectPreviousShip()
	{
		if (CanChangeShip())
		{
			Services.GetService<IGuiTooltipService>().HideTooltip();
			int num = availableShips.IndexOf(selectedShipName);
			num = ((num > 0) ? (num - 1) : (availableShips.Count - 1));
			UpdateShip(availableShips[num], nextOrPrevious: false);
		}
	}

	private void UpdateShip(StaticString shipName, bool nextOrPrevious = true, bool syncOverNetwork = true, bool refreshContent = true)
	{
		if (!(shipName == selectedShipName))
		{
			if (selectedShipName != null)
			{
				LaunchSelectedShipOutAnimation(nextOrPrevious);
			}
			selectedShipName = shipName;
			Dungeon.SetShip(selectedShipName);
			if (syncOverNetwork && gameNetManager.IsServer())
			{
				Session session = gameNetManager.GetSession();
				session.SetLobbyData(Session.LOBBYDATA_GAME_SHIP, selectedShipName.ToString());
			}
			LaunchSelectedShipInAnimation();
			if (refreshContent)
			{
				RefreshContent();
			}
		}
	}

	protected virtual void Update()
	{
		if (LobbyDataChanged)
		{
			OnLobbyDataChanged();
			LobbyDataChanged = false;
		}
		if (!base.AgeTransform.Visible || !base.IsVisible)
		{
			return;
		}
		if (inputManager == null)
		{
			inputManager = Services.GetService<IInputService>();
		}
		if (gameNetManager == null)
		{
			gameNetManager = SingletonManager.Get<GameNetworkManager>();
		}
		if (requesterPanel == null)
		{
			requesterPanel = SingletonManager.Get<RequesterPanel>();
		}
		if (requesterPanel.IsVisible)
		{
			return;
		}
		if (gameNetManager.IsServerOrSinglePlayer())
		{
			if (inputManager.GetControlDown(Control.PreviousShip))
			{
				SelectPreviousShip();
			}
			else if (inputManager.GetControlDown(Control.NextShip))
			{
				SelectNextShip();
			}
			if (inputManager.GetControlDown(Control.ChangeDifficulty))
			{
				DungeonGenerationParams nextDungeonGenerationParams = Dungeon.NextDungeonGenerationParams;
				SelectGameDifficulty(((int)(nextDungeonGenerationParams.GameDifficulty + 1) % GenericUtilities.GetEnumValues<GameDifficulty>().Length).ToEnum<GameDifficulty>());
				if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController)
				{
					xboxDifficultyIcon.StartAllModifiers();
				}
			}
			if (IsMultiplayer && inputManager.GetControlDown(Control.ChangeLobbyType))
			{
				SelectLobbyType(((int)(currentLobbyType + 1) % GenericUtilities.GetEnumValues<LobbyType>().Length).ToEnum<LobbyType>());
				if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController)
				{
					xboxLobbyIcon.StartAllModifiers();
				}
			}
		}
		if (inputManager.GetControlDown(Control.StartGame) && CanChangeMPReadyState())
		{
			if (IsMultiplayer)
			{
				SetLocalPlayerReadyState(!startReadyToggle.State);
				if (startReadyToggle.State)
				{
					selectableManager.UnsetCategory(SelectionCategory.GameSelectionPanel);
				}
				else
				{
					selectableManager.SetCategory(SelectionCategory.GameSelectionPanel);
				}
			}
			else
			{
				StartGame();
			}
		}
		if (IsMultiplayer && inputManager.GetControlDown(Control.Chat))
		{
			chatPanelLobby.Focus();
		}
	}

	public void SetSelectedHero(int index, StaticString heroConfigName)
	{
		SelectedHeroes[index] = heroConfigName;
		Dungeon.SetSelectedHeroes(SelectedHeroes);
	}

	private void OnCancelButtonClick()
	{
		QuitLobbyIfPossible();
	}

	private void OnStartButtonClick()
	{
		if (!isShipLocked)
		{
			StartGame();
		}
	}

	private void StartGame()
	{
		LaunchSelectedShipConfirmAnimation();
	}

	private void OnQuitConfirmResult(RequesterPanel.Result result)
	{
		if (result == RequesterPanel.Result.Yes)
		{
			QuitLobby();
		}
	}

	private void OnEasyDifficultyToggleClick(GameObject eventSender)
	{
		if (CanChangeDifficulty())
		{
			SelectGameDifficulty(GameDifficulty.Easy);
		}
	}

	private void OnNormalDifficultyToggleClick(GameObject eventSender)
	{
		if (CanChangeDifficulty())
		{
			SelectGameDifficulty(GameDifficulty.Normal);
		}
	}

	private void OnPrivateLobbyToggleClick(GameObject eventSender)
	{
		if (CanChangeLobbyType())
		{
			SelectLobbyType(LobbyType.Private);
		}
	}

	private void OnFriendsLobbyToggleClick(GameObject eventSender)
	{
		if (CanChangeLobbyType())
		{
			SelectLobbyType(LobbyType.Friends);
		}
	}

	private void OnPublicLobbyToggleClick(GameObject eventSender)
	{
		if (CanChangeLobbyType())
		{
			SelectLobbyType(LobbyType.Public);
		}
	}

	private void SelectGameDifficulty(GameDifficulty difficulty, bool syncOverNetwork = true, bool checkChangeRights = true)
	{
		if (!checkChangeRights || CanChangeDifficulty())
		{
			Dungeon.SetGameDifficulty(difficulty);
			if (IsMultiplayer && syncOverNetwork)
			{
				Session session = gameNetManager.GetSession();
				session.SetLobbyData(Session.LOBBYDATA_GAME_DIFFICULTY, difficulty.ToString());
			}
			GameDifficultyToggle[] array = gameDifficultyToggles;
			for (int i = 0; i < array.Length; i++)
			{
				GameDifficultyToggle gameDifficultyToggle = array[i];
				gameDifficultyToggle.Toggle.State = (gameDifficultyToggle.Difficulty == difficulty);
			}
		}
	}

	private void SelectLobbyType(LobbyType type, bool syncOverNetwork = true, bool checkChangeRights = true)
	{
		if (!checkChangeRights || CanChangeLobbyType())
		{
			currentLobbyType = type;
			if (IsMultiplayer && syncOverNetwork)
			{
				Session session = gameNetManager.GetSession();
				session.SetLobbyData(Session.LOBBYDATA_LOBBY_TYPE, type.ToString());
			}
			LobbyTypeToggle[] array = lobbyTypeToggles;
			for (int i = 0; i < array.Length; i++)
			{
				LobbyTypeToggle lobbyTypeToggle = array[i];
				lobbyTypeToggle.Toggle.State = (lobbyTypeToggle.Type == type);
			}
		}
	}

	private void UnbindHeroSelectionItems()
	{
		List<HeroSelectionItem> children = heroesTable.GetChildren<HeroSelectionItem>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
		}
	}

	private void RefreshHeroSelectionItem(AgeTransform tableItem, HeroGameStatsData heroStats, int index)
	{
		HeroSelectionItem component = tableItem.GetComponent<HeroSelectionItem>();
		List<int> list = new List<int>();
		for (int i = 0; i < SelectedHeroes.Length; i++)
		{
			if (heroStats.ConfigName == SelectedHeroes[i])
			{
				list.Add(i);
			}
		}
		if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			HeroItemSelectable component2 = tableItem.GetComponent<HeroItemSelectable>();
			component2.IsShipLocked = isShipLocked;
			if (component2.IsRegistered && isShipLocked && selectableManager.GetCurrentCategorySelectedElement() != component2)
			{
				component2.Unregister();
			}
			else if (!component2.IsRegistered && !isShipLocked)
			{
				component2.Register();
			}
		}
		component.Bind(heroStats, list);
		component.RefreshContent();
		HeroSelectionItemsByHeroName.Add(heroStats.ConfigName, component);
		if (inputManager.CurrentControlScheme != 0 && heroStats.ConfigName == RandomHeroName)
		{
			tableItem.Visible = false;
		}
	}

	public HeroGameStatsData GetHeroStats(StaticString heroConfigName)
	{
		for (int i = 0; i < selectableHeroesStats.Count; i++)
		{
			HeroGameStatsData heroGameStatsData = selectableHeroesStats[i];
			if (heroGameStatsData.ConfigName == heroConfigName)
			{
				return selectableHeroesStats[i];
			}
		}
		for (int j = 0; j < selectableHeroesHidden.Length; j++)
		{
			if (selectableHeroesHidden[j].ConfigName == heroConfigName)
			{
				return selectableHeroesHidden[j];
			}
		}
		Diagnostics.LogError("Could not find " + heroConfigName);
		return default(HeroGameStatsData);
	}

	public int GetLocalPlayerIndex()
	{
		for (int i = 0; i < competitorSlots.Count; i++)
		{
			if (competitorSlots[i].CompetitorIsLocalOwner)
			{
				return i;
			}
		}
		return -1;
	}

	public void TrySelectHero(StaticString heroConfigName)
	{
		if (!CanChangeHero())
		{
			return;
		}
		int num = -1;
		if (IsMultiplayer)
		{
			num = GetLocalPlayerIndex();
		}
		else
		{
			for (int i = 0; i < shipMaxHeroCount; i++)
			{
				if (SelectedHeroes[i] == RandomHeroName)
				{
					num = i;
					break;
				}
			}
			if (num < 0)
			{
				num = Mathf.Min(lastUsedSlotIndex, shipMaxHeroCount - 1);
			}
		}
		if (num >= 0)
		{
			lastUsedSlotIndex = num;
			SelectHero(num, heroConfigName);
		}
	}

	public void TryUnselectHero(StaticString heroConfigName)
	{
		if (!CanChangeHero())
		{
			return;
		}
		int num = -1;
		if (IsMultiplayer)
		{
			num = GetLocalPlayerIndex();
		}
		else
		{
			for (int i = 0; i < shipMaxHeroCount; i++)
			{
				if (SelectedHeroes[i] == heroConfigName)
				{
					num = i;
					break;
				}
			}
		}
		if (num < 0)
		{
			Diagnostics.LogError("Unable to unselect " + heroConfigName + ": not in selected heroes list");
		}
		else
		{
			SelectHero(num, RandomHeroName);
		}
	}

	public void SelectHero(int playerIndex, StaticString heroConfigName)
	{
		if (IsMultiplayer && !IsSavedMPGame && playerIndex == gameNetManager.GetLocalPlayerSlotIndex())
		{
			Session session = gameNetManager.GetSession();
			session.SetLobbyMemberData(Session.MEMBERDATA_HERO, heroConfigName);
		}
		if (competitorSlots.Count > playerIndex)
		{
			competitorSlots[playerIndex].UpdateHero(GetHeroStats(heroConfigName));
		}
	}

	private bool CanChangeShip()
	{
		if (isRunningShipTransition)
		{
			return false;
		}
		if (IsSavedMPGame)
		{
			return false;
		}
		if (IsMultiplayer && !gameNetManager.IsServer())
		{
			return false;
		}
		if (Session != null && Session.LocalPlayerReady)
		{
			return false;
		}
		return !IsGameReadyToLaunch();
	}

	private bool CanChangeDifficulty()
	{
		if (isRunningShipTransition)
		{
			return false;
		}
		if (IsSavedMPGame)
		{
			return false;
		}
		if (IsMultiplayer && !gameNetManager.IsServer())
		{
			return false;
		}
		if (Session != null && Session.LocalPlayerReady)
		{
			return false;
		}
		if (IsSelectedShipLocked())
		{
			return false;
		}
		return !IsGameReadyToLaunch();
	}

	private bool CanChangeLobbyType()
	{
		if (isRunningShipTransition)
		{
			return false;
		}
		if (IsSavedMPGame)
		{
			return false;
		}
		if (IsMultiplayer && !gameNetManager.IsServer())
		{
			return false;
		}
		if (Session != null && Session.LocalPlayerReady)
		{
			return false;
		}
		if (IsSelectedShipLocked())
		{
			return false;
		}
		return !IsGameReadyToLaunch();
	}

	private bool CanChangeHero()
	{
		if (isRunningShipTransition)
		{
			return false;
		}
		if (IsSavedMPGame)
		{
			return false;
		}
		if (gameNetManager.IsServerOrSinglePlayer() && IsSelectedShipLocked())
		{
			return false;
		}
		if (Session != null && Session.LocalPlayerReady)
		{
			return false;
		}
		return !IsGameReadyToLaunch();
	}

	private bool CanChangeMPReadyState()
	{
		if (isRunningShipTransition)
		{
			return false;
		}
		if (gameNetManager.IsServerOrSinglePlayer() && IsSelectedShipLocked() && mpSaveData == null)
		{
			return false;
		}
		if (gameNetManager.IsMultiplayerSession() && gameNetManager.GetPlayerCount() == 1)
		{
			return true;
		}
		if (gameNetManager.IsMultiplayerSession() && gameNetManager.GetPlayerCount() < MPMinPlayerCount)
		{
			return false;
		}
		return !IsGameReadyToLaunch();
	}

	private bool CanStartSoloGame()
	{
		if (isRunningShipTransition)
		{
			return false;
		}
		if (IsSelectedShipLocked())
		{
			return false;
		}
		return true;
	}

	private bool CanQuitLobby()
	{
		if (isRunningShipTransition)
		{
			return false;
		}
		return !IsGameReadyToLaunch();
	}

	private bool IsSelectedShipLocked()
	{
		if (selectedShipName == null)
		{
			return false;
		}
		if (!availableShips.Contains(selectedShipName))
		{
			return true;
		}
		return lockedShips.Contains(selectedShipName);
	}

	private void UpdateInteractivity()
	{
		startButton.AgeTransform.Visible = !IsMultiplayer;
		startButton.AgeTransform.Enable = (!IsMultiplayer && !isShipLocked && CanStartSoloGame());
		startReadyToggle.AgeTransform.Visible = IsMultiplayer;
		if (IsMultiplayer && gameNetManager.GetPlayerCount() < MPMinPlayerCount)
		{
			startReadyToggle.AgeTransform.Enable = startReadyToggle.State;
			startReadyToggle.AgeTransform.AgeTooltip.Content = AgeLocalizer.Instance.LocalizeString("%StartReadyToggle_NeedAtLeastNPlayers").Replace("$MinPlayersCount", MPMinPlayerCount.ToString());
		}
		else if (CanChangeMPReadyState())
		{
			startReadyToggle.AgeTransform.Enable = true;
			startReadyToggle.AgeTransform.AgeTooltip.Content = string.Empty;
		}
		else
		{
			startReadyToggle.AgeTransform.Enable = false;
			startReadyToggle.AgeTransform.AgeTooltip.Content = string.Empty;
		}
		cancelButton.AgeTransform.Enable = CanQuitLobby();
		AgeControlButton[] array = shipSelectButtons;
		foreach (AgeControlButton ageControlButton in array)
		{
			ageControlButton.AgeTransform.Visible = CanChangeShip();
			ageControlButton.AgeTransform.Enable = CanChangeShip();
		}
		GameDifficultyToggle[] array2 = gameDifficultyToggles;
		for (int j = 0; j < array2.Length; j++)
		{
			GameDifficultyToggle gameDifficultyToggle = array2[j];
			gameDifficultyToggle.Toggle.AgeTransform.Enable = CanChangeDifficulty();
		}
		LobbyTypeToggle[] array3 = lobbyTypeToggles;
		for (int k = 0; k < array3.Length; k++)
		{
			LobbyTypeToggle lobbyTypeToggle = array3[k];
			lobbyTypeToggle.Toggle.AgeTransform.Enable = CanChangeLobbyType();
		}
		heroesTable.Enable = CanChangeHero();
	}
}
[Serializable]
public struct GameDifficultyToggle
{
	public GameDifficulty Difficulty;

	public AgeControlToggle Toggle;
}
public enum LobbyType
{
	Private,
	Friends,
	Public
}
[Serializable]
public struct LobbyTypeToggle
{
	public LobbyType Type;

	public AgeControlToggle Toggle;
}
public class GameSessionLine : MonoBehaviour
{
	[SerializeField]
	private AgePrimitiveLabel nameLabel;

	[SerializeField]
	private AgePrimitiveLabel slotFillingLabel;

	[SerializeField]
	private Color defaultColor;

	[SerializeField]
	private Color wrongHashColor;

	[SerializeField]
	private Color mpSaveColor;

	public AGERowSelectable RowSelectable;

	private SessionListPanel Parent;

	public LobbyDescription LobbyDescription
	{
		get;
		private set;
	}

	public void Bind(LobbyDescription lobbyDescription, SessionListPanel parent)
	{
		LobbyDescription = lobbyDescription;
		Parent = parent;
	}

	public void Unbind()
	{
		LobbyDescription = null;
		Parent = null;
	}

	public void RefreshContent()
	{
		if (LobbyDescription == null)
		{
			Diagnostics.LogError("Trying to refresh a GameSessionLine that doesn't have a LobbyDescription");
			return;
		}
		nameLabel.Text = AgeLocalizer.Instance.LocalizeString("%MPSessionName").Replace("$HostName", LobbyDescription.Name);
		slotFillingLabel.Text = $"{LobbyDescription.NumberOfLobbyMembers}/{LobbyDescription.MaximumNumberOfPlayers}";
		if (!string.IsNullOrEmpty(LobbyDescription.SaveKey))
		{
			nameLabel.TintColor = mpSaveColor;
			nameLabel.AgeTransform.AgeTooltip.Content = null;
		}
		else if (!IsSameVersion())
		{
			nameLabel.TintColor = wrongHashColor;
		}
		else
		{
			nameLabel.TintColor = defaultColor;
			nameLabel.AgeTransform.AgeTooltip.Content = null;
		}
	}

	private bool IsSameVersion()
	{
		return LobbyDescription.Version == Amplitude.Unity.Framework.Application.Version.ToString() && LobbyDescription.Checksum == HashManager.GetCurrentHash();
	}

	private void OnClickLineCB(GameObject gameObject)
	{
		if (LobbyDescription.NumberOfLobbyMembers >= LobbyDescription.MaximumNumberOfPlayers)
		{
			SingletonManager.Get<NotificationPanel>().EnqueueNotification("%FullLobby", NotificationType.Error);
		}
		else
		{
			Parent.OnClickLineCB(this);
		}
	}
}
public class GameToScreenPositionSync : MonoBehaviour
{
	[SerializeField]
	private AgeTransform ageTfm;

	[SerializeField]
	private Transform gameEntityTfm;

	[SerializeField]
	private Vector2 screenOffset;

	[SerializeField]
	private Vector3 worldOffset;

	private IGameResolutionService gameResManager;

	private IGameCameraService gameCamManager;

	public Transform GameEntityTfm
	{
		get
		{
			return gameEntityTfm;
		}
		set
		{
			gameEntityTfm = value;
		}
	}

	public Camera Camera
	{
		get;
		set;
	}

	public Vector2 ScreenOffset
	{
		get
		{
			return screenOffset;
		}
		set
		{
			screenOffset = value;
		}
	}

	public Vector2 WorldOffset
	{
		get
		{
			return worldOffset;
		}
		set
		{
			worldOffset = value;
		}
	}

	public void UpdatePosition()
	{
		if (ageTfm.Visible && !(GameEntityTfm == null))
		{
			if (gameResManager == null)
			{
				gameResManager = Services.GetService<IGameResolutionService>();
			}
			if (gameCamManager == null)
			{
				gameCamManager = Services.GetService<IGameCameraService>();
			}
			Vector2 vector = gameCamManager.WorldToScreenPoint(GameEntityTfm.position + worldOffset, Camera);
			ageTfm.X = vector.x - ageTfm.Width / 2f + screenOffset.x * AgeUtils.CurrentUpscaleFactor();
			AgeTransform ageTransform = ageTfm;
			ScreenResolution currentDisplayResolution = gameResManager.GetCurrentDisplayResolution();
			ageTransform.Y = (float)currentDisplayResolution.Height - vector.y - ageTfm.Height / 2f + screenOffset.y;
		}
	}

	private void Awake()
	{
		ageTfm = GetComponent<AgeTransform>();
	}

	private void LateUpdate()
	{
		UpdatePosition();
	}
}
public abstract class GuiItem : MonoBehaviour
{
	[SerializeField]
	public AgePrimitiveImage ItemIcon;

	public AgePrimitiveLabel ItemName;

	public AgePrimitiveImage ItemBackground;

	public AgePrimitiveImage ItemCategoryIcon;

	public AgeControlButton ItemButton;

	public AgeTransform ItemHighlight;

	public Color DefaultBackgroundColor;

	public AgeTransform UnequipButton;

	public AgeTransform ItemTransferMarker;

	private IInputService inputService;

	public AGESelectable Selectable
	{
		get;
		private set;
	}

	public abstract InventoryItem GetItem();

	protected virtual void Awake()
	{
		inputService = Services.GetService<IInputService>();
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			Selectable = GetComponent<AGESelectable>();
			ItemTransferMarker.OverrideClip = true;
		}
	}

	public virtual InventoryListPanel GetInventoryListPanel()
	{
		return null;
	}

	public void SelectItem()
	{
		InventoryListPanel.SelectItemStatic(this);
		InventoryListPanel inventoryListPanel = GetInventoryListPanel();
		if (inventoryListPanel != null)
		{
			inventoryListPanel.SelectItem(this);
		}
	}

	public void SetSelected(bool selected)
	{
		if (inputService.CurrentControlScheme != ControlScheme.XBoxOneController)
		{
			InventoryListPanel.SelectedGuiItem.ItemHighlight.Visible = selected;
			HeroStatsPanel heroStatsPanel = SingletonManager.Get<HeroStatsPanel>();
			if (heroStatsPanel.IsVisible)
			{
				heroStatsPanel.SetSelectedInventoryItem((!selected) ? null : GetItem());
			}
		}
	}

	public virtual void RefreshContent(IGuiPanelHelper helper = null, bool active = true, bool enabled = true, StaticString costPropertyName = null, bool isBuyable = true)
	{
		InventoryItem item = GetItem();
		if (item != null)
		{
			ItemName.AgeTransform.Visible = !item.IsGift;
		}
	}
}
public class HeroActiveSkillsPanel : GuiPanel
{
	[SerializeField]
	private Transform activeSkillPfb;

	[SerializeField]
	private AgeTransform activeSkillsTable;

	[SerializeField]
	private HeroListPanel heroListPanel;

	[SerializeField]
	private float arrowXPositionStart;

	[SerializeField]
	private float xPositionStart;

	[SerializeField]
	private float xPositionOffset;

	[SerializeField]
	private float maxRightestPosition;

	public Hero Hero
	{
		get;
		private set;
	}

	public void Bind(Hero hero)
	{
		if (Hero != null)
		{
			Unbind();
		}
		Hero = hero;
		SingletonManager.Get<Dungeon>().OnCrystalStateChanged += OnCrystalStateChanged;
	}

	public void Unbind()
	{
		UnbindActiveSkillItems();
		Hero = null;
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		if (dungeon != null)
		{
			dungeon.OnCrystalStateChanged -= OnCrystalStateChanged;
		}
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		UnbindActiveSkillItems();
		activeSkillsTable.Width = 0f;
		activeSkillsTable.ReserveChildren(Hero.FilteredActiveSkills.Count, activeSkillPfb);
		activeSkillsTable.RefreshChildrenIList(Hero.FilteredActiveSkills, RefreshActiveSkillPanel);
		activeSkillsTable.ArrangeChildren();
		base.AgeTransform.Width = activeSkillsTable.Width;
	}

	public override void Hide(bool instant = false)
	{
		base.Hide(instant);
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		RefreshContent();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		base.NeedRefresh = false;
		yield return base.OnHide(instant);
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		base.UseRefreshLoop = true;
	}

	private void OnCrystalStateChanged(CrystalState state)
	{
		base.NeedRefresh = true;
	}

	private void UnbindActiveSkillItems()
	{
		List<ActiveSkillItem> children = activeSkillsTable.GetChildren<ActiveSkillItem>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
		}
	}

	private void RefreshActiveSkillPanel(AgeTransform tableItem, ActiveSkill activeSkill, int index)
	{
		ActiveSkillItem component = tableItem.GetComponent<ActiveSkillItem>();
		if (component != null && activeSkill != null)
		{
			component.Bind(Hero, activeSkill, index);
			component.RefreshContent();
		}
	}
}
public class HeroBiographyPanel : GuiPanel
{
	[SerializeField]
	private AgeTransform parentContainer;

	[SerializeField]
	private AgePrimitiveLabel heroBiographyLabel;

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		StaticString heroName = StaticString.Empty;
		if (parameters.Length > 0 && parameters[0] is StaticString)
		{
			heroName = (parameters[0] as StaticString);
		}
		AgeTransform competitorSlotTransform = null;
		if (parameters.Length > 0 && parameters[1] is AgeTransform)
		{
			competitorSlotTransform = (parameters[1] as AgeTransform);
		}
		heroBiographyLabel.AgeTransform.Height = 0f;
		if (heroName != StaticString.Empty)
		{
			if (!base.GuiService.GuiPanelHelper.TryGetGuiElement(heroName, out GuiElement guiElement))
			{
				heroBiographyLabel.ForceText($"Missing GuiElement: {heroName}");
			}
			else
			{
				heroBiographyLabel.ForceText(AgeLocalizer.Instance.LocalizeString(guiElement.Description));
			}
		}
		AgeTransform labelTransform = heroBiographyLabel.AgeTransform;
		base.AgeTransform.Height = labelTransform.Height + labelTransform.PixelMarginTop + labelTransform.PixelMarginBottom;
		if (competitorSlotTransform != null)
		{
			base.AgeTransform.Y = competitorSlotTransform.Y;
			float panelBottom = base.AgeTransform.Y + base.AgeTransform.Height;
			if (panelBottom > parentContainer.Height)
			{
				base.AgeTransform.Y -= panelBottom - parentContainer.Height;
			}
		}
	}
}
public class HeroEquipementBasePanel : GuiPanel
{
	[SerializeField]
	private AgeTransform equipmentTable;

	[SerializeField]
	private Transform equipmentSlotPrefab;

	[SerializeField]
	protected GUIComparingLabel healthLevelUpLabel;

	[SerializeField]
	protected GUIComparingLabel healthRegenLevelUpLabel;

	[SerializeField]
	protected GUIComparingLabel defenseLevelUpLabel;

	[SerializeField]
	protected GUIComparingLabel moveSpeedLevelUpLabel;

	[SerializeField]
	protected GUIComparingLabel dpsLevelUpLabel;

	[SerializeField]
	protected GUIComparingLabel attackPowerLevelUpLabel;

	[SerializeField]
	protected GUIComparingLabel attackCooldownLevelUpLabel;

	[SerializeField]
	protected GUIComparingLabel witLevelUpLabel;

	[SerializeField]
	protected AgePrimitiveLabel healthLabel;

	[SerializeField]
	protected AgePrimitiveLabel healthRegenLabel;

	[SerializeField]
	protected AgePrimitiveLabel defenseLabel;

	[SerializeField]
	protected AgePrimitiveLabel moveSpeedLabel;

	[SerializeField]
	protected AgePrimitiveLabel dpsLabel;

	[SerializeField]
	protected AgePrimitiveLabel attackPowerLabel;

	[SerializeField]
	protected AgePrimitiveLabel attackCooldownLabel;

	[SerializeField]
	protected AgePrimitiveLabel witLabel;

	public InventoryItem SelectedInventoryItem;

	public InventoryItem HoveredInventoryItem;

	protected AgeTransform tooltipDock;

	protected Health heroHealth;

	private readonly string heroPath = "Dungeon/Room/Hero";

	public Hero BoundHero
	{
		get;
		set;
	}

	public InventoryItem ComparedItem
	{
		get
		{
			if (HoveredInventoryItem != null && !HoveredInventoryItem.IsGift)
			{
				return HoveredInventoryItem;
			}
			if (SelectedInventoryItem != null && !SelectedInventoryItem.IsGift)
			{
				return SelectedInventoryItem;
			}
			return null;
		}
	}

	public virtual void Bind(Hero hero, AgeTransform tooltipDock)
	{
		BoundHero = hero;
		this.tooltipDock = tooltipDock;
		heroHealth = BoundHero.GetComponent<Health>();
	}

	public void Unbind()
	{
		List<EquipmentSlotItem> children = equipmentTable.GetChildren<EquipmentSlotItem>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
		}
	}

	protected override IEnumerator OnHide(bool instant)
	{
		SelectedInventoryItem = null;
		HoveredInventoryItem = null;
		yield return base.OnHide(instant);
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		Unbind();
		equipmentTable.ReserveChildren(BoundHero.EquipmentSlots.Length, equipmentSlotPrefab, "EquipmentSlot");
		equipmentTable.RefreshChildrenIList(new List<EquipmentSlot>(BoundHero.EquipmentSlots), RefreshEquipmentSlot);
	}

	private void RefreshEquipmentSlot(AgeTransform tableSlot, EquipmentSlot slot, int index)
	{
		EquipmentSlotItem component = tableSlot.GetComponent<EquipmentSlotItem>();
		component.Bind(slot, tooltipDock, index);
		component.RefreshContent();
	}

	public void RefreshStatBonuses(InventoryItem item = null)
	{
		if (item != null)
		{
			SelectedInventoryItem = item;
		}
		if (ComparedItem != null && BoundHero != null && BoundHero.CanEquipItem(ComparedItem))
		{
			RefreshComparedItemBonuses();
			RefreshStats();
		}
	}

	public void RefreshComparedItemBonuses()
	{
		if (BoundHero == null || ComparedItem == null || !BoundHero.CanEquipItem(ComparedItem))
		{
			return;
		}
		SimulationDescriptor shipDesc = SingletonManager.Get<Dungeon>().ShipDesc;
		float simPropertyValue = BoundHero.GetSimPropertyValue(SimulationProperties.AttackPower);
		float simPropertyValue2 = BoundHero.GetSimPropertyValue(SimulationProperties.AttackCooldown);
		float num = GenericUtilities.RoundHalfAwayFromZero(simPropertyValue / simPropertyValue2);
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 0f;
		float num7 = 0f;
		float num8 = 0f;
		if (!BoundHero.EquipmentSlots.Any((EquipmentSlot e) => e.CategoryParameters.CategoryName == ComparedItem.ItemConfig.CategoryParameters.CategoryName && e.EquippedItem == null))
		{
			EquipmentSlot[] equipmentSlots = BoundHero.EquipmentSlots;
			foreach (EquipmentSlot equipmentSlot in equipmentSlots)
			{
				if (equipmentSlot.EquippedItem != null && equipmentSlot.CategoryParameters.CategoryName == ComparedItem.ItemConfig.CategoryParameters.CategoryName)
				{
					num2 -= equipmentSlot.EquippedItem.SimulationObject.GetPropertyValue(SimulationProperties.MaxHealth);
					num3 -= equipmentSlot.EquippedItem.SimulationObject.GetPropertyValue(SimulationProperties.HealthRegen);
					num4 -= equipmentSlot.EquippedItem.SimulationObject.GetPropertyValue(SimulationProperties.Defense);
					num5 -= equipmentSlot.EquippedItem.SimulationObject.GetPropertyValue(SimulationProperties.MoveSpeed);
					num6 -= equipmentSlot.EquippedItem.SimulationObject.GetPropertyValue(SimulationProperties.AttackPower);
					num7 -= equipmentSlot.EquippedItem.SimulationObject.GetPropertyValue(SimulationProperties.AttackCooldown);
					num8 -= equipmentSlot.EquippedItem.SimulationObject.GetPropertyValue(SimulationProperties.Wit);
					break;
				}
			}
		}
		num2 += ComparedItem.SimulationObject.GetPropertyValue(SimulationProperties.MaxHealth);
		num3 += ComparedItem.SimulationObject.GetPropertyValue(SimulationProperties.HealthRegen);
		num4 += ComparedItem.SimulationObject.GetPropertyValue(SimulationProperties.Defense);
		num5 += ComparedItem.SimulationObject.GetPropertyValue(SimulationProperties.MoveSpeed);
		num6 += ComparedItem.SimulationObject.GetPropertyValue(SimulationProperties.AttackPower);
		num7 += ComparedItem.SimulationObject.GetPropertyValue(SimulationProperties.AttackCooldown);
		num8 += ComparedItem.SimulationObject.GetPropertyValue(SimulationProperties.Wit);
		healthLevelUpLabel.Text = Mathf.Ceil(SimMonoBehaviour.ApplyDescModifier(num2, SimulationProperties.MaxHealth, shipDesc, heroPath)).ToString();
		healthRegenLevelUpLabel.Text = GenericUtilities.RoundHalfAwayFromZero(num3).ToString();
		defenseLevelUpLabel.Text = GenericUtilities.RoundHalfAwayFromZero(SimMonoBehaviour.ApplyDescModifier(num4, SimulationProperties.Defense, shipDesc, heroPath)).ToString();
		moveSpeedLevelUpLabel.Text = GenericUtilities.RoundHalfAwayFromZero(SimMonoBehaviour.ApplyDescModifier(num5, SimulationProperties.MoveSpeed, shipDesc, heroPath)).ToString();
		float num9 = SimMonoBehaviour.ApplyDescModifier(num6, SimulationProperties.AttackPower, shipDesc, heroPath);
		attackPowerLevelUpLabel.Text = GenericUtilities.RoundHalfAwayFromZero(num9).ToString();
		float num10 = SimMonoBehaviour.ApplyDescModifier(num7, SimulationProperties.AttackCooldown, shipDesc, heroPath);
		attackCooldownLevelUpLabel.Text = num10.RoundWithDecimals(1).ToString();
		float num11 = (simPropertyValue + num9) / (simPropertyValue2 + num10);
		if (num11 != num)
		{
			dpsLevelUpLabel.Text = GenericUtilities.RoundHalfAwayFromZero(num11 - num).ToString();
		}
		else
		{
			dpsLevelUpLabel.Text = string.Empty;
		}
		witLevelUpLabel.Text = GenericUtilities.RoundHalfAwayFromZero(SimMonoBehaviour.ApplyDescModifier(num8, SimulationProperties.Wit, shipDesc, heroPath)).ToString();
	}

	private void RefreshStats()
	{
		float health = heroHealth.GetHealth();
		float maxHealth = heroHealth.GetMaxHealth();
		float simPropertyValue = BoundHero.GetSimPropertyValue(SimulationProperties.HealthRegen);
		float simPropertyValue2 = BoundHero.GetSimPropertyValue(SimulationProperties.Defense);
		float f = BoundHero.GetSimPropertyValue(SimulationProperties.MoveSpeedReal) * 10f;
		float simPropertyValue3 = BoundHero.GetSimPropertyValue(SimulationProperties.AttackPower);
		float simPropertyValue4 = BoundHero.GetSimPropertyValue(SimulationProperties.AttackCooldown);
		float simPropertyValue5 = BoundHero.GetSimPropertyValue(SimulationProperties.Wit);
		float num = GenericUtilities.RoundHalfAwayFromZero(simPropertyValue3 / simPropertyValue4);
		healthLabel.Text = Mathf.Ceil(health) + "/" + Mathf.Ceil(maxHealth);
		healthRegenLabel.Text = Mathf.Ceil(simPropertyValue).ToString();
		defenseLabel.Text = Mathf.Ceil(simPropertyValue2).ToString();
		moveSpeedLabel.Text = Mathf.Ceil(f).ToString();
		attackPowerLabel.Text = Mathf.Ceil(simPropertyValue3).ToString();
		attackCooldownLabel.Text = simPropertyValue4.RoundWithDecimals(1).ToString();
		dpsLabel.Text = num.ToString();
		witLabel.Text = Mathf.Ceil(simPropertyValue5).ToString();
	}
}
public class HeroEquipementPadPanel : HeroEquipementBasePanel
{
	[SerializeField]
	private AgePrimitiveImage heroPortrait;

	public void Bind(Hero hero, GUIComparingLabel healthLevelUpLabel, GUIComparingLabel healthRegenLevelUpLabel, GUIComparingLabel defenseLevelUpLabel, GUIComparingLabel moveSpeedLevelUpLabel, GUIComparingLabel dpsLevelUpLabel, GUIComparingLabel attackPowerLevelUpLabel, GUIComparingLabel attackCooldownLevelUpLabel, GUIComparingLabel witLevelUpLabel, AgeTransform tooltipDock, AgePrimitiveLabel healthLabel, AgePrimitiveLabel healthRegenLabel, AgePrimitiveLabel defenseLabel, AgePrimitiveLabel moveSpeedLabel, AgePrimitiveLabel dpsLabel, AgePrimitiveLabel attackPowerLabel, AgePrimitiveLabel attackCooldownLabel, AgePrimitiveLabel witLabel)
	{
		base.Bind(hero, tooltipDock);
		base.healthLevelUpLabel = healthLevelUpLabel;
		base.healthRegenLevelUpLabel = healthRegenLevelUpLabel;
		base.defenseLevelUpLabel = defenseLevelUpLabel;
		base.moveSpeedLevelUpLabel = moveSpeedLevelUpLabel;
		base.dpsLevelUpLabel = dpsLevelUpLabel;
		base.attackPowerLevelUpLabel = attackPowerLevelUpLabel;
		base.attackCooldownLevelUpLabel = attackCooldownLevelUpLabel;
		base.witLevelUpLabel = witLevelUpLabel;
		base.healthLabel = healthLabel;
		base.healthRegenLabel = healthRegenLabel;
		base.defenseLabel = defenseLabel;
		base.moveSpeedLabel = moveSpeedLabel;
		base.dpsLabel = dpsLabel;
		base.attackPowerLabel = attackPowerLabel;
		base.attackCooldownLabel = attackCooldownLabel;
		base.witLabel = witLabel;
		Show();
	}

	public override void Show(params object[] parameters)
	{
		if (!base.IsLoaded)
		{
			Load();
		}
		base.Show(parameters);
		RefreshContent();
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		if (base.GuiService.GuiPanelHelper.TryGetGuiElement(base.BoundHero.Config.Name, out GuiElement guiElement) && base.GuiService.GuiPanelHelper.TryGetTextureFromIcon(guiElement, IconSize.Small, out Texture2D texture))
		{
			heroPortrait.Image = texture;
		}
	}
}
public class HeroHighScorePortraitPanel : GuiPanel
{
	[SerializeField]
	private AgePrimitiveImage heroImage;

	private StaticString heroName;

	public void Bind(StaticString heroName)
	{
		this.heroName = heroName;
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		IGuiPanelHelper guiPanelHelper = Services.GetService<IGuiService>().GuiPanelHelper;
		Diagnostics.Assert(guiPanelHelper != null, "Unable to access GuiPanelHelper");
		if (guiPanelHelper.TryGetGuiElement(heroName, out GuiElement guiElement) && guiPanelHelper.TryGetTextureFromIcon(guiElement, IconSize.Small, out Texture2D texture))
		{
			heroImage.Image = texture;
		}
	}
}
public class HeroItem : MonoBehaviour
{
	public AgeTransform AgeTransform;

	[SerializeField]
	private AgePrimitiveLabel nameLabel;

	[SerializeField]
	private AgeTransform healthTfm;

	[SerializeField]
	private AgeTransform feedbackTfm;

	[SerializeField]
	private AgeTransform feedbackWounded1Tfm;

	[SerializeField]
	private AgeTransform feedbackWounded2Tfm;

	[SerializeField]
	private float hitFeedbackDuration;

	[SerializeField]
	private AgePrimitiveImage icon;

	[SerializeField]
	private AgePrimitiveImage deadHeroIconTransf;

	[SerializeField]
	private AgePrimitiveLabel levelLabel;

	[SerializeField]
	private AgeTransform crystalIcon;

	[SerializeField]
	private AgeTransform repairIcon;

	[SerializeField]
	private AgeTransform operateIcon;

	[SerializeField]
	private Texture2D operateTexture;

	[SerializeField]
	private Texture2D operateBonusTexture;

	[SerializeField]
	private AgeControlToggle toggle;

	[SerializeField]
	private AgeControlToggle togglePanel;

	[SerializeField]
	private AgeTransform healButton;

	[SerializeField]
	private AgePrimitiveLabel healCostLabel;

	[SerializeField]
	private AgePrimitiveImage healIcon;

	[SerializeField]
	private AgePrimitiveImage backgroundPortrait;

	[SerializeField]
	private AgePrimitiveImage otherPlayerForeground;

	[SerializeField]
	private AgeTransform openPanelButton;

	[SerializeField]
	private AgeTransform healthBar;

	[SerializeField]
	private AgeTransform deadHeroBackground;

	[SerializeField]
	private Texture2D deadHeroIcon;

	[SerializeField]
	private AgePrimitiveLabel groupsLabels;

	[SerializeField]
	private AgeTransform openButton;

	[SerializeField]
	private AgeTransform mobLevelHolder;

	[SerializeField]
	private AgeTransform[] mobLevels;

	[SerializeField]
	private AgeTransform tamedMobHealthBar;

	[SerializeField]
	private AgeTransform tamedMobHealthTfm;

	private bool isLevelUpAffordable;

	private Health heroHealth;

	private AgeModifierColorSwitch backgroundColorSwitch;

	private AgePrimitiveImage operateIconImage;

	private Color normalColor;

	private Color hoverColor;

	private Color onNormalColor;

	private Color hoverOnColor;

	private bool mouseIn;

	private bool isOwnedByLocalPlayer;

	private IGameControlService gameControlService;

	public Hero Hero
	{
		get;
		private set;
	}

	public AgeTransform OpenButton => openButton;

	public void Bind(Hero hero)
	{
		if (Hero != null && Hero != hero)
		{
			Diagnostics.LogWarning("HeroItem.Bind: still bound to {0}!", Hero.name);
			Unbind();
		}
		if (!(hero == Hero))
		{
			if (gameControlService == null)
			{
				gameControlService = Services.GetService<IGameControlService>();
			}
			Hero = hero;
			if (hero != null)
			{
				heroHealth = hero.GetComponent<Health>();
				Hero.GetSimWrapper().Refreshed += OnHeroRefreshed;
				heroHealth.OnHit += OnHeroHit;
				heroHealth.OnHealthChanged += OnHeroHealthChange;
				Hero hero2 = Hero;
				hero2.OnLevelUp = (HeroMobCommon.LevelUpEventHandler)Delegate.Combine(hero2.OnLevelUp, new HeroMobCommon.LevelUpEventHandler(OnHeroLevelUp));
				Hero.OnHasCrystalChanged += Hero_OnHasCrystalChanged;
				Hero.OnMobTamed += Hero_OnMobTamed;
				isOwnedByLocalPlayer = Hero.NetSyncElement.IsOwnedByLocalPlayer();
			}
		}
	}

	public void Unbind()
	{
		isOwnedByLocalPlayer = false;
		if (Hero != null)
		{
			Hero.GetSimWrapper().Refreshed -= OnHeroRefreshed;
			Hero hero = Hero;
			hero.OnLevelUp = (HeroMobCommon.LevelUpEventHandler)Delegate.Remove(hero.OnLevelUp, new HeroMobCommon.LevelUpEventHandler(OnHeroLevelUp));
			Hero.OnHasCrystalChanged -= Hero_OnHasCrystalChanged;
			Hero.OnMobTamed -= Hero_OnMobTamed;
			if (Hero.TamedMob != null)
			{
				if (Hero.TamedMob.HealthCpnt != null)
				{
					Hero.TamedMob.HealthCpnt.OnHealthChanged -= RefreshContent;
				}
				Hero.TamedMob.OnTameLevelUp -= RefreshContent;
			}
			Hero = null;
		}
		if (heroHealth != null)
		{
			heroHealth.OnHit -= OnHeroHit;
			heroHealth.OnHealthChanged -= OnHeroHealthChange;
			heroHealth = null;
		}
	}

	public void RefreshContent()
	{
		isOwnedByLocalPlayer = (Hero != null && Hero.NetSyncElement.IsOwnedByLocalPlayer());
		bool flag = Hero == null;
		openPanelButton.Visible = !flag;
		openPanelButton.Enable = isOwnedByLocalPlayer;
		healthBar.Visible = !flag;
		levelLabel.AgeTransform.Visible = !flag;
		togglePanel.AgeTransform.Enable = !flag;
		toggle.enabled = !flag;
		healButton.Visible = !flag;
		backgroundPortrait.AgeTransform.Visible = !flag;
		deadHeroBackground.Visible = flag;
		deadHeroIconTransf.AgeTransform.Visible = flag;
		if (!flag)
		{
			healthTfm.PercentRight = 100f * heroHealth.GetHealthRatio();
			levelLabel.Text = AgeLocalizer.Instance.LocalizeString("%HeroLevelLabel").Replace("$HeroLevel", Hero.Level.ToString());
			if (Hero.TamedMob != null && Hero.TamedMob.HealthCpnt != null)
			{
				tamedMobHealthTfm.PercentRight = 100f * Hero.TamedMob.HealthCpnt.GetHealthRatio();
			}
			if (isOwnedByLocalPlayer)
			{
				bool flag2 = isLevelUpAffordable;
				HeroLevelConfig nextLevelConfig = Hero.GetNextLevelConfig();
				isLevelUpAffordable = (nextLevelConfig != null && Player.LocalPlayer.FoodStock >= nextLevelConfig.FoodCost);
				if (!flag2 && isLevelUpAffordable)
				{
					levelLabel.AgeTransform.StartAllModifiers();
				}
				else if (flag2 && !isLevelUpAffordable)
				{
					levelLabel.AgeTransform.StartAllModifiers(forward: false);
				}
			}
			openButton.Visible = isOwnedByLocalPlayer;
			crystalIcon.Visible = Hero.HasCrystal;
			repairIcon.Visible = (Hero.RepairingModule != null);
			operateIcon.Visible = (Hero.OperatingModule != null);
			mobLevelHolder.Visible = (Hero.TamedMob != null && Hero.TamedMob.HealthCpnt.IsAlive());
			tamedMobHealthBar.Visible = mobLevelHolder.Visible;
			if (mobLevelHolder.Visible)
			{
				for (int i = 0; i < mobLevels.Length; i++)
				{
					mobLevels[i].Visible = (i < Hero.TamedMob.TameLevel - 1);
				}
			}
			IGuiPanelHelper guiPanelHelper = Services.GetService<IGuiService>().GuiPanelHelper;
			Diagnostics.Assert(guiPanelHelper != null, "Unable to access GuiPanelHelper");
			if (guiPanelHelper.TryGetGuiElement(Hero.Config.Name, out GuiElement guiElement))
			{
				if (guiPanelHelper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Small, out Texture2D texture))
				{
					icon.Image = texture;
				}
				nameLabel.Text = Hero.LocalizedName;
			}
			if (icon.Image == null)
			{
				icon.Image = GuiManager.GetTransparentTexture();
			}
			string text = string.Empty;
			int num = 0;
			while (gameControlService.HeroGroups != null && num < gameControlService.HeroGroups.Length)
			{
				if (gameControlService.HeroGroups[num] != null && gameControlService.HeroGroups[num].Contains(Hero.Config.Name))
				{
					text = text + num.ToString() + " ";
				}
				num++;
			}
			groupsLabels.Text = text;
			UpdateHealButton();
			operateIconImage.Image = ((!Hero.HasOperatingBonus) ? operateTexture : operateBonusTexture);
		}
		else
		{
			deadHeroIconTransf.Image = deadHeroIcon;
			mobLevelHolder.Visible = false;
			tamedMobHealthBar.Visible = false;
		}
		otherPlayerForeground.AgeTransform.Visible = !isOwnedByLocalPlayer;
		GetComponent<AgeTransform>().Enable = isOwnedByLocalPlayer;
	}

	private void UpdateHealButton()
	{
		if (Hero == null)
		{
			healButton.Visible = false;
			return;
		}
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		healButton.Visible = (!dungeon.ShipConfig.ForbidHeal && (!heroHealth.IsFullLive() || (Hero.TamedMob != null && !Hero.TamedMob.HealthCpnt.IsFullLive())));
		if (Services.GetService<IInputService>().CurrentControlScheme == ControlScheme.XBoxOneController && !Hero.SelectedHeroes.Contains(Hero))
		{
			healButton.Visible = false;
		}
		if (healButton.Visible)
		{
			float num = Hero.GetHealFoodCost();
			healCostLabel.Text = num.ToString();
			if (Player.LocalPlayer.FoodStock < num)
			{
				healCostLabel.TintColor = Color.red;
				healIcon.TintColor = Color.red;
			}
			else
			{
				healCostLabel.TintColor = Color.green;
				healIcon.TintColor = Color.green;
			}
		}
		healButton.Enable = isOwnedByLocalPlayer;
	}

	public void Reset()
	{
		togglePanel.State = false;
	}

	public void SetState(bool state)
	{
		toggle.State = state;
		togglePanel.State = false;
		UpdateHealButton();
	}

	public void RefreshHeroStatsPanelToggle()
	{
		HeroStatsPanel heroStatsPanel = SingletonManager.Get<HeroStatsPanel>(mandatory: false);
		togglePanel.State = (heroStatsPanel != null && heroStatsPanel.BoundHero == Hero && heroStatsPanel.IsVisible && !heroStatsPanel.IsHiding);
	}

	protected virtual void Awake()
	{
		toggle = GetComponent<AgeControlToggle>();
		togglePanel = togglePanel.GetComponent<AgeControlToggle>();
		backgroundColorSwitch = backgroundPortrait.GetComponent<AgeModifierColorSwitch>();
		operateIconImage = operateIcon.GetComponent<AgePrimitiveImage>();
		normalColor = backgroundColorSwitch.NormalColor;
		onNormalColor = backgroundColorSwitch.OnColor;
		hoverColor = backgroundColorSwitch.HoverColor;
		hoverOnColor = backgroundColorSwitch.HoverOnColor;
	}

	private void OnHeroRefreshed(object sender)
	{
		RefreshContent();
	}

	private void OnHeroHealthChange()
	{
		RefreshContent();
	}

	private void Hero_OnMobTamed(Mob newMob, Mob oldMob)
	{
		if (oldMob != null)
		{
			if (oldMob.HealthCpnt != null)
			{
				oldMob.HealthCpnt.OnHealthChanged -= RefreshContent;
			}
			oldMob.OnTameLevelUp -= RefreshContent;
			oldMob.OnMobDeath -= TamedMob_OnMobDeath;
		}
		newMob.OnTameLevelUp += RefreshContent;
		newMob.OnMobDeath += TamedMob_OnMobDeath;
		if (newMob.HealthCpnt != null)
		{
			newMob.HealthCpnt.OnHealthChanged += RefreshContent;
		}
	}

	private void OnHeroHit(AttackInfo hit)
	{
		CancelInvoke("HitFeedbackEnd");
		feedbackTfm.Alpha = 1f;
		Invoke("HitFeedbackEnd", hitFeedbackDuration);
	}

	private void HitFeedbackEnd()
	{
		feedbackTfm.Alpha = 0f;
	}

	public void SelectHero()
	{
		if (!isOwnedByLocalPlayer)
		{
			Diagnostics.LogWarning(Hero.name + " > HeroPanel.SelectHero: owned by another player!");
			return;
		}
		Hero.Select();
		toggle.State = true;
		IGuiService service = Services.GetService<IGuiService>();
		Diagnostics.Assert(service != null, "Unable to access GuiPanelHelper");
		InventoryPanel inventoryPanel = SingletonManager.Get<InventoryPanel>();
		if (inventoryPanel != null && inventoryPanel.IsVisible)
		{
			inventoryPanel.OnHeroSelected(Hero);
		}
	}

	private void OnLeftClick()
	{
		if (Hero != null)
		{
			SelectHero();
		}
	}

	private void OnRightClick()
	{
		ToggleHeroStatsPanelDisplay();
	}

	private void OnHeroesButtonClick()
	{
		ToggleHeroStatsPanelDisplay();
	}

	private void ToggleHeroStatsPanelDisplay()
	{
		if (!(Hero != null))
		{
			return;
		}
		if (Hero.SelectedHeroes.Count != 1 || Hero.SelectedHeroes[0] != Hero)
		{
			SelectHero();
			if (Hero.SelectedHeroes.Count == 1)
			{
				Services.GetService<IGameControlService>().SetHeroStatsPanelDisplay(on: true);
			}
		}
		else if (Hero.SelectedHeroes.Count == 1)
		{
			Services.GetService<IGameControlService>().ToggleHeroStatsPanelDisplay();
		}
	}

	private void OnHeroLevelUp()
	{
		RefreshContent();
	}

	private void TamedMob_OnMobDeath(Mob mob)
	{
		RefreshContent();
	}

	private void Hero_OnHasCrystalChanged(bool hasCrystal)
	{
		crystalIcon.Visible = hasCrystal;
	}

	private void OnHealButtonClick()
	{
		if (Hero != null && Hero.NetSyncElement.IsOwnedByLocalPlayer())
		{
			Hero.Heal();
		}
	}

	private void OnMouseEnter()
	{
		mouseIn = true;
	}

	private void OnMouseLeave()
	{
		mouseIn = false;
	}

	private void LateUpdate()
	{
		if (Hero != null && Hero.HealthCpnt != null)
		{
			float healthRatio = Hero.HealthCpnt.GetHealthRatio();
			bool flag = Hero.SelectedHeroes.Contains(Hero);
			if (healthRatio < Hero.LowHealthValue)
			{
				feedbackWounded1Tfm.Visible = true;
				feedbackWounded2Tfm.Visible = true;
			}
			else
			{
				feedbackWounded1Tfm.Visible = false;
				feedbackWounded2Tfm.Visible = false;
			}
			if (flag)
			{
				backgroundPortrait.TintColor = ((!mouseIn) ? onNormalColor : hoverOnColor);
			}
			else
			{
				backgroundPortrait.TintColor = ((!mouseIn) ? normalColor : hoverColor);
			}
			backgroundColorSwitch.NormalColor = normalColor;
			backgroundColorSwitch.HoverColor = hoverColor;
			backgroundColorSwitch.HoverOnColor = hoverOnColor;
			backgroundColorSwitch.OnColor = onNormalColor;
		}
	}
}
public class HeroListPanel : GuiPanel
{
	[SerializeField]
	private Transform heroPanelPrefab;

	[SerializeField]
	private AgeTransform heroItemsTable;

	[SerializeField]
	private HeroActiveSkillsPanel heroActiveSkillsPanel;

	[SerializeField]
	private HeroStatsPanel heroStatsPanel;

	[SerializeField]
	private AgeTransform arrowTfm;

	private List<Hero> allHeroes = new List<Hero>();

	public override void RefreshContent()
	{
		base.RefreshContent();
		UnbindHeroItems();
		BuildHeroesList();
		heroItemsTable.Width = 0f;
		heroItemsTable.ReserveChildren(allHeroes.Count, heroPanelPrefab, "HeroItem");
		heroItemsTable.RefreshChildrenIList(allHeroes, RefreshHeroPanel);
		heroItemsTable.ArrangeChildren();
		base.AgeTransform.Width = heroItemsTable.Width;
		OnHeroSelectionChanged();
	}

	public HeroItem GetHeroItem(Hero hero)
	{
		List<HeroItem> children = heroItemsTable.GetChildren<HeroItem>();
		for (int i = 0; i < children.Count; i++)
		{
			if (children[i].Hero == hero)
			{
				return children[i];
			}
		}
		Diagnostics.LogError("Unable to find hero panel for " + hero.name);
		return null;
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		IGameControlService gameControlManager = Services.GetService<IGameControlService>();
		gameControlManager.OnHeroStatsPanelChanged += OnHeroStatsPanelChanged;
		IGameEventService gameEventManager = Services.GetService<IGameEventService>();
		gameEventManager.OnHeroListChanged += OnHeroListChanged;
		gameEventManager.OnHeroSelectionChanged += OnHeroSelectionChanged;
		RefreshContent();
		OnHeroSelectionChanged();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		IGameControlService gameControlManager = Services.GetService<IGameControlService>();
		gameControlManager.OnHeroStatsPanelChanged += OnHeroStatsPanelChanged;
		IGameEventService gameEventManager = Services.GetService<IGameEventService>();
		gameEventManager.OnHeroListChanged -= OnHeroListChanged;
		gameEventManager.OnHeroSelectionChanged -= OnHeroSelectionChanged;
		yield return base.OnHide(instant);
	}

	private HeroItem GetOnlySelectedHeroItem()
	{
		if (Hero.SelectedHeroes.Count != 1)
		{
			return null;
		}
		List<HeroItem> children = heroItemsTable.GetChildren<HeroItem>();
		for (int i = 0; i < children.Count; i++)
		{
			if (children[i].Hero == Hero.SelectedHeroes[0])
			{
				return children[i];
			}
		}
		return null;
	}

	private void BuildHeroesList()
	{
		for (int i = 0; i < allHeroes.Count; i++)
		{
			if (allHeroes[i] != null)
			{
				Hero hero = allHeroes[i];
				hero.OnLevelUp = (HeroMobCommon.LevelUpEventHandler)Delegate.Remove(hero.OnLevelUp, new HeroMobCommon.LevelUpEventHandler(OnHeroLevelUp));
			}
		}
		allHeroes.Clear();
		allHeroes.AddRange(Hero.LocalPlayerActiveRecruitedHeroes);
		allHeroes.AddRange(Hero.RemotePlayersActiveRecruitedHeroes);
		for (int j = 0; j < allHeroes.Count; j++)
		{
			if (allHeroes[j] != null)
			{
				Hero hero2 = allHeroes[j];
				hero2.OnLevelUp = (HeroMobCommon.LevelUpEventHandler)Delegate.Combine(hero2.OnLevelUp, new HeroMobCommon.LevelUpEventHandler(OnHeroLevelUp));
			}
		}
		for (int k = 0; k < Hero.RecentlyDeceasedHeroes.Count; k++)
		{
			allHeroes.Add(null);
		}
	}

	private void UnbindHeroItems()
	{
		List<HeroItem> children = base.AgeTransform.GetChildren<HeroItem>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
		}
	}

	private void OnHeroListChanged()
	{
		RefreshContent();
	}

	private void OnHeroSelectionChanged()
	{
		UpdateHeroStatsPanel();
		UpdateActiveSkillsPanel();
		UpdateArrow();
	}

	private void OnHeroLevelUp()
	{
		OnHeroSelectionChanged();
	}

	public void OnHeroStatsPanelChanged(bool on)
	{
		List<HeroItem> children = heroItemsTable.GetChildren<HeroItem>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].RefreshHeroStatsPanelToggle();
		}
	}

	private void UpdateActiveSkillsPanel()
	{
		if (Hero.SelectedHeroes.Count != 1 || Hero.SelectedHeroes[0].FilteredActiveSkills.Count == 0)
		{
			heroActiveSkillsPanel.Hide();
			heroActiveSkillsPanel.Unbind();
			return;
		}
		if (heroActiveSkillsPanel.Hero != Hero.SelectedHeroes[0])
		{
			heroActiveSkillsPanel.Unbind();
		}
		heroActiveSkillsPanel.Bind(Hero.SelectedHeroes[0]);
		if (!heroActiveSkillsPanel.IsVisible)
		{
			heroActiveSkillsPanel.Show();
		}
		else
		{
			heroActiveSkillsPanel.RefreshContent();
		}
		if (heroActiveSkillsPanel.IsVisible)
		{
			HeroItem heroItem = GetHeroItem(Hero.SelectedHeroes[0]);
			heroActiveSkillsPanel.AgeTransform.X = heroItemsTable.X + heroItem.AgeTransform.X + heroItem.AgeTransform.Width / 2f - heroActiveSkillsPanel.AgeTransform.Width / 2f;
			if (heroActiveSkillsPanel.AgeTransform.X + heroActiveSkillsPanel.AgeTransform.Width > base.AgeTransform.Width)
			{
				heroActiveSkillsPanel.AgeTransform.X = base.AgeTransform.Width - heroActiveSkillsPanel.AgeTransform.Width;
			}
		}
	}

	private void UpdateHeroStatsPanel()
	{
		if (!(heroStatsPanel != null))
		{
			return;
		}
		if (Hero.SelectedHeroes.Count == 1)
		{
			if (heroStatsPanel.IsVisible)
			{
				heroStatsPanel.Unbind();
				heroStatsPanel.Bind(Hero.SelectedHeroes[0], 0);
				heroStatsPanel.RefreshContent();
			}
		}
		else
		{
			heroStatsPanel.Unbind();
			if (heroStatsPanel.IsVisible)
			{
				Services.GetService<IGameControlService>().SetHeroStatsPanelDisplay(on: false);
			}
		}
	}

	private void UpdateArrow()
	{
		if (heroActiveSkillsPanel.IsVisible)
		{
			arrowTfm.Visible = true;
			HeroItem heroItem = GetHeroItem(Hero.SelectedHeroes[0]);
			arrowTfm.X = heroItemsTable.X + heroItem.AgeTransform.X + heroItem.AgeTransform.Width / 2f - arrowTfm.Width / 2f;
		}
		else
		{
			arrowTfm.Visible = false;
		}
	}

	private void RefreshHeroPanel(AgeTransform tableItem, Hero hero, int index)
	{
		HeroItem component = tableItem.GetComponent<HeroItem>();
		if (component == null)
		{
			Diagnostics.LogError("In the HeroListPanel, trying to refresh a table item that is not a HeroItem");
		}
		component.Bind(hero);
		component.RefreshContent();
	}

	private void Update()
	{
		if (arrowTfm.Visible ^ heroActiveSkillsPanel.IsVisible)
		{
			UpdateArrow();
		}
	}
}
public class HeroPanel : GuiPanel
{
	protected IGameControlService gameControlManager;

	public bool UnpauseOnHide
	{
		get;
		set;
	}

	public event EventHandler<EventArgs> OnShowDuringTutorial;

	public void HandleShowInTutorial()
	{
		if (TutorialManager.IsEnable && this.OnShowDuringTutorial != null)
		{
			this.OnShowDuringTutorial(this, new EventArgs());
		}
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		gameControlManager = Services.GetService<IGameControlService>();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		if (UnpauseOnHide)
		{
			UnpauseOnHide = false;
			gameControlManager.SetGamePause(paused: false);
		}
		yield return base.OnHide(instant);
	}

	public virtual void OnEscapeBehavior()
	{
	}
}
public class HeroPlayerNamePanel : GuiPanel
{
	[SerializeField]
	private AgePrimitiveLabel playerNameLabel;

	public void DisplayPlayerName(string playerName, float yOffset)
	{
		playerNameLabel.Text = playerName;
		GetComponent<GameToScreenPositionSync>().WorldOffset = yOffset * Vector3.up;
		Show();
	}
}
public class HeroRecruitmentPanel : PopupMenuPanelRoom
{
	[SerializeField]
	private AgePrimitiveLabel foodCostLabel;

	private Hero hero;

	private IInputService inputManager;

	private AgeTransform worldPosGuiContainer;

	protected override Room GetRoom()
	{
		if (hero != null)
		{
			return hero.RoomElement.ParentRoom;
		}
		return null;
	}

	public void Display(Hero hero, string heroSpeech)
	{
		this.hero = hero;
		Room room = GetRoom();
		if (room == null)
		{
			Diagnostics.LogError("Cant find room to display HeroRecruitmentPanel");
			return;
		}
		SingletonManager.Get<DialogPanel>().Display(heroSpeech, hero.transform, Vector2.zero, room.CenterPosition, -1f);
		GetComponent<GameToScreenPositionSync>().GameEntityTfm = this.hero.transform;
		ShowWhenFinishedHiding();
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		if (hero == null)
		{
			Diagnostics.LogError("Trying to refresh the HeroRecruitmentPanel while there's no hero attached to it");
			return;
		}
		float hiringFoodCost = hero.GetHiringFoodCost();
		foodCostLabel.Text = hiringFoodCost.ToString();
		if (Player.LocalPlayer.FoodStock < hiringFoodCost)
		{
			foodCostLabel.TintColor = Color.red;
		}
		else if ((float)Hero.LocalPlayerActiveRecruitedHeroes.Count >= GameConfig.GetGameConfig().PlayerMaxHeroCount.GetValue())
		{
			foodCostLabel.TintColor = Color.grey;
		}
		else
		{
			foodCostLabel.TintColor = Color.green;
		}
	}

	public override void ClosePanel()
	{
		base.ClosePanel();
		hero = null;
		SingletonManager.Get<DialogPanel>().Hide();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		gameEventManager.OnDungeonFIDSChanged += OnDungeonFIDSChanged;
		if (worldPosGuiContainer != null)
		{
			worldPosGuiContainer.Visible = false;
		}
		RefreshContent();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		GetComponent<GameToScreenPositionSync>().GameEntityTfm = null;
		gameEventManager.OnDungeonFIDSChanged -= OnDungeonFIDSChanged;
		if (worldPosGuiContainer != null)
		{
			worldPosGuiContainer.Visible = true;
		}
		yield return base.OnHide(instant);
		PopupMenuPanel.UnregisterPopupMenuPanel(this);
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		worldPosGuiContainer = SingletonManager.Get<MainGameScreen>().WorldPosGUIContainer.GetComponent<AgeTransform>();
	}

	private void OnRecruitButtonClick()
	{
		hero.Recruit();
		ClosePanel();
	}

	private void OnIgnoreButtonClick()
	{
		ClosePanel();
	}

	private void OnDungeonFIDSChanged()
	{
		RefreshContent();
	}

	public override void OnEscapeBehavior()
	{
		ClosePanel();
	}

	private void Update()
	{
		if (base.IsVisible)
		{
			if (inputManager == null)
			{
				inputManager = Services.GetService<IInputService>();
			}
			if (inputManager.GetControlDown(Control.ConfirmSelectable))
			{
				OnRecruitButtonClick();
			}
		}
	}
}
public class HeroSelectionItem : MonoBehaviour
{
	[SerializeField]
	private AgeTransform[] heroHighlights;

	[SerializeField]
	private AgePrimitiveImage portraitImg;

	[SerializeField]
	private AgePrimitiveImage lockedImg;

	[SerializeField]
	private AgePrimitiveImage notDiscoveredImg;

	[SerializeField]
	private AgeTooltip tooltip;

	[SerializeField]
	private AgeModifier activeCommunityEventMod;

	private GameSelectionPanel gameSelectionPanel;

	private List<int> slotIndexes = new List<int>();

	private HeroConfig heroConfig;

	private bool isUnlockedForActiveCommunityEvent;

	public HeroGameStatsData HeroStats
	{
		get;
		private set;
	}

	public void Bind(HeroGameStatsData heroStats, List<int> selectedIndexes)
	{
		gameSelectionPanel = SingletonManager.Get<GameSelectionPanel>();
		HeroStats = heroStats;
		IDatabase<HeroConfig> database = Databases.GetDatabase<HeroConfig>();
		HeroGameStatsData heroStats2 = HeroStats;
		heroConfig = database.GetValue(heroStats2.ConfigName);
		HeroGameStatsData heroStats3 = HeroStats;
		isUnlockedForActiveCommunityEvent = (heroStats3.Status != HeroStatus.Unlocked && heroConfig.IsCommunityEventHero() && heroConfig.IsCommunityEventActive());
		RefreshPortrait();
		slotIndexes = selectedIndexes;
		for (int i = 0; i < heroHighlights.Length; i++)
		{
			heroHighlights[i].Visible = slotIndexes.Contains(i);
		}
		HeroGameStatsData heroStats4 = HeroStats;
		if (heroStats4.ConfigName == GameSelectionPanel.RandomHeroName)
		{
			gameSelectionPanel.RandomHeroItem = this;
		}
		RefreshTooltip();
	}

	public void Unbind()
	{
		slotIndexes.Clear();
		gameSelectionPanel = null;
	}

	public void RefreshContent()
	{
	}

	public void ConfirmSelect(int selectedSlotIndex)
	{
		heroHighlights[selectedSlotIndex].Visible = true;
		slotIndexes.Add(selectedSlotIndex);
	}

	public void ConfirmUnselect(int unselectedSlotIndex)
	{
		heroHighlights[unselectedSlotIndex].Visible = false;
		slotIndexes.Remove(unselectedSlotIndex);
	}

	public void UnselectRandom(int unselectedSlotIndex)
	{
		heroHighlights[unselectedSlotIndex].Visible = false;
		slotIndexes.Remove(unselectedSlotIndex);
	}

	private void RefreshPortrait()
	{
		IGuiPanelHelper guiPanelHelper = Services.GetService<IGuiService>().GuiPanelHelper;
		Diagnostics.Assert(guiPanelHelper != null, "Unable to access GuiPanelHelper");
		HeroGameStatsData heroStats = HeroStats;
		if (guiPanelHelper.TryGetGuiElement(heroStats.ConfigName, out GuiElement guiElement) && guiPanelHelper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Small, out Texture2D texture))
		{
			portraitImg.Image = texture;
		}
		AgeTransform ageTransform = portraitImg.AgeTransform;
		HeroGameStatsData heroStats2 = HeroStats;
		ageTransform.Visible = (heroStats2.Status != 0 || isUnlockedForActiveCommunityEvent);
		AgeTransform ageTransform2 = lockedImg.AgeTransform;
		HeroGameStatsData heroStats3 = HeroStats;
		ageTransform2.Visible = (heroStats3.Status == HeroStatus.Discovered && !isUnlockedForActiveCommunityEvent);
		AgeTransform ageTransform3 = notDiscoveredImg.AgeTransform;
		HeroGameStatsData heroStats4 = HeroStats;
		ageTransform3.Visible = (heroStats4.Status == HeroStatus.Unknown && !isUnlockedForActiveCommunityEvent);
		if (isUnlockedForActiveCommunityEvent)
		{
			activeCommunityEventMod.StartAnimation();
		}
		else
		{
			activeCommunityEventMod.Reset();
		}
	}

	private void RefreshTooltip()
	{
		tooltip.Content = string.Empty;
		if (isUnlockedForActiveCommunityEvent)
		{
			tooltip.Class = string.Empty;
			tooltip.Content = "%HeroStatusUnlockedForCommunityEventTooltip";
			return;
		}
		HeroGameStatsData heroStats = HeroStats;
		if (heroStats.Status == HeroStatus.Unknown)
		{
			tooltip.Class = string.Empty;
			tooltip.Content = "%HeroStatusUnknownTooltip";
			return;
		}
		HeroGameStatsData heroStats2 = HeroStats;
		if (heroStats2.Status == HeroStatus.Discovered)
		{
			IGuiPanelHelper guiPanelHelper = Services.GetService<IGuiService>().GuiPanelHelper;
			Diagnostics.Assert(guiPanelHelper != null, "Unable to access GuiPanelHelper");
			HeroGameStatsData heroStats3 = HeroStats;
			if (guiPanelHelper.TryGetGuiElement(heroStats3.ConfigName, out GuiElement guiElement))
			{
				string newValue = AgeLocalizer.Instance.LocalizeString(guiElement.Title);
				tooltip.Content = AgeLocalizer.Instance.LocalizeString("%HeroStatusDiscoveredTooltip").Replace("$Name", newValue);
			}
			return;
		}
		HeroGameStatsData heroStats4 = HeroStats;
		if (heroStats4.Status == HeroStatus.Unlocked)
		{
			IGuiPanelHelper guiPanelHelper2 = Services.GetService<IGuiService>().GuiPanelHelper;
			Diagnostics.Assert(guiPanelHelper2 != null, "Unable to access GuiPanelHelper");
			HeroGameStatsData heroStats5 = HeroStats;
			if (guiPanelHelper2.TryGetGuiElement(heroStats5.ConfigName, out GuiElement _))
			{
				tooltip.Class = "HeroSelection";
				AgeTooltip ageTooltip = tooltip;
				HeroGameStatsData heroStats6 = HeroStats;
				ageTooltip.Content = heroStats6.ConfigName;
			}
		}
	}

	private bool IsSelectable()
	{
		HeroGameStatsData heroStats = HeroStats;
		int result;
		if (heroStats.ConfigName != GameSelectionPanel.RandomHeroName)
		{
			HeroGameStatsData heroStats2 = HeroStats;
			result = ((heroStats2.Status == HeroStatus.Unlocked || isUnlockedForActiveCommunityEvent) ? 1 : 0);
		}
		else
		{
			result = 0;
		}
		return (byte)result != 0;
	}

	private void OnLeftClick()
	{
		if (!IsSelectable())
		{
			return;
		}
		IAudioEventService service = Services.GetService<IAudioEventService>();
		Diagnostics.Assert(service != null);
		if ((!gameSelectionPanel.IsMultiplayer) ? (slotIndexes.Count > 0) : slotIndexes.Contains(gameSelectionPanel.GetLocalPlayerIndex()))
		{
			int num = 0;
			while (true)
			{
				int num2 = num;
				DungeonGenerationParams nextDungeonGenerationParams = Dungeon.NextDungeonGenerationParams;
				if (num2 >= nextDungeonGenerationParams.NewGame_SelectedHeroes.Length)
				{
					break;
				}
				DungeonGenerationParams nextDungeonGenerationParams2 = Dungeon.NextDungeonGenerationParams;
				StaticString x = nextDungeonGenerationParams2.NewGame_SelectedHeroes[num];
				HeroGameStatsData heroStats = HeroStats;
				if (x == heroStats.ConfigName)
				{
					GameSelectionPanel obj = gameSelectionPanel;
					HeroGameStatsData heroStats2 = HeroStats;
					obj.TryUnselectHero(heroStats2.ConfigName);
					service.Play2DEvent("Master/GUI/Main_DeselectHero");
					return;
				}
				num++;
			}
		}
		GameSelectionPanel obj2 = gameSelectionPanel;
		HeroGameStatsData heroStats3 = HeroStats;
		obj2.TrySelectHero(heroStats3.ConfigName);
		service.Play2DEvent("Master/GUI/Main_SelectHero");
	}
}
public class HeroSkillsPadLine : MonoBehaviour
{
	[SerializeField]
	private AgePrimitiveImage heroPortrait;

	[SerializeField]
	private AgeTransform activeSkillsTable;

	[SerializeField]
	private AgeTransform passiveSkillsTable;

	[SerializeField]
	private Transform activeSkillPfb;

	[SerializeField]
	private Transform passiveSkillPfb;

	[SerializeField]
	private AgePrimitiveLabel levelLabel;

	[SerializeField]
	private AgeTransform borders;

	protected int heroIndex = int.MaxValue;

	private Selectable previousPassiveSkillSelected;

	private StaticString portraitSize = GuiPanel.IconSize.Small;

	private List<Hero> allHeroes;

	private bool selected;

	private int maxPassiveSkills = 12;

	private List<PassiveSkill> clampedPassiveSkills = new List<PassiveSkill>();

	private IGuiService guiService;

	private AgeTransform heroLevelUpButton;

	private AgePrimitiveLabel heroLevelUpCostLabel;

	private AgeTransform tooltipDock;

	public Hero BoundHero
	{
		get;
		private set;
	}

	public bool Selected
	{
		get
		{
			return selected;
		}
		set
		{
			selected = value;
			borders.Visible = selected;
		}
	}

	public void Bind(Hero hero, int index, AgeTransform parentTooltipDock)
	{
		BoundHero = hero;
		heroIndex = index;
		tooltipDock = parentTooltipDock;
		if (guiService == null)
		{
			guiService = Services.GetService<IGuiService>();
		}
		allHeroes = Hero.GetAllPlayersActiveRecruitedHeroes();
		for (int i = 0; i < allHeroes.Count; i++)
		{
			if (allHeroes[i] != null)
			{
				allHeroes[i].OnSkillsChanged += OnHeroSkillsChanged;
			}
		}
		BoundHero.OnSimRefreshed += OnHeroSimRefreshed;
		Hero boundHero = BoundHero;
		boundHero.OnLevelUp = (HeroMobCommon.LevelUpEventHandler)Delegate.Combine(boundHero.OnLevelUp, new HeroMobCommon.LevelUpEventHandler(OnHeroLevelUp));
		Services.GetService<IGameEventService>().OnDungeonFIDSChanged += OnDungeonFIDSChanged;
		Selected = false;
	}

	public void Unbind()
	{
		BoundHero.OnSimRefreshed -= OnHeroSimRefreshed;
		Hero boundHero = BoundHero;
		boundHero.OnLevelUp = (HeroMobCommon.LevelUpEventHandler)Delegate.Remove(boundHero.OnLevelUp, new HeroMobCommon.LevelUpEventHandler(OnHeroLevelUp));
		Services.GetService<IGameEventService>().OnDungeonFIDSChanged -= OnDungeonFIDSChanged;
		for (int i = 0; i < allHeroes.Count; i++)
		{
			if (allHeroes[i] != null)
			{
				allHeroes[i].OnSkillsChanged -= OnHeroSkillsChanged;
			}
		}
		UnbindActiveSkillItems();
		UnbindPassiveSkillItems();
		BoundHero = null;
	}

	public void RefreshContent()
	{
		if (!(BoundHero == null))
		{
			if (guiService.GuiPanelHelper.TryGetGuiElement(BoundHero.Config.Name, out GuiElement guiElement) && guiService.GuiPanelHelper.TryGetTextureFromIcon(guiElement, portraitSize, out Texture2D texture))
			{
				heroPortrait.Image = texture;
			}
			if (BoundHero != null)
			{
				levelLabel.AgeTransform.Visible = true;
				levelLabel.Text = BoundHero.Level.ToString();
			}
			RefreshSkills();
		}
	}

	private void AssignTooltipToItem(AgeTransform itemTransform)
	{
		AgeTooltip ageTooltip = itemTransform.AgeTooltip;
		if (ageTooltip != null)
		{
			ageTooltip.Anchor = tooltipDock;
			ageTooltip.AnchorMode = AgeTooltipAnchorMode.RIGHT_CENTER;
		}
	}

	private void RefreshSkills()
	{
		foreach (ActiveSkill filteredActiveSkill in BoundHero.FilteredActiveSkills)
		{
			filteredActiveSkill.PreviewLevel = 0;
		}
		foreach (PassiveSkill filteredPassiveSkill in BoundHero.FilteredPassiveSkills)
		{
			filteredPassiveSkill.PreviewLevel = 0;
		}
		UnbindActiveSkillItems();
		activeSkillsTable.ReserveChildren(BoundHero.FilteredActiveSkills.Count, activeSkillPfb, "ActiveSkillItem");
		activeSkillsTable.RefreshChildrenIList(BoundHero.FilteredActiveSkills, RefreshActiveSkillItem);
		UnbindPassiveSkillItems();
		clampedPassiveSkills.Clear();
		for (int i = 0; i < maxPassiveSkills && i < BoundHero.FilteredPassiveSkills.Count; i++)
		{
			clampedPassiveSkills.Add(BoundHero.FilteredPassiveSkills[i]);
		}
		passiveSkillsTable.ReserveChildren(clampedPassiveSkills.Count, passiveSkillPfb, "PassiveSkillItem");
		passiveSkillsTable.RefreshChildrenIList(clampedPassiveSkills, RefreshPassiveSkillItem);
	}

	private void RefreshActiveSkillItem(AgeTransform tableItem, ActiveSkill activeSkill, int index)
	{
		ActiveSkillItem component = tableItem.GetComponent<ActiveSkillItem>();
		component.Bind(BoundHero, activeSkill, index, registerSelectable: true);
		component.RefreshContent();
		AssignTooltipToItem(component.GetComponent<AgeTransform>());
		if (Services.GetService<IInputService>().CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			AGERowSelectable component2 = component.GetComponent<AGERowSelectable>();
			if (component2 != null)
			{
				component2.OnSelectEvent += Selectable_OnSelectEvent;
				component2.OnUnselectEvent += Selectable_OnUnselectEvent;
			}
		}
	}

	private void RefreshPassiveSkillItem(AgeTransform tableItem, PassiveSkill passiveSkill, int index)
	{
		PassiveSkillItem component = tableItem.GetComponent<PassiveSkillItem>();
		component.Bind(BoundHero, passiveSkill);
		component.RefreshContent();
		AssignTooltipToItem(component.GetComponent<AgeTransform>());
		if (Services.GetService<IInputService>().CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			AGERowSelectable component2 = component.GetComponent<AGERowSelectable>();
			if (component2 != null)
			{
				component2.OnSelectEvent += Selectable_OnSelectEvent;
				component2.OnUnselectEvent += Selectable_OnUnselectEvent;
			}
		}
	}

	private void Selectable_OnSelectEvent(AGESelectable obj)
	{
		Selected = true;
	}

	private void Selectable_OnUnselectEvent(AGESelectable obj)
	{
		Selected = false;
	}

	private void UnbindActiveSkillItems()
	{
		ControlScheme currentControlScheme = Services.GetService<IInputService>().CurrentControlScheme;
		List<ActiveSkillItem> children = activeSkillsTable.GetChildren<ActiveSkillItem>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
			if (currentControlScheme == ControlScheme.XBoxOneController)
			{
				AGERowSelectable component = children[i].GetComponent<AGERowSelectable>();
				if (component != null)
				{
					component.OnSelectEvent -= Selectable_OnSelectEvent;
					component.OnUnselectEvent -= Selectable_OnUnselectEvent;
				}
			}
		}
	}

	private void UnbindPassiveSkillItems()
	{
		ControlScheme currentControlScheme = Services.GetService<IInputService>().CurrentControlScheme;
		List<PassiveSkillItem> children = passiveSkillsTable.GetChildren<PassiveSkillItem>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
			if (currentControlScheme == ControlScheme.XBoxOneController)
			{
				AGERowSelectable component = children[i].GetComponent<AGERowSelectable>();
				if (component != null)
				{
					component.OnSelectEvent -= Selectable_OnSelectEvent;
					component.OnUnselectEvent -= Selectable_OnUnselectEvent;
				}
			}
		}
	}

	private void OnHeroSkillsChanged()
	{
		RefreshContent();
	}

	private void OnHeroSimRefreshed()
	{
		RefreshContent();
	}

	private void OnHeroLevelUp()
	{
		RefreshContent();
	}

	private void OnDungeonFIDSChanged()
	{
		RefreshContent();
	}
}
public class HeroStatsBasePanel : HeroPanel
{
	[SerializeField]
	private AgePrimitiveLabel titleLabel;

	[SerializeField]
	private AgePrimitiveLabel levelLabel;

	[SerializeField]
	protected AgePrimitiveLabel levelLevelUpLabel;

	[SerializeField]
	private AgePrimitiveLabel healthLabel;

	[SerializeField]
	protected GUIComparingLabel healthLevelUpLabel;

	[SerializeField]
	private AgePrimitiveLabel healthRegenLabel;

	[SerializeField]
	protected GUIComparingLabel healthRegenLevelUpLabel;

	[SerializeField]
	private AgePrimitiveLabel defenseLabel;

	[SerializeField]
	protected GUIComparingLabel defenseLevelUpLabel;

	[SerializeField]
	private AgePrimitiveLabel moveSpeedLabel;

	[SerializeField]
	protected GUIComparingLabel moveSpeedLevelUpLabel;

	[SerializeField]
	private AgePrimitiveLabel dpsLabel;

	[SerializeField]
	protected GUIComparingLabel dpsLevelUpLabel;

	[SerializeField]
	private AgePrimitiveLabel attackPowerLabel;

	[SerializeField]
	protected GUIComparingLabel attackPowerLevelUpLabel;

	[SerializeField]
	private AgePrimitiveLabel attackCooldownLabel;

	[SerializeField]
	protected GUIComparingLabel attackCooldownLevelUpLabel;

	[SerializeField]
	private AgePrimitiveLabel witLabel;

	[SerializeField]
	protected GUIComparingLabel witLevelUpLabel;

	[SerializeField]
	protected AgeTransform levelUpButton;

	[SerializeField]
	protected AgePrimitiveLabel levelUpCostLabel;

	[SerializeField]
	protected AgePrimitiveImage heroPortrait;

	[SerializeField]
	protected AgePrimitiveLabel healCostLabel;

	[SerializeField]
	protected AgePrimitiveLabel restCostLabel;

	[SerializeField]
	protected AgePrimitiveLabel dismissCostLabel;

	[SerializeField]
	protected AgeTransform unlockGroup;

	[SerializeField]
	protected AgePrimitiveLabel unlockLabel;

	[SerializeField]
	protected AgeTransform healButton;

	[SerializeField]
	protected AgeTransform restButton;

	[SerializeField]
	protected AgeTransform dismissButton;

	[SerializeField]
	protected AgeTransform biographyButton;

	[SerializeField]
	protected AgeTransform closeBiographyButton;

	protected SelectableManager selectableManager;

	protected IInputService inputService;

	protected IGameEventService gameEventService;

	protected List<Hero> allHeroes = new List<Hero>();

	protected Health heroHealth;

	protected bool isMouseOverLevelUpButton;

	protected int heroIndex = int.MaxValue;

	protected StaticString portraitSize = IconSize.Small;

	protected bool isSelected;

	public Hero BoundHero
	{
		get;
		private set;
	}

	public bool IsMouseOverLevelUpButton => isMouseOverLevelUpButton;

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		base.UseRefreshLoop = true;
		base.RefreshDelay = 0.15f;
		portraitSize = IconSize.Small;
		selectableManager = SingletonManager.Get<SelectableManager>();
		inputService = Services.GetService<IInputService>();
		gameEventService = Services.GetService<IGameEventService>();
	}

	public virtual void Bind(Hero hero, int index)
	{
		if (!base.IsLoaded)
		{
			Load();
		}
		BoundHero = hero;
		heroIndex = index;
		heroHealth = BoundHero.GetComponent<Health>();
		BoundHero.OnSimRefreshed += OnHeroSimRefreshed;
		heroHealth.OnHealthChanged += OnHeroHealthChange;
		Hero boundHero = BoundHero;
		boundHero.OnLevelUp = (HeroMobCommon.LevelUpEventHandler)Delegate.Combine(boundHero.OnLevelUp, new HeroMobCommon.LevelUpEventHandler(OnHeroLevelUp));
		gameEventService.OnDungeonFIDSChanged += OnDungeonFIDSChanged;
		if (base.IsVisible)
		{
			gameEventService.TriggerDisplayedHeroStatsRefreshedEvent(hero);
		}
	}

	public virtual void Bind(Hero hero, int index, AgeTransform healButton, AgePrimitiveLabel healCostLabel, AgeTransform restButton, AgePrimitiveLabel restCostLabel, AgeTransform dismissButton, AgePrimitiveLabel dismissCostLabel, AgeTransform levelUpButton, AgePrimitiveLabel levelUpCostLabel, AgeTransform biographyButton, AgeTransform closeBiographyButton)
	{
		this.healButton = healButton;
		this.healCostLabel = healCostLabel;
		this.restButton = restButton;
		this.restCostLabel = restCostLabel;
		this.dismissButton = dismissButton;
		this.dismissCostLabel = dismissCostLabel;
		this.levelUpButton = levelUpButton;
		this.levelUpCostLabel = levelUpCostLabel;
		this.biographyButton = biographyButton;
		this.closeBiographyButton = closeBiographyButton;
		Bind(hero, index);
	}

	public virtual void Unbind()
	{
		if (heroHealth != null)
		{
			heroHealth.OnHealthChanged -= OnHeroHealthChange;
			heroHealth = null;
		}
		if (BoundHero != null)
		{
			BoundHero.OnSimRefreshed -= OnHeroSimRefreshed;
			Hero boundHero = BoundHero;
			boundHero.OnLevelUp = (HeroMobCommon.LevelUpEventHandler)Delegate.Remove(boundHero.OnLevelUp, new HeroMobCommon.LevelUpEventHandler(OnHeroLevelUp));
			gameEventService.OnDungeonFIDSChanged -= OnDungeonFIDSChanged;
			BoundHero = null;
		}
		heroIndex = int.MaxValue;
	}

	public string GetBackstories()
	{
		string text = string.Empty;
		if (UserProfile.Data != null && UserProfile.Data.BackstoriesUnlocked != null && BoundHero != null)
		{
			List<BackstoryData> list = new List<BackstoryData>();
			for (int i = 0; i < UserProfile.Data.BackstoriesUnlocked.Count; i++)
			{
				BackstoryData backstoryData = UserProfile.Data.BackstoriesUnlocked[i];
				if (backstoryData.HeroName == BoundHero.Config.Name)
				{
					list.Add(UserProfile.Data.BackstoriesUnlocked[i]);
				}
			}
			list.Sort((BackstoryData bs1, BackstoryData bs2) => (bs1.StoryName + bs1.StepIndex.ToString()).CompareTo(bs2.StoryName + bs2.StepIndex.ToString()));
			string b = string.Empty;
			{
				foreach (BackstoryData item in list)
				{
					if (item.StoryName != b)
					{
						text += Environment.NewLine;
					}
					text = text + Environment.NewLine + AgeLocalizer.Instance.LocalizeString(item.Text);
					b = item.StoryName;
				}
				return text;
			}
		}
		return text;
	}

	public override void Show(params object[] parameters)
	{
		base.Show(parameters);
		if (BoundHero == null && GetReleventHeroList().Count > heroIndex)
		{
			Bind(GetReleventHeroList()[heroIndex], heroIndex);
		}
		if (BoundHero != null)
		{
			BoundHero.AudioEmitter.PlayEvent("Master/GUI/OpenHeroMenu");
		}
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		RefreshContent();
	}

	public override void Hide(bool instant = false)
	{
		base.Hide(instant);
	}

	protected override IEnumerator OnHide(bool instant)
	{
		base.NeedRefresh = false;
		if (BoundHero != null)
		{
			BoundHero.AudioEmitter.PlayEvent("Master/GUI/CloseHeroMenu");
		}
		yield return base.OnHide(instant);
	}

	public override void RefreshContent()
	{
		if (!(BoundHero == null))
		{
			base.RefreshContent();
			titleLabel.Text = BoundHero.LocalizedName;
			RefreshLevelIcon();
			RefreshUnlockStatus();
			RefreshStats();
			RefreshStatBonuses();
			RefreshPortrait();
			if (isSelected || inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
			{
				RefreshButtons();
			}
		}
	}

	public virtual void RefreshButtons()
	{
		if (!(BoundHero == null))
		{
			RefreshLevelUpButton();
			RefreshHealButton();
			RefreshCooldownRestoreButton();
			RefreshDismissButton();
		}
	}

	private void RefreshPortrait()
	{
		if (base.GuiService.GuiPanelHelper.TryGetGuiElement(BoundHero.Config.Name, out GuiElement guiElement) && base.GuiService.GuiPanelHelper.TryGetTextureFromIcon(guiElement, portraitSize, out Texture2D texture))
		{
			heroPortrait.Image = texture;
		}
	}

	private void RefreshStats()
	{
		float health = heroHealth.GetHealth();
		float maxHealth = heroHealth.GetMaxHealth();
		float simPropertyValue = BoundHero.GetSimPropertyValue(SimulationProperties.HealthRegen);
		float simPropertyValue2 = BoundHero.GetSimPropertyValue(SimulationProperties.Defense);
		float f = BoundHero.GetSimPropertyValue(SimulationProperties.MoveSpeedReal) * 10f;
		float simPropertyValue3 = BoundHero.GetSimPropertyValue(SimulationProperties.AttackPower);
		float simPropertyValue4 = BoundHero.GetSimPropertyValue(SimulationProperties.AttackCooldown);
		float simPropertyValue5 = BoundHero.GetSimPropertyValue(SimulationProperties.Wit);
		float num = GenericUtilities.RoundHalfAwayFromZero(simPropertyValue3 / simPropertyValue4);
		healthLabel.Text = Mathf.Ceil(health) + "/" + Mathf.Ceil(maxHealth);
		healthRegenLabel.Text = Mathf.Ceil(simPropertyValue).ToString();
		defenseLabel.Text = Mathf.Ceil(simPropertyValue2).ToString();
		moveSpeedLabel.Text = Mathf.Ceil(f).ToString();
		attackPowerLabel.Text = Mathf.Ceil(simPropertyValue3).ToString();
		attackCooldownLabel.Text = simPropertyValue4.RoundWithDecimals(1).ToString();
		dpsLabel.Text = num.ToString();
		witLabel.Text = Mathf.Ceil(simPropertyValue5).ToString();
	}

	protected virtual void RefreshStatBonuses()
	{
		healthLevelUpLabel.Text = string.Empty;
		healthRegenLevelUpLabel.Text = string.Empty;
		defenseLevelUpLabel.Text = string.Empty;
		moveSpeedLevelUpLabel.Text = string.Empty;
		attackPowerLevelUpLabel.Text = string.Empty;
		attackCooldownLevelUpLabel.Text = string.Empty;
		dpsLevelUpLabel.Text = string.Empty;
		witLevelUpLabel.Text = string.Empty;
		if (isMouseOverLevelUpButton)
		{
			RefreshLevelUpBonuses();
		}
	}

	private void RefreshLevelUpBonuses()
	{
		if (!isMouseOverLevelUpButton)
		{
			return;
		}
		Dictionary<StaticString, float> levelUpModifiers = BoundHero.GetLevelUpModifiers();
		if (levelUpModifiers == null)
		{
			return;
		}
		SimulationDescriptor shipDesc = SingletonManager.Get<Dungeon>().ShipDesc;
		string path = "Dungeon/Room/Hero";
		float simPropertyValue = BoundHero.GetSimPropertyValue(SimulationProperties.AttackPower);
		float simPropertyValue2 = BoundHero.GetSimPropertyValue(SimulationProperties.AttackCooldown);
		float num = GenericUtilities.RoundHalfAwayFromZero(simPropertyValue / simPropertyValue2);
		if (levelUpModifiers.ContainsKey(SimulationProperties.MaxHealth))
		{
			healthLevelUpLabel.Text = SimMonoBehaviour.ApplyDescModifier(levelUpModifiers[SimulationProperties.MaxHealth], SimulationProperties.Defense, shipDesc, path).ToString();
		}
		if (levelUpModifiers.ContainsKey(SimulationProperties.HealthRegen))
		{
			healthRegenLevelUpLabel.Text = SimMonoBehaviour.ApplyDescModifier(levelUpModifiers[SimulationProperties.HealthRegen], SimulationProperties.Defense, shipDesc, path).ToString();
		}
		if (levelUpModifiers.ContainsKey(SimulationProperties.Defense))
		{
			defenseLevelUpLabel.Text = SimMonoBehaviour.ApplyDescModifier(levelUpModifiers[SimulationProperties.Defense], SimulationProperties.Defense, shipDesc, path).ToString();
		}
		if (levelUpModifiers.ContainsKey(SimulationProperties.MoveSpeed))
		{
			moveSpeedLevelUpLabel.Text = SimMonoBehaviour.ApplyDescModifier(levelUpModifiers[SimulationProperties.MoveSpeed], SimulationProperties.MoveSpeed, shipDesc, path).ToString();
		}
		float num2 = 0f;
		if (levelUpModifiers.ContainsKey(SimulationProperties.AttackPower))
		{
			num2 = SimMonoBehaviour.ApplyDescModifier(levelUpModifiers[SimulationProperties.AttackPower], SimulationProperties.AttackPower, shipDesc, path);
			attackPowerLevelUpLabel.Text = num2.ToString();
		}
		float num3 = 0f;
		if (levelUpModifiers.ContainsKey(SimulationProperties.AttackCooldown))
		{
			num3 = SimMonoBehaviour.ApplyDescModifier(levelUpModifiers[SimulationProperties.AttackCooldown], SimulationProperties.AttackCooldown, shipDesc, path);
			attackCooldownLevelUpLabel.Text = num3.RoundWithDecimals(1).ToString();
		}
		if (levelUpModifiers.ContainsKey(SimulationProperties.AttackPower) || levelUpModifiers.ContainsKey(SimulationProperties.AttackCooldown))
		{
			float num4 = GenericUtilities.RoundHalfAwayFromZero((simPropertyValue + num2) / (simPropertyValue2 + num3));
			if (num4 != num)
			{
				dpsLevelUpLabel.Text = GenericUtilities.RoundHalfAwayFromZero(num4 - num).ToString();
			}
			else
			{
				dpsLevelUpLabel.Text = string.Empty;
			}
		}
		if (levelUpModifiers.ContainsKey(SimulationProperties.Wit))
		{
			witLevelUpLabel.Text = SimMonoBehaviour.ApplyDescModifier(levelUpModifiers[SimulationProperties.Wit], SimulationProperties.Wit, shipDesc, path).ToString();
		}
	}

	private void RefreshLevelIcon()
	{
		if (isMouseOverLevelUpButton)
		{
			levelLabel.AgeTransform.Visible = false;
			levelLabel.Text = string.Empty;
			if (BoundHero != null)
			{
				levelLevelUpLabel.Text = (BoundHero.Level + 1).ToString();
				levelLevelUpLabel.AgeTransform.Visible = true;
			}
		}
		else
		{
			if (BoundHero != null)
			{
				levelLabel.AgeTransform.Visible = true;
				levelLabel.Text = BoundHero.Level.ToString();
			}
			levelLevelUpLabel.Text = string.Empty;
			levelLevelUpLabel.AgeTransform.Visible = false;
		}
	}

	private void RefreshUnlockStatus()
	{
		if (BoundHero.UnlockLevel > 0)
		{
			unlockGroup.Visible = true;
			string newValue = (SingletonManager.Get<Dungeon>().Level - (BoundHero.UnlockLevel - BoundHero.Config.UnlockLevelCount)).ToString();
			string newValue2 = BoundHero.Config.UnlockLevelCount.ToString();
			unlockLabel.Text = AgeLocalizer.Instance.LocalizeString("%HeroUnlockTitle").Replace("$Done", newValue).Replace("$Needed", newValue2);
			unlockGroup.AgeTooltip.Content = AgeLocalizer.Instance.LocalizeString("%HeroUnlockTooltip").Replace("$Done", newValue).Replace("$Needed", newValue2);
		}
		else
		{
			unlockGroup.Visible = false;
			unlockLabel.Text = string.Empty;
			unlockGroup.AgeTooltip.Content = string.Empty;
		}
	}

	protected virtual void RefreshHealButton()
	{
		float num = BoundHero.GetHealFoodCost();
		healCostLabel.Text = num.ToString();
		if (Player.LocalPlayer.FoodStock < num)
		{
			healCostLabel.TintColor = Color.red;
		}
		else
		{
			healCostLabel.TintColor = Color.green;
		}
		healButton.Visible = !SingletonManager.Get<Dungeon>().ShipConfig.ForbidHeal;
	}

	protected virtual void RefreshCooldownRestoreButton()
	{
		float num = BoundHero.GetRestScienceCost();
		restCostLabel.Text = num.ToString();
		if (Player.LocalPlayer.ScienceStock < num)
		{
			restCostLabel.TintColor = Color.red;
		}
		else
		{
			restCostLabel.TintColor = Color.green;
		}
		restButton.Visible = !SingletonManager.Get<Dungeon>().ShipConfig.ForbidHeal;
	}

	protected virtual void RefreshLevelUpButton()
	{
		HeroLevelConfig nextLevelConfig = BoundHero.GetNextLevelConfig();
		levelUpButton.Enable = true;
		if (nextLevelConfig != null)
		{
			levelUpButton.Visible = true;
			float foodCost = nextLevelConfig.FoodCost;
			levelUpCostLabel.Text = foodCost.ToString();
			if (Player.LocalPlayer.FoodStock < foodCost)
			{
				levelUpCostLabel.TintColor = Color.red;
				levelUpCostLabel.AgeTransform.ResetAllModifiers();
			}
			else
			{
				levelUpCostLabel.TintColor = Color.green;
				levelUpCostLabel.AgeTransform.StartAllModifiers();
			}
		}
		else
		{
			levelUpButton.Visible = false;
		}
	}

	protected virtual void RefreshDismissButton()
	{
		float num = (float)(BoundHero.Level * BoundHero.Level) + GameConfig.GetGameConfig().DismissingFoodCoef;
		dismissCostLabel.Text = "+" + num.ToString();
		dismissButton.Enable = (SingletonManager.Get<Dungeon>().CurrentGamePhase == GamePhase.Strategy);
	}

	protected virtual void OnLevelUpButtonClick()
	{
		if (BoundHero == null && GetReleventHeroList().Count > heroIndex)
		{
			Bind(GetReleventHeroList()[heroIndex], heroIndex);
		}
		levelUpButton.Enable = false;
		BoundHero.LevelUp();
	}

	public virtual void OnLevelUpButtonEnter()
	{
		isMouseOverLevelUpButton = true;
		RefreshStatBonuses();
		RefreshLevelIcon();
	}

	public virtual void OnLevelUpButtonLeave()
	{
		isMouseOverLevelUpButton = false;
		RefreshStatBonuses();
		RefreshLevelIcon();
	}

	private void OnHealButtonClick()
	{
		BoundHero.Heal();
	}

	private void OnRestButtonClick()
	{
		BoundHero.Rest();
		base.NeedRefresh = true;
	}

	protected virtual List<Hero> GetReleventHeroList()
	{
		return Hero.LocalPlayerActiveRecruitedHeroes;
	}

	private void OnHeroSimRefreshed()
	{
		if (base.IsVisible)
		{
			base.NeedRefresh = true;
		}
	}

	private void OnHeroHealthChange()
	{
		if (base.IsVisible)
		{
			base.NeedRefresh = true;
		}
	}

	private void OnHeroLevelUp()
	{
		if (base.IsVisible)
		{
			base.NeedRefresh = true;
		}
	}

	private void OnDungeonFIDSChanged()
	{
		if (base.IsVisible)
		{
			base.NeedRefresh = true;
		}
	}
}
public class HeroStatsPadLine : HeroStatsBasePanel
{
	[SerializeField]
	private AgeTransform levelUpConfirmGroup;

	[SerializeField]
	private AgePrimitiveLabel levelUpConfirmLabel;

	[SerializeField]
	private AgeTransform cancelGroup;

	[SerializeField]
	private AgePrimitiveLabel skillPreviewLabel;

	protected AGESelectable selectable;

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		selectable = GetComponent<AGESelectable>();
		selectable.OnSelectEvent += Selectable_OnSelectEvent;
		selectable.OnUnselected += Selectable_OnUnselected;
	}

	protected virtual void OnDestroy()
	{
		Unload();
	}

	public override void Bind(Hero hero, int index, AgeTransform healButton, AgePrimitiveLabel healCostLabel, AgeTransform restButton, AgePrimitiveLabel restCostLabel, AgeTransform dismissButton, AgePrimitiveLabel dismissCostLabel, AgeTransform levelUpButton, AgePrimitiveLabel levelUpCostLabel, AgeTransform biographyButton, AgeTransform closeBiographyButton)
	{
		base.Bind(hero, index, healButton, healCostLabel, restButton, restCostLabel, dismissButton, dismissCostLabel, levelUpButton, levelUpCostLabel, biographyButton, closeBiographyButton);
		Show();
	}

	public override void Unbind()
	{
		base.Unbind();
		Hide();
	}

	public void OnLevelUpButtonPressed()
	{
		if (isMouseOverLevelUpButton)
		{
			base.BoundHero.LevelUp();
			OnLevelUpButtonLeave();
		}
		else
		{
			OnLevelUpButtonEnter();
		}
	}

	private void Selectable_OnSelectEvent(AGESelectable obj)
	{
		isSelected = true;
		RefreshButtons();
		if (isMouseOverLevelUpButton)
		{
			biographyButton.Visible = false;
			closeBiographyButton.Visible = false;
		}
		else
		{
			biographyButton.Visible = !SingletonManager.Get<TabHeroesStatsPanel>().BiographyMode;
			closeBiographyButton.Visible = SingletonManager.Get<TabHeroesStatsPanel>().BiographyMode;
		}
	}

	private void Selectable_OnUnselected()
	{
		isSelected = false;
		OnLevelUpButtonLeave();
	}

	public override void RefreshButtons()
	{
		base.RefreshButtons();
	}

	protected override void RefreshHealButton()
	{
		base.RefreshHealButton();
		healButton.Enable = (healButton.Visible && healCostLabel.TintColor != Color.red);
		healButton.Visible = !isMouseOverLevelUpButton;
	}

	protected override void RefreshCooldownRestoreButton()
	{
		base.RefreshCooldownRestoreButton();
		restButton.Enable = (restButton.Visible && restCostLabel.TintColor != Color.red);
		restButton.Visible = !isMouseOverLevelUpButton;
	}

	protected override void RefreshLevelUpButton()
	{
		//Discarded unreachable code: IL_0140, IL_01cc
		base.RefreshLevelUpButton();
		levelUpButton.Enable = (levelUpButton.Visible && levelUpCostLabel.TintColor != Color.red);
		levelUpButton.Visible = !isMouseOverLevelUpButton;
		cancelGroup.Visible = isMouseOverLevelUpButton;
		levelUpConfirmGroup.Visible = isMouseOverLevelUpButton;
		levelUpConfirmLabel.Text = AgeLocalizer.Instance.LocalizeString("%ConfirmLevelUp") + " " + levelUpCostLabel.Text + " \\7700\\#REVERT#";
		bool flag = false;
		StaticString x = string.Empty;
		if (isMouseOverLevelUpButton)
		{
			HeroLevelConfig nextLevelConfig = base.BoundHero.GetNextLevelConfig();
			if (nextLevelConfig != null)
			{
				if (nextLevelConfig.HasActiveSkills)
				{
					string[] skills = nextLevelConfig.Skills;
					int num = 0;
					if (num < skills.Length)
					{
						string x2 = skills[num];
						SkillConfig value = Databases.GetDatabase<SkillConfig>().GetValue(x2);
						value.Init();
						ActiveSkill x3 = base.BoundHero.ActiveSkillLesserThan(value);
						flag = true;
						x = ((!(x3 == null)) ? "%SkillLevelUp" : "%NewSkill");
					}
				}
				if (!flag && nextLevelConfig.HasPassiveSkills)
				{
					string[] skills2 = nextLevelConfig.Skills;
					int num2 = 0;
					if (num2 < skills2.Length)
					{
						string x4 = skills2[num2];
						SkillConfig value2 = Databases.GetDatabase<SkillConfig>().GetValue(x4);
						value2.Init();
						PassiveSkill x5 = base.BoundHero.PassiveSkillLesserThan(value2);
						flag = true;
						x = ((!(x5 == null)) ? "%SkillLevelUp" : "%NewSkill");
					}
				}
			}
		}
		skillPreviewLabel.AgeTransform.Visible = flag;
		skillPreviewLabel.Text = x;
	}

	protected override void RefreshDismissButton()
	{
		base.RefreshDismissButton();
		dismissButton.Visible = !isMouseOverLevelUpButton;
	}

	public override void OnLevelUpButtonEnter()
	{
		base.OnLevelUpButtonEnter();
		RefreshButtons();
	}

	public override void OnLevelUpButtonLeave()
	{
		base.OnLevelUpButtonLeave();
		RefreshButtons();
	}
}
public class HeroStatsPanel : HeroStatsBasePanel, IPopupMenuPanel
{
	[SerializeField]
	private AgePrimitiveLabel heroBiography;

	[SerializeField]
	private AgeControlScrollView heroBiographyScrollView;

	[SerializeField]
	private AGESelectable heroBiographySelectable;

	[SerializeField]
	private AgeTransform activeSkillsTable;

	[SerializeField]
	private AgeTransform passiveSkillsTable;

	[SerializeField]
	private Transform activeSkillPfb;

	[SerializeField]
	private Transform passiveSkillPfb;

	[SerializeField]
	private AgeTransform newActiveSkillIcon;

	[SerializeField]
	private AgeTransform newPassiveSkillIcon;

	[SerializeField]
	private AgeTransform scrollRightButton;

	[SerializeField]
	private AgeTransform scrollLeftButton;

	[SerializeField]
	private AGESelectable defaultSelectable;

	[SerializeField]
	private AgePrimitiveLabel xboxEquipInputLabel;

	[SerializeField]
	private AGESelectable passiveSkillScrollLeft;

	[SerializeField]
	private AGESelectable passiveSkillScrollRight;

	[SerializeField]
	private AgeTransform gameMenuIndication;

	[SerializeField]
	private HeroEquipementBasePanel equipmentPanel;

	private int passiveSkillShowIndex;

	private int passiveSkillMaxShowCount = 6;

	private int scrollModifier;

	private Selectable previousPassiveSkillSelected;

	public AgePrimitiveLabel XboxEquipInputLabel => xboxEquipInputLabel;

	protected override void Awake()
	{
		base.Awake();
		if (Services.GetService<IInputService>().CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			SingletonManager.RegisterInstance(this, typeof(HeroPanel));
			SingletonManager.RegisterInstance(equipmentPanel);
		}
	}

	public override void Bind(Hero hero, int index)
	{
		base.Bind(hero, index);
		equipmentPanel.Bind(hero, null);
		scrollModifier = 0;
		passiveSkillShowIndex = 0;
		RefreshHeroBiography();
	}

	public override void Unbind()
	{
		base.Unbind();
		UnbindActiveSkillItems();
		UnbindPassiveSkillItems();
		equipmentPanel.Unbind();
	}

	public override void Show(params object[] parameters)
	{
		gameEventService.OnItemListSelected += InventoryListPanel_OnItemSelected;
		base.Show(parameters);
		equipmentPanel.Show(parameters);
	}

	public override void Hide(bool instant = false)
	{
		if (gameEventService != null)
		{
			gameEventService.OnItemListSelected -= InventoryListPanel_OnItemSelected;
		}
		base.Hide(instant);
	}

	public override void RefreshContent()
	{
		if (!(base.BoundHero == null))
		{
			base.RefreshContent();
			RefreshSkillsTables();
			equipmentPanel.RefreshContent();
		}
	}

	public void SetSelectedInventoryItem(InventoryItem item)
	{
		equipmentPanel.SelectedInventoryItem = item;
		RefreshStatBonuses();
		RefreshSkillsTables();
	}

	public void SetHoveredInventoryItem(InventoryItem item)
	{
		equipmentPanel.HoveredInventoryItem = item;
		RefreshStatBonuses();
		RefreshSkillsTables();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		PopupMenuPanel.RegisterPopupMenuPanel(this);
		SingletonManager.Get<ResearchPanel>().Hide();
		SingletonManager.Get<ResearchingPanel>().Hide();
		List<Hero> heroes = GetReleventHeroList();
		if (heroes.Count > heroIndex)
		{
			heroes[heroIndex].Select(recordSelectTime: true, unselectOthers: true, triggerHeroSelectionEvent: false);
		}
		allHeroes = Hero.GetAllPlayersActiveRecruitedHeroes();
		for (int i = 0; i < allHeroes.Count; i++)
		{
			if (allHeroes[i] != null)
			{
				allHeroes[i].OnSkillsChanged += OnHeroSkillsChanged;
			}
		}
		HandleShowInTutorial();
		if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard && gameEventService != null)
		{
			gameEventService.OnInGameClickDown += OnInGameClickDown;
		}
		yield return base.OnShow(parameters);
	}

	protected override IEnumerator OnHide(bool instant)
	{
		for (int i = 0; i < allHeroes.Count; i++)
		{
			if (allHeroes[i] != null)
			{
				allHeroes[i].OnSkillsChanged -= OnHeroSkillsChanged;
			}
		}
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			gameMenuIndication.StartAllModifiers(forward: false);
		}
		else if (gameEventService != null)
		{
			gameEventService.OnInGameClickDown -= OnInGameClickDown;
		}
		PopupMenuPanel.UnregisterPopupMenuPanel(this);
		yield return base.OnHide(instant);
	}

	public override void OnEscapeBehavior()
	{
		Hide();
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		portraitSize = IconSize.Large;
	}

	private void RefreshHeroBiography()
	{
		if (base.GuiService.GuiPanelHelper.TryGetGuiElement(base.BoundHero.Config.Name, out GuiElement guiElement))
		{
			heroBiography.Text = string.Empty;
			heroBiography.AgeTransform.Height = 0f;
			heroBiography.Text = AgeLocalizer.Instance.LocalizeString(guiElement.Description);
			heroBiography.Text += GetBackstories();
			heroBiographyScrollView.ResetUp();
		}
	}

	private void RefreshSkillsTables()
	{
		if (base.BoundHero == null)
		{
			return;
		}
		HeroLevelConfig nextLevelConfig = base.BoundHero.GetNextLevelConfig();
		foreach (ActiveSkill filteredActiveSkill in base.BoundHero.FilteredActiveSkills)
		{
			filteredActiveSkill.PreviewLevel = 0;
		}
		foreach (PassiveSkill filteredPassiveSkill in base.BoundHero.FilteredPassiveSkills)
		{
			filteredPassiveSkill.PreviewLevel = 0;
		}
		newActiveSkillIcon.Visible = false;
		newPassiveSkillIcon.Visible = false;
		if (nextLevelConfig != null && isMouseOverLevelUpButton)
		{
			if (nextLevelConfig.HasActiveSkills)
			{
				string[] skills = nextLevelConfig.Skills;
				foreach (string x in skills)
				{
					SkillConfig value = Databases.GetDatabase<SkillConfig>().GetValue(x);
					value.Init();
					ActiveSkill activeSkill = base.BoundHero.ActiveSkillLesserThan(value);
					if (activeSkill == null)
					{
						newActiveSkillIcon.Visible = true;
					}
					else
					{
						activeSkill.PreviewLevel = value.Level;
					}
				}
			}
			if (nextLevelConfig.HasPassiveSkills)
			{
				string[] skills2 = nextLevelConfig.Skills;
				foreach (string x2 in skills2)
				{
					SkillConfig value2 = Databases.GetDatabase<SkillConfig>().GetValue(x2);
					value2.Init();
					PassiveSkill passiveSkill = base.BoundHero.PassiveSkillLesserThan(value2);
					if (passiveSkill == null)
					{
						newPassiveSkillIcon.Visible = true;
					}
					else
					{
						passiveSkill.PreviewLevel = value2.Level;
					}
				}
			}
		}
		else if (equipmentPanel.ComparedItem != null && base.BoundHero.CanEquipItem(equipmentPanel.ComparedItem) && equipmentPanel.ComparedItem.ItemConfig.Skills != null && equipmentPanel.ComparedItem.ItemConfig.Skills.Length > 0)
		{
			for (int k = 0; k < equipmentPanel.ComparedItem.ItemConfig.Skills.Length; k++)
			{
				SkillConfig value3 = Databases.GetDatabase<SkillConfig>().GetValue(equipmentPanel.ComparedItem.ItemConfig.Skills[k]);
				value3.Init();
				if (value3.IsActive)
				{
					ActiveSkill activeSkill2 = base.BoundHero.ActiveSkillLesserThan(value3);
					if (activeSkill2 == null)
					{
						newActiveSkillIcon.Visible = true;
					}
					else
					{
						activeSkill2.PreviewLevel = value3.Level;
					}
				}
				else
				{
					PassiveSkill passiveSkill2 = base.BoundHero.PassiveSkillLesserThan(value3);
					if (passiveSkill2 == null)
					{
						newPassiveSkillIcon.Visible = true;
					}
					else
					{
						passiveSkill2.PreviewLevel = value3.Level;
					}
				}
			}
		}
		if (newActiveSkillIcon.Visible)
		{
			newActiveSkillIcon.PixelMarginLeft = (newActiveSkillIcon.Width + 2f) * (float)base.BoundHero.FilteredActiveSkills.Count;
		}
		if (newPassiveSkillIcon.Visible)
		{
			newPassiveSkillIcon.PixelMarginLeft = (newPassiveSkillIcon.Width + 2f) * (float)Mathf.Min(passiveSkillMaxShowCount - 1, base.BoundHero.FilteredPassiveSkills.Count);
			if (base.BoundHero.FilteredPassiveSkills.Count >= passiveSkillMaxShowCount)
			{
				scrollModifier = 1;
				passiveSkillShowIndex = Mathf.Max(0, base.BoundHero.FilteredPassiveSkills.Count - passiveSkillMaxShowCount + scrollModifier);
			}
		}
		else if (scrollModifier > 0)
		{
			scrollModifier = 0;
			passiveSkillShowIndex = Mathf.Max(0, base.BoundHero.FilteredPassiveSkills.Count - passiveSkillMaxShowCount);
		}
		UnbindActiveSkillItems();
		activeSkillsTable.ReserveChildren(base.BoundHero.FilteredActiveSkills.Count, activeSkillPfb, "ActiveSkillItem");
		activeSkillsTable.RefreshChildrenArray(base.BoundHero.FilteredActiveSkills.ToArray(), RefreshActiveSkillItem);
		int num = Mathf.Min(passiveSkillMaxShowCount - scrollModifier, base.BoundHero.FilteredPassiveSkills.Count);
		if (passiveSkillShowIndex + num <= base.BoundHero.FilteredPassiveSkills.Count)
		{
			List<PassiveSkill> range = base.BoundHero.FilteredPassiveSkills.GetRange(passiveSkillShowIndex, num);
			UnbindPassiveSkillItems();
			passiveSkillsTable.ReserveChildren(passiveSkillMaxShowCount, passiveSkillPfb, "PassiveSkillItem");
			passiveSkillsTable.RefreshChildrenArray(range.ToArray(), RefreshPassiveSkillItem);
		}
		bool visible = base.BoundHero.FilteredPassiveSkills.Count > passiveSkillMaxShowCount;
		scrollRightButton.Visible = visible;
		scrollLeftButton.Visible = visible;
		UpdateScrollButtonVisibility();
	}

	private void UnbindActiveSkillItems()
	{
		List<ActiveSkillItem> children = activeSkillsTable.GetChildren<ActiveSkillItem>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
		}
	}

	private void UnbindPassiveSkillItems()
	{
		List<PassiveSkillItem> children = passiveSkillsTable.GetChildren<PassiveSkillItem>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
			if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
			{
				children[i].RowSelectable.OnSelectEvent -= RowSelectable_OnSelectEvent;
			}
		}
	}

	private void RefreshActiveSkillItem(AgeTransform tableItem, ActiveSkill activeSkill, int index)
	{
		ActiveSkillItem component = tableItem.GetComponent<ActiveSkillItem>();
		component.Bind(base.BoundHero, activeSkill, index, registerSelectable: true);
		component.RefreshContent();
	}

	private void RefreshPassiveSkillItem(AgeTransform tableItem, PassiveSkill passiveSkill, int index)
	{
		PassiveSkillItem component = tableItem.GetComponent<PassiveSkillItem>();
		component.Bind(base.BoundHero, passiveSkill);
		component.RefreshContent();
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			component.RowSelectable.Index = index;
			component.RowSelectable.OnSelectEvent += RowSelectable_OnSelectEvent;
		}
	}

	private void RowSelectable_OnSelectEvent(AGESelectable obj)
	{
		if (base.BoundHero.FilteredPassiveSkills.Count > passiveSkillMaxShowCount)
		{
			AGERowSelectable aGERowSelectable = obj as AGERowSelectable;
			if (aGERowSelectable != null && aGERowSelectable.Index == 0 && !passiveSkillScrollLeft.IsRegistered)
			{
				passiveSkillScrollLeft.Register();
			}
			else if (passiveSkillScrollLeft.IsRegistered)
			{
				passiveSkillScrollLeft.Unregister();
			}
			if (aGERowSelectable != null && aGERowSelectable.Index == passiveSkillMaxShowCount - 1 && !passiveSkillScrollRight.IsRegistered)
			{
				passiveSkillScrollRight.Register();
			}
			else if (passiveSkillScrollRight.IsRegistered)
			{
				passiveSkillScrollRight.Unregister();
			}
		}
		else
		{
			if (passiveSkillScrollLeft.IsRegistered)
			{
				passiveSkillScrollLeft.Unregister();
			}
			if (passiveSkillScrollRight.IsRegistered)
			{
				passiveSkillScrollRight.Unregister();
			}
		}
		UpdateScrollButtonVisibility();
		previousPassiveSkillSelected = obj;
	}

	private void UpdateScrollButtonVisibility()
	{
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			bool flag = base.BoundHero.FilteredPassiveSkills.Count > passiveSkillMaxShowCount;
			scrollLeftButton.Visible = (flag && passiveSkillShowIndex > 0);
			scrollRightButton.Visible = (flag && passiveSkillShowIndex == 0);
		}
	}

	protected override void RefreshStatBonuses()
	{
		base.RefreshStatBonuses();
		if (!isMouseOverLevelUpButton)
		{
			equipmentPanel.RefreshComparedItemBonuses();
		}
	}

	private void OnHeroSkillsChanged()
	{
		if (base.IsVisible)
		{
			base.NeedRefresh = true;
		}
	}

	public override void OnLevelUpButtonEnter()
	{
		base.OnLevelUpButtonEnter();
		RefreshSkillsTables();
	}

	public override void OnLevelUpButtonLeave()
	{
		base.OnLevelUpButtonLeave();
		RefreshSkillsTables();
	}

	private void OnCloseButtonClick()
	{
		Hide();
	}

	private void OnDismissButtonClick()
	{
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		if (dungeon.CurrentGamePhase == GamePhase.Strategy)
		{
			SingletonManager.Get<RequesterPanel>().Display("%DismissHeroConfirm", OnDismissConfirmResult, RequesterPanel.ButtonsMode.YesNo);
		}
		else
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_ActionDismissFail"));
		}
	}

	public void OnScrollPassiveLeft()
	{
		if (passiveSkillShowIndex > 0)
		{
			passiveSkillShowIndex--;
			base.NeedRefresh = true;
		}
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController && previousPassiveSkillSelected != null)
		{
			previousPassiveSkillSelected.Select(silent: true);
		}
		UpdateScrollButtonVisibility();
	}

	public void OnScrollPassiveRight()
	{
		if (base.BoundHero.FilteredPassiveSkills.Count - passiveSkillShowIndex > passiveSkillMaxShowCount)
		{
			passiveSkillShowIndex++;
			base.NeedRefresh = true;
		}
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController && previousPassiveSkillSelected != null)
		{
			previousPassiveSkillSelected.Select(silent: true);
		}
		UpdateScrollButtonVisibility();
	}

	private void OnDismissConfirmResult(RequesterPanel.Result result)
	{
		if (result != RequesterPanel.Result.Yes)
		{
			return;
		}
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		if (dungeon.CurrentGamePhase != 0)
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_ActionDismissFail"));
			return;
		}
		base.BoundHero.Dismiss();
		IAudioEventService service = Services.GetService<IAudioEventService>();
		service.Play2DEvent("Master/GUI/DismissButton");
		Hide();
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			selectableManager.SetCategory(SelectionCategory.RoomForMove);
		}
	}

	public void InventoryListPanel_OnItemSelected(InventoryListPanel sender, InventoryGuiItem inventoryGuiItem)
	{
		if (base.IsVisible)
		{
			base.NeedRefresh = true;
		}
	}

	protected override List<Hero> GetReleventHeroList()
	{
		return Hero.SelectedHeroes;
	}

	private void OnInGameClickDown(MouseButton mouseButton)
	{
		if (mouseButton == MouseButton.Right)
		{
			Hide();
		}
	}
}
internal enum TabPanelType
{
	Stats,
	Equipment,
	Skills,
	PlayerList,
	System
}
public class HeroesPadPanel : HeroPanel
{
	[SerializeField]
	private TabHeroesStatsPanel statPanel;

	[SerializeField]
	private TabHeroesEquipmentPanel equipementPanel;

	[SerializeField]
	private TabHeroesSkillsPanel skillsPanel;

	[SerializeField]
	private TabPlayerListPanel playerListPanel;

	[SerializeField]
	private TabSystemPanel systemPanel;

	[SerializeField]
	private AgeControlToggle[] tabTogglesArray;

	[SerializeField]
	private AgeTransform tabsTable;

	[SerializeField]
	protected AgeTransform closeGroup;

	[SerializeField]
	protected AgeTransform xboxTabButtonLeft;

	[SerializeField]
	protected AgeTransform xboxTabButtonRight;

	private bool doUpdate;

	private List<TabPanelType> activeTabPanelTypes = new List<TabPanelType>();

	private Dictionary<TabPanelType, AgeControlToggle> tabTogglesByType = new Dictionary<TabPanelType, AgeControlToggle>();

	private Dictionary<TabPanelType, TabBasePanel> tabPanelsByType = new Dictionary<TabPanelType, TabBasePanel>();

	private IInputService inputService;

	private SelectableManager selectableManager;

	private IGameEventService gameEventService;

	private TutorialManager tutorialManager;

	private IGameCameraService gameCameraService;

	public int CurrentTabIndex
	{
		get;
		set;
	}

	public TabHeroesStatsPanel StatPanel
	{
		get
		{
			return statPanel;
		}
		private set
		{
		}
	}

	public override void OnEscapeBehavior()
	{
		if (!SpecialEscapeBehavior(testOnly: false))
		{
			Hide();
			selectableManager.SetCategory(SelectionCategory.RoomForMove);
		}
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		tabPanelsByType[activeTabPanelTypes[CurrentTabIndex]].RefreshContent();
	}

	protected override void Awake()
	{
		base.Awake();
		tabPanelsByType.Add(TabPanelType.Stats, statPanel);
		tabPanelsByType.Add(TabPanelType.Equipment, equipementPanel);
		tabPanelsByType.Add(TabPanelType.Skills, skillsPanel);
		tabPanelsByType.Add(TabPanelType.PlayerList, playerListPanel);
		tabPanelsByType.Add(TabPanelType.System, systemPanel);
		tabTogglesByType.Add(TabPanelType.Stats, tabTogglesArray[0]);
		tabTogglesByType.Add(TabPanelType.Equipment, tabTogglesArray[1]);
		tabTogglesByType.Add(TabPanelType.Skills, tabTogglesArray[2]);
		tabTogglesByType.Add(TabPanelType.PlayerList, tabTogglesArray[3]);
		tabTogglesByType.Add(TabPanelType.System, tabTogglesArray[4]);
		selectableManager = SingletonManager.Get<SelectableManager>();
		inputService = Services.GetService<IInputService>();
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			SingletonManager.RegisterInstance(this, typeof(HeroPanel));
		}
		gameEventService = Services.GetService<IGameEventService>();
		gameEventService.OnGameStarted += GameEventService_OnGameStarted;
		gameEventService.OnGameStopped += GameEventService_OnGameStopped;
		gameCameraService = Services.GetService<IGameCameraService>();
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		tutorialManager = SingletonManager.Get<TutorialManager>();
		SetupTabsAndPanels();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		doUpdate = false;
		Hero.OnLocalActiveHeroesChange -= Hero_OnLocalActiveHeroesChange;
		tabPanelsByType[activeTabPanelTypes[CurrentTabIndex]].Hide(instant);
		if (TutorialManager.IsEnable && tutorialManager != null)
		{
			tutorialManager.MovePanelLeft();
		}
		yield return base.OnHide(instant);
	}

	public override void Show(params object[] parameters)
	{
		if (!gameCameraService.IsSwitchingCamera)
		{
			base.Show(parameters);
		}
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		StartCoroutine(UpdateLoop());
		Hero.OnLocalActiveHeroesChange += Hero_OnLocalActiveHeroesChange;
		if (TutorialManager.IsEnable)
		{
			CurrentTabIndex = 0;
			HandleShowInTutorial();
		}
		foreach (KeyValuePair<TabPanelType, AgeControlToggle> kvp in tabTogglesByType)
		{
			kvp.Value.State = (kvp.Key == activeTabPanelTypes[CurrentTabIndex]);
			if (kvp.Key != activeTabPanelTypes[CurrentTabIndex] && tabPanelsByType[kvp.Key].IsVisible)
			{
				tabPanelsByType[kvp.Key].Hide();
			}
		}
		tabPanelsByType[activeTabPanelTypes[CurrentTabIndex]].Show(parameters);
		if (TutorialManager.IsEnable && tutorialManager != null)
		{
			tutorialManager.MovePanelRight();
		}
	}

	private void Hero_OnLocalActiveHeroesChange()
	{
		base.NeedRefresh = true;
		SpecialEscapeBehavior(testOnly: false);
	}

	private void GameEventService_OnGameStarted()
	{
		SetupTabsAndPanels();
	}

	private void GameEventService_OnGameStopped(bool killAutoSave)
	{
		Hide();
	}

	private void SelectTabIndex(int index)
	{
		TabPanelType key = activeTabPanelTypes[index];
		tabPanelsByType[key].Show();
		tabTogglesByType[key].State = true;
	}

	private void SetupTabsAndPanels()
	{
		activeTabPanelTypes.Clear();
		activeTabPanelTypes.Add(TabPanelType.Stats);
		activeTabPanelTypes.Add(TabPanelType.Equipment);
		activeTabPanelTypes.Add(TabPanelType.Skills);
		if (SingletonManager.Get<GameNetworkManager>().IsMultiplayerSession())
		{
			activeTabPanelTypes.Add(TabPanelType.PlayerList);
		}
		activeTabPanelTypes.Add(TabPanelType.System);
		foreach (TabBasePanel value in tabPanelsByType.Values)
		{
			value.Hide();
		}
		for (int i = 0; i < tabTogglesArray.Length; i++)
		{
			tabTogglesArray[i].AgeTransform.Visible = false;
			tabTogglesArray[i].State = false;
		}
		for (int j = 0; j < activeTabPanelTypes.Count; j++)
		{
			TabPanelType key = activeTabPanelTypes[j];
			tabTogglesByType[key].AgeTransform.Visible = true;
		}
		int num = tabsTable.ComputeVisibleChildren();
		float width = Mathf.Floor(tabsTable.Width / (float)num);
		for (int k = 0; k < tabTogglesArray.Length; k++)
		{
			tabTogglesArray[k].AgeTransform.Width = width;
		}
		CurrentTabIndex = 0;
		tabTogglesByType[activeTabPanelTypes[CurrentTabIndex]].State = true;
	}

	private bool SpecialEscapeBehavior(bool testOnly)
	{
		bool result = false;
		if (statPanel.IsVisible)
		{
			HeroStatsPadLine selectedStatPanel = statPanel.GetSelectedStatPanel();
			if (selectedStatPanel != null && selectedStatPanel.IsMouseOverLevelUpButton)
			{
				if (!testOnly)
				{
					selectedStatPanel.OnLevelUpButtonLeave();
					statPanel.RefreshContent();
				}
				result = true;
			}
			else if (statPanel.BiographyMode)
			{
				if (!testOnly)
				{
					statPanel.BiographyMode = false;
				}
				result = true;
			}
		}
		else if (equipementPanel.IsVisible && InventoryListPanel.SelectedGuiItem != null)
		{
			if (!testOnly)
			{
				equipementPanel.RestoreNormalSelection(restorePreviousItemSelected: true);
			}
			result = true;
		}
		return result;
	}

	private IEnumerator UpdateLoop()
	{
		doUpdate = true;
		ControlsOverviewPanel controlsOverviewPanel = SingletonManager.Get<ControlsOverviewPanel>();
		while (doUpdate)
		{
			if (tabPanelsByType[(TabPanelType)CurrentTabIndex].CanNavigate() && !controlsOverviewPanel.IsVisible)
			{
				if (inputService.GetControlDown(Control.PreviousTab))
				{
					UnselectTabIndex(CurrentTabIndex);
					CurrentTabIndex = (CurrentTabIndex + activeTabPanelTypes.Count - 1) % activeTabPanelTypes.Count;
					SelectTabIndex(CurrentTabIndex);
					xboxTabButtonLeft.StartAllModifiers();
				}
				else if (inputService.GetControlDown(Control.NextTab))
				{
					UnselectTabIndex(CurrentTabIndex);
					CurrentTabIndex = (CurrentTabIndex + 1) % activeTabPanelTypes.Count;
					SelectTabIndex(CurrentTabIndex);
					xboxTabButtonRight.StartAllModifiers();
				}
			}
			closeGroup.Visible = !SpecialEscapeBehavior(testOnly: true);
			yield return null;
		}
	}

	private void UnselectTabIndex(int index)
	{
		TabPanelType key = activeTabPanelTypes[index];
		tabPanelsByType[key].Hide();
		tabTogglesByType[key].State = false;
	}
}
public class HighscoreItem : MonoBehaviour
{
	[SerializeField]
	private AgePrimitiveLabel scoreLabel;

	[SerializeField]
	private AgePrimitiveLabel difficultyLabel;

	[SerializeField]
	private AgePrimitiveImage resultImage;

	[SerializeField]
	private AgePrimitiveImage shipBackground;

	[SerializeField]
	private Texture2D winningGameImage;

	[SerializeField]
	private Texture2D lostGameImage;

	[SerializeField]
	private AgePrimitiveLabel floorLabel;

	[SerializeField]
	private AgeTransform heroTable;

	[SerializeField]
	private Transform heroPortraitPfb;

	[SerializeField]
	private Color winGameTextColor;

	[SerializeField]
	private AgeModifier latestHSGlow;

	private HighscoreData data;

	public void Bind(HighscoreData data)
	{
		this.data = data;
	}

	public void Unbind()
	{
		latestHSGlow.Reset();
		data = null;
	}

	public void RefreshContent()
	{
		scoreLabel.Text = data.Score.ToString("### ###");
		scoreLabel.TintColor = ((!data.Victory) ? Color.white : winGameTextColor);
		difficultyLabel.Text = "%Difficulty" + data.Difficulty.ToString() + "Title";
		resultImage.Image = ((!data.Victory) ? lostGameImage : winningGameImage);
		floorLabel.Text = data.Floor.ToString();
		floorLabel.AgeTransform.Visible = !data.Victory;
		shipBackground.Image = AgeManager.Instance.FindDynamicTexture("GUI/DynamicBitmaps/LeaderBoard/" + data.ShipName);
		if (data.Time != 0.0 && data.Time == SingletonManager.Get<HighscoresPanel>().LatestHighscoreTime)
		{
			latestHSGlow.StartAnimation();
		}
		heroTable.ReserveChildren(data.HeroesUsed.Length, heroPortraitPfb);
		heroTable.RefreshChildrenArray(data.HeroesUsed, RefreshHeroPortraits);
		heroTable.ArrangeChildren();
	}

	private void RefreshHeroPortraits(AgeTransform tableItem, StaticString heroName, int index)
	{
		HeroHighScorePortraitPanel component = tableItem.GetComponent<HeroHighScorePortraitPanel>();
		component.Bind(heroName);
		component.RefreshContent();
	}
}
public class HighscoresPanel : GuiPanel
{
	[SerializeField]
	private AgeTransform scoreTable;

	[SerializeField]
	private AgeControlScrollView scoreScrollView;

	[SerializeField]
	private Transform highScoreItemPfb;

	[SerializeField]
	private AgeControlToggle spToggle;

	[SerializeField]
	private AgeControlToggle mpToggle;

	public double LatestHighscoreTime;

	public override void Show(params object[] parameters)
	{
		base.Show(parameters);
		if (parameters.Length > 0 && parameters[0] is bool)
		{
			bool flag = (bool)parameters[0];
			spToggle.State = !flag;
			mpToggle.State = flag;
		}
		else if (!spToggle.State && !mpToggle.State)
		{
			spToggle.State = true;
		}
		RefreshContent();
	}

	public override void Hide(bool instant = false)
	{
		UnbindHighScoreItems();
		LatestHighscoreTime = -1.0;
		base.Hide(instant);
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		List<HighscoreData> source = (!spToggle.State) ? UserProfile.Data.HighscoresMP : UserProfile.Data.HighscoresSP;
		HighscoreData[] array = source.OrderByDescending((HighscoreData h) => h.Score).ToArray();
		UnbindHighScoreItems();
		scoreTable.Height = 0f;
		scoreTable.ReserveChildren(array.Length, highScoreItemPfb, "HighScoreItem");
		scoreTable.RefreshChildrenArray(array, RefreshHighScoreItem);
		scoreTable.ArrangeChildren();
		scoreScrollView.OnPositionRecomputed();
	}

	private void UnbindHighScoreItems()
	{
		List<HighscoreItem> children = scoreTable.GetChildren<HighscoreItem>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
		}
	}

	private void RefreshHighScoreItem(AgeTransform tableItem, HighscoreData highscoreData, int index)
	{
		HighscoreItem component = tableItem.GetComponent<HighscoreItem>();
		component.Bind(highscoreData);
		component.RefreshContent();
	}

	public void OnSingleplayerButtonClicked(GameObject eventSender)
	{
		mpToggle.State = false;
		spToggle.State = true;
		RefreshContent();
	}

	public void OnMultiplayerButtonClicked(GameObject eventSender)
	{
		mpToggle.State = true;
		spToggle.State = false;
		RefreshContent();
	}
}
public interface IPopupMenuPanel
{
	void OnEscapeBehavior();
}
public class InteractivityLockedPanel : GuiPanel
{
}
public class InventoryGuiItem : GuiItem
{
	public AgeControlHoverArea HoverArea;

	public AgeTransform HoverSwitch;

	public AgeTransform ItemCostPanel;

	public AgePrimitiveLabel ItemCostLabel;

	public AgePrimitiveImage ItemCostIcon;

	public Color ItemCostLabelDefaultColor;

	public Color ItemCostLabelInvalidColor;

	private AgeTooltip tooltip;

	private bool isBuyable;

	private IInputService inputService;

	private InventoryListPanel currentInventoryListPanel;

	private static List<Color> rarityColors;

	private int colorIndex;

	public float colorTimeMin;

	public float colorTimeMax;

	private float colorTime;

	private float currentColorTime;

	private bool doUpdate;

	public InventoryItem CurrentItem
	{
		get;
		private set;
	}

	public override InventoryItem GetItem()
	{
		return CurrentItem;
	}

	public override InventoryListPanel GetInventoryListPanel()
	{
		return currentInventoryListPanel;
	}

	public void SetInventoryListPanel(InventoryListPanel panel)
	{
		currentInventoryListPanel = panel;
	}

	public void Bind(InventoryListPanel inventory, InventoryItem item, AgeTransform tooltipDock)
	{
		currentInventoryListPanel = inventory;
		CurrentItem = item;
		doUpdate = CurrentItem.IsGift;
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			base.Selectable.Register();
		}
		AgeTooltip component = GetComponent<AgeTooltip>();
		if (component != null && tooltipDock != null)
		{
			component.Anchor = tooltipDock;
			component.AnchorMode = AgeTooltipAnchorMode.RIGHT_CENTER;
		}
		if (doUpdate && rarityColors == null)
		{
			rarityColors = new List<Color>();
			ItemHeroRarityConfig[] values = Databases.GetDatabase<ItemHeroRarityConfig>().GetValues();
			for (int i = 0; i < values.Length - 1; i++)
			{
				rarityColors.Add(values[i].ColorValue);
			}
		}
	}

	public void Unbind()
	{
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			base.Selectable.Unregister();
		}
	}

	public override void RefreshContent(IGuiPanelHelper helper = null, bool active = true, bool enabled = true, StaticString costPropertyName = null, bool isBuyable = true)
	{
		base.RefreshContent(helper, active, enabled, costPropertyName, isBuyable);
		this.isBuyable = isBuyable;
		StaticString name = (!GetItem().IsGift) ? CurrentItem.ItemConfig.Name.ToString() : "Gift";
		GuiElement guiElement = null;
		helper?.TryGetGuiElement(name, out guiElement);
		if (guiElement != null)
		{
			if (helper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Small, out Texture2D texture))
			{
				ItemIcon.Image = texture;
			}
			ItemName.Text = AgeLocalizer.Instance.LocalizeString(guiElement.Title);
			if (enabled)
			{
				GetComponent<AgeTransform>().Alpha = 1f;
			}
			else
			{
				GetComponent<AgeTransform>().Alpha = 0.5f;
			}
			HoverSwitch.Visible = enabled;
		}
		if (CurrentItem.ItemConfig.CategoryParameters.TypeName != null)
		{
			helper.TryGetGuiElement(CurrentItem.ItemConfig.CategoryParameters.TypeName, out guiElement);
		}
		else
		{
			helper.TryGetGuiElement(CurrentItem.ItemConfig.CategoryParameters.CategoryName, out guiElement);
		}
		if (guiElement != null && helper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Tiny, out Texture2D texture2))
		{
			ItemCategoryIcon.Image = texture2;
		}
		if (!CurrentItem.IsGift)
		{
			if (CurrentItem.RarityCfg != null)
			{
				Color colorValue = CurrentItem.RarityCfg.GetItemHeroRarityConfig().ColorValue;
				colorValue.a = DefaultBackgroundColor.a;
				ItemBackground.TintColor = colorValue;
			}
			else
			{
				ItemBackground.TintColor = DefaultBackgroundColor;
			}
		}
		ItemButton.enabled = active;
		if (tooltip != null)
		{
			tooltip.Content = CurrentItem.ItemConfig.Name;
			tooltip.ClientData = CurrentItem;
		}
		NPCMerchant nPCMerchant = null;
		if (CurrentItem != null && CurrentItem.CurrentInventory != null)
		{
			nPCMerchant = (CurrentItem.CurrentInventory.ParentSimMB as NPCMerchant);
		}
		bool flag = true;
		if (nPCMerchant == null)
		{
			nPCMerchant = SingletonManager.Get<MainGameScreen>().MerchantPanel.Merchant;
			flag = false;
		}
		if (costPropertyName != null && nPCMerchant != null)
		{
			ItemCostPanel.Visible = true;
			float num = Mathf.CeilToInt((!flag) ? CurrentItem.GetSellingCostForCurrency(nPCMerchant.CurrencyCfg.Currency) : CurrentItem.GetCostForCurrency(nPCMerchant.CurrencyCfg.Currency));
			if (this.isBuyable)
			{
				ItemCostLabel.TintColor = ItemCostLabelDefaultColor;
			}
			else
			{
				ItemCostLabel.TintColor = ItemCostLabelInvalidColor;
			}
			ItemCostLabel.Text = num.ToString();
			MerchantPanel merchantPanel = SingletonManager.Get<MainGameScreen>().MerchantPanel;
			ItemCostIcon.Image = merchantPanel.FIDSImages[(int)nPCMerchant.CurrencyCfg.Currency];
		}
		else
		{
			ItemCostPanel.Visible = false;
		}
		UnequipButton.Visible = false;
		ItemTransferMarker.Visible = false;
	}

	protected override void Awake()
	{
		base.Awake();
		tooltip = GetComponent<AgeTooltip>();
		inputService = Services.GetService<IInputService>();
	}

	private void OnItemButtonClick()
	{
		currentInventoryListPanel.SelectItem(this);
	}

	public void OnItemButtonDoubleClick()
	{
		if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			TriggerItemAction();
		}
	}

	public void TriggerItemAction()
	{
		Diagnostics.Assert(currentInventoryListPanel != null);
		if (InventoryListPanel.SelectedGuiItem != this)
		{
			SelectItem();
		}
		if (!(currentInventoryListPanel != null))
		{
			return;
		}
		MerchantPanel merchantPanel = MainGameScreen.CurrentInventoryPanel as MerchantPanel;
		if (currentInventoryListPanel.RestrictedSlots != null && (merchantPanel == null || merchantPanel.IsBuying))
		{
			EquipmentSlot bestEquipmentSlotForItem = EquipmentSlot.GetBestEquipmentSlotForItem(currentInventoryListPanel.RestrictedSlots, CurrentItem);
			if (bestEquipmentSlotForItem != null)
			{
				bestEquipmentSlotForItem.OnSlotPanelClick();
				return;
			}
		}
		OnMouseLeave();
		if (merchantPanel != null)
		{
			merchantPanel.ApplyItemAction();
		}
		if (currentInventoryListPanel != null)
		{
			currentInventoryListPanel.SelectItem(null);
		}
	}

	private void OnUnequipButtonClick()
	{
		if (CurrentItem != null)
		{
			Dungeon dungeon = SingletonManager.Get<Dungeon>();
			CurrentItem.MoveToInventory(dungeon.GetBestAvailableInventoryForPlayer(CurrentItem.OwnerPlayerID));
		}
	}

	private void OnMouseEnter()
	{
		HeroStatsPanel heroStatsPanel = SingletonManager.Get<HeroStatsPanel>();
		if (heroStatsPanel.IsVisible)
		{
			heroStatsPanel.SetHoveredInventoryItem(CurrentItem);
		}
	}

	private void OnMouseLeave()
	{
		HeroStatsPanel heroStatsPanel = SingletonManager.Get<HeroStatsPanel>();
		if (heroStatsPanel.IsVisible)
		{
			heroStatsPanel.SetHoveredInventoryItem(null);
		}
	}

	private void Update()
	{
		if (!doUpdate)
		{
			return;
		}
		if (colorIndex < rarityColors.Count)
		{
			float num = currentColorTime / colorTime;
			int index = (colorIndex != rarityColors.Count - 1) ? (colorIndex + 1) : 0;
			ItemBackground.TintColor = Color.Lerp(rarityColors[colorIndex], rarityColors[index], 1f - num);
			currentColorTime -= Time.deltaTime;
			if (currentColorTime <= 0f)
			{
				colorIndex++;
				currentColorTime = colorTime;
			}
		}
		else
		{
			colorIndex = 0;
			colorTime = UnityEngine.Random.Range(colorTimeMin, colorTimeMax);
		}
	}
}
public class InventoryListPanel : GuiPanel
{
	public AgeControlScrollView InventoryScrollView;

	public AgeTransform InventoryTable;

	public Transform InventoryItemPrefabMouse;

	public Transform InventoryItemPrefabPad;

	public int itemPerRow = 4;

	private NPCMerchant merchant;

	private IGameEventService gameEventManager;

	private IInputService inputService;

	private AGEScrollableTableHelper scrollableTableHelper;

	private InventoryPanel sharedInventoryPanel;

	private InventoryPanel backpackInventoryPanel;

	private GameNetworkManager gameNetManager;

	public InventoryPanel InventoryPanel
	{
		get;
		set;
	}

	public AgeTransform TooltipDock
	{
		get;
		set;
	}

	public static GuiItem SelectedGuiItem
	{
		get;
		set;
	}

	public EquipmentSlot[] RestrictedSlots
	{
		get;
		set;
	}

	public Inventory[] Inventories
	{
		get;
		private set;
	}

	public bool CheckEquipable
	{
		get;
		private set;
	}

	public bool CheckBuyable
	{
		get;
		private set;
	}

	public List<InventoryItemSelectable> ChildrenItems
	{
		get;
		private set;
	}

	public bool IsMerchantPanel
	{
		get;
		protected set;
	}

	public StaticString CostPropertyName
	{
		get;
		private set;
	}

	protected override void Awake()
	{
		base.Awake();
		scrollableTableHelper = GetComponent<AGEScrollableTableHelper>();
		sharedInventoryPanel = SingletonManager.Get<InventoryPanel>();
		backpackInventoryPanel = sharedInventoryPanel.SubInventoryPanel;
	}

	public void Bind(Inventory[] inventories, EquipmentSlot[] restrictedSlots = null, StaticString costPropertyName = null, bool checkEquipable = true, bool checkBuyable = false)
	{
		if (Inventories != null)
		{
			Unbind();
		}
		Inventories = inventories;
		IsMerchantPanel = (Inventories != null && Inventories.Length == 1 && Inventories[0].ParentSimMB is NPCMerchant);
		merchant = ((!IsMerchantPanel) ? null : (Inventories[0].ParentSimMB as NPCMerchant));
		if (Inventories != null)
		{
			for (int i = 0; i < 1; i++)
			{
				Inventory obj = Inventories[i];
				obj.OnItemAdded = (Inventory.ItemAddedHandler)Delegate.Combine(obj.OnItemAdded, new Inventory.ItemAddedHandler(Inventory_OnItemAdded));
				Inventory obj2 = Inventories[i];
				obj2.OnItemRemoved = (Inventory.ItemRemovedHandler)Delegate.Combine(obj2.OnItemRemoved, new Inventory.ItemRemovedHandler(Inventory_OnItemRemoved));
			}
		}
		if (restrictedSlots != null)
		{
			RestrictedSlots = restrictedSlots;
		}
		CheckEquipable = checkEquipable;
		CheckBuyable = checkBuyable;
		CostPropertyName = costPropertyName;
	}

	public void Unbind()
	{
		UnbindInventoryGuiItems();
		if (Inventories != null)
		{
			for (int i = 0; i < 1; i++)
			{
				Inventory obj = Inventories[i];
				obj.OnItemAdded = (Inventory.ItemAddedHandler)Delegate.Remove(obj.OnItemAdded, new Inventory.ItemAddedHandler(Inventory_OnItemAdded));
				Inventory obj2 = Inventories[i];
				obj2.OnItemRemoved = (Inventory.ItemRemovedHandler)Delegate.Remove(obj2.OnItemRemoved, new Inventory.ItemRemovedHandler(Inventory_OnItemRemoved));
			}
			Inventories = null;
		}
		if (ChildrenItems != null && scrollableTableHelper != null)
		{
			for (int j = 0; j < ChildrenItems.Count; j++)
			{
				ChildrenItems[j].OnSelectEvent -= scrollableTableHelper.OnChildSelected;
			}
		}
		RestrictedSlots = null;
		merchant = null;
	}

	public void RefreshContent(IGuiPanelHelper helper = null)
	{
		base.RefreshContent();
		ulong localPlayerID = gameNetManager.GetLocalPlayerID();
		List<InventoryItem> list = new List<InventoryItem>();
		if (Inventories != null)
		{
			for (int i = 0; i < Inventories.Length; i++)
			{
				Inventory inventory = Inventories[i];
				for (int j = 0; j < inventory.Items.Count; j++)
				{
					InventoryItem inventoryItem = inventory.Items[j];
					if ((IsMerchantPanel && inventoryItem.CurrentInventory != null && inventoryItem.CurrentInventory.ParentSimMB is NPCMerchant) || inventory.Name == Inventory.SharedInventoryName || inventoryItem.OwnerPlayerID == ulong.MaxValue || inventoryItem.OwnerPlayerID == localPlayerID)
					{
						list.Add(inventoryItem);
					}
				}
			}
		}
		int num = -1;
		Selectable currentCategorySelectedElement = SingletonManager.Get<SelectableManager>().GetCurrentCategorySelectedElement();
		if (currentCategorySelectedElement != null)
		{
			InventoryItemSelectable inventoryItemSelectable = currentCategorySelectedElement as InventoryItemSelectable;
			if (inventoryItemSelectable != null && inventoryItemSelectable.InventoryGuiItem != null)
			{
				InventoryItem item = inventoryItemSelectable.InventoryGuiItem.GetItem();
				bool flag = false;
				for (int k = 0; k < Inventories.Length; k++)
				{
					if (flag)
					{
						break;
					}
					for (int l = 0; l < Inventories[k].Items.Count; l++)
					{
						if (Inventories[k].Items[l] == item)
						{
							num = inventoryItemSelectable.Index;
							flag = true;
							break;
						}
					}
				}
			}
		}
		UnbindInventoryGuiItems();
		InventoryTable.Height = 0f;
		InventoryTable.ReserveChildren(list.Count, (inputService.CurrentControlScheme != 0) ? InventoryItemPrefabPad : InventoryItemPrefabMouse, "InventoryItem");
		ChildrenItems = new List<InventoryItemSelectable>();
		InventoryTable.RefreshChildrenIList(list, RefreshInventoryItem);
		InventoryTable.ArrangeChildren();
		if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			if (list.Count >= 8 && list.Count % 4 == 0)
			{
				InventoryTable.Height += InventoryTable.GetChildren()[0].Height;
			}
		}
		else if (num >= 0)
		{
			SelectItemAtIndex(num);
		}
		InventoryScrollView.OnPositionRecomputed();
	}

	public void Reset()
	{
		InventoryScrollView.ResetUp();
	}

	public void SelectItem(GuiItem inventoryGuiItem)
	{
		if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			if (SelectedGuiItem != null)
			{
				SelectedGuiItem.SetSelected(selected: false);
			}
			SelectedGuiItem = inventoryGuiItem;
		}
		else if (inventoryGuiItem == null)
		{
			SelectItemStatic(inventoryGuiItem);
		}
		if (inventoryGuiItem != null)
		{
			InventoryGuiItem inventoryGuiItem2 = inventoryGuiItem as InventoryGuiItem;
			if (inventoryGuiItem2 != null)
			{
				inventoryGuiItem2.SetInventoryListPanel(this);
			}
			if (inventoryGuiItem.GetItem().CurrentInventory == null)
			{
				RestoreInventory(inventoryGuiItem.GetItem());
			}
			if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
			{
				SelectedGuiItem.SetSelected(selected: true);
			}
		}
		gameEventManager.TriggerItemListSelectedEvent(this, inventoryGuiItem as InventoryGuiItem);
	}

	public static void SelectItemStatic(GuiItem inventoryGuiItem)
	{
		if (SelectedGuiItem != null)
		{
			SelectedGuiItem.SetSelected(selected: false);
			SelectedGuiItem.ItemTransferMarker.Visible = false;
		}
		SelectedGuiItem = inventoryGuiItem;
		if (SelectedGuiItem != null)
		{
			SelectedGuiItem.SetSelected(selected: true);
			SelectedGuiItem.ItemTransferMarker.Visible = true;
		}
	}

	protected override IEnumerator OnLoad()
	{
		gameEventManager = Services.GetService<IGameEventService>();
		inputService = Services.GetService<IInputService>();
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
		yield return base.OnLoad();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		InventoryScrollView.ResetUp();
		if (scrollableTableHelper != null)
		{
			scrollableTableHelper.Reset();
		}
		RefreshContent();
		yield return base.OnShow(parameters);
	}

	protected override IEnumerator OnHide(bool instant)
	{
		SelectItem(null);
		yield return base.OnHide(instant);
	}

	private void UnbindInventoryGuiItems()
	{
		List<InventoryGuiItem> children = InventoryTable.GetChildren<InventoryGuiItem>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
			if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
			{
				children[i].Selectable.OnSelectEvent -= scrollableTableHelper.OnChildSelected;
			}
		}
	}

	private void RefreshInventoryItem(AgeTransform tableItem, InventoryItem item, int index)
	{
		InventoryGuiItem component = tableItem.GetComponent<InventoryGuiItem>();
		component.Bind(this, item, TooltipDock);
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			InventoryItemSelectable component2 = component.GetComponent<InventoryItemSelectable>();
			component2.Index = index;
			component2.Row = index / itemPerRow;
			component2.OnSelectEvent += scrollableTableHelper.OnChildSelected;
			ChildrenItems.Add(component2);
		}
		bool active = true;
		bool enabled = true;
		if (CheckEquipable)
		{
			active = false;
			enabled = false;
			if (RestrictedSlots != null)
			{
				for (int i = 0; i < RestrictedSlots.Length; i++)
				{
					if (RestrictedSlots[i].CanHoldItem(item))
					{
						enabled = true;
						break;
					}
				}
				active = true;
			}
			else
			{
				enabled = true;
			}
		}
		bool isBuyable = true;
		if (CheckBuyable && IsMerchantPanel)
		{
			isBuyable = item.CanBuy(merchant);
		}
		component.RefreshContent(base.GuiService.GuiPanelHelper, active, enabled, CostPropertyName, isBuyable);
	}

	private void Inventory_OnItemAdded(InventoryItem item)
	{
		RefreshContent();
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController && ChildrenItems.Count == 0)
		{
			backpackInventoryPanel.XboxInputText.Visible = false;
			sharedInventoryPanel.XboxInputText.Visible = false;
		}
	}

	private void Inventory_OnItemRemoved(InventoryItem item)
	{
		RefreshContent();
	}

	public void SelectItemAtIndex(int index)
	{
		if (index != -1 && ChildrenItems.Count > 0)
		{
			InventoryItemSelectable inventoryItemSelectable = null;
			inventoryItemSelectable = ((index < ChildrenItems.Count) ? ChildrenItems[index] : ChildrenItems[ChildrenItems.Count - 1]);
			if (inventoryItemSelectable != null)
			{
				inventoryItemSelectable.Select(silent: true);
				inventoryItemSelectable.KeepDisplayOnStart = true;
			}
		}
	}

	private void RestoreInventory(InventoryItem item)
	{
		if (Inventories.Length == 1)
		{
			item.CurrentInventory = Inventories[0];
		}
		else
		{
			if (Inventories.Length <= 1)
			{
				return;
			}
			int num = 0;
			while (true)
			{
				if (num < Inventories.Length)
				{
					if (Inventories[num].Items.Contains(item))
					{
						break;
					}
					num++;
					continue;
				}
				return;
			}
			item.CurrentInventory = Inventories[num];
		}
	}
}
public class InventoryPanel : PopupMenuPanel
{
	[SerializeField]
	private AgeTransform iventoryListContainer;

	[SerializeField]
	private Transform inventoryListPrefab;

	[SerializeField]
	private AgeControlToggle inventoryToggle;

	[SerializeField]
	private SubInventoryPanel subInventoryPanel;

	[SerializeField]
	private AgeTransform xboxInputText;

	[SerializeField]
	protected AgeTransform tooltipDock;

	protected InventoryListPanel inventoryList;

	protected TutorialManager tutorialManager;

	protected bool isMerchantPanel;

	protected NPCMerchant merchant;

	protected SelectableManager selectableManager;

	private IInputService inputService;

	public Inventory[] Inventories
	{
		get;
		protected set;
	}

	public SubInventoryPanel SubInventoryPanel => subInventoryPanel;

	public AgeTransform XboxInputText => xboxInputText;

	protected override void Awake()
	{
		base.Awake();
		selectableManager = SingletonManager.Get<SelectableManager>();
	}

	public virtual void Bind(params object[] parameters)
	{
		Inventory[] inventories = null;
		EquipmentSlot[] restrictedSlots = null;
		if (parameters.Length >= 1)
		{
			if (parameters[0] is Inventory[])
			{
				inventories = (parameters[0] as Inventory[]);
			}
			else if (parameters[0] is Inventory)
			{
				inventories = new Inventory[1]
				{
					parameters[0] as Inventory
				};
			}
			if (parameters.Length >= 2 && parameters[1] is EquipmentSlot[])
			{
				restrictedSlots = (parameters[1] as EquipmentSlot[]);
			}
		}
		Bind(inventories, restrictedSlots);
		if (subInventoryPanel != null)
		{
			subInventoryPanel.Bind(SingletonManager.Get<Dungeon>().BackpackInventory, restrictedSlots);
		}
	}

	protected void Bind(Inventory inventory, EquipmentSlot[] restrictedSlots = null)
	{
		Bind(new Inventory[1]
		{
			inventory
		}, restrictedSlots);
	}

	protected void Bind(Inventory[] inventories, EquipmentSlot[] restrictedSlots = null)
	{
		BindInventoryList(inventories, restrictedSlots);
		Inventories = inventories;
		isMerchantPanel = (Inventories != null && Inventories.Length == 1 && Inventories[0].ParentSimMB is NPCMerchant);
		merchant = ((!isMerchantPanel) ? null : (Inventories[0].ParentSimMB as NPCMerchant));
	}

	public virtual void Unbind()
	{
		inventoryList.Unbind();
		Inventories = null;
		merchant = null;
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		inventoryList.RefreshContent(base.GuiService.GuiPanelHelper);
		if (subInventoryPanel != null)
		{
			subInventoryPanel.RefreshContent();
		}
	}

	public virtual void OnItemAction()
	{
	}

	public void OnHeroSelected(Hero selectedHero)
	{
		if (selectedHero != null)
		{
			inventoryList.RestrictedSlots = selectedHero.EquipmentSlots;
			if (subInventoryPanel != null)
			{
				subInventoryPanel.inventoryList.RestrictedSlots = selectedHero.EquipmentSlots;
			}
			base.NeedRefresh = true;
		}
	}

	protected virtual void BindInventoryList(Inventory[] inventories, EquipmentSlot[] restrictedSlots = null)
	{
		inventoryList.Bind(inventories, restrictedSlots);
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		tutorialManager = SingletonManager.Get<TutorialManager>();
		inputService = Services.GetService<IInputService>();
		base.UseRefreshLoop = true;
		Transform newItem = UnityEngine.Object.Instantiate(inventoryListPrefab);
		newItem.parent = iventoryListContainer.transform;
		newItem.name = "InventoryList";
		newItem.GetComponent<AgeTransform>().Init();
		inventoryList = newItem.GetComponent<InventoryListPanel>();
		inventoryList.Load();
		inventoryList.TooltipDock = tooltipDock;
		inventoryList.InventoryPanel = this;
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		Bind(parameters);
		if (subInventoryPanel != null)
		{
			subInventoryPanel.AgeTransform.Visible = true;
		}
		inventoryList.Show(parameters);
		gameEventManager.OnDisplayedHeroStatsRefreshed += HeroStatsPanel_OnDisplayedHeroStatsRefreshed;
		gameEventManager.OnItemListSelected += InventoryListPanel_OnItemSelected;
		MainGameScreen.CurrentInventoryPanel = this;
		if (inventoryToggle != null)
		{
			inventoryToggle.State = !isMerchantPanel;
		}
		yield return base.OnShow(parameters);
		if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			ConstructionPanel constructionPanel = SingletonManager.Get<ConstructionPanel>();
			constructionPanel.UnselectCurrentCategory();
		}
		SingletonManager.Get<ResearchPanel>().Hide();
		SingletonManager.Get<ResearchingPanel>().Hide();
		if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			SingletonManager.Get<PlayerListPanel>().Hide();
		}
		base.NeedRefresh = true;
		if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard && TutorialManager.IsEnable && tutorialManager != null)
		{
			tutorialManager.MovePanelCenter();
		}
	}

	protected override IEnumerator OnHide(bool instant)
	{
		base.NeedRefresh = false;
		yield return null;
		inventoryList.Hide(instant);
		Unbind();
		gameEventManager.OnDisplayedHeroStatsRefreshed -= HeroStatsPanel_OnDisplayedHeroStatsRefreshed;
		if (inventoryList != null)
		{
			gameEventManager.OnItemListSelected -= InventoryListPanel_OnItemSelected;
		}
		MainGameScreen.CurrentInventoryPanel = null;
		if (inventoryToggle != null)
		{
			inventoryToggle.State = false;
		}
		if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard && TutorialManager.IsEnable && tutorialManager != null)
		{
			tutorialManager.MovePanelLeft();
		}
		yield return base.OnHide(instant);
	}

	protected virtual void InventoryListPanel_OnItemSelected(InventoryListPanel sender, InventoryGuiItem inventoryGuiItem)
	{
	}

	protected virtual void HeroStatsPanel_OnDisplayedHeroStatsRefreshed(Hero selectedHero)
	{
		if (selectedHero != null)
		{
			inventoryList.RestrictedSlots = selectedHero.EquipmentSlots;
			if (subInventoryPanel != null)
			{
				subInventoryPanel.inventoryList.RestrictedSlots = selectedHero.EquipmentSlots;
			}
			base.NeedRefresh = true;
		}
	}

	protected virtual void OnCloseButtonClick()
	{
		ClosePanel();
	}

	public override void ClosePanel()
	{
		MainGameScreen mainGameScreen = SingletonManager.Get<MainGameScreen>();
		if (mainGameScreen != null && this == mainGameScreen.SharedInventoryPanel)
		{
			mainGameScreen.SetSharedInventoryPanelDisplay(display: false);
		}
		else
		{
			base.ClosePanel();
		}
	}

	public virtual void OnPanelButtonClick()
	{
		if (InventoryListPanel.SelectedGuiItem == null || InventoryListPanel.SelectedGuiItem.GetItem() == null)
		{
			return;
		}
		InventoryItem item = InventoryListPanel.SelectedGuiItem.GetItem();
		for (int i = 0; i < Inventories.Length; i++)
		{
			if (item.CurrentInventory == Inventories[i])
			{
				return;
			}
		}
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		Inventory bestAvailableInventory = Inventory.GetBestAvailableInventory(Inventories, item.OwnerPlayerID);
		if (bestAvailableInventory == null)
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_BackpackFull"));
			return;
		}
		InventoryListPanel inventoryListPanel = InventoryListPanel.SelectedGuiItem.GetInventoryListPanel();
		StaticString name = bestAvailableInventory.Name;
		ulong localPlayerID = SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID();
		EquipmentSlotItem equipmentSlotItem = InventoryListPanel.SelectedGuiItem as EquipmentSlotItem;
		if (equipmentSlotItem != null)
		{
			equipmentSlotItem.Slot.UnequipItem();
		}
		StaticString staticString = (!(equipmentSlotItem == null)) ? string.Empty : item.CurrentInventory.Name.ToString();
		if (name == Inventory.SharedInventoryName && (staticString == Inventory.BackpackInventoryName || string.IsNullOrEmpty(staticString)))
		{
			dungeon.NetSyncElement.SendRPCToServer(SingletonRPC.Dungeon_RequestMoveItemToSharedInventory, item.UniqueIDCategory, item.UniqueID, localPlayerID);
		}
		else if (name == Inventory.BackpackInventoryName && (staticString == Inventory.SharedInventoryName || string.IsNullOrEmpty(staticString)))
		{
			dungeon.NetSyncElement.SendRPCToServer(SingletonRPC.Dungeon_RequestMoveItemToBackpackInventory, item.UniqueIDCategory, item.UniqueID, localPlayerID);
		}
		else
		{
			Diagnostics.LogError("Moving item from {0} to {1} (shouldn't happen)!", staticString, name);
			item.MoveToInventory(bestAvailableInventory);
		}
		if (inventoryListPanel != null)
		{
			inventoryListPanel.SelectItem(null);
		}
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController && inventoryList != null && inventoryList.ChildrenItems != null && inventoryList.ChildrenItems.Count > 0)
		{
			InventoryItemSelectable inventoryItemSelectable = inventoryList.ChildrenItems[inventoryList.ChildrenItems.Count - 1];
			inventoryItemSelectable.KeepDisplayOnStart = true;
			selectableManager.Select(inventoryItemSelectable);
		}
	}
}
public class JournalPanel : PopupMenuPanel
{
	[SerializeField]
	private HighscoresPanel highScoresPanel;

	[SerializeField]
	private StatsPanel statsPanel;

	[SerializeField]
	private DynamicTextureLoader[] backgroundsAutoLoaders;

	private IInputService inputService;

	protected override void Awake()
	{
		base.Awake();
		inputService = Services.GetService<IInputService>();
	}

	public override void Show(params object[] parameters)
	{
		if (!base.IsVisible)
		{
			highScoresPanel.Show(parameters);
			statsPanel.Show();
			if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
			{
				SingletonManager.Get<SelectableManager>().SetCategory(SelectionCategory.Journal);
			}
		}
		base.Show(parameters);
	}

	public override void Hide(bool instant = false)
	{
		if (base.IsVisible)
		{
			highScoresPanel.Hide(instant);
			statsPanel.Hide(instant);
			if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
			{
				SingletonManager.Get<SelectableManager>().UnsetCategory(SelectionCategory.Journal);
			}
			MainMenuPanel mainMenuPanel = SingletonManager.Get<MainMenuPanel>();
			mainMenuPanel.Show();
		}
		base.Hide(instant);
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		for (int i = 0; i < backgroundsAutoLoaders.Length; i++)
		{
			backgroundsAutoLoaders[i].Load();
		}
	}

	private void OnCloseButtonClick()
	{
		Hide();
	}

	private void OnOverlayClick()
	{
	}

	private void Update()
	{
		if (base.AgeTransform.Visible && inputService != null && inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			if (inputService.GetControlDown(Control.AlbumNextPage))
			{
				highScoresPanel.OnMultiplayerButtonClicked(null);
			}
			else if (inputService.GetControlDown(Control.AlbumPreviousPage))
			{
				highScoresPanel.OnSingleplayerButtonClicked(null);
			}
		}
	}
}
public class KeyBindingTextField : AgeControlTextField
{
	public List<KeyCode> KeysCurrentlyPressed = new List<KeyCode>();

	private KeyCode[] allKeyCodes;

	private GameObject savedOnKeyDownObject;

	private bool waitingForMouseUp;

	public override void KeyDown()
	{
		if (waitingForMouseUp)
		{
			if (Input.GetKey(KeyCode.Mouse0))
			{
				waitingForMouseUp = false;
				OnKeyDownObject = savedOnKeyDownObject;
			}
			return;
		}
		for (int i = 0; i < allKeyCodes.Length; i++)
		{
			if (Input.GetKey(allKeyCodes[i]) && KeysCurrentlyPressed.Count < 2)
			{
				KeysCurrentlyPressed.Add(allKeyCodes[i]);
			}
		}
		if (OnKeyDownObject != null && !string.IsNullOrEmpty(OnKeyDownMethod))
		{
			OnKeyDownObject.SendMessage(OnKeyDownMethod, base.gameObject, SendMessageOptions.RequireReceiver);
		}
	}

	public override void FocusGain()
	{
		base.FocusGain();
		waitingForMouseUp = true;
		OnKeyDownObject = null;
	}

	public override void FocusLoss()
	{
		waitingForMouseUp = false;
		base.FocusLoss();
		KeysCurrentlyPressed.Clear();
	}

	public override void Init()
	{
		base.Init();
		List<KeyCode> list = new List<KeyCode>();
		foreach (object value in Enum.GetValues(typeof(KeyCode)))
		{
			list.Add((KeyCode)(int)value);
		}
		allKeyCodes = list.ToArray();
		savedOnKeyDownObject = OnKeyDownObject;
	}
}
public class LoadingPanel : GuiPanel
{
	[SerializeField]
	private AgePrimitiveLabel progressLabel;

	[SerializeField]
	private AgePrimitiveLabel waitingForOtherPlayersLabel;

	[SerializeField]
	private AgePrimitiveImage levelImage;

	[SerializeField]
	private string levelImagesPath;

	public override void Show(params object[] parameters)
	{
		base.Show(parameters);
		DynamicTextureLoader component = levelImage.GetComponent<DynamicTextureLoader>();
		levelImage.AgeTransform.Width = base.AgeTransform.Width;
		levelImage.AgeTransform.Height = base.AgeTransform.Height;
		component.Load(levelImagesPath + GameConfig.GetGameConfig().GetTileset().ToString(), forceReload: true);
		progressLabel.AgeTransform.Visible = false;
		waitingForOtherPlayersLabel.AgeTransform.Visible = false;
	}

	public void SetLoadingProgress(float progress)
	{
		progressLabel.Text = (100f * progress).RoundHalfAwayFromZero() + "%";
		progressLabel.AgeTransform.Visible = true;
	}

	public void DisplayWaitingForOtherPlayersLabel()
	{
		waitingForOtherPlayersLabel.AgeTransform.Visible = true;
	}
}
public class LogPanel : GuiPanel
{
	[SerializeField]
	private Color errorTextColor;

	[SerializeField]
	private Color alertTextColor;

	[SerializeField]
	private Color eventTextColor;

	[SerializeField]
	private Color dialogueTextColor;

	[SerializeField]
	private Color messageTextColor;

	[SerializeField]
	private Color unlockTextColor;

	[SerializeField]
	private Color albumTextColor;

	[SerializeField]
	private AgeTransform logArea;

	[SerializeField]
	private AgePrimitiveLabel remainingLinesLabel;

	[SerializeField]
	private AgePrimitiveLabel lastLineLabel;

	[SerializeField]
	private AgePrimitiveImage icon;

	[SerializeField]
	private AgeControlScrollView scrollView;

	[SerializeField]
	private AgePrimitiveImage button;

	[SerializeField]
	private Texture2D buttonShow;

	[SerializeField]
	private Texture2D buttonHide;

	[SerializeField]
	private AgeTransform backgroundGeneral;

	private bool reducedMode;

	private StringBuilder previousLinesStringBuilder = new StringBuilder();

	public bool IsReduced => reducedMode;

	public override void Initialize()
	{
		base.Initialize();
		scrollView.ResetDown();
		UpdateButtonTexture();
	}

	public void AddLog(string text, NotificationType notifType, StaticString eventType = null)
	{
		text = ((notifType != NotificationType.Dialogue || string.IsNullOrEmpty(eventType)) ? AgeLocalizer.Instance.LocalizeString(text) : (AgeLocalizer.Instance.LocalizeString("%" + eventType + "_FirstName") + ": " + text));
		text = ColorLogText(text, notifType, eventType);
		if (!string.IsNullOrEmpty(lastLineLabel.Text))
		{
			if (previousLinesStringBuilder.Length > 0)
			{
				previousLinesStringBuilder.Append(Environment.NewLine);
			}
			previousLinesStringBuilder.Append(lastLineLabel.Text);
			if (previousLinesStringBuilder.Length > 3000)
			{
				int num = previousLinesStringBuilder.ToString().IndexOf(Environment.NewLine);
				if (num > 0)
				{
					previousLinesStringBuilder.Remove(0, num + Environment.NewLine.Length);
				}
			}
		}
		remainingLinesLabel.AgeTransform.Height = 0f;
		remainingLinesLabel.ForceText(previousLinesStringBuilder.ToString());
		lastLineLabel.AgeTransform.Height = 0f;
		lastLineLabel.ForceText(AgeLocalizer.Instance.LocalizeString(text));
		if (!reducedMode)
		{
			scrollView.VirtualArea.Height = remainingLinesLabel.AgeTransform.Height + lastLineLabel.AgeTransform.Height;
			scrollView.VirtualArea.Y = scrollView.Viewport.Height - scrollView.VirtualArea.Height;
		}
		else
		{
			scrollView.VirtualArea.Height = lastLineLabel.AgeTransform.Height;
			scrollView.Viewport.Height = scrollView.VirtualArea.Height;
		}
		scrollView.ResetDown();
		icon.Image = GetNotificationIcon(eventType);
	}

	public void Reset()
	{
		previousLinesStringBuilder.Length = 0;
		remainingLinesLabel.Text = string.Empty;
		lastLineLabel.Text = string.Empty;
		icon.Image = GuiManager.GetTransparentTexture();
		reducedMode = true;
		OnButtonClick();
		lastLineLabel.AgeTransform.Height = 0f;
		remainingLinesLabel.AgeTransform.Height = 0f;
		scrollView.VirtualArea.Height = 0f;
	}

	public void OnButtonClick()
	{
		SwitchDisplay(!reducedMode);
	}

	public void SwitchDisplay(bool reduced)
	{
		reducedMode = reduced;
		backgroundGeneral.Visible = !reducedMode;
		scrollView.Viewport.AttachTop = !reducedMode;
		scrollView.Viewport.Height = ((!reducedMode) ? scrollView.AgeTransform.Height : lastLineLabel.AgeTransform.Height);
		remainingLinesLabel.AgeTransform.Visible = !reducedMode;
		if (!reducedMode)
		{
			scrollView.VirtualArea.Height = remainingLinesLabel.AgeTransform.Height + lastLineLabel.AgeTransform.Height;
		}
		else
		{
			scrollView.VirtualArea.Height = lastLineLabel.AgeTransform.Height;
		}
		scrollView.ResetDown();
		UpdateButtonTexture();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		RefreshContent();
	}

	private string ColorLogText(string text, NotificationType type, StaticString eventType)
	{
		Color color;
		switch (type)
		{
		case NotificationType.Error:
			color = errorTextColor;
			break;
		case NotificationType.Alert:
			color = alertTextColor;
			break;
		case NotificationType.Dialogue:
			color = dialogueTextColor;
			break;
		case NotificationType.Event:
			color = eventTextColor;
			break;
		case NotificationType.AlbumPicture:
			color = albumTextColor;
			break;
		case NotificationType.Backstory:
		case NotificationType.MiscUnlock:
			color = unlockTextColor;
			break;
		default:
			color = messageTextColor;
			break;
		}
		AgeUtils.ColorToHexaKey(color, out string hexaKey);
		return hexaKey + text + "#REVERT#";
	}

	public static Texture2D GetNotificationIcon(StaticString eventType)
	{
		if (eventType != null)
		{
			IGuiService service = Services.GetService<IGuiService>();
			if (service != null && service.GuiPanelHelper.TryGetGuiElement(eventType, out GuiElement guiElement) && service.GuiPanelHelper.TryGetTextureFromIcon(guiElement, IconSize.Small, out Texture2D texture))
			{
				return texture;
			}
		}
		Diagnostics.LogWarning("No log icon found for event: " + eventType);
		return GuiManager.GetTransparentTexture();
	}

	private void UpdateButtonTexture()
	{
		button.Image = (reducedMode ? buttonShow : buttonHide);
	}
}
public class MPSaveLine : MonoBehaviour
{
	[SerializeField]
	private AgePrimitiveLabel label;

	private SaveInfo data;

	public void Init(SaveInfo data)
	{
		this.data = data;
		label.Text = data.GetMPSaveName();
	}

	private void OnClick()
	{
		SingletonManager.Get<MPSaveListPanel>().Hide();
		Services.GetService<IGameControlService>().StartSavedMultiplayerGame(data.Key, data.PlayerIDs.Length);
	}
}
public class MPSaveListPanel : PopupMenuPanel
{
	[SerializeField]
	private Transform linePrefab;

	[SerializeField]
	private AgeTransform table;

	[SerializeField]
	private AgeControlScrollView scrollView;

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		List<SaveInfo> mpSaveKeys = UserProfile.Data.GetMPSaveKeys();
		table.Height = 0f;
		table.ReserveChildren(mpSaveKeys.Count, linePrefab);
		table.RefreshChildrenIList(mpSaveKeys, RefreshLine);
		table.ArrangeChildren();
		scrollView.OnPositionRecomputed();
	}

	private void RefreshLine(AgeTransform tableItem, SaveInfo data, int index)
	{
		MPSaveLine component = tableItem.GetComponent<MPSaveLine>();
		component.Init(data);
	}

	private void OnCancelButtonClick()
	{
		Hide();
	}
}
public class MainMenuPanel : GuiPanel
{
	[SerializeField]
	private AgePrimitiveLabel versionLabel;

	[SerializeField]
	private AgeControlButton continueButton;

	[SerializeField]
	private AgeControlButton multiplayerButton;

	[SerializeField]
	private AgePrimitiveImage G2GLogoNormal;

	[SerializeField]
	private AgePrimitiveImage G2GLogoHover;

	[SerializeField]
	private AgePrimitiveImage amplitudeLogoNormal;

	[SerializeField]
	private AgePrimitiveImage amplitudeLogoHover;

	[SerializeField]
	private string intro1MoviePath;

	[SerializeField]
	private string intro2MoviePath;

	[SerializeField]
	private AgeTransform dlcIconsTable;

	[SerializeField]
	private Transform dlcIconPfb;

	[SerializeField]
	private AgeTransform mainMenu;

	[SerializeField]
	private XboxMainMenuPanel mainMenuPanelXbox;

	private IXboxEventService xboxEventService;

	private INetworkingService networkingService;

	private IInputService inputService;

	public bool IsPlayingIntroMovie
	{
		get;
		private set;
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		IAudioLayeredMusicService musicService = Services.GetService<IAudioLayeredMusicService>();
		if (musicService != null)
		{
			musicService.StopAllMusics();
			musicService.PlayLayeredMusic("MusicMenu", "MusicMenu", 10);
		}
		DLCController steamDLCController = SingletonManager.Get<DLCController>();
		SetDLCIcons((from dlc in steamDLCController.GetCheckedDLCs()
			where dlc.MainMenuIcon
			select dlc).ToArray());
		RefreshContent();
		DungeonsApplication.OnUserStorageDataLoaded += OnUserStorageDataLoaded;
		inputService = Services.GetService<IInputService>();
		if (inputService != null && inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			string[] joysticks = Input.GetJoystickNames();
			if (joysticks == null || joysticks.Length == 0 || !joysticks.Any((string name) => !string.IsNullOrEmpty(name)))
			{
				SingletonManager.Get<RequesterPanel>().Display("%NoGamepadDetected", OnNoControllerConfirmed, RequesterPanel.ButtonsMode.YesNo, "%RequesterPanelTitle", -1f, hideOnCB: false);
				StartCoroutine(HideRequesterPanelOnControllersDetected());
				inputService.SetPadMode(enable: false);
			}
		}
	}

	private IEnumerator HideRequesterPanelOnControllersDetected()
	{
		while (true)
		{
			string[] joysticks = Input.GetJoystickNames();
			if (joysticks != null)
			{
				for (int i = 0; i < joysticks.Length; i++)
				{
					if (!string.IsNullOrEmpty(joysticks[i]))
					{
						OnNoControllerConfirmed(RequesterPanel.Result.No);
						yield break;
					}
				}
			}
			yield return null;
		}
	}

	private void OnNoControllerConfirmed(RequesterPanel.Result result)
	{
		if (result == RequesterPanel.Result.Yes)
		{
			Amplitude.Unity.Framework.Application.Registry.SetValue(InputManager.EnableXBoxControllerRegistryPath, value: false);
			SingletonManager.Get<RequesterPanel>().Display("%ControlSchemeChangedRestart", OnRestartConfirmed);
		}
		else
		{
			SingletonManager.Get<RequesterPanel>().Hide();
			inputService.SetPadMode(enable: true);
		}
	}

	private void OnRestartConfirmed(RequesterPanel.Result result)
	{
		UnityEngine.Application.Quit();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		yield return base.OnHide(instant);
		Services.GetService<IAudioLayeredMusicService>()?.StopAllMusics();
		DungeonsApplication.OnUserStorageDataLoaded -= OnUserStorageDataLoaded;
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		if (continueButton != null)
		{
			continueButton.AgeTransform.Enable = GameSave.HasSinglePlayerSaveFile();
			continueButton.GetComponent<AgeTooltip>().Content = "%Continue" + ((!continueButton.AgeTransform.Enable) ? "KO" : "OK") + "Tooltip";
		}
		if (multiplayerButton != null)
		{
			INetworkingService service = Services.GetService<INetworkingService>();
			multiplayerButton.AgeTransform.Enable = service.IsMultiplayerAvailable;
		}
	}

	public void DisplayGameQuitDialogue()
	{
		SingletonManager.Get<RequesterPanel>().Display("%QuitGameConfirm", OnQuitConfirmResult, RequesterPanel.ButtonsMode.YesNo);
	}

	public void SetDLCIcons(DLC[] dlcs)
	{
		dlcIconsTable.ReserveChildren(dlcs.Length, dlcIconPfb);
		dlcIconsTable.RefreshChildrenIList(dlcs, RefreshDLCIcon);
	}

	private void RefreshDLCIcon(AgeTransform portraitSlot, DLC dlc, int index)
	{
		DLCIcon component = portraitSlot.GetComponent<DLCIcon>();
		component.Init(dlc);
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		versionLabel.Text = AgeLocalizer.Instance.LocalizeString("%GameMenuVersionFormat");
		versionLabel.Text = versionLabel.Text.Replace("$Application", "#4D4D4D#" + Amplitude.Unity.Framework.Application.Name);
		versionLabel.Text = versionLabel.Text.Replace("$Version", "#REVERT##4D4D4D#" + Amplitude.Unity.Framework.Application.Version.Major + "." + Amplitude.Unity.Framework.Application.Version.Minor + "." + Amplitude.Unity.Framework.Application.Version.Revision + "#REVERT#");
		G2GLogoNormal.GetComponent<DynamicTextureLoader>().Load();
		G2GLogoHover.GetComponent<DynamicTextureLoader>().Load();
		amplitudeLogoNormal.GetComponent<DynamicTextureLoader>().Load();
		amplitudeLogoHover.GetComponent<DynamicTextureLoader>().Load();
	}

	private void OpenForumURL()
	{
		OnG2GMouseLeave();
		Process.Start("http://forums.amplitude-studios.com/forumdisplay.php?29-Dungeon-of-the-Endless");
	}

	private void OpenWebsiteURL()
	{
		OnAmplitudeMouseLeave();
		Process.Start("http://www.amplitude-studios.com/");
	}

	private void PrepareToLeaveMainMenu()
	{
		Services.GetService<IInputService>().SetInputMode(InputMode.MouseKeyboard);
		Hide();
		SingletonManager.Get<MainMenuCamera>().GetComponent<Camera>().enabled = false;
	}

	public void StartNewGame()
	{
		Services.GetService<IGameControlService>().StartNewSinglePlayerGame();
	}

	public void LaunchNewGameSequence()
	{
		PrepareToLeaveMainMenu();
		Hide();
		IsPlayingIntroMovie = true;
		PlayVideo(intro2MoviePath, delegate
		{
			IsPlayingIntroMovie = false;
			StartNewGame();
		});
	}

	private void OnMultiplayerButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<SessionListPanel>().Show();
	}

	private void OnLoadMPSaveButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<MPSaveListPanel>().Show();
	}

	private void OnMultiplayerCreateButtonClick(GameObject gameObject)
	{
		Services.GetService<IGameControlService>().StartNewMultiplayerGame();
		SingletonManager.Get<SessionListPanel>().Hide();
	}

	private void OnNewGameButtonClick(GameObject gameObject)
	{
		if (GameSave.HasSinglePlayerSaveFile())
		{
			SingletonManager.Get<RequesterPanel>().Display("%NewGameWhileSavedGameConfirm", OnNewGameConfirm, RequesterPanel.ButtonsMode.YesNo);
		}
		else
		{
			DisplayGameSelectionInterface();
		}
	}

	private void OnNewGameConfirm(RequesterPanel.Result result)
	{
		if (result == RequesterPanel.Result.Yes)
		{
			DisplayGameSelectionInterface();
		}
	}

	private void DisplayGameSelectionInterface()
	{
		Hide();
		IsPlayingIntroMovie = true;
		PlayVideo(intro1MoviePath, delegate
		{
			IsPlayingIntroMovie = false;
			GameSelectionPanel gameSelectionPanel = SingletonManager.Get<GameSelectionPanel>();
			gameSelectionPanel.Display(isMultiplayer: false, null, -1, OnGameSelectionPanelDisplayConfirm);
		});
	}

	private void PlayVideo(StaticString videoPath, MoviePanel.OnVideoCompleteDlg onCompleteDelegate)
	{
		MoviePanel moviePanel = null;
		moviePanel = SingletonManager.Get<MoviePanel>();
		moviePanel.StartVideo(videoPath, onCompleteDelegate);
	}

	public void StopVideo()
	{
		MoviePanel moviePanel = null;
		moviePanel = SingletonManager.Get<MoviePanel>();
		if (moviePanel.IsVisible)
		{
			moviePanel.OnMoviePlaybackComplete();
		}
	}

	private void OnGameSelectionPanelDisplayConfirm(bool selectionConfirmed)
	{
		if (selectionConfirmed)
		{
			LaunchNewGameSequence();
		}
	}

	private void OnContinueButtonClick(GameObject gameObject)
	{
		SaveInfo sPAutoSaveInfo = GameSave.GetSPAutoSaveInfo();
		if (sPAutoSaveInfo != null && sPAutoSaveInfo.IsInGame && GameSave.HasSPAutoSaveFile() && !GameSave.HasSPUserSaveFile())
		{
			SingletonManager.Get<RequesterPanel>().Display("%ContinueCrashedGameMessage", delegate
			{
				LoadSPSave();
			});
		}
		else
		{
			LoadSPSave();
		}
	}

	private void LoadSPSave()
	{
		PrepareToLeaveMainMenu();
		string saveKey = null;
		GameSave.GetBestSPSaveData(ref saveKey);
		if (saveKey != null)
		{
			Services.GetService<IGameControlService>().StartSavedSinglePlayerGame(saveKey);
		}
	}

	private void OnOptionsButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<OptionsPanel>().Show();
	}

	private void OnJournalButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<JournalPanel>().Show();
	}

	public void OnControlsButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<ShortcutsPanel>().Show();
	}

	private void OnCreditsButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<CreditsPanel>().Show();
	}

	private void OnAlbumButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<Album>().Focus(display: true);
	}

	private void OnQuitButtonClick(GameObject gameObject)
	{
		DisplayGameQuitDialogue();
	}

	private void OnQuitConfirmResult(RequesterPanel.Result result)
	{
		if (result == RequesterPanel.Result.Yes)
		{
			UnityEngine.Application.Quit();
		}
	}

	private void OnSignInConfirm(RequesterPanel.Result result)
	{
		Services.GetService<IXboxGameControlService>().RequestSignIn(0u);
	}

	private void OnG2GMouseEnter()
	{
		G2GLogoNormal.AgeTransform.Alpha = 0f;
		G2GLogoHover.AgeTransform.Alpha = 1f;
	}

	private void OnG2GMouseLeave()
	{
		G2GLogoNormal.AgeTransform.Alpha = 1f;
		G2GLogoHover.AgeTransform.Alpha = 0f;
	}

	private void OnAmplitudeMouseEnter()
	{
		amplitudeLogoNormal.AgeTransform.Alpha = 0f;
		amplitudeLogoHover.AgeTransform.Alpha = 1f;
	}

	private void OnAmplitudeMouseLeave()
	{
		amplitudeLogoNormal.AgeTransform.Alpha = 1f;
		amplitudeLogoHover.AgeTransform.Alpha = 0f;
	}

	private void NetworkingService_ConnectionStateChanged(object sender, ConnectionStateChangedEventArgs e)
	{
		multiplayerButton.AgeTransform.Enable = (e.OnlineState == XboxOneOnlineState.Online);
	}

	private void OnUserStorageDataLoaded()
	{
		RefreshContent();
	}
}
public class MerchantPadPanel : MerchantPanel
{
	[SerializeField]
	private AgeTransform heroTable;

	[SerializeField]
	private Transform heroEquipementPanelPrefab;

	[SerializeField]
	private AgeTransform statsTable;

	[SerializeField]
	private GUIComparingLabel healthLevelUpLabel;

	[SerializeField]
	private GUIComparingLabel healthRegenLevelUpLabel;

	[SerializeField]
	private GUIComparingLabel defenseLevelUpLabel;

	[SerializeField]
	private GUIComparingLabel moveSpeedLevelUpLabel;

	[SerializeField]
	private GUIComparingLabel dpsLevelUpLabel;

	[SerializeField]
	private GUIComparingLabel attackPowerLevelUpLabel;

	[SerializeField]
	private GUIComparingLabel attackCooldownLevelUpLabel;

	[SerializeField]
	private GUIComparingLabel witLevelUpLabel;

	[SerializeField]
	private AgeTransform closeGroup;

	[SerializeField]
	private AgeTransform selectButtonsBuyTable;

	[SerializeField]
	private AgeTransform selectButtonBuy;

	[SerializeField]
	private AgeTransform selectButtonsSellTable;

	[SerializeField]
	private AgeTransform selectButtonSell;

	[SerializeField]
	private AgeTransform validateButtonsBuyTable;

	[SerializeField]
	private AgeTransform validateButtonsSellTable;

	[SerializeField]
	private AgeTransform buyAndEquipButton;

	[SerializeField]
	protected AgePrimitiveLabel healthLabel;

	[SerializeField]
	protected AgePrimitiveLabel healthRegenLabel;

	[SerializeField]
	protected AgePrimitiveLabel defenseLabel;

	[SerializeField]
	protected AgePrimitiveLabel moveSpeedLabel;

	[SerializeField]
	protected AgePrimitiveLabel dpsLabel;

	[SerializeField]
	protected AgePrimitiveLabel attackPowerLabel;

	[SerializeField]
	protected AgePrimitiveLabel attackCooldownLabel;

	[SerializeField]
	protected AgePrimitiveLabel witLabel;

	private readonly string selectionCategoryName = SelectionCategory.HeroStatsPanel_Merchant.ToString();

	private List<HeroEquipementPadPanel> heroEquipmentPanels = new List<HeroEquipementPadPanel>();

	private List<Selectable> unregisteredSelectables = new List<Selectable>();

	private List<ItemHolderSelectable> registeredSelectables = new List<ItemHolderSelectable>();

	private InventorySelectable[] emptyList = new InventorySelectable[0];

	private bool doUpdate;

	private InventoryItem currentItem;

	private GuiItem currentGuiItem;

	protected override void Awake()
	{
		base.Awake();
		SingletonManager.RegisterInstance(this, typeof(MerchantPanel));
	}

	public override void OnEscapeBehavior()
	{
		if (!SpecialEscapeBehavior(testOnly: false))
		{
			Hide();
			selectableManager.SetCategory(SelectionCategory.RoomForMove);
		}
	}

	public void OnItemSelected(InventoryItem item, Hero hero = null)
	{
		if (hero != null && currentItem != null)
		{
			for (int i = 0; i < heroEquipmentPanels.Count; i++)
			{
				if (heroEquipmentPanels[i].BoundHero == hero)
				{
					statsTable.Visible = true;
					heroEquipmentPanels[i].RefreshStatBonuses(currentItem);
					break;
				}
			}
		}
		else
		{
			statsTable.Visible = false;
		}
		RefreshButtonsTables();
	}

	public void OnItemConfirmed(GuiItem guiItem)
	{
		if (base.IsBuying)
		{
			TabHeroesEquipmentPanel.OnItemConfirmed(guiItem, out currentGuiItem, out currentItem, unregisteredSelectables, registeredSelectables, emptyList, selectionCategoryName);
		}
		else
		{
			ApplyItemAction();
		}
		RefreshButtonsTables();
	}

	public override void RefreshContent()
	{
		AgeTransform ageTransform = null;
		int num = selectItemAtIndex;
		if (num == -1)
		{
			Selectable currentCategorySelectedElement = selectableManager.GetCurrentCategorySelectedElement();
			if (currentCategorySelectedElement != null)
			{
				EquipmentSlotItemSelectable equipmentSlotItemSelectable = currentCategorySelectedElement as EquipmentSlotItemSelectable;
				if (equipmentSlotItemSelectable != null)
				{
					num = equipmentSlotItemSelectable.SlotPanel.Index;
					ageTransform = equipmentSlotItemSelectable.AgeTfm.GetParent();
				}
			}
		}
		base.RefreshContent();
		for (int i = 0; i < heroEquipmentPanels.Count; i++)
		{
			heroEquipmentPanels[i].Unbind();
		}
		heroEquipmentPanels.Clear();
		heroTable.ReserveChildren(Hero.LocalPlayerActiveRecruitedHeroes.Count, heroEquipementPanelPrefab, "HeroStatPadItem");
		heroTable.RefreshChildrenArray(Hero.LocalPlayerActiveRecruitedHeroes.ToArray(), RefreshHeroStatItem);
		if (num >= 0)
		{
			selectItemAtIndex = -1;
			if (ageTransform != null)
			{
				Transform child = ageTransform.transform.GetChild(num);
				if (child != null)
				{
					Selectable component = child.GetComponent<Selectable>();
					if (component != null)
					{
						component.Select(silent: true);
					}
				}
			}
			else
			{
				inventoryList.SelectItemAtIndex(num);
			}
		}
		RefreshButtonsTables();
	}

	public void RestoreNormalSelection(bool restorePreviousItemSelected = false)
	{
		statsTable.Visible = false;
		for (int i = 0; i < unregisteredSelectables.Count; i++)
		{
			unregisteredSelectables[i].Register();
		}
		for (int j = 0; j < registeredSelectables.Count; j++)
		{
			registeredSelectables[j].SetHighlight(show: false);
		}
		unregisteredSelectables.Clear();
		registeredSelectables.Clear();
		currentItem = null;
		InventoryListPanel.SelectItemStatic(null);
		if (restorePreviousItemSelected && currentGuiItem != null)
		{
			selectableManager.Select(currentGuiItem.Selectable);
		}
		currentGuiItem = null;
		RefreshButtonsTables();
	}

	protected override void BuyCurrentItem()
	{
		base.BuyCurrentItem();
	}

	public override void OnCurrentItemBought()
	{
		base.OnCurrentItemBought();
		currentItem = null;
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		Hide(instant: true);
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		statsTable.Visible = false;
		selectItemAtIndex = 0;
		RestoreNormalSelection();
		StartCoroutine(UpdateLoop());
	}

	protected override IEnumerator OnHide(bool instant)
	{
		doUpdate = false;
		yield return base.OnHide(instant);
	}

	private void RefreshButtonsTables()
	{
		Selectable currentCategorySelectedElement = selectableManager.GetCurrentCategorySelectedElement();
		InventoryItemSelectable x = currentCategorySelectedElement as InventoryItemSelectable;
		selectButtonsBuyTable.Visible = (InventoryListPanel.SelectedGuiItem == null && base.IsBuying);
		selectButtonsSellTable.Visible = (InventoryListPanel.SelectedGuiItem == null && !base.IsBuying);
		validateButtonsBuyTable.Visible = (InventoryListPanel.SelectedGuiItem != null && base.IsBuying);
		validateButtonsSellTable.Visible = (InventoryListPanel.SelectedGuiItem != null && !base.IsBuying);
		buyAndEquipButton.Visible = (InventoryListPanel.SelectedGuiItem != null && base.IsBuying && currentCategorySelectedElement != null);
		selectButtonBuy.Enable = (selectButtonsBuyTable.Visible && x != null);
		selectButtonSell.Enable = (selectButtonsSellTable.Visible && x != null);
	}

	private void RefreshHeroStatItem(AgeTransform tableItem, Hero hero, int index)
	{
		HeroEquipementPadPanel component = tableItem.GetComponent<HeroEquipementPadPanel>();
		heroEquipmentPanels.Add(component);
		component.Bind(Hero.LocalPlayerActiveRecruitedHeroes[index], healthLevelUpLabel, healthRegenLevelUpLabel, defenseLevelUpLabel, moveSpeedLevelUpLabel, dpsLevelUpLabel, attackPowerLevelUpLabel, attackCooldownLevelUpLabel, witLevelUpLabel, tooltipDock, healthLabel, healthRegenLabel, defenseLabel, moveSpeedLabel, dpsLabel, attackPowerLabel, attackCooldownLabel, witLabel);
	}

	private bool SpecialEscapeBehavior(bool testOnly)
	{
		bool result = false;
		if (InventoryListPanel.SelectedGuiItem != null)
		{
			if (!testOnly)
			{
				inventoryList.SelectItem(null);
				RestoreNormalSelection(restorePreviousItemSelected: true);
				RefreshContent();
			}
			result = true;
		}
		return result;
	}

	private IEnumerator UpdateLoop()
	{
		doUpdate = true;
		while (doUpdate)
		{
			if (inputService.GetControlDown(Control.PreviousTab) || inputService.GetControlDown(Control.NextTab))
			{
				currentItem = null;
				statsTable.Visible = false;
				if (base.IsBuying)
				{
					DisplaySellInventory(forceRefresh: true);
				}
				else
				{
					DisplayBuyInventory(forceRefresh: true);
				}
			}
			else if (currentItem != null && base.IsBuying && inputService.GetControlDown(Control.RoomInteraction))
			{
				selectItemAtIndex = currentGuiItem.GetComponent<InventoryItemSelectable>().Index;
				ApplyItemAction();
			}
			closeGroup.Visible = !SpecialEscapeBehavior(testOnly: true);
			yield return null;
		}
	}
}
public class MerchantPanel : InventoryPanel
{
	public delegate void OnHidePanelHandler();

	[SerializeField]
	private AgeTransform gameMenuIndication;

	public AgeControlToggle BuyToggle;

	public AgeControlToggle SellToggle;

	public AgeControlButton ItemActionButton;

	public AgeTransform ItemAction;

	public AgePrimitiveLabel ItemActionLabel;

	public AgePrimitiveLabel MerchantDialogLabel;

	public Texture2D[] FIDSImages;

	public AgePrimitiveImage FIDSImage;

	public AgePrimitiveLabel TitleLabel;

	public AgeTransform MerchantHealth;

	public AgePrimitiveImage MerchantIcon;

	public OnHidePanelHandler OnHidePanel;

	protected bool disableUnequipableItems;

	protected int selectedItemIndex = -1;

	protected int selectItemAtIndex = -1;

	protected IInputService inputService;

	private NPCMerchant _merchant;

	private AgeTransform lifeBar;

	public bool IsBuying
	{
		get;
		private set;
	}

	public NPCMerchant Merchant
	{
		get
		{
			return _merchant;
		}
		private set
		{
			if (_merchant != null)
			{
				_merchant.HealthCpnt.OnHit -= OnHit;
			}
			_merchant = value;
			if (_merchant != null)
			{
				_merchant.HealthCpnt.OnHit += OnHit;
			}
		}
	}

	public bool DealDone
	{
		get;
		protected set;
	}

	protected override void Awake()
	{
		base.Awake();
		inputService = Services.GetService<IInputService>();
		lifeBar = MerchantHealth.transform.parent.GetComponent<AgeTransform>();
	}

	public override void Bind(params object[] parameters)
	{
		EquipmentSlot[] restrictedSlots = null;
		if (parameters.Length >= 1)
		{
			if (parameters[0] is NPCMerchant)
			{
				Merchant = (parameters[0] as NPCMerchant);
			}
			if (parameters.Length >= 2 && parameters[1] is EquipmentSlot[])
			{
				restrictedSlots = (parameters[1] as EquipmentSlot[]);
			}
		}
		Bind(Merchant.CurrentInventory, restrictedSlots);
	}

	public override void Unbind()
	{
		Merchant = null;
		base.Unbind();
	}

	public override void Show(params object[] parameters)
	{
		if (Services.GetService<IInputService>().CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			Services.GetService<IGameControlService>().SetHeroStatsPanelDisplay(on: true, displayInventory: false);
		}
		base.Show(parameters);
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		if (selectedItemIndex > 0)
		{
			if (inventoryList != null)
			{
				inventoryList.SelectItemAtIndex(selectedItemIndex);
			}
			else
			{
				selectedItemIndex = -1;
			}
		}
		if (Merchant != null)
		{
			RefreshDialog();
			if (base.GuiService.GuiPanelHelper.TryGetGuiElement(Merchant.Config.Name, out GuiElement guiElement) && base.GuiService.GuiPanelHelper.TryGetTextureFromIcon(guiElement, IconSize.Small, out Texture2D texture))
			{
				MerchantIcon.Image = texture;
			}
			RefreshLifeBar();
			FIDSImage.Image = FIDSImages[(int)Merchant.CurrencyCfg.Currency];
			NPCMerchantConfig merchantConfig = Merchant.MerchantConfig;
			SellToggle.AgeTransform.Enable = !merchantConfig.IsLimited;
			TitleLabel.Text = "%" + merchantConfig.Name;
		}
		if (ItemAction != null)
		{
			RefreshBuyItemButton();
		}
		DealDone = false;
	}

	public void ApplyItemAction()
	{
		if (IsBuying)
		{
			if (InventoryListPanel.SelectedGuiItem != null && !InventoryListPanel.SelectedGuiItem.GetItem().CanBuy(Merchant))
			{
				SingletonManager.Get<Dungeon>().EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_ItemBuyFailResources" + Merchant.CurrencyCfg.Name));
			}
			else
			{
				BuyCurrentItem();
			}
		}
		else
		{
			SellCurrentItem();
		}
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		BuyToggle.State = true;
		SellToggle.State = false;
		IsBuying = true;
		if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			if (TutorialManager.IsEnable && tutorialManager != null)
			{
				tutorialManager.MovePanelCenter();
			}
		}
		else if (TutorialManager.IsEnable && tutorialManager != null)
		{
			tutorialManager.MovePanelRight();
		}
		if (gameMenuIndication != null)
		{
			gameMenuIndication.Visible = false;
		}
		gameEventManager.OnDungeonFIDSChanged += OnDungeonFIDSChanged;
		Diagnostics.Assert(Merchant != null, "[MerchantPanel] wrong parameters for panel. The linked NPCMerchant is needed as first parameter of the function Show");
	}

	protected override IEnumerator OnHide(bool instant)
	{
		base.NeedRefresh = false;
		if (Merchant != null)
		{
			Merchant = null;
		}
		if (TutorialManager.IsEnable && tutorialManager != null)
		{
			tutorialManager.MovePanelLeft();
		}
		gameEventManager.OnDungeonFIDSChanged -= OnDungeonFIDSChanged;
		yield return base.OnHide(instant);
		if (OnHidePanel != null)
		{
			OnHidePanel();
		}
	}

	protected override IEnumerator OnLoadGame()
	{
		base.OnLoadGame();
		Hide(instant: true);
		yield break;
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		base.UseRefreshLoop = true;
		tutorialManager = SingletonManager.Get<TutorialManager>();
	}

	protected override void BindInventoryList(Inventory[] inventories, EquipmentSlot[] restrictedSlots = null)
	{
		StaticString staticString = null;
		bool checkBuyable = false;
		if (IsBuying)
		{
			staticString = SimulationProperties.Cost;
			checkBuyable = true;
		}
		else
		{
			staticString = SimulationProperties.SellingCost;
		}
		inventoryList.Bind(inventories, restrictedSlots, staticString, checkEquipable: false, checkBuyable);
	}

	protected override void InventoryListPanel_OnItemSelected(InventoryListPanel sender, InventoryGuiItem inventoryGuiItem)
	{
		if (ItemAction != null)
		{
			RefreshBuyItemButton();
		}
	}

	protected void RefreshLifeBar()
	{
		if (MerchantHealth != null && Merchant != null && Merchant.HealthCpnt != null && !Merchant.HealthCpnt.IsInvincible)
		{
			lifeBar.Visible = true;
			MerchantHealth.PercentRight = 100f * Merchant.HealthCpnt.GetHealthRatio();
		}
		else
		{
			lifeBar.Visible = false;
		}
	}

	protected void RefreshDialog()
	{
		Dungeon x = SingletonManager.Get<Dungeon>();
		if (!(x == null))
		{
			string empty = string.Empty;
			empty = (IsBuying ? ((InventoryListPanel.SelectedGuiItem != null && InventoryListPanel.SelectedGuiItem.GetItem() != null) ? ((!InventoryListPanel.SelectedGuiItem.GetItem().CanBuy(Merchant)) ? Merchant.GetDialogLocalizedTextByName(string.Concat(NPCMerchantConfig.NPCDialog_Merchant_PurchaseNotEnoughResource, Merchant.CurrencyCfg.Name)) : Merchant.GetDialogLocalizedTextByName(NPCMerchantConfig.NPCDialog_Merchant_PurchaseItemSelected)) : ((!DealDone) ? Merchant.GetDialogLocalizedTextByName(NPCMerchantConfig.NPCDialog_Merchant_PurchaseIntroduction) : Merchant.GetDialogLocalizedTextByName(NPCMerchantConfig.NPCDialog_Merchant_PurchaseDone))) : ((InventoryListPanel.SelectedGuiItem != null) ? Merchant.GetDialogLocalizedTextByName(NPCMerchantConfig.NPCDialog_Merchant_SaleItemSelected) : ((!DealDone) ? Merchant.GetDialogLocalizedTextByName(NPCMerchantConfig.NPCDialog_Merchant_SaleIntroduction) : Merchant.GetDialogLocalizedTextByName(NPCMerchantConfig.NPCDialog_Merchant_SaleDone))));
			MerchantDialogLabel.Text = empty;
		}
	}

	private void RefreshBuyItemButton()
	{
		Dungeon x = SingletonManager.Get<Dungeon>();
		if (x == null)
		{
			return;
		}
		if (InventoryListPanel.SelectedGuiItem != null)
		{
			if (IsBuying)
			{
				ItemActionLabel.Text = AgeLocalizer.Instance.LocalizeString("%MerchantBuyItemTitle");
				if (InventoryListPanel.SelectedGuiItem.GetItem() != null && InventoryListPanel.SelectedGuiItem.GetItem().CanBuy(Merchant))
				{
					ItemActionButton.AgeTransform.Enable = true;
					ItemActionButton.AgeTransform.Alpha = 1f;
				}
				else
				{
					ItemActionButton.AgeTransform.Enable = false;
					ItemActionButton.AgeTransform.Alpha = 0.5f;
				}
			}
			else
			{
				ItemActionLabel.Text = AgeLocalizer.Instance.LocalizeString("%MerchantSellItemTitle");
				ItemActionButton.AgeTransform.Enable = true;
				ItemActionButton.AgeTransform.Alpha = 1f;
			}
			ItemAction.Visible = true;
		}
		else
		{
			ItemAction.Visible = false;
			ItemActionButton.AgeTransform.Enable = false;
		}
	}

	public virtual void DisplayBuyInventory(bool forceRefresh = false)
	{
		if (Merchant != null)
		{
			BuyToggle.State = true;
			SellToggle.State = false;
			IsBuying = true;
			inventoryList.SelectItem(null);
			Bind(Merchant.CurrentInventory);
			if (forceRefresh)
			{
				base.NeedRefresh = true;
				SelectFirstInventoryItem();
			}
		}
	}

	public virtual void DisplaySellInventory(bool forceRefresh = false)
	{
		if (Merchant.MerchantConfig.IsLimited)
		{
			return;
		}
		BuyToggle.State = false;
		SellToggle.State = true;
		IsBuying = false;
		inventoryList.SelectItem(null);
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		if (dungeon != null)
		{
			Bind(dungeon.Inventories);
			if (forceRefresh)
			{
				base.NeedRefresh = true;
				SelectFirstInventoryItem();
			}
		}
	}

	public void SelectFirstInventoryItem()
	{
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			selectItemAtIndex = 0;
		}
	}

	private void OnItemActionButtonClick()
	{
		ApplyItemAction();
	}

	protected virtual void BuyCurrentItem()
	{
		if (!(InventoryListPanel.SelectedGuiItem == null) && InventoryListPanel.SelectedGuiItem.GetItem() != null)
		{
			InventoryItem item = InventoryListPanel.SelectedGuiItem.GetItem();
			if (item.CurrentInventory.ParentSimMB != merchant)
			{
				Diagnostics.LogError("Cannot buy an item not in merchant inventory!");
			}
			else
			{
				Merchant.NetSyncElement.SendRPCToServer(UniqueIDRPC.NPCMerchant_RequestBuyItemFromMerchantPanel, item.UniqueIDCategory, item.UniqueID, SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID());
			}
		}
	}

	public virtual void OnCurrentItemBought()
	{
		inventoryList.SelectItem(null);
		DealDone = true;
		base.NeedRefresh = true;
	}

	protected virtual void SellCurrentItem()
	{
		if (InventoryListPanel.SelectedGuiItem == null || InventoryListPanel.SelectedGuiItem.GetItem() == null)
		{
			return;
		}
		int num = -1;
		InventoryListPanel inventoryListPanel = null;
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			InventoryItemSelectable component = InventoryListPanel.SelectedGuiItem.GetComponent<InventoryItemSelectable>();
			if (component != null)
			{
				num = component.Index;
				inventoryListPanel = InventoryListPanel.SelectedGuiItem.GetInventoryListPanel();
			}
		}
		InventoryItem item = InventoryListPanel.SelectedGuiItem.GetItem();
		if (item.CurrentInventory.ParentSimMB is NPCMerchant)
		{
			Diagnostics.LogError("Cannot sell an item from a merchant inventory!");
			return;
		}
		Merchant.NetSyncElement.SendRPCToServer(UniqueIDRPC.NPCMerchant_RequestSellItemFromMerchantPanel, item.UniqueIDCategory, item.UniqueID, SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID());
		if (num >= 0 && inventoryListPanel != null)
		{
			inventoryListPanel.SelectItemAtIndex(num);
		}
	}

	public void OnCurrentItemSold()
	{
		inventoryList.SelectItem(null);
		DealDone = true;
		base.NeedRefresh = true;
	}

	public void OnSwitchBuyButtonClick()
	{
		DisplayBuyInventory(forceRefresh: true);
	}

	public void OnSwitchSellButtonClick()
	{
		DisplaySellInventory(forceRefresh: true);
	}

	private void OnHit(AttackInfo hit)
	{
		RefreshLifeBar();
	}

	private void OnDungeonFIDSChanged()
	{
		base.NeedRefresh = true;
	}

	private InventoryItemSelectable GetChildItemSelected()
	{
		if (base.IsVisible && !base.IsHiding)
		{
			Selectable currentCategorySelectedElement = selectableManager.GetCurrentCategorySelectedElement();
			if (currentCategorySelectedElement != null)
			{
				return currentCategorySelectedElement as InventoryItemSelectable;
			}
		}
		return null;
	}
}
public class ModuleSlotHighlightItem : MonoBehaviour
{
	public AgeTransform AgeTransform;

	public GameToScreenPositionSync GameToScreenPositionSync;
}
public class MouseManagePanel : GuiPanel
{
	[SerializeField]
	private AgeControlToggle moduleLevelUpToggle;

	[SerializeField]
	private Texture2D moduleLevelUpToggleCursorTexture;

	private void OnModuleLevelUpButtonClick()
	{
		IGuiService service = Services.GetService<IGuiService>();
		if (moduleLevelUpToggle.State)
		{
			service.ChangeCursor(moduleLevelUpToggleCursorTexture);
		}
		else
		{
			service.ChangeCursorToDefault();
		}
	}
}
public class MoviePanel : GuiPanel
{
	public delegate void OnVideoCompleteDlg();

	protected OnVideoCompleteDlg onVideoCompleteDlg;

	protected bool listenToInputs;

	private AgePrimitiveMovie movieCpnt;

	protected override void Awake()
	{
		base.Awake();
		movieCpnt = GetComponent<AgePrimitiveMovie>();
	}

	public virtual void StartVideo(string moviePath, OnVideoCompleteDlg onVideoCompleteDlg)
	{
		movieCpnt.MovieName = moviePath;
		this.onVideoCompleteDlg = onVideoCompleteDlg;
		Show();
	}

	public override void Show(params object[] parameters)
	{
		if (movieCpnt != null)
		{
			listenToInputs = false;
			movieCpnt.PlayMovie();
		}
		base.Show(parameters);
	}

	public virtual void OnMoviePlaybackComplete()
	{
		if (base.IsVisible)
		{
			if (onVideoCompleteDlg != null)
			{
				onVideoCompleteDlg();
			}
			Hide();
		}
	}

	public void OnBinkMoviePlaybackComplete()
	{
		OnMoviePlaybackComplete();
	}

	protected virtual void Update()
	{
		if (!base.IsVisible)
		{
			return;
		}
		if (movieCpnt == null)
		{
			OnMoviePlaybackComplete();
		}
		else if (!listenToInputs && !Input.GetMouseButton(0) && !Input.anyKeyDown)
		{
			listenToInputs = true;
		}
		else if (listenToInputs && (Input.GetMouseButton(0) || Input.anyKeyDown))
		{
			if (movieCpnt != null)
			{
				movieCpnt.StopMovie();
			}
			OnMoviePlaybackComplete();
			listenToInputs = false;
		}
	}
}
public enum NotificationType
{
	Message,
	Error,
	Alert,
	Dialogue,
	Event,
	AlbumPicture,
	Backstory,
	MiscUnlock
}
public class NotificationData
{
	public string Message;

	public NotificationType MessageType;

	public NotificationClickHandler OnClick;

	public string NotificationInformation;

	public NotificationData(NotificationType type, string message, NotificationClickHandler onClick, string notificationInformation = null)
	{
		MessageType = type;
		Message = message;
		OnClick = onClick;
		NotificationInformation = notificationInformation;
	}
}
public class NotificationPanel : GuiPanel
{
	[SerializeField]
	private Color messageDefaultColor;

	[SerializeField]
	private Color messageErrorColor;

	[SerializeField]
	private AgePrimitiveLabel messageLabel;

	[SerializeField]
	private AgeControlButton button;

	[SerializeField]
	private AgeTransform notificationArea;

	[SerializeField]
	private float minDisplayDuration;

	[SerializeField]
	private float maxDisplayDuration;

	[SerializeField]
	private AgeTransform backgroundLeft;

	[SerializeField]
	private AgeTransform backgroundRight;

	[SerializeField]
	private AgePrimitiveImage icon;

	[SerializeField]
	private Texture2D transparentImage;

	private float currentDisplayStartTime;

	private float nextDisplayTime;

	private Queue<NotificationData> notificationsQueue;

	private NotificationData currentNotification;

	private float initialWidth;

	public NotificationData CurrentNotification => currentNotification;

	public void EnqueueNotification(string message, NotificationType type = NotificationType.Message, NotificationClickHandler onClick = null, bool foreGround = false, string notificationInformation = null)
	{
		if (!ContainsMessage(message) && !(messageLabel.Text == message) && (foreGround || (!SingletonManager.Get<VictoryPanel>().IsVisible && !SingletonManager.Get<GameOverPanel>().IsVisible)))
		{
			notificationsQueue.Enqueue(new NotificationData(type, message, onClick, notificationInformation));
			if (base.IsVisible)
			{
				nextDisplayTime = currentDisplayStartTime + minDisplayDuration;
			}
			else
			{
				nextDisplayTime = Time.time;
			}
		}
	}

	protected override void Awake()
	{
		base.Awake();
		notificationsQueue = new Queue<NotificationData>();
		initialWidth = base.AgeTransform.Width;
	}

	protected override IEnumerator OnHide(bool instant)
	{
		notificationArea.Visible = false;
		notificationsQueue.Clear();
		yield return base.OnHide(instant);
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		notificationArea.Visible = true;
		notificationArea.ResetAllModifiers();
		notificationArea.Alpha = notificationArea.GetComponent<AgeModifierAlpha>().StartAlpha;
		yield return base.OnShow(parameters);
		RefreshContent();
	}

	private void Update()
	{
		if (notificationsQueue.Count > 0 && Time.time >= nextDisplayTime)
		{
			Show();
			currentNotification = notificationsQueue.Dequeue();
			if (currentNotification.MessageType == NotificationType.Message)
			{
				messageLabel.AgeTransform.StartAllModifiers();
				backgroundLeft.StartAllModifiers();
				backgroundRight.StartAllModifiers();
				icon.AgeTransform.StartAllModifiers();
			}
			else if (currentNotification.MessageType == NotificationType.Error)
			{
				backgroundLeft.Width = 225f;
				backgroundRight.Width = 225f;
				backgroundLeft.Alpha = 1f;
				backgroundRight.Alpha = 1f;
			}
			else if (currentNotification.MessageType == NotificationType.Alert)
			{
				backgroundLeft.Width = 225f;
				backgroundRight.Width = 225f;
				backgroundLeft.Alpha = 1f;
				backgroundRight.Alpha = 1f;
			}
			icon.Image = transparentImage;
			if (currentNotification.MessageType == NotificationType.Event)
			{
				icon.Image = LogPanel.GetNotificationIcon(currentNotification.NotificationInformation);
			}
			else if (!string.IsNullOrEmpty(CurrentNotification.NotificationInformation))
			{
				IGuiService service = Services.GetService<IGuiService>();
				if (service != null && service.GuiPanelHelper.TryGetGuiElement(CurrentNotification.NotificationInformation, out GuiElement guiElement) && service.GuiPanelHelper.TryGetTextureFromIcon(guiElement, IconSize.Small, out Texture2D texture))
				{
					icon.Image = texture;
				}
			}
			bool flag = false;
			if (icon.Image != null)
			{
				flag = true;
			}
			else
			{
				icon.Image = GuiManager.GetTransparentTexture();
			}
			base.AgeTransform.Width = ((!flag) ? initialWidth : (initialWidth + icon.AgeTransform.Width)) * AgeUtils.CurrentUpscaleFactor();
			messageLabel.AgeTransform.PixelOffsetLeft = ((!flag) ? 0f : icon.AgeTransform.Width) * AgeUtils.CurrentUpscaleFactor();
			messageLabel.Text = currentNotification.Message;
			button.AgeTransform.Enable = (currentNotification.OnClick != null);
			notificationArea.Visible = true;
			notificationArea.StartAllModifiers();
			currentDisplayStartTime = Time.time;
			nextDisplayTime = Time.time + maxDisplayDuration;
		}
		else if (notificationArea.Visible && !notificationArea.ModifiersRunning)
		{
			currentNotification = null;
			messageLabel.Text = string.Empty;
			notificationArea.Visible = false;
			Hide(instant: true);
		}
	}

	private bool ContainsMessage(string message)
	{
		foreach (NotificationData item in notificationsQueue)
		{
			if (item.Message.Equals(message))
			{
				return true;
			}
		}
		return false;
	}

	private void OnNotifClick()
	{
		if (currentNotification != null && currentNotification.OnClick != null)
		{
			currentNotification.OnClick();
		}
	}
}
public class OptionsPanel : PopupMenuPanel
{
	private delegate void OnResolutionChangeCancel();

	[SerializeField]
	private float displayedVolumeMultiplier;

	[SerializeField]
	private Transform controlBindingLinePrefab;

	[SerializeField]
	private AgeTransform controlBindingsTable;

	[SerializeField]
	private AgeControlScrollView controlBindingsScrollView;

	[SerializeField]
	private AgeControlDropList resolutionDropList;

	[SerializeField]
	private AgeControlDropList resolutionModeDropList;

	[SerializeField]
	private AgeControlToggle fullscreenToggle;

	[SerializeField]
	private AgeControlToggle highDefinitionUIToggle;

	[SerializeField]
	private AgeControlToggle vSyncToggle;

	[SerializeField]
	private AgeControlToggle controlSchemeToggle;

	[SerializeField]
	private AgeControlSlider masterVolSlider;

	[SerializeField]
	private AgePrimitiveLabel masterVolValue;

	[SerializeField]
	private AgeControlSlider bgmVolSlider;

	[SerializeField]
	private AgePrimitiveLabel bgmVolValue;

	[SerializeField]
	private AgeControlSlider ambianceVolSlider;

	[SerializeField]
	private AgePrimitiveLabel ambianceVolValue;

	[SerializeField]
	private AgeControlSlider sfxVolSlider;

	[SerializeField]
	private AgePrimitiveLabel sfxVolValue;

	[SerializeField]
	private AgeControlSlider guiVolSlider;

	[SerializeField]
	private AgePrimitiveLabel guiVolValue;

	private static readonly string[] DeletionKeys = new string[1]
	{
		"Escape"
	};

	private Dictionary<StaticString, List<string>> controlRegistryPathsAndBindings = new Dictionary<StaticString, List<string>>();

	private IGameResolutionService gameResolutionManager;

	private IAudioVolumeService audioVolumeManager;

	private IGuiSettingsService guiSettingsManager;

	private IInputService inputManager;

	private RequesterPanel requesterPanel;

	private bool saveSettings;

	private float originalMasterVolume;

	private float originalBGMVolume;

	private float originalAmbianceVolume;

	private float originalSFXVolume;

	private float originalGUIVolume;

	private StaticString[] controlRegistryPaths;

	private StaticString bindingControlRegistryPath;

	private List<string> bindingValues;

	private ControlBindingLine controlBindingLine;

	private List<ResolutionMode> availableModes = new List<ResolutionMode>();

	private SelectableManager selectableManager;

	public override void RefreshContent()
	{
		base.RefreshContent();
		controlBindingsTable.Height = 0f;
		controlBindingsTable.ReserveChildren(controlRegistryPathsAndBindings.Count, controlBindingLinePrefab, "ControlBinding");
		controlBindingsTable.RefreshChildrenIList(controlRegistryPathsAndBindings.ToList(), RefreshControlBinding);
		controlBindingsTable.ArrangeChildren();
		controlBindingsScrollView.OnPositionRecomputed();
		UpdateControlScheme();
		UpdateResolutionOptions();
		UpdateVSyncOption();
		UpdateMasterVolumeDisplay();
		UpdateBGMVolumeDisplay();
		UpdateAmbianceVolumeDisplay();
		UpdateSFXVolumeDisplay();
		UpdateGUIVolumeDisplay();
	}

	public void ChangeControlBinding(StaticString controlRegistryPath, List<string> bindings, int newBindingIndex, ControlBindingLine controlBindingLine)
	{
		if (controlRegistryPathsAndBindings.ContainsKey(controlRegistryPath))
		{
			this.controlBindingLine = controlBindingLine;
			bindingControlRegistryPath = controlRegistryPath;
			bindingValues = bindings;
			string[] array = null;
			if (Array.IndexOf(DeletionKeys, bindings[newBindingIndex]) >= 0)
			{
				bindings[newBindingIndex] = KeyCode.None.ToString();
			}
			else
			{
				array = (from binding in controlRegistryPathsAndBindings
					where binding.Value.Count > newBindingIndex && binding.Value.Contains(bindings[newBindingIndex]) && binding.Key != controlRegistryPath
					select AgeLocalizer.Instance.LocalizeString("%ControlBindings" + binding.Key.ToString().Substring(binding.Key.ToString().LastIndexOf('/') + 1))).ToArray();
			}
			if (array != null && array.Length > 0 && bindings[newBindingIndex] != "None")
			{
				string newValue = "\n- " + string.Join("\n- ", array);
				requesterPanel.Display(AgeLocalizer.Instance.LocalizeString("%SameBindingConfirmMessage").Replace("{1}", newValue).Replace("{0}", bindings[newBindingIndex]), OnChangeControlBindingConfirm, RequesterPanel.ButtonsMode.YesNo, "%SameBindingConfirmTitle");
			}
			else
			{
				OnChangeControlBindingConfirm(RequesterPanel.Result.Yes);
			}
		}
	}

	public void OnChangeControlBindingConfirm(RequesterPanel.Result result)
	{
		if (result == RequesterPanel.Result.Yes)
		{
			controlRegistryPathsAndBindings[bindingControlRegistryPath] = bindingValues;
		}
		controlBindingLine.UpdateBindingText(controlRegistryPathsAndBindings[bindingControlRegistryPath]);
	}

	public void UpdateMasterVolumeDisplay()
	{
		UpdateVolumeDisplay(masterVolSlider, masterVolValue, audioVolumeManager.GetMasterVolume());
	}

	public void UpdateBGMVolumeDisplay()
	{
		UpdateVolumeDisplay(bgmVolSlider, bgmVolValue, audioVolumeManager.GetBGMVolume());
	}

	public void UpdateAmbianceVolumeDisplay()
	{
		UpdateVolumeDisplay(ambianceVolSlider, ambianceVolValue, audioVolumeManager.GetAmbianceVolume());
	}

	public void UpdateSFXVolumeDisplay()
	{
		UpdateVolumeDisplay(sfxVolSlider, sfxVolValue, audioVolumeManager.GetSFXVolume());
	}

	public void UpdateGUIVolumeDisplay()
	{
		UpdateVolumeDisplay(guiVolSlider, guiVolValue, audioVolumeManager.GetGUIVolume());
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		base.UseRefreshLoop = true;
		gameResolutionManager = Services.GetService<IGameResolutionService>();
		guiSettingsManager = Services.GetService<IGuiSettingsService>();
		audioVolumeManager = Services.GetService<IAudioVolumeService>();
		inputManager = Services.GetService<IInputService>();
		requesterPanel = SingletonManager.Get<RequesterPanel>();
		Diagnostics.Assert(requesterPanel != null);
		gameResolutionManager.OnGameResolutionChanged += OnGameResolutionChanged;
		gameResolutionManager.OnVSyncChanged += OnVSyncChanged;
		audioVolumeManager.OnAudioVolumesChanged += OnAudioVolumesChanged;
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		saveSettings = false;
		BuildControlsBindingsDictionary();
		originalMasterVolume = audioVolumeManager.GetMasterVolume();
		originalBGMVolume = audioVolumeManager.GetBGMVolume();
		originalAmbianceVolume = audioVolumeManager.GetAmbianceVolume();
		originalSFXVolume = audioVolumeManager.GetSFXVolume();
		originalGUIVolume = audioVolumeManager.GetGUIVolume();
		base.NeedRefresh = true;
	}

	protected override IEnumerator OnHide(bool instant)
	{
		yield return base.OnHide(instant);
		base.NeedRefresh = false;
		if (saveSettings)
		{
			SaveControlsBindings();
			gameResolutionManager.SaveCurrentGameResolution();
			gameResolutionManager.SaveVSync();
			guiSettingsManager.SaveCurrentGameResolution();
			yield break;
		}
		controlRegistryPathsAndBindings.Clear();
		gameResolutionManager.RestoreSavedResolution();
		gameResolutionManager.RestoreSavedVSync();
		guiSettingsManager.RestoreSavedHighDefinitionUI();
		audioVolumeManager.SetMasterVolume(originalMasterVolume);
		audioVolumeManager.SetBGMVolume(originalBGMVolume);
		audioVolumeManager.SetAmbianceVolume(originalAmbianceVolume);
		audioVolumeManager.SetSFXVolume(originalSFXVolume);
		audioVolumeManager.SetGUIVolume(originalGUIVolume);
	}

	private void UpdateResolutionOptions()
	{
		ScreenResolution[] availableScreenResolutions = gameResolutionManager.GetAvailableScreenResolutions();
		if (resolutionDropList.ItemTable == null || resolutionDropList.ItemTable.Length == 0)
		{
			string[] array = new string[availableScreenResolutions.Length];
			string[] array2 = new string[availableScreenResolutions.Length];
			for (int i = 0; i < availableScreenResolutions.Length; i++)
			{
				string key;
				string key2;
				if (gameResolutionManager.IsResolutionPixelPerfect(availableScreenResolutions[i]))
				{
					key = "%ScreenResolutionName_PixelPerfect";
					key2 = "%ScreenResolutionTooltip_PixelPerfect";
				}
				else if (gameResolutionManager.IsResolutionSameRatio(availableScreenResolutions[i]))
				{
					key = "%ScreenResolutionName_SameRatio";
					key2 = "%ScreenResolutionTooltip_SameRatio";
				}
				else
				{
					key = "%ScreenResolutionName";
					key2 = "%ScreenResolutionTooltip";
				}
				array[i] = AgeLocalizer.Instance.LocalizeString(key).Replace("$Width", availableScreenResolutions[i].Width.ToString()).Replace("$Height", availableScreenResolutions[i].Height.ToString());
				array2[i] = AgeLocalizer.Instance.LocalizeString(key2);
			}
			resolutionDropList.ItemTable = array;
			resolutionDropList.TooltipTable = array2;
		}
		GameResolution currentGameResolution = gameResolutionManager.CurrentGameResolution;
		ScreenResolution screenResolution = currentGameResolution.ScreenResolution;
		for (int j = 0; j < availableScreenResolutions.Length; j++)
		{
			if (availableScreenResolutions[j].Width == screenResolution.Width && availableScreenResolutions[j].Height == screenResolution.Height)
			{
				resolutionDropList.SelectedItem = j;
				break;
			}
		}
		UpdateResolutionModeDropList();
		AgeControlToggle ageControlToggle = fullscreenToggle;
		GameResolution currentGameResolution2 = gameResolutionManager.CurrentGameResolution;
		ageControlToggle.State = currentGameResolution2.Fullscreen;
		UpdateHighDefinitionUIAvailability();
	}

	private void UpdateResolutionModeDropList()
	{
		GameResolution currentGameResolution = gameResolutionManager.CurrentGameResolution;
		ScreenResolution screenResolution = (inputManager.CurrentControlScheme != 0) ? gameResolutionManager.GetAvailableScreenResolutions()[resolutionDropList.SelectedItem] : currentGameResolution.ScreenResolution;
		availableModes.Clear();
		if (gameResolutionManager.IsResolutionPixelPerfect(screenResolution))
		{
			availableModes.Add(ResolutionMode.PixelPerfect);
		}
		else if (gameResolutionManager.IsResolutionSameRatio(screenResolution))
		{
			availableModes.Add(ResolutionMode.PixelPerfect);
			availableModes.Add(ResolutionMode.NoBorders);
		}
		else
		{
			if (gameResolutionManager.TryGetBestPixelPerfectResolution(screenResolution, out ScreenResolution pixelPerfectResolution))
			{
				availableModes.Add(ResolutionMode.PixelPerfect);
				ScreenResolution bestSameRatioResolution = gameResolutionManager.GetBestSameRatioResolution(screenResolution);
				if (pixelPerfectResolution.Width != bestSameRatioResolution.Width || pixelPerfectResolution.Height != bestSameRatioResolution.Height)
				{
					availableModes.Add(ResolutionMode.SameRatio);
				}
			}
			else
			{
				availableModes.Add(ResolutionMode.SameRatio);
			}
			availableModes.Add(ResolutionMode.NoBorders);
		}
		string[] array = new string[availableModes.Count];
		string[] array2 = new string[availableModes.Count];
		for (int i = 0; i < availableModes.Count; i++)
		{
			array[i] = AgeLocalizer.Instance.LocalizeString("%ResolutionModeName_" + availableModes[i].ToString());
			array2[i] = AgeLocalizer.Instance.LocalizeString("%ResolutionModeTooltip_" + availableModes[i].ToString());
		}
		resolutionModeDropList.ItemTable = array;
		resolutionModeDropList.TooltipTable = array2;
		int num = availableModes.IndexOf(currentGameResolution.Mode);
		if (num >= 0)
		{
			resolutionModeDropList.SelectedItem = num;
		}
	}

	private void UpdateVSyncOption()
	{
		vSyncToggle.State = gameResolutionManager.VSync;
	}

	private void UpdateControlScheme()
	{
		controlSchemeToggle.State = Amplitude.Unity.Framework.Application.Registry.GetValue<bool>(InputManager.EnableXBoxControllerRegistryPath);
	}

	private void OnToggleControlScheme(GameObject obj)
	{
		Amplitude.Unity.Framework.Application.Registry.SetValue(InputManager.EnableXBoxControllerRegistryPath, controlSchemeToggle.State);
		SingletonManager.Get<RequesterPanel>().Display("%ControlSchemeChangedRestart");
	}

	private void OnGameResolutionChanged()
	{
		base.NeedRefresh = true;
	}

	private void OnVSyncChanged()
	{
		base.NeedRefresh = true;
	}

	private void AskResolutionChangeConfirmation(RequesterPanel.ResultEventHandler onConfirm = null)
	{
		requesterPanel.Display("%ResolutionChangeConfirmMessage", onConfirm, RequesterPanel.ButtonsMode.YesNo, "%ResolutionChangeConfirmTitle", 10f);
	}

	private void OnAudioVolumesChanged()
	{
		if (inputManager.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			base.NeedRefresh = true;
			return;
		}
		UpdateMasterVolumeDisplay();
		UpdateBGMVolumeDisplay();
		UpdateAmbianceVolumeDisplay();
		UpdateSFXVolumeDisplay();
		UpdateGUIVolumeDisplay();
	}

	private void OnConfirmButtonClick(GameObject obj)
	{
		if (inputManager.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			SaveAndHide();
		}
		else
		{
			OnSelectResolution(null);
		}
	}

	private void SaveAndHide()
	{
		saveSettings = true;
		Hide();
	}

	private void OnCancelButtonClick(GameObject obj)
	{
		saveSettings = false;
		Hide();
	}

	private void OnResetButtonClick()
	{
		requesterPanel.Display("%ResetControlsConfirmMessage", OnControlsResetConfirm, RequesterPanel.ButtonsMode.YesNo, "%ResetControlsConfirmTitle");
	}

	private void OnControlsResetConfirm(RequesterPanel.Result result)
	{
		if (result == RequesterPanel.Result.Yes)
		{
			ResetControlBindings();
		}
	}

	private void OnSelectResolution(GameObject obj)
	{
		if (obj == null || inputManager.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			GameResolution originalGameRes = gameResolutionManager.CurrentGameResolution;
			ScreenResolution screenResolution = originalGameRes.ScreenResolution;
			ScreenResolution screenResolution2 = gameResolutionManager.GetAvailableScreenResolutions()[resolutionDropList.SelectedItem];
			if (screenResolution2.Width == screenResolution.Width && screenResolution2.Height == screenResolution.Height)
			{
				if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController)
				{
					OnSelectResolutionMode(null);
					SaveAndHide();
				}
			}
			else
			{
				GameResolution gameResolution = default(GameResolution);
				gameResolution.ScreenResolution = screenResolution2;
				gameResolution.Fullscreen = originalGameRes.Fullscreen;
				gameResolution.Mode = ResolutionMode.NoBorders;
				gameResolutionManager.SetGameResolution(gameResolution);
				AskResolutionChangeConfirmation(delegate(RequesterPanel.Result result)
				{
					if (result == RequesterPanel.Result.No)
					{
						gameResolutionManager.SetGameResolution(originalGameRes);
					}
					if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController)
					{
						OnSelectResolutionMode(null);
						SaveAndHide();
					}
				});
			}
		}
		else if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			UpdateResolutionModeDropList();
		}
	}

	private void OnSelectResolutionMode(GameObject obj)
	{
		if (obj == null || inputManager.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			ResolutionMode resolutionMode = availableModes[resolutionModeDropList.SelectedItem];
			GameResolution currentGameResolution = gameResolutionManager.CurrentGameResolution;
			ResolutionMode mode = currentGameResolution.Mode;
			if (resolutionMode != mode)
			{
				gameResolutionManager.SetResolutionMode(resolutionMode);
			}
		}
	}

	private void OnToggleFullscreen(GameObject obj)
	{
		GameResolution currentGameResolution = gameResolutionManager.CurrentGameResolution;
		bool originalFullscreen = currentGameResolution.Fullscreen;
		gameResolutionManager.SetFullscreen(fullscreenToggle.State);
		AskResolutionChangeConfirmation(delegate(RequesterPanel.Result result)
		{
			if (result == RequesterPanel.Result.No)
			{
				gameResolutionManager.SetFullscreen(originalFullscreen);
			}
		});
	}

	private void OnToggleHighDefinitionUI(GameObject obj)
	{
		bool originalHighDefinitionUI = guiSettingsManager.HighDefinitionUI;
		guiSettingsManager.HighDefinitionUI = highDefinitionUIToggle.State;
		AskResolutionChangeConfirmation(delegate(RequesterPanel.Result result)
		{
			if (result == RequesterPanel.Result.No)
			{
				guiSettingsManager.HighDefinitionUI = originalHighDefinitionUI;
				UpdateHighDefinitionUIAvailability();
			}
		});
	}

	private void OnToggleVSync(GameObject obj)
	{
		gameResolutionManager.SetVSync(vSyncToggle.State);
	}

	private void OnMasterVolumeSliderDrag()
	{
		audioVolumeManager.SetMasterVolume(GenericUtilities.RoundHalfAwayFromZero(masterVolSlider.CurrentValue) / displayedVolumeMultiplier);
	}

	private void OnBGMVolumeSliderDrag()
	{
		audioVolumeManager.SetBGMVolume(GenericUtilities.RoundHalfAwayFromZero(bgmVolSlider.CurrentValue) / displayedVolumeMultiplier);
	}

	private void OnAmbianceVolumeSliderDrag()
	{
		audioVolumeManager.SetAmbianceVolume(GenericUtilities.RoundHalfAwayFromZero(ambianceVolSlider.CurrentValue) / displayedVolumeMultiplier);
	}

	private void OnSFXVolumeSliderDrag()
	{
		audioVolumeManager.SetSFXVolume(GenericUtilities.RoundHalfAwayFromZero(sfxVolSlider.CurrentValue) / displayedVolumeMultiplier);
	}

	private void OnGUIVolumeSliderDrag()
	{
		audioVolumeManager.SetGUIVolume(GenericUtilities.RoundHalfAwayFromZero(guiVolSlider.CurrentValue) / displayedVolumeMultiplier);
	}

	private void BuildControlsBindingsDictionary()
	{
		Dictionary<StaticString, StaticString> dictionary = Amplitude.Unity.Framework.Application.Registry.FindAllKeys((StaticString key) => key.ToString().StartsWith(InputManager.KeyboardControlsBaseRegistryPath + "Default")).ToDictionary((StaticString path) => new StaticString(path.ToString().Substring(path.ToString().LastIndexOf('/') + 1)), (StaticString path) => path);
		string keyboardName = "KBL_" + (inputManager as InputManager).KeyboardLayoutName;
		IEnumerable<StaticString> enumerable = Amplitude.Unity.Framework.Application.Registry.FindAllKeys((StaticString key) => key.ToString().StartsWith(InputManager.KeyboardControlsBaseRegistryPath + keyboardName));
		foreach (StaticString item in enumerable)
		{
			StaticString key2 = item.ToString().Substring(item.ToString().LastIndexOf('/') + 1);
			if (dictionary.ContainsKey(key2))
			{
				dictionary[key2] = item;
			}
			else
			{
				dictionary.Add(key2, item);
			}
		}
		controlRegistryPaths = dictionary.Values.ToArray();
		controlRegistryPathsAndBindings.Clear();
		StaticString[] array = controlRegistryPaths;
		foreach (StaticString key3 in array)
		{
			List<string> list = new List<string>();
			string value = Amplitude.Unity.Framework.Application.Registry.GetValue<string>(key3);
			string[] array2 = value.Split(' ');
			bool flag = false;
			for (int j = 0; j < 2; j++)
			{
				if (flag)
				{
					break;
				}
				if (array2.Length > j)
				{
					if (Array.IndexOf(DeletionKeys, array2[j]) >= 0)
					{
						flag = true;
					}
					else
					{
						list.Add(array2[j]);
					}
				}
				else
				{
					list.Add(string.Empty);
				}
			}
			if (!flag)
			{
				controlRegistryPathsAndBindings.Add(key3, list);
			}
		}
	}

	private void SaveControlsBindings()
	{
		inputManager.ClearCachedInputs();
		foreach (KeyValuePair<StaticString, List<string>> controlRegistryPathsAndBinding in controlRegistryPathsAndBindings)
		{
			StaticString key = controlRegistryPathsAndBinding.Key;
			string value = Amplitude.Unity.Framework.Application.Registry.GetValue<string>(key);
			string text = string.Join(" ", controlRegistryPathsAndBinding.Value.ToArray()).Trim();
			if (text != value)
			{
				Amplitude.Unity.Framework.Application.Registry.SetValue<string>(key, text);
			}
		}
	}

	private void RefreshControlBinding(AgeTransform tableItem, KeyValuePair<StaticString, List<string>> registryPathAndBindings, int index)
	{
		ControlBindingLine component = tableItem.GetComponent<ControlBindingLine>();
		component.RefreshContent(registryPathAndBindings.Key, registryPathAndBindings.Value, this);
	}

	private void ResetControlBindings()
	{
		Diagnostics.Assert(controlRegistryPaths != null);
		for (int i = 0; i < controlRegistryPaths.Length; i++)
		{
			Amplitude.Unity.Framework.Application.Registry.SetValue<string>(controlRegistryPaths[i], string.Empty);
		}
		Amplitude.Unity.Framework.Application.Registry.Export(Amplitude.Unity.Framework.Application.RegistryFilePath);
		Amplitude.Unity.Framework.Application.LoadRegistry();
		BuildControlsBindingsDictionary();
		RefreshContent();
	}

	private void UpdateVolumeDisplay(AgeControlSlider slider, AgePrimitiveLabel valueLabel, float volume)
	{
		float num = volume * displayedVolumeMultiplier;
		valueLabel.Text = GenericUtilities.RoundHalfAwayFromZero(num).ToString();
		slider.CurrentValue = num;
	}

	private void UpdateHighDefinitionUIAvailability()
	{
		List<GuiError> guiErrors = new List<GuiError>();
		if (guiSettingsManager.CanUseHighDefinitionUI(guiErrors))
		{
			highDefinitionUIToggle.AgeTransform.Enable = true;
			highDefinitionUIToggle.AgeTransform.AgeTooltip.Content = string.Empty;
		}
		else
		{
			highDefinitionUIToggle.AgeTransform.Enable = false;
			highDefinitionUIToggle.AgeTransform.AgeTooltip.Content = GuiError.FirstLocalizedMessage(guiErrors);
		}
		guiSettingsManager.HighDefinitionUI &= guiSettingsManager.CanUseHighDefinitionUI();
		highDefinitionUIToggle.State = guiSettingsManager.HighDefinitionUI;
	}

	public override void OnEscapeBehavior()
	{
		if (AgeManager.Instance.FocusedControl == null || inputManager.CurrentControlScheme == ControlScheme.XBoxOneController || (inputManager.CurrentControlScheme == ControlScheme.MouseAndKeyboard && base.IsVisible))
		{
			if (selectableManager == null)
			{
				selectableManager = SingletonManager.Get<SelectableManager>();
			}
			Selectable currentCategorySelectedElement = selectableManager.GetCurrentCategorySelectedElement();
			if (currentCategorySelectedElement != null)
			{
				currentCategorySelectedElement.OnUnselect();
			}
			base.OnEscapeBehavior();
		}
	}

	private void Update()
	{
		if (base.IsVisible && inputManager != null && inputManager.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			if (inputManager.GetControlDown(Control.OptionsConfirm))
			{
				OnConfirmButtonClick(null);
			}
			else if (inputManager.GetControlDown(Control.OptionsReset))
			{
				OnResetButtonClick();
			}
		}
	}
}
public class PassiveSkillItem : SkillItem
{
	public AGERowSelectable RowSelectable
	{
		get;
		private set;
	}

	protected override void Awake()
	{
		base.Awake();
		RowSelectable = GetComponent<AGERowSelectable>();
	}
}
public class PlayerLine : MonoBehaviour
{
	[Serializable]
	private struct PingRank
	{
		public float maxLag;

		public Color color;
	}

	[SerializeField]
	private AgePrimitiveLabel playerNameLabel;

	[SerializeField]
	private Color hostNameColor;

	[SerializeField]
	private AgeControlButton[] transferIndustryButtons;

	[SerializeField]
	private AgeControlButton[] transferScienceButtons;

	[SerializeField]
	private AgeControlButton[] transferFoodButtons;

	[SerializeField]
	private AgePrimitiveImage pingIcon;

	[SerializeField]
	private PingRank[] pingRanks;

	[SerializeField]
	private AgeTransform kickButtonAgeTfm;

	[SerializeField]
	private AgeTransform transferHeroButtonAgeTfm;

	[SerializeField]
	private AgeTooltip transferHeroButtonTooltip;

	[SerializeField]
	private AgeControlToggle industryAutoTransferToggle;

	[SerializeField]
	private AgeControlToggle foodAutoTransferToggle;

	[SerializeField]
	private AgeControlToggle scienceAutoTransferToggle;

	private string playerName;

	private GameNetworkManager gameNetManager;

	private IGameEventService gameEventService;

	private IInputService inputService;

	private SelectableManager selectableManager;

	public ulong PlayerID
	{
		get;
		private set;
	}

	public void Bind(ulong playerID)
	{
		if (gameNetManager == null)
		{
			gameNetManager = SingletonManager.Get<GameNetworkManager>();
		}
		PlayerID = playerID;
		playerName = gameNetManager.GetPlayerName(playerID);
	}

	public void Unbind()
	{
		PlayerID = 0uL;
	}

	private void Start()
	{
		inputService = Services.GetService<IInputService>();
		gameEventService = Services.GetService<IGameEventService>();
		gameEventService.OnGamePhaseChanged += RefreshTransferHeroButton;
		selectableManager = SingletonManager.Get<SelectableManager>();
	}

	public void RefreshContent()
	{
		string text = AgeLocalizer.Instance.LocalizeString("%TransferFIDSToPlayerTooltip").Replace("$player", playerName);
		string newValue = AgeLocalizer.Instance.LocalizeString("%FIDS_Industry_Colorized");
		string newValue2 = AgeLocalizer.Instance.LocalizeString("%FIDS_Science_Colorized");
		string newValue3 = AgeLocalizer.Instance.LocalizeString("%FIDS_Food_Colorized");
		playerNameLabel.Text = playerName;
		if (gameNetManager.GetServerPlayerID() == PlayerID)
		{
			playerNameLabel.TintColor = hostNameColor;
		}
		for (int i = 0; i < transferIndustryButtons.Length; i++)
		{
			AgeControlButton ageControlButton = transferIndustryButtons[i];
			int buttonQuantity = GetButtonQuantity(ageControlButton);
			ageControlButton.AgeTransform.Enable = (Mathf.Floor(Player.LocalPlayer.IndustryStock) >= (float)buttonQuantity);
			ageControlButton.AgeTransform.AgeTooltip.Content = text.Replace("$amount", buttonQuantity.ToString()).Replace("$FIDS", newValue);
		}
		for (int j = 0; j < transferScienceButtons.Length; j++)
		{
			AgeControlButton ageControlButton2 = transferScienceButtons[j];
			int buttonQuantity2 = GetButtonQuantity(ageControlButton2);
			ageControlButton2.AgeTransform.Enable = (Mathf.Floor(Player.LocalPlayer.ScienceStock) >= (float)buttonQuantity2);
			ageControlButton2.AgeTransform.AgeTooltip.Content = text.Replace("$amount", buttonQuantity2.ToString()).Replace("$FIDS", newValue2);
		}
		for (int k = 0; k < transferFoodButtons.Length; k++)
		{
			AgeControlButton ageControlButton3 = transferFoodButtons[k];
			int buttonQuantity3 = GetButtonQuantity(ageControlButton3);
			ageControlButton3.AgeTransform.Enable = (Mathf.Floor(Player.LocalPlayer.FoodStock) >= (float)buttonQuantity3);
			ageControlButton3.AgeTransform.AgeTooltip.Content = text.Replace("$amount", buttonQuantity3.ToString()).Replace("$FIDS", newValue3);
		}
		kickButtonAgeTfm.Enable = gameNetManager.IsServer();
		RefreshTransferHeroButton();
		industryAutoTransferToggle.State = (Player.LocalPlayer.FIDSAutoTransferPlayerIDs.ContainsKey(FIDS.Industry) && Player.LocalPlayer.FIDSAutoTransferPlayerIDs[FIDS.Industry] == PlayerID);
		foodAutoTransferToggle.State = (Player.LocalPlayer.FIDSAutoTransferPlayerIDs.ContainsKey(FIDS.Food) && Player.LocalPlayer.FIDSAutoTransferPlayerIDs[FIDS.Food] == PlayerID);
		scienceAutoTransferToggle.State = (Player.LocalPlayer.FIDSAutoTransferPlayerIDs.ContainsKey(FIDS.Science) && Player.LocalPlayer.FIDSAutoTransferPlayerIDs[FIDS.Science] == PlayerID);
		PingUpdate();
	}

	private void RefreshTransferHeroButton()
	{
		if (Hero.SelectedHeroes == null)
		{
			transferHeroButtonAgeTfm.Enable = false;
			transferHeroButtonTooltip.Content = "%NoHeroSelected";
		}
		else if (SingletonManager.Get<Dungeon>().CurrentGamePhase == GamePhase.Action)
		{
			transferHeroButtonAgeTfm.Enable = false;
			transferHeroButtonTooltip.Content = "%CantTransferHeroDuringAction";
		}
		else
		{
			transferHeroButtonAgeTfm.Enable = true;
			transferHeroButtonTooltip.Content = "%HeroTransferDescription";
		}
	}

	private void OnTransferIndustry(GameObject obj)
	{
		int buttonQuantity = GetButtonQuantity(obj.GetComponent<AgeControlButton>());
		Player.LocalPlayer.SendFIDSToPlayer(buttonQuantity, FIDS.Industry, PlayerID);
	}

	private void OnTransferScience(GameObject obj)
	{
		int buttonQuantity = GetButtonQuantity(obj.GetComponent<AgeControlButton>());
		Player.LocalPlayer.SendFIDSToPlayer(buttonQuantity, FIDS.Science, PlayerID);
	}

	private void OnTransferFood(GameObject obj)
	{
		int buttonQuantity = GetButtonQuantity(obj.GetComponent<AgeControlButton>());
		Player.LocalPlayer.SendFIDSToPlayer(buttonQuantity, FIDS.Food, PlayerID);
	}

	private void OnAutoTransferIndustry(GameObject obj)
	{
		Player.LocalPlayer.ToggleFIDSAutoTransferPlayerID(FIDS.Industry, PlayerID);
	}

	private void OnAutoTransferScience(GameObject obj)
	{
		Player.LocalPlayer.ToggleFIDSAutoTransferPlayerID(FIDS.Science, PlayerID);
	}

	private void OnAutoTransferFood(GameObject obj)
	{
		Player.LocalPlayer.ToggleFIDSAutoTransferPlayerID(FIDS.Food, PlayerID);
	}

	private int GetButtonQuantity(AgeControlButton transferButton)
	{
		if (transferButton != null && int.TryParse(transferButton.OnActivateData, out int result))
		{
			return result;
		}
		return int.MaxValue;
	}

	private void OnHeroTransferButtonClick(GameObject obj)
	{
		if (Hero.SelectedHeroes == null || Hero.SelectedHeroes.Count <= 0)
		{
			return;
		}
		Hero[] array = Hero.SelectedHeroes.ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].GiveToPlayer(PlayerID);
		}
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			selectableManager.SetCategory(SelectionCategory.RoomForMove);
			if (Hero.SelectedHeroes.Count == 0 && Hero.LocalPlayerActiveRecruitedHeroes.Count > 0)
			{
				Hero.LocalPlayerActiveRecruitedHeroes[0].Select();
			}
		}
	}

	private void OnKickButtonClick(GameObject obj)
	{
		if (gameNetManager.IsServer())
		{
			RequesterPanel requesterPanel = SingletonManager.Get<RequesterPanel>();
			requesterPanel.Display(AgeLocalizer.Instance.LocalizeString("%KickPlayerFromGameConfirmationMessage").Replace("$PlayerName", playerName), delegate(RequesterPanel.Result result)
			{
				if (result == RequesterPanel.Result.Yes)
				{
					gameNetManager.KickPlayer(PlayerID, PlayerKickReason.InGame);
				}
			}, RequesterPanel.ButtonsMode.YesNo);
		}
	}

	private void PingUpdate()
	{
		float averageLagForPlayer = gameNetManager.GetAverageLagForPlayer(PlayerID);
		int num = 0;
		PingRank pingRank;
		while (true)
		{
			if (num < pingRanks.Length)
			{
				pingRank = pingRanks[num];
				if (averageLagForPlayer <= pingRank.maxLag || pingRank.maxLag < 0f)
				{
					break;
				}
				num++;
				continue;
			}
			return;
		}
		pingIcon.TintColor = pingRank.color;
	}
}
public class PlayerListPanel : VisibilityToggleGuiPanel
{
	[SerializeField]
	private Transform playerFIDSTransferLinePfb;

	[SerializeField]
	private AgeTransform playerFIDSTransferLinesTable;

	private GameNetworkManager gameNetManager;

	public override void RefreshContent()
	{
		base.RefreshContent();
		ulong localPlayerID = gameNetManager.GetLocalPlayerID();
		ulong[] lobbyPlayerIDs = gameNetManager.GetLobbyPlayerIDs();
		List<ulong> list = new List<ulong>();
		for (int i = 0; i < lobbyPlayerIDs.Length; i++)
		{
			if (lobbyPlayerIDs[i] != localPlayerID)
			{
				list.Add(lobbyPlayerIDs[i]);
			}
		}
		if (list.Count == 0)
		{
			Hide(instant: true);
		}
		UnbindPlayerFIDSTransferLines();
		playerFIDSTransferLinesTable.Height = 0f;
		playerFIDSTransferLinesTable.ReserveChildren(list.Count, playerFIDSTransferLinePfb, "PlayerFIDSTransferLine");
		playerFIDSTransferLinesTable.RefreshChildrenIList(list, RefreshPlayerLines);
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		SingletonManager.Get<InventoryPanel>().Hide();
		SingletonManager.Get<MainGameScreen>().MerchantPanel.Hide();
		Services.GetService<IGameEventService>().OnDungeonFIDSChanged += RefreshContent;
		RefreshContent();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		Services.GetService<IGameEventService>().OnDungeonFIDSChanged -= RefreshContent;
		yield return base.OnHide(instant);
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
	}

	protected override void OnUnload()
	{
		gameNetManager = null;
		base.OnUnload();
	}

	private void UnbindPlayerFIDSTransferLines()
	{
		List<PlayerLine> children = playerFIDSTransferLinesTable.GetChildren<PlayerLine>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
		}
	}

	private void RefreshPlayerLines(AgeTransform tableItem, ulong playerID, int index)
	{
		PlayerLine component = tableItem.GetComponent<PlayerLine>();
		if (component != null)
		{
			component.Bind(playerID);
			component.RefreshContent();
		}
	}
}
public class PlayerTransferLine : MonoBehaviour
{
	[Serializable]
	private struct PingRank
	{
		public float maxLag;

		public Color color;
	}

	[SerializeField]
	private AgeTransform playerHighlight;

	[SerializeField]
	private AgePrimitiveLabel playerNameLabel;

	[SerializeField]
	private Color hostNameColor;

	[SerializeField]
	private AgeControlButton[] transferIndustryButtons;

	[SerializeField]
	private AgeControlButton[] transferScienceButtons;

	[SerializeField]
	private AgeControlButton[] transferFoodButtons;

	[SerializeField]
	private AgePrimitiveImage pingIcon;

	[SerializeField]
	private PingRank[] pingRanks;

	[SerializeField]
	private AgeTransform transferableHeroesTable;

	[SerializeField]
	private Transform transferableHeroPrefab;

	private string playerName;

	private GameNetworkManager gameNetManager;

	private Hero heroToGive;

	public ulong PlayerID
	{
		get;
		private set;
	}

	public string PlayerName
	{
		get
		{
			return playerName;
		}
		private set
		{
		}
	}

	public AgeTransform PlayerHighlight
	{
		get
		{
			return playerHighlight;
		}
		private set
		{
		}
	}

	public void Bind(ulong playerID, int lineNumber)
	{
		heroToGive = null;
		for (int i = 0; i < transferableHeroesTable.GetChildren().Count; i++)
		{
			TransferableHero component = transferableHeroesTable.GetChildren()[i].GetComponent<TransferableHero>();
			component.Unbind();
		}
		if (gameNetManager == null)
		{
			gameNetManager = SingletonManager.Get<GameNetworkManager>();
		}
		PlayerID = playerID;
		playerName = gameNetManager.GetPlayerName(playerID);
		TransferResourceSelectable[] componentsInChildren = GetComponentsInChildren<TransferResourceSelectable>();
		for (int j = 0; j < componentsInChildren.Length; j++)
		{
			componentsInChildren[j].LineNumber = lineNumber;
		}
		Services.GetService<IGameEventService>().OnHeroListChanged += RefreshContent;
	}

	public void Unbind()
	{
		Services.GetService<IGameEventService>().OnHeroListChanged -= RefreshContent;
		playerName = string.Empty;
		PlayerID = 0uL;
	}

	public void RefreshContent()
	{
		playerNameLabel.Text = playerName;
		if (gameNetManager.GetServerPlayerID() == PlayerID)
		{
			playerNameLabel.TintColor = hostNameColor;
		}
		for (int i = 0; i < transferIndustryButtons.Length; i++)
		{
			AgeControlButton ageControlButton = transferIndustryButtons[i];
			int buttonQuantity = GetButtonQuantity(ageControlButton);
			ageControlButton.AgeTransform.Enable = (Mathf.Floor(Player.LocalPlayer.IndustryStock) >= (float)buttonQuantity);
		}
		for (int j = 0; j < transferScienceButtons.Length; j++)
		{
			AgeControlButton ageControlButton2 = transferScienceButtons[j];
			int buttonQuantity2 = GetButtonQuantity(ageControlButton2);
			ageControlButton2.AgeTransform.Enable = (Mathf.Floor(Player.LocalPlayer.ScienceStock) >= (float)buttonQuantity2);
		}
		for (int k = 0; k < transferFoodButtons.Length; k++)
		{
			AgeControlButton ageControlButton3 = transferFoodButtons[k];
			int buttonQuantity3 = GetButtonQuantity(ageControlButton3);
			ageControlButton3.AgeTransform.Enable = (Mathf.Floor(Player.LocalPlayer.FoodStock) >= (float)buttonQuantity3);
		}
		transferableHeroesTable.Width = 0f;
		transferableHeroesTable.ReserveChildren(Hero.LocalPlayerActiveRecruitedHeroes.Count, transferableHeroPrefab, "PlayerFIDSTransferLine");
		transferableHeroesTable.RefreshChildrenIList(Hero.LocalPlayerActiveRecruitedHeroes, RefreshTransferableHero);
		transferableHeroesTable.ArrangeChildren();
		transferableHeroesTable.PixelOffsetLeft = -0.5f * transferableHeroesTable.Width;
		PingUpdate();
	}

	private void OnTransferIndustry(GameObject obj)
	{
		int buttonQuantity = GetButtonQuantity(obj.GetComponent<AgeControlButton>());
		Player.LocalPlayer.SendFIDSToPlayer(buttonQuantity, FIDS.Industry, PlayerID);
	}

	private void OnTransferScience(GameObject obj)
	{
		int buttonQuantity = GetButtonQuantity(obj.GetComponent<AgeControlButton>());
		Player.LocalPlayer.SendFIDSToPlayer(buttonQuantity, FIDS.Science, PlayerID);
	}

	private void OnTransferFood(GameObject obj)
	{
		int buttonQuantity = GetButtonQuantity(obj.GetComponent<AgeControlButton>());
		Player.LocalPlayer.SendFIDSToPlayer(buttonQuantity, FIDS.Food, PlayerID);
	}

	private void OnTransferHero(GameObject obj)
	{
		AgeControlButton component = obj.GetComponent<AgeControlButton>();
		heroToGive = (component.OnActivateDataObject as Hero);
		string message = string.Format(AgeLocalizer.Instance.LocalizeString("%GiveHeroConfirm"), heroToGive.LocalizedName, playerName);
		SingletonManager.Get<RequesterPanel>().Display(message, OnGiveHeroConfirmResult, RequesterPanel.ButtonsMode.YesNo);
	}

	private int GetButtonQuantity(AgeControlButton transferButton)
	{
		if (transferButton != null && int.TryParse(transferButton.OnActivateData, out int result))
		{
			return result;
		}
		return int.MaxValue;
	}

	private void OnGiveHeroConfirmResult(RequesterPanel.Result result)
	{
		if (result == RequesterPanel.Result.Yes)
		{
			heroToGive.GiveToPlayer(PlayerID);
			heroToGive = null;
		}
		if (Hero.SelectedHeroes.Count == 0 && Hero.LocalPlayerActiveRecruitedHeroes.Count > 0)
		{
			Hero.LocalPlayerActiveRecruitedHeroes[0].Select();
		}
	}

	private void PingUpdate()
	{
		float averageLagForPlayer = gameNetManager.GetAverageLagForPlayer(PlayerID);
		int num = 0;
		PingRank pingRank;
		while (true)
		{
			if (num < pingRanks.Length)
			{
				pingRank = pingRanks[num];
				if (averageLagForPlayer <= pingRank.maxLag || pingRank.maxLag < 0f)
				{
					break;
				}
				num++;
				continue;
			}
			return;
		}
		pingIcon.TintColor = pingRank.color;
	}

	private void RefreshTransferableHero(AgeTransform tableItem, Hero hero, int index)
	{
		TransferableHero component = tableItem.GetComponent<TransferableHero>();
		component.Bind(hero, base.gameObject);
		component.RefreshContent();
	}
}
public class PopupMenuPanel : AutoCloseGuiPanel, IPopupMenuPanel
{
	private static List<IPopupMenuPanel> registeredPopupMenuPanels = new List<IPopupMenuPanel>();

	public static IPopupMenuPanel GetTopPopupMenuPanel()
	{
		if (registeredPopupMenuPanels.Count > 0)
		{
			return registeredPopupMenuPanels[registeredPopupMenuPanels.Count - 1];
		}
		return null;
	}

	public static void RegisterPopupMenuPanel(IPopupMenuPanel popupMenuPanel)
	{
		registeredPopupMenuPanels.Add(popupMenuPanel);
	}

	public static void UnregisterPopupMenuPanel(IPopupMenuPanel popupMenuPanel)
	{
		registeredPopupMenuPanels.Remove(popupMenuPanel);
	}

	public static void CloseTopPopupMenuPanelForEscapeBehavior()
	{
		GetTopPopupMenuPanel()?.OnEscapeBehavior();
	}

	public virtual void OnEscapeBehavior()
	{
		Hide();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		RegisterPopupMenuPanel(this);
	}

	protected override IEnumerator OnHide(bool instant)
	{
		yield return base.OnHide(instant);
		UnregisterPopupMenuPanel(this);
	}
}
public class PopupMenuPanelRoom : PopupMenuPanel
{
	protected SelectableManager selectableManager;

	protected override IEnumerator OnShow(params object[] parameters)
	{
		if (selectableManager == null)
		{
			selectableManager = SingletonManager.Get<SelectableManager>();
		}
		Room room = GetRoom();
		if (room != null)
		{
			selectableManager.Select(room.SelectableForMove);
		}
		SingletonManager.Get<StelePanel>().HideWhenFinishedShowing();
		yield return base.OnShow(parameters);
	}

	protected virtual Room GetRoom()
	{
		return null;
	}
}
public class RequesterPanel : GuiModalPanel, IPopupMenuPanel
{
	public enum ButtonsMode
	{
		OK,
		YesNo
	}

	public enum Result
	{
		OK,
		Yes,
		No
	}

	public delegate void ResultEventHandler(Result result);

	[SerializeField]
	private AgePrimitiveLabel titleLabel;

	[SerializeField]
	private AgePrimitiveLabel messageLabel;

	[SerializeField]
	private AgeTransform okButton;

	[SerializeField]
	private AgeTransform yesButton;

	[SerializeField]
	private AgeTransform noButton;

	private ResultEventHandler onResult;

	private ButtonsMode buttonsMode;

	private string message;

	private float remainingDuration;

	private bool hideOnCB;

	private Album album;

	private IInputService inputManager;

	public override void Hide(bool instant = false)
	{
		base.Hide(instant);
	}

	public void Display(string message, ResultEventHandler handler = null, ButtonsMode buttonsMode = ButtonsMode.OK, string title = "%RequesterPanelTitle", float duration = -1f, bool hideOnCB = true)
	{
		Diagnostics.Log("RequesterPanel message: {0}", message);
		titleLabel.Text = title;
		this.message = message;
		messageLabel.Text = message;
		onResult = handler;
		this.buttonsMode = buttonsMode;
		this.hideOnCB = hideOnCB;
		if (album == null)
		{
			album = SingletonManager.Get<Album>();
		}
		if (duration > 0f)
		{
			remainingDuration = duration;
			UpdateRemainingDurationDisplay();
		}
		switch (buttonsMode)
		{
		case ButtonsMode.OK:
			okButton.Visible = true;
			yesButton.Visible = false;
			noButton.Visible = false;
			break;
		case ButtonsMode.YesNo:
			okButton.Visible = false;
			yesButton.Visible = true;
			noButton.Visible = true;
			break;
		}
		if (album != null && album.IsDisplayed)
		{
			album.Focus(display: false);
		}
		Show();
	}

	public virtual void OnEscapeBehavior()
	{
		switch (buttonsMode)
		{
		case ButtonsMode.OK:
			OnOkButtonClicked();
			break;
		case ButtonsMode.YesNo:
			OnNoButtonClicked();
			break;
		}
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		inputManager = Services.GetService<IInputService>();
		if (inputManager.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			Services.GetService<IGameEventService>().OnHeroSelectionChanged += OnHeroSelectionChanged;
		}
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		PopupMenuPanel.RegisterPopupMenuPanel(this);
	}

	protected override IEnumerator OnHide(bool instant)
	{
		yield return base.OnHide(instant);
		PopupMenuPanel.UnregisterPopupMenuPanel(this);
		remainingDuration = -1f;
	}

	protected override void Awake()
	{
		base.Awake();
		SingletonManager.RegisterInstance(this);
	}

	private void OnOkButtonClicked()
	{
		if (hideOnCB)
		{
			Hide();
		}
		if (onResult != null)
		{
			onResult(Result.OK);
		}
	}

	private void OnYesButtonClicked()
	{
		if (hideOnCB)
		{
			Hide();
		}
		if (onResult != null)
		{
			onResult(Result.Yes);
		}
	}

	private void OnNoButtonClicked()
	{
		if (hideOnCB)
		{
			Hide();
		}
		if (onResult != null)
		{
			onResult(Result.No);
		}
	}

	private void OnHeroSelectionChanged()
	{
		Hide();
	}

	private void UpdateRemainingDurationDisplay()
	{
		if (remainingDuration > 0f)
		{
			messageLabel.Text = AgeLocalizer.Instance.LocalizeString(message).Replace("$TimeLeft", Mathf.CeilToInt(remainingDuration).ToString());
		}
	}

	private void Update()
	{
		if (!base.IsVisible)
		{
			return;
		}
		if (inputManager.GetControlDown(Control.ConfirmSelectable))
		{
			switch (buttonsMode)
			{
			case ButtonsMode.OK:
				OnOkButtonClicked();
				break;
			case ButtonsMode.YesNo:
				OnYesButtonClicked();
				break;
			}
		}
		if (remainingDuration > 0f)
		{
			remainingDuration -= DungeonsApplication.GetRealtimeDelta();
			UpdateRemainingDurationDisplay();
			if (remainingDuration <= 0f)
			{
				OnNoButtonClicked();
			}
		}
	}
}
public class BPItem : MonoBehaviour
{
	protected BluePrintConfig bpConfig;

	[SerializeField]
	private AgePrimitiveImage categoryImg;

	[SerializeField]
	private AgePrimitiveImage moduleImg;

	[SerializeField]
	private AgePrimitiveLabel moduleNameLabel;

	[SerializeField]
	private AgePrimitiveLabel levelLabel;

	[SerializeField]
	private AgeTooltip[] tooltips;

	public void Bind(BluePrintConfig bpConfig)
	{
		this.bpConfig = bpConfig;
	}

	public virtual void Unbind()
	{
		AgeTooltip[] array = tooltips;
		foreach (AgeTooltip ageTooltip in array)
		{
			ageTooltip.Content = string.Empty;
			ageTooltip.ClientData = null;
		}
		bpConfig = null;
	}

	public virtual void RefreshContent()
	{
		IGuiPanelHelper guiPanelHelper = Services.GetService<IGuiService>().GuiPanelHelper;
		Texture2D texture;
		if (guiPanelHelper.TryGetGuiElement(bpConfig.ModuleCategory.ToString(), out GuiElement guiElement))
		{
			if (guiPanelHelper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Small, out texture))
			{
				categoryImg.Image = texture;
			}
			else
			{
				Diagnostics.LogError("Unable to find small icon for \"" + bpConfig.ModuleCategory + "\"");
			}
		}
		else
		{
			Diagnostics.LogError("Unable to find GUI element for \"" + bpConfig.ModuleCategory + "\"");
		}
		if (guiPanelHelper.TryGetGuiElement(bpConfig.Name, out guiElement))
		{
			moduleNameLabel.Text = guiElement.Title;
			if (guiPanelHelper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Small, out texture))
			{
				moduleImg.Image = texture;
			}
			else
			{
				Diagnostics.LogError("Unable to find small icon for \"" + bpConfig.Name + "\"");
			}
		}
		else
		{
			Diagnostics.LogError("Unable to find GUI element for \"" + bpConfig.Name + "\"");
		}
		if (bpConfig.ModuleLevel == 1)
		{
			levelLabel.Text = AgeLocalizer.Instance.LocalizeString("%BluePrintLevelNew");
		}
		else
		{
			BluePrintConfig moduleUnlockedBluePrint = SingletonManager.Get<Dungeon>().GetModuleUnlockedBluePrint(bpConfig.ModuleCategory, bpConfig.ModuleName);
			levelLabel.Text = AgeLocalizer.Instance.LocalizeString("%BluePrintLevelUp").Replace("$level1", moduleUnlockedBluePrint.ModuleLevel.ToString()).Replace("$level2", bpConfig.ModuleLevel.ToString());
		}
		AgeTooltip[] array = tooltips;
		foreach (AgeTooltip ageTooltip in array)
		{
			ageTooltip.Content = bpConfig.Name;
			ageTooltip.ClientData = bpConfig;
		}
	}
}
public class ResearchPanel : PopupMenuPanelRoom
{
	[SerializeField]
	private AgeTransform researchableBPTable;

	[SerializeField]
	private Transform researchableBPPfb;

	[SerializeField]
	private AgePrimitiveLabel turnCountLabel;

	[SerializeField]
	private AgePrimitiveLabel resetCostLabel;

	[SerializeField]
	private AgeTransform resetButton;

	[SerializeField]
	private AgeTransform tooltipDock;

	private Artifact artifact;

	private Dungeon dungeon;

	private GameConfig gameconfig;

	private IInputService inputService;

	private bool doUpdate;

	protected override void Awake()
	{
		base.Awake();
		inputService = Services.GetService<IInputService>();
	}

	protected override Room GetRoom()
	{
		return artifact.RoomElement.ParentRoom;
	}

	public void Bind(Artifact artifact)
	{
		this.artifact = artifact;
	}

	public void Unbind()
	{
		UnbindResearchableBPItems();
		artifact = null;
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		if (dungeon == null)
		{
			dungeon = SingletonManager.Get<Dungeon>();
		}
		if (gameconfig == null)
		{
			gameconfig = GameConfig.GetGameConfig();
		}
		UnbindResearchableBPItems();
		BluePrintConfig[] researchableBPs = SingletonManager.Get<Dungeon>().GetResearchableBPs();
		researchableBPTable.ReserveChildren(researchableBPs.Length, researchableBPPfb, "ResearchableBPItem");
		researchableBPTable.RefreshChildrenArray(researchableBPs, RefreshResearchableBPItem);
		float value = gameconfig.ResetResearchesCost.GetValue(artifact.RoomElement.ParentRoom);
		string key = (!(Player.LocalPlayer.ScienceStock < value)) ? "%ResearchCostOKFormat" : "%ResearchCostKOFormat";
		resetCostLabel.Text = AgeLocalizer.Instance.LocalizeString(key).Replace("$Value", value.ToString());
		resetButton.Visible = (researchableBPs != null && researchableBPs.Length > 0);
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		gameEventManager.OnDungeonFIDSChanged += OnDungeonFIDSChanged;
		artifact.HealthCpnt.OnDeath += OnArtifactDeath;
		IGameControlService gameControlManager = Services.GetService<IGameControlService>();
		Diagnostics.Assert(gameControlManager != null);
		gameControlManager.SetHeroStatsPanelDisplay(on: false, displayInventory: false);
		StartCoroutine(UpdateLoop());
	}

	protected override IEnumerator OnHide(bool instant)
	{
		yield return base.OnHide(instant);
		doUpdate = false;
		gameEventManager.OnDungeonFIDSChanged -= OnDungeonFIDSChanged;
		artifact.HealthCpnt.OnDeath -= OnArtifactDeath;
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			if (selectableManager == null)
			{
				selectableManager = SingletonManager.Get<SelectableManager>();
			}
			selectableManager.UnsetCategory(SelectionCategory.TopPanel);
		}
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		turnCountLabel.Text = AgeLocalizer.Instance.LocalizeString(turnCountLabel.Text).Replace("$TurnCount", GameConfig.GetGameConfig().BluePrintResearchTurnCount.ToString());
	}

	private void UnbindResearchableBPItems()
	{
		List<ResearchableBPItem> children = researchableBPTable.GetChildren<ResearchableBPItem>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
		}
	}

	private void RefreshResearchableBPItem(AgeTransform tableItem, BluePrintConfig bpConfig, int index)
	{
		ResearchableBPItem component = tableItem.GetComponent<ResearchableBPItem>();
		component.Bind(artifact, bpConfig, this, tooltipDock);
		component.RefreshContent();
	}

	private void OnCloseButtonClick()
	{
		Hide();
	}

	private void OnArtifactDeath(ulong attackerOwnerPlayerID = 0)
	{
		Hide();
	}

	private void OnDungeonFIDSChanged()
	{
		RefreshContent();
	}

	private void OnResetButtonClick()
	{
		float value = gameconfig.ResetResearchesCost.GetValue(artifact.RoomElement.ParentRoom);
		if (Player.LocalPlayer.ConsumeScience(value))
		{
			dungeon.ResetResearches();
			resetButton.StartAllModifiers();
		}
		else
		{
			dungeon.EnqueueErrorNotification(AgeLocalizer.Instance.LocalizeString("%Error_ResetResearchesFailResources"));
		}
	}

	private IEnumerator UpdateLoop()
	{
		doUpdate = true;
		while (doUpdate)
		{
			if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController && inputService.GetControlDown(Control.ResetResearches))
			{
				OnResetButtonClick();
			}
			yield return null;
		}
	}
}
public class ResearchableBPItem : BPItem
{
	[SerializeField]
	private AgePrimitiveLabel researchScienceCostLabel;

	[SerializeField]
	private AgeTransform activateButton;

	private Artifact artifact;

	private ResearchPanel researchPanel;

	public void Bind(Artifact artifact, BluePrintConfig bpConfig, ResearchPanel researchPanel, AgeTransform tooltipDock)
	{
		Bind(bpConfig);
		this.artifact = artifact;
		this.researchPanel = researchPanel;
		if (activateButton != null)
		{
			AgeTooltip ageTooltip = activateButton.AgeTooltip;
			if (ageTooltip != null)
			{
				ageTooltip.Anchor = tooltipDock;
			}
		}
	}

	public override void Unbind()
	{
		artifact = null;
		researchPanel = null;
		base.Unbind();
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		if (Player.LocalPlayer.ScienceStock >= bpConfig.ResearchScienceCost)
		{
			researchScienceCostLabel.Text = AgeLocalizer.Instance.LocalizeString("%ResearchCostOKFormat").Replace("$Value", bpConfig.ResearchScienceCost.ToString());
		}
		else
		{
			researchScienceCostLabel.Text = AgeLocalizer.Instance.LocalizeString("%ResearchCostKOFormat").Replace("$Value", bpConfig.ResearchScienceCost.ToString());
		}
	}

	private void OnResearchButtonClick()
	{
		IAudioEventService service = Services.GetService<IAudioEventService>();
		if (artifact.ResearchBluePrintByPlayer(bpConfig))
		{
			service.Play2DEvent("Master/GUI/ResearchButton");
			researchPanel.Hide();
			GoogleAnalyticsManager googleAnalyticsManager = SingletonManager.Get<GoogleAnalyticsManager>();
			if (googleAnalyticsManager != null)
			{
				googleAnalyticsManager.SendResearchedBPAnalytics(bpConfig);
			}
		}
		else
		{
			service.Play2DEvent("Master/GUI/ErrorActionMenu");
		}
	}
}
public class ResearchedBPItem : BPItem
{
	[SerializeField]
	private AgePrimitiveLabel turnsLeftLabel;

	private Artifact artifact;

	public void Bind(Artifact artifact)
	{
		Bind(artifact.ResearchedBP);
		this.artifact = artifact;
	}

	public override void Unbind()
	{
		artifact = null;
		base.Unbind();
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		turnsLeftLabel.Text = AgeLocalizer.Instance.LocalizeString("%ResearchTurnLeftValueFormat").Replace("$Value", (artifact.ResearchStartTurn + GameConfig.GetGameConfig().BluePrintResearchTurnCount - SingletonManager.Get<Dungeon>().Turn).ToString());
	}
}
public class ResearchingPanel : PopupMenuPanel
{
	[SerializeField]
	private ResearchedBPItem researchedBPItem;

	private Artifact artifact;

	public void Bind(Artifact artifact)
	{
		this.artifact = artifact;
		researchedBPItem.Bind(this.artifact);
	}

	public void Unbind()
	{
		researchedBPItem.Unbind();
		artifact = null;
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		researchedBPItem.RefreshContent();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		gameEventManager.OnDungeonTurnChanged += OnDungeonTurnChanged;
		artifact.HealthCpnt.OnDeath += OnArtifactDeath;
	}

	protected override IEnumerator OnHide(bool instant)
	{
		yield return base.OnHide(instant);
		gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChanged;
		artifact.HealthCpnt.OnDeath -= OnArtifactDeath;
	}

	private void OnDungeonTurnChanged()
	{
		RefreshContent();
	}

	private void OnCloseButtonClick()
	{
		Hide();
	}

	private void OnArtifactDeath(ulong attackerOwnerPlayerID = 0)
	{
		Hide();
	}
}
public class RoomEnergyItem : MonoBehaviour
{
	[SerializeField]
	private AgeTransform unpoweredImage;

	[SerializeField]
	private AgeTransform poweredImage;

	public void SetState(bool on)
	{
		poweredImage.Alpha = (on ? 1 : 0);
		unpoweredImage.Alpha = ((!on) ? 1 : 0);
	}
}
public class SessionListPanel : PopupMenuPanel
{
	private enum SortingMethod
	{
		None,
		NameAscending,
		NameDescending,
		SlotsAscending,
		SlotsDescending
	}

	[SerializeField]
	private Transform gameSessionLinePrefab;

	[SerializeField]
	private AgeTransform gameSessionsTable;

	[SerializeField]
	private AgeControlScrollView gameSessionsScrollView;

	[SerializeField]
	private AgeControlButton refreshButton;

	[SerializeField]
	private AgeControlToggle sortByNameToggle;

	[SerializeField]
	private AgeControlToggle sortBySlotsToggle;

	[SerializeField]
	private AgePrimitiveLabel refreshingLabel;

	[SerializeField]
	private AgeControlDropList filterDropList;

	[SerializeField]
	private AGEScrollableTableHelper scrollableTableHelper;

	private LobbyDescription selectedLobby;

	private SortingMethod sortingMethod;

	private ISteamClientService steamClientService;

	private IMatchMakingService matchMakingService;

	private IInputService inputService;

	private SelectableManager selectableManager;

	private AgeTransform.RefreshTableItem<LobbyDescription> refreshGameSessionLineDelegate;

	private Steamworks.SteamMatchMaking.ELobbyDistanceFilter distanceFilter = Steamworks.SteamMatchMaking.ELobbyDistanceFilter.k_ELobbyDistanceFilterDefault;

	private bool doUpdate;

	private bool isRefreshingLobbyList;

	private List<LobbyDescription> LobbyDescriptions
	{
		get;
		set;
	}

	private LobbyDescription SelectedLobbyDesc
	{
		get
		{
			return selectedLobby;
		}
		set
		{
			selectedLobby = value;
		}
	}

	[Service]
	private ISessionService SessionService
	{
		get;
		set;
	}

	public void OnClickLineCB(GameSessionLine gameSessionLine)
	{
		SelectedLobbyDesc = gameSessionLine.LobbyDescription;
		if (SelectedLobbyDesc != null)
		{
			IGameControlService service = Services.GetService<IGameControlService>();
			service.JoinMultiplayerGame(SelectedLobbyDesc.LobbyID);
			Hide();
		}
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		UnbindGameSessionLines();
		gameSessionsTable.Height = 0f;
		gameSessionsTable.ReserveChildren(LobbyDescriptions.Count, gameSessionLinePrefab);
		gameSessionsTable.RefreshChildrenIList(LobbyDescriptions, refreshGameSessionLineDelegate);
		gameSessionsTable.ArrangeChildren();
		gameSessionsScrollView.OnPositionRecomputed();
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		matchMakingService = Services.GetService<IMatchMakingService>();
		inputService = Services.GetService<IInputService>();
		selectableManager = SingletonManager.Get<SelectableManager>();
		steamClientService = Services.GetService<ISteamClientService>();
		refreshGameSessionLineDelegate = RefreshGameSessionLine;
		LobbyDescriptions = new List<LobbyDescription>();
	}

	protected override void OnUnload()
	{
		refreshGameSessionLineDelegate = null;
		base.OnUnload();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		StartCoroutine(UpdateLoop());
		LobbyDescriptions.Clear();
		RefreshContent();
		Steamworks.SteamMatchMaking.ELobbyDistanceFilter[] filters = GenericUtilities.GetEnumValues<Steamworks.SteamMatchMaking.ELobbyDistanceFilter>();
		if (filterDropList.ItemTable == null || filterDropList.ItemTable.Length == 0)
		{
			string[] filterNames = new string[filters.Length];
			string[] filterTooltips = new string[filters.Length];
			for (int j = 0; j < filters.Length; j++)
			{
				filterNames[j] = AgeLocalizer.Instance.LocalizeString("%LobbyListFilterName_" + filters[j].ToString());
				filterTooltips[j] = AgeLocalizer.Instance.LocalizeString("%LobbyListFilterTooltip_" + filters[j].ToString());
			}
			filterDropList.ItemTable = filterNames;
			filterDropList.TooltipTable = filterTooltips;
		}
		for (int i = 0; i < filters.Length; i++)
		{
			if (distanceFilter == filters[i])
			{
				filterDropList.SelectedItem = i;
				break;
			}
		}
		RequestLobbyList();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		doUpdate = false;
		UnbindGameSessionLines();
		yield return base.OnHide(instant);
	}

	private void OnCancelButtonClick(GameObject gameObject)
	{
		Hide();
	}

	private void OnRefreshButtonClick(GameObject gameObject)
	{
		RequestLobbyList();
	}

	private void OnSelectFilter(GameObject obj)
	{
		distanceFilter = filterDropList.SelectedItem.ToEnum<Steamworks.SteamMatchMaking.ELobbyDistanceFilter>();
		RequestLobbyList();
	}

	private void UnbindGameSessionLines()
	{
		List<GameSessionLine> children = gameSessionsTable.GetChildren<GameSessionLine>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
			if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController && scrollableTableHelper != null)
			{
				children[i].RowSelectable.OnSelectEvent -= scrollableTableHelper.OnChildSelected;
			}
		}
	}

	private void RefreshGameSessionLine(AgeTransform tableItem, LobbyDescription lobbyDescription, int index)
	{
		GameSessionLine component = tableItem.GetComponent<GameSessionLine>();
		if (component == null)
		{
			Diagnostics.LogError("In the MenuJoinGameScreen, trying to refresh a table item that is not a GameSessionLine");
			return;
		}
		component.Bind(lobbyDescription, this);
		component.RefreshContent();
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController && scrollableTableHelper != null)
		{
			component.RowSelectable.Row = index;
			component.RowSelectable.OnSelectEvent -= scrollableTableHelper.OnChildSelected;
			component.RowSelectable.OnSelectEvent += scrollableTableHelper.OnChildSelected;
		}
	}

	private void RequestLobbyList()
	{
		if (isRefreshingLobbyList)
		{
			Diagnostics.LogWarning("Already refreshing lobby list!");
		}
		else if (matchMakingService == null)
		{
			Diagnostics.LogWarning("Steam matchmaking is null; make sure your Steam client is running...");
		}
		else if (matchMakingService.RequestLobbyList(distanceFilter))
		{
			isRefreshingLobbyList = true;
			matchMakingService.MatchMakingRequestLobbyList += MatchMaking_CallbackRequestLobbyList;
			refreshButton.AgeTransform.Enable = false;
			refreshingLabel.AgeTransform.Visible = true;
			gameSessionsTable.Visible = false;
			steamClientService.ClientSteamServerConnectFailure += ISteamClientService_ClientSteamServerConnectFailure;
		}
		else
		{
			Diagnostics.LogWarning("Failed to request the list of lobbies.");
		}
	}

	private void ISteamClientService_ClientSteamServerConnectFailure(object sender, SteamServerConnectFailureEventArgs e)
	{
		matchMakingService.MatchMakingRequestLobbyList -= MatchMaking_CallbackRequestLobbyList;
		steamClientService.ClientSteamServerConnectFailure -= ISteamClientService_ClientSteamServerConnectFailure;
		UpdateLobbyList(0);
		SingletonManager.Get<RequesterPanel>().Display("%SessionSteamServerConnectFailure");
	}

	private void MatchMaking_CallbackRequestLobbyList(object sender, MatchMakingRequestLobbyListEventArgs e)
	{
		isRefreshingLobbyList = false;
		matchMakingService.MatchMakingRequestLobbyList -= MatchMaking_CallbackRequestLobbyList;
		steamClientService.ClientSteamServerConnectFailure -= ISteamClientService_ClientSteamServerConnectFailure;
		UpdateLobbyList(e.LobbyCount);
	}

	private void UpdateLobbyList(int lobbyCount)
	{
		Diagnostics.Log("Request Lobby List : " + lobbyCount + " result(s).");
		refreshButton.AgeTransform.Enable = true;
		refreshingLabel.AgeTransform.Visible = false;
		gameSessionsTable.Visible = true;
		LobbyDescriptions.Clear();
		for (int i = 0; i < lobbyCount; i++)
		{
			LobbyDescription lobbyDesc = GetLobbyDesc(i);
			if (lobbyDesc != null && lobbyDesc.IsJoinable())
			{
				LobbyDescriptions.Add(lobbyDesc);
			}
		}
		ApplySortingMethod();
	}

	private IEnumerator UpdateLoop()
	{
		doUpdate = true;
		while (doUpdate)
		{
			SelectionCategoryData currentCategory = selectableManager.CurrentCategory;
			if (currentCategory.Category == SelectionCategory.SessionListPanel)
			{
				if (inputService.GetControlDown(Control.RefreshSession))
				{
					refreshButton.AgeTransform.StartAllModifiers();
					OnRefreshButtonClick(base.gameObject);
				}
				else if (inputService.GetControlDown(Control.LoadGameSession))
				{
					SingletonManager.Get<MainMenuPanel>().SendMessage("OnLoadMPSaveButtonClick", base.gameObject);
				}
				else if (inputService.GetControlDown(Control.CreateSession))
				{
					SingletonManager.Get<MainMenuPanel>().SendMessage("OnMultiplayerCreateButtonClick", base.gameObject);
				}
			}
			yield return null;
		}
	}

	private LobbyDescription GetLobbyDesc(int index)
	{
		LobbyDescription lobbyDescription = null;
		ulong lobbyIDByIndex = matchMakingService.GetLobbyIDByIndex(index);
		return new LobbyDescription(matchMakingService, lobbyIDByIndex);
	}

	private void OnSortByNameButtonClick(GameObject gameObject)
	{
		if (sortingMethod == SortingMethod.NameAscending)
		{
			sortingMethod = SortingMethod.NameDescending;
		}
		else
		{
			sortingMethod = SortingMethod.NameAscending;
		}
		ApplySortingMethod();
	}

	private void OnSortBySlotsButtonClick(GameObject gameObject)
	{
		if (sortingMethod == SortingMethod.SlotsAscending)
		{
			sortingMethod = SortingMethod.SlotsDescending;
		}
		else
		{
			sortingMethod = SortingMethod.SlotsAscending;
		}
		ApplySortingMethod();
	}

	private void ApplySortingMethod()
	{
		switch (sortingMethod)
		{
		case SortingMethod.NameAscending:
			LobbyDescriptions = LobbyDescriptions.OrderBy((LobbyDescription l) => l.Name).ToList();
			sortByNameToggle.State = true;
			sortBySlotsToggle.State = false;
			break;
		case SortingMethod.NameDescending:
			LobbyDescriptions = LobbyDescriptions.OrderByDescending((LobbyDescription l) => l.Name).ToList();
			sortByNameToggle.State = true;
			sortBySlotsToggle.State = false;
			break;
		case SortingMethod.SlotsAscending:
			LobbyDescriptions = LobbyDescriptions.OrderBy((LobbyDescription l) => l.NumberOfLobbyMembers).ToList();
			sortByNameToggle.State = false;
			sortBySlotsToggle.State = true;
			break;
		case SortingMethod.SlotsDescending:
			LobbyDescriptions = LobbyDescriptions.OrderByDescending((LobbyDescription l) => l.NumberOfLobbyMembers).ToList();
			sortByNameToggle.State = false;
			sortBySlotsToggle.State = true;
			break;
		}
		RefreshContent();
	}

	private void OnOverlayClick()
	{
	}
}
public class ShipSelectionCamera : MonoBehaviour
{
	[SerializeField]
	private float zoom;

	[SerializeField]
	private SpriteAnimationRuntime2[] shipAnimations;

	private IGameResolutionService gameResolutionManager;

	private Dictionary<StaticString, SpriteAnimationRuntime2> shipAnimationsByName;

	public Camera Camera
	{
		get;
		private set;
	}

	public SpriteAnimationRuntime2[] ShipAnimations => shipAnimations;

	public SpriteAnimationRuntime2 GetShipAnimation(StaticString shipName)
	{
		if (shipAnimationsByName == null)
		{
			shipAnimationsByName = new Dictionary<StaticString, SpriteAnimationRuntime2>();
			for (int i = 0; i < shipAnimations.Length; i++)
			{
				SpriteAnimationRuntime2 spriteAnimationRuntime = shipAnimations[i];
				shipAnimationsByName.Add(spriteAnimationRuntime.gameObject.name, spriteAnimationRuntime);
			}
		}
		if (shipAnimationsByName.TryGetValue(shipName, out SpriteAnimationRuntime2 value))
		{
			return value;
		}
		Diagnostics.LogError("No \"{0}\" ship animation found!", shipName);
		return null;
	}

	private void Awake()
	{
		Camera = GetComponent<Camera>();
	}

	private IEnumerator Start()
	{
		for (gameResolutionManager = Services.GetService<IGameResolutionService>(); gameResolutionManager == null; gameResolutionManager = Services.GetService<IGameResolutionService>())
		{
			yield return null;
		}
		ApplyCurrentGameResolution();
		gameResolutionManager.OnGameResolutionChanged += OnGameResolutionChanged;
	}

	private void OnGameResolutionChanged()
	{
		ApplyCurrentGameResolution();
	}

	private void ApplyCurrentGameResolution()
	{
		GameResolution currentGameResolution = gameResolutionManager.CurrentGameResolution;
		Camera.orthographicSize = (float)currentGameResolution.ScreenResolution.Height / 2f / zoom;
	}
}
public class ShortcutsPanel : PopupMenuPanel
{
	[SerializeField]
	private DynamicTextureLoader[] backgroundsAutoLoaders;

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		base.AgeTransform.StartAllModifiers(forward: true, recursive: true);
		AgeTransform gameMenuPanelAgeTfm = SingletonManager.Get<GameMenuPanel>().GetComponent<AgeTransform>();
		if (gameMenuPanelAgeTfm.Visible)
		{
			gameMenuPanelAgeTfm.Enable = false;
		}
	}

	protected override IEnumerator OnHide(bool instant)
	{
		yield return base.OnHide(instant);
		base.AgeTransform.ResetAllModifiers(toStart: true, recursive: true);
		AgeTransform gameMenuPanelAgeTfm = SingletonManager.Get<GameMenuPanel>().GetComponent<AgeTransform>();
		if (gameMenuPanelAgeTfm.Visible)
		{
			gameMenuPanelAgeTfm.Enable = true;
		}
	}

	public void Hide()
	{
		Hide(instant: false);
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		for (int i = 0; i < backgroundsAutoLoaders.Length; i++)
		{
			backgroundsAutoLoaders[i].Load();
		}
	}
}
public class SituationDialogPanel : AutoCloseGuiPanel
{
	[SerializeField]
	private AgePrimitiveLabel textLabel;

	public void Display(string text, Transform tfm, float duration = -1f)
	{
		textLabel.Text = text;
		if (base.IsVisible)
		{
			StopCoroutine("HideDialog");
			Hide(instant: true);
		}
		GetComponent<GameToScreenPositionSync>().GameEntityTfm = tfm;
		Show();
		GetComponent<GameToScreenPositionSync>().UpdatePosition();
		if (duration >= 0f)
		{
			StartCoroutine("HideDialog", duration);
		}
	}

	private IEnumerator HideDialog(float duration)
	{
		float closingTime = Time.time + duration;
		while (closingTime > Time.time)
		{
			yield return null;
		}
		GetComponent<GameToScreenPositionSync>().GameEntityTfm = null;
		Hide();
	}
}
public class SkillItem : MonoBehaviour
{
	protected Hero hero;

	protected Skill skill;

	[SerializeField]
	private AgePrimitiveImage icon;

	[SerializeField]
	private GuiSkillLevelLabel levelLabel;

	private AgeTooltip tooltip;

	public void Bind(Hero hero, Skill skill)
	{
		this.hero = hero;
		this.skill = skill;
	}

	public virtual void Unbind()
	{
		tooltip.Content = string.Empty;
		tooltip.ClientData = null;
		hero = null;
		skill = null;
	}

	public virtual void RefreshContent()
	{
		if (!(skill != null))
		{
			return;
		}
		IGuiPanelHelper guiPanelHelper = Services.GetService<IGuiService>().GuiPanelHelper;
		GuiElement guiElement = null;
		guiPanelHelper.TryGetGuiElement(skill.Config.BaseName, out guiElement);
		if (guiElement != null)
		{
			if (guiPanelHelper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Small, out Texture2D texture))
			{
				icon.Image = texture;
				if ((bool)icon.GetComponent<AgeModifierImageSwitch>())
				{
					icon.GetComponent<AgeModifierImageSwitch>().NormalImage = texture;
					icon.GetComponent<AgeModifierImageSwitch>().OnImage = texture;
					if (guiPanelHelper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Large, out texture))
					{
						icon.GetComponent<AgeModifierImageSwitch>().HoverImage = texture;
						icon.GetComponent<AgeModifierImageSwitch>().HoverOnImage = texture;
					}
				}
			}
			tooltip.Content = guiElement.Description;
		}
		tooltip.Content = skill.Config.BaseName;
		tooltip.ClientData = skill;
		if (skill.PreviewLevel > 0)
		{
			levelLabel.SetText(skill.PreviewLevel.ToString(), previewMode: true);
			levelLabel.AgeTransform.Visible = true;
		}
		else
		{
			levelLabel.SetText(skill.Config.Level.ToString(), previewMode: false);
			levelLabel.AgeTransform.Visible = (skill.Config.Level > 1);
		}
	}

	protected virtual void Awake()
	{
		tooltip = GetComponent<AgeTooltip>();
	}
}
public class StatItem : MonoBehaviour
{
	[SerializeField]
	private AgePrimitiveLabel statNameLabel;

	[SerializeField]
	private AgePrimitiveLabel statValueLabel;

	private StatisticName achievementStatName;

	private AchievementManagerDOTE achievementManager;

	private void Awake()
	{
		achievementManager = SingletonManager.Get<AchievementManagerDOTE>();
	}

	public void Bind(StatisticName achievementStatName)
	{
		this.achievementStatName = achievementStatName;
	}

	public void RefreshContent()
	{
		statNameLabel.Text = AgeLocalizer.Instance.LocalizeString("%Stat_" + achievementStatName.ToString());
		float statisticValue = achievementManager.GetStatisticValue(achievementStatName);
		statValueLabel.Text = statisticValue.ToString();
	}
}
public class StatsPanel : GuiPanel
{
	[SerializeField]
	private StatisticName[] stats;

	[SerializeField]
	private AgeTransform statsTable;

	[SerializeField]
	private Transform statItemPfb;

	public override void Show(params object[] parameters)
	{
		base.Show(parameters);
		RefreshContent();
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		statsTable.ReserveChildren(stats.Length, statItemPfb, "StatItem");
		statsTable.RefreshChildrenArray(stats, RefreshStatsTable);
	}

	private void RefreshStatsTable(AgeTransform tableItem, StatisticName stat, int index)
	{
		StatItem component = tableItem.GetComponent<StatItem>();
		component.Bind(stat);
		component.RefreshContent();
	}
}
public class StelePanel : PopupMenuPanel
{
	[SerializeField]
	private AgePrimitiveLabel typeLabel;

	[SerializeField]
	private AgePrimitiveLabel turnsLeftLabel;

	[SerializeField]
	private AgePrimitiveLabel descriptionLabel;

	[SerializeField]
	private AgeTransform effectsContainer;

	[SerializeField]
	private Transform steleEffectPfb;

	private Stele stele;

	private float initalHeight;

	private PopupMenuPanelRoom[] popupMenuPanelRoomCpts;

	private IInputService inputService;

	private IGameCameraService gameCameraService;

	private Stele Stele
	{
		get
		{
			return stele;
		}
		set
		{
			if (stele != null)
			{
				Stele.HealthCpnt.OnDeath -= OnSteleDeath;
			}
			stele = value;
			if (stele != null)
			{
				Stele.HealthCpnt.OnDeath += OnSteleDeath;
			}
		}
	}

	protected override void Awake()
	{
		base.Awake();
		inputService = Services.GetService<IInputService>();
		gameCameraService = Services.GetService<IGameCameraService>();
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			popupMenuPanelRoomCpts = UnityEngine.Object.FindObjectsOfType<PopupMenuPanelRoom>();
		}
	}

	public void Bind(Stele stele)
	{
		Stele = stele;
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		if (Stele == null)
		{
			Diagnostics.LogError("StelePanel: Stele is null");
			return;
		}
		if (Stele.TypeEventConfig == null)
		{
			Diagnostics.LogError("StelePanel: TypeEventConfig is null");
			return;
		}
		if (Stele.TypeEventConfig.Name == null)
		{
			Diagnostics.LogError("StelePanel: Name is null");
			return;
		}
		typeLabel.Text = AgeLocalizer.Instance.LocalizeString("%Stele_" + Stele.TypeEventConfig.Name);
		descriptionLabel.Text = AgeLocalizer.Instance.LocalizeString("%Stele_Description_Default");
		turnsLeftLabel.Text = AgeLocalizer.Instance.LocalizeString("%SteleTurnLeftValueFormat").Replace("$Value", Stele.HealthCpnt.GetHealth().ToString());
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		gameEventManager.OnDungeonTurnChanged += OnDungeonTurnChanged;
		List<string> effectStrs = new List<string>();
		SimulationObject skillSimObj = Stele.GetSimObj();
		if (Stele.SimDesc != null)
		{
			effectStrs.AddRange(GetEffectListFromSim(skillSimObj, Stele.SimDesc));
		}
		effectsContainer.Height = 0f;
		effectsContainer.ReserveChildren(effectStrs.Count, steleEffectPfb, "Effect");
		effectsContainer.RefreshChildrenIList(effectStrs, RefreshEffect);
		base.AgeTransform.Height = initalHeight + effectsContainer.Height;
		if (popupMenuPanelRoomCpts != null)
		{
			for (int i = 0; i < popupMenuPanelRoomCpts.Length; i++)
			{
				popupMenuPanelRoomCpts[i].ClosePanel();
			}
		}
		if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			gameCameraService.Focus(Stele.RoomElement.ParentRoom.CenterPosition, LerpType.Linear, -1f);
		}
		yield return base.OnShow(parameters);
	}

	protected override IEnumerator OnHide(bool instant)
	{
		yield return base.OnHide(instant);
		gameEventManager.OnDungeonTurnChanged -= OnDungeonTurnChanged;
		Stele = null;
	}

	protected override IEnumerator OnLoad()
	{
		initalHeight = base.AgeTransform.Height;
		return base.OnLoad();
	}

	private void OnDungeonTurnChanged()
	{
		RefreshContent();
	}

	private void OnCloseButtonClick()
	{
		Hide();
	}

	private void OnSteleDeath(ulong attackerOwnerPlayerID = 0)
	{
		Hide();
	}

	private List<string> GetEffectListFromSim(SimulationObject steleSimObj, SimulationDescriptor simDesc, string forcedPath = null)
	{
		List<string> list = new List<string>();
		Dictionary<StaticString, float> dictionary = new Dictionary<StaticString, float>();
		SimulationModifierDescriptor[] simulationModifierDescriptors = simDesc.SimulationModifierDescriptors;
		foreach (SimulationModifierDescriptor simulationModifierDescriptor in simulationModifierDescriptors)
		{
			float num = simulationModifierDescriptor.ComputeValue(steleSimObj, steleSimObj, SimulationPropertyRefreshContext.GetContext());
			if (simulationModifierDescriptor.Operation == SimulationModifierDescriptor.ModifierOperation.Percent)
			{
				num = GenericUtilities.RoundHalfAwayFromZero(100f * num);
			}
			dictionary.Add((string)simulationModifierDescriptor.TargetPropertyName + "_" + simulationModifierDescriptor.Path, num);
		}
		SimulationModifierDescriptor[] simulationModifierDescriptors2 = simDesc.SimulationModifierDescriptors;
		foreach (SimulationModifierDescriptor simulationModifierDescriptor2 in simulationModifierDescriptors2)
		{
			string text = AgeLocalizer.Instance.LocalizeStringDefaults("%Skill_Effect_" + (string)simulationModifierDescriptor2.TargetPropertyName + "_" + simulationModifierDescriptor2.Operation, null);
			if (!string.IsNullOrEmpty(text))
			{
				string text2 = AgeLocalizer.Instance.LocalizeString("%Skill_Effect_On_" + ((forcedPath == null) ? simulationModifierDescriptor2.Path.ToString() : forcedPath));
				text2 = text2.Replace("$ModEffect", text);
				while (text2.Contains("$Value_"))
				{
					int startIndex = text2.IndexOf("$Value_");
					int num2 = text2.IndexOf(' ', startIndex);
					string text3 = (num2 <= -1) ? text2.Substring(startIndex) : text2.Substring(startIndex, num2);
					string x = text3.Replace("$Value_", string.Empty) + "_" + simulationModifierDescriptor2.Path;
					text2 = text2.Replace(text3, dictionary[x].ToString());
				}
				float num = dictionary[(string)simulationModifierDescriptor2.TargetPropertyName + "_" + simulationModifierDescriptor2.Path];
				string text4 = num.ToString();
				SimulationModifierDescriptor.ModifierOperation operation = simulationModifierDescriptor2.Operation;
				if (operation == SimulationModifierDescriptor.ModifierOperation.Addition || operation == SimulationModifierDescriptor.ModifierOperation.Percent)
				{
					text4 = ((!(num > 0f)) ? string.Empty : "+") + text4;
				}
				text2 = text2.Replace("$Value", text4);
				list.Add(text2);
			}
		}
		return list;
	}

	private void RefreshEffect(AgeTransform tableItem, string effectStr, int index)
	{
		SkillEffectItem component = tableItem.GetComponent<SkillEffectItem>();
		component.RefreshContent(effectStr);
		tableItem.Y = effectsContainer.Height;
		effectsContainer.Height += tableItem.Height + effectsContainer.VerticalSpacing;
	}
}
public class SteleTimerPanel : MonoBehaviour
{
	private IGameCameraService gameCameraService;

	private AgeTransform ageTransform;

	protected void Awake()
	{
		ageTransform = GetComponent<AgeTransform>();
		gameCameraService = Services.GetService<IGameCameraService>();
		gameCameraService.OnBeginTacticalMapCameraToggle += UpdateVisibility;
		gameCameraService.OnEndTacticalMapCameraToggle += UpdateVisibility;
		if (Services.GetService<IInputService>().CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			GetComponent<GameToScreenPositionSync>().ScreenOffset = new Vector2(0f, 20f);
		}
	}

	private void UpdateVisibility(bool obj)
	{
		ageTransform.Visible = !gameCameraService.IsTacticalMapActive();
	}
}
public class StoryDialogPanel : AutoCloseGuiPanel
{
	public delegate void OnFinishedHandler();

	[SerializeField]
	private AgePrimitiveLabel textLabel;

	private AgeModifier modifer;

	public event OnFinishedHandler OnFinished;

	protected override void Awake()
	{
		base.Awake();
		modifer = GetComponent<AgeModifier>();
	}

	public void Display(string text, Transform tfm, Camera camera, float duration = -1f)
	{
		textLabel.Text = text;
		GameToScreenPositionSync component = GetComponent<GameToScreenPositionSync>();
		component.Camera = camera;
		component.GameEntityTfm = tfm;
		Show();
		modifer.StartAnimation();
		if (duration >= 0f)
		{
			Invoke("OnHidePanel", duration);
		}
	}

	private void OnHidePanel()
	{
		GetComponent<GameToScreenPositionSync>().GameEntityTfm = null;
		Hide();
		if (this.OnFinished != null)
		{
			this.OnFinished();
		}
	}

	private void Update()
	{
	}
}
public class SubInventoryPanel : InventoryPanel
{
}
public class TabBasePanel : GuiPanel
{
	public virtual bool CanNavigate()
	{
		return true;
	}
}
public class TabHeroesEquipmentPanel : TabBasePanel
{
	[SerializeField]
	private AgeTransform heroTable;

	[SerializeField]
	private Transform heroEquipementPanelPrefab;

	[SerializeField]
	private AgeTransform statsTable;

	[SerializeField]
	private AgeTransform selectButtonsTable;

	[SerializeField]
	private AgeTransform transferButtonsTable;

	[SerializeField]
	private GUIComparingLabel healthLevelUpLabel;

	[SerializeField]
	private GUIComparingLabel healthRegenLevelUpLabel;

	[SerializeField]
	private GUIComparingLabel defenseLevelUpLabel;

	[SerializeField]
	private GUIComparingLabel moveSpeedLevelUpLabel;

	[SerializeField]
	private GUIComparingLabel dpsLevelUpLabel;

	[SerializeField]
	private GUIComparingLabel attackPowerLevelUpLabel;

	[SerializeField]
	private GUIComparingLabel attackCooldownLevelUpLabel;

	[SerializeField]
	private GUIComparingLabel witLevelUpLabel;

	[SerializeField]
	private InventorySelectable[] inventoriesSelectable;

	[SerializeField]
	private AgeTransform tooltipDock;

	[SerializeField]
	private AgePrimitiveLabel healthLabel;

	[SerializeField]
	private AgePrimitiveLabel healthRegenLabel;

	[SerializeField]
	private AgePrimitiveLabel defenseLabel;

	[SerializeField]
	private AgePrimitiveLabel moveSpeedLabel;

	[SerializeField]
	private AgePrimitiveLabel dpsLabel;

	[SerializeField]
	private AgePrimitiveLabel attackPowerLabel;

	[SerializeField]
	private AgePrimitiveLabel attackCooldownLabel;

	[SerializeField]
	private AgePrimitiveLabel witLabel;

	private IGameControlService gameControlService;

	private SelectableManager selectableManager;

	private List<Selectable> unregisteredSelectables = new List<Selectable>();

	private List<ItemHolderSelectable> registeredSelectables = new List<ItemHolderSelectable>();

	private List<HeroEquipementPadPanel> heroEquipmentPanels = new List<HeroEquipementPadPanel>();

	private InventoryItem currentItem;

	private GuiItem currentGuiItem;

	private Dungeon dungeon;

	private readonly string selectionCategoryName = SelectionCategory.HeroStatsPanel_Equipment.ToString();

	protected override void Awake()
	{
		base.Awake();
		gameControlService = Services.GetService<IGameControlService>();
		selectableManager = SingletonManager.Get<SelectableManager>();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		if (dungeon == null)
		{
			dungeon = SingletonManager.Get<Dungeon>();
			Inventory sharedInventory = dungeon.SharedInventory;
			sharedInventory.OnItemRemoved = (Inventory.ItemRemovedHandler)Delegate.Combine(sharedInventory.OnItemRemoved, new Inventory.ItemRemovedHandler(Inventory_OnItemRemoved));
			Inventory backpackInventory = dungeon.BackpackInventory;
			backpackInventory.OnItemRemoved = (Inventory.ItemRemovedHandler)Delegate.Combine(backpackInventory.OnItemRemoved, new Inventory.ItemRemovedHandler(Inventory_OnItemRemoved));
		}
		Services.GetService<IGameEventService>().OnHeroListChanged += RefreshContent;
		yield return base.OnShow(parameters);
		gameControlService.SetSharedInventoryPanelDisplay(on: true);
		RefreshContent();
		RestoreNormalSelection();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		gameControlService.SetSharedInventoryPanelDisplay(on: false);
		unregisteredSelectables.Clear();
		statsTable.Visible = false;
		Services.GetService<IGameEventService>().OnHeroListChanged -= RefreshContent;
		if (dungeon == null)
		{
			dungeon = SingletonManager.Get<Dungeon>();
			Inventory sharedInventory = dungeon.SharedInventory;
			sharedInventory.OnItemRemoved = (Inventory.ItemRemovedHandler)Delegate.Remove(sharedInventory.OnItemRemoved, new Inventory.ItemRemovedHandler(Inventory_OnItemRemoved));
			Inventory backpackInventory = dungeon.BackpackInventory;
			backpackInventory.OnItemRemoved = (Inventory.ItemRemovedHandler)Delegate.Remove(backpackInventory.OnItemRemoved, new Inventory.ItemRemovedHandler(Inventory_OnItemRemoved));
		}
		yield return base.OnHide(instant);
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		if (base.IsVisible)
		{
			for (int i = 0; i < heroEquipmentPanels.Count; i++)
			{
				heroEquipmentPanels[i].Unbind();
			}
			heroEquipmentPanels.Clear();
			heroTable.ReserveChildren(Hero.LocalPlayerActiveRecruitedHeroes.Count, heroEquipementPanelPrefab, "HeroStatPadItem");
			heroTable.RefreshChildrenArray(Hero.LocalPlayerActiveRecruitedHeroes.ToArray(), RefreshHeroStatItem);
		}
	}

	private void RefreshHeroStatItem(AgeTransform tableItem, Hero hero, int index)
	{
		HeroEquipementPadPanel component = tableItem.GetComponent<HeroEquipementPadPanel>();
		heroEquipmentPanels.Add(component);
		component.Bind(Hero.LocalPlayerActiveRecruitedHeroes[index], healthLevelUpLabel, healthRegenLevelUpLabel, defenseLevelUpLabel, moveSpeedLevelUpLabel, dpsLevelUpLabel, attackPowerLevelUpLabel, attackCooldownLevelUpLabel, witLevelUpLabel, tooltipDock, healthLabel, healthRegenLabel, defenseLabel, moveSpeedLabel, dpsLabel, attackPowerLabel, attackCooldownLabel, witLabel);
	}

	public void OnItemSelected(InventoryItem item, Hero hero = null)
	{
		transferButtonsTable.Visible = (InventoryListPanel.SelectedGuiItem != null);
		selectButtonsTable.Visible = (InventoryListPanel.SelectedGuiItem == null);
		selectButtonsTable.Enable = (item != null);
		if (hero != null && currentItem != null)
		{
			int num = 0;
			while (true)
			{
				if (num < heroEquipmentPanels.Count)
				{
					if (heroEquipmentPanels[num].BoundHero == hero)
					{
						break;
					}
					num++;
					continue;
				}
				return;
			}
			statsTable.Visible = true;
			heroEquipmentPanels[num].RefreshStatBonuses(currentItem);
		}
		else
		{
			statsTable.Visible = false;
		}
	}

	public void OnItemConfirmed(GuiItem guiItem)
	{
		OnItemConfirmed(guiItem, out currentGuiItem, out currentItem, unregisteredSelectables, registeredSelectables, inventoriesSelectable, selectionCategoryName);
	}

	public static void OnItemConfirmed(GuiItem guiItem, out GuiItem currentGuiItem, out InventoryItem currentItem, List<Selectable> unregisteredSelectables, List<ItemHolderSelectable> registeredSelectables, InventorySelectable[] inventoriesSelectable, string selectionCategoryName)
	{
		currentGuiItem = guiItem;
		currentItem = guiItem.GetItem();
		unregisteredSelectables.Clear();
		SelectableManager selectableManager = SingletonManager.Get<SelectableManager>();
		List<Selectable> list = new List<Selectable>(selectableManager.SelectablesByCategoryName[selectionCategoryName]);
		list.AddRange(inventoriesSelectable);
		for (int i = 0; i < list.Count; i++)
		{
			ItemHolderSelectable itemHolderSelectable = list[i] as ItemHolderSelectable;
			if (itemHolderSelectable != null)
			{
				if (list[i] != guiItem.Selectable && itemHolderSelectable.CanHoldItem(currentItem))
				{
					itemHolderSelectable.Register();
					itemHolderSelectable.SetHighlight(show: true);
					registeredSelectables.Add(itemHolderSelectable);
					continue;
				}
				itemHolderSelectable.SetHighlight(show: false);
			}
			if (list[i].IsRegistered)
			{
				unregisteredSelectables.Add(list[i]);
				list[i].Unregister();
			}
		}
	}

	public void RestoreNormalSelection(bool restorePreviousItemSelected = false)
	{
		transferButtonsTable.Visible = false;
		selectButtonsTable.Visible = true;
		selectButtonsTable.Enable = true;
		statsTable.Visible = false;
		for (int i = 0; i < unregisteredSelectables.Count; i++)
		{
			unregisteredSelectables[i].Register();
		}
		for (int j = 0; j < inventoriesSelectable.Length; j++)
		{
			inventoriesSelectable[j].Unregister();
		}
		for (int k = 0; k < registeredSelectables.Count; k++)
		{
			registeredSelectables[k].SetHighlight(show: false);
		}
		unregisteredSelectables.Clear();
		registeredSelectables.Clear();
		InventoryListPanel.SelectItemStatic(null);
		currentItem = null;
		if (restorePreviousItemSelected && currentGuiItem != null)
		{
			selectableManager.Select(currentGuiItem.Selectable);
		}
		currentGuiItem = null;
	}

	public void Inventory_OnItemRemoved(InventoryItem item)
	{
		if (item == currentItem)
		{
			RestoreNormalSelection();
		}
	}

	private void SelectableManager_OnSelectionChanged(Selectable selectable)
	{
		throw new NotImplementedException();
	}
}
public class TabHeroesSkillsPanel : TabBasePanel
{
	[SerializeField]
	private AgeTransform heroSkillsLinesTable;

	[SerializeField]
	private Transform heroSkillsLinePrefab;

	[SerializeField]
	private AgeTransform tooltipDock;

	public HeroSkillsPadLine GetSelectedSkillsLine()
	{
		for (int i = 0; i < heroSkillsLinesTable.GetChildren().Count; i++)
		{
			AgeTransform ageTransform = heroSkillsLinesTable.GetChildren()[i];
			if (ageTransform.Visible && ageTransform.Alpha > 0f)
			{
				HeroSkillsPadLine component = ageTransform.GetComponent<HeroSkillsPadLine>();
				if (component.Selected)
				{
					return component;
				}
			}
		}
		return null;
	}

	public Hero GetSelectedHero()
	{
		HeroSkillsPadLine selectedSkillsLine = GetSelectedSkillsLine();
		if (selectedSkillsLine != null)
		{
			return selectedSkillsLine.BoundHero;
		}
		return null;
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		if (base.IsVisible)
		{
			List<HeroSkillsPadLine> children = heroSkillsLinesTable.GetChildren<HeroSkillsPadLine>();
			for (int i = 0; i < children.Count; i++)
			{
				children[i].Unbind();
			}
			heroSkillsLinesTable.DestroyAllChildren();
			if (Hero.LocalPlayerActiveRecruitedHeroes.Count > 0)
			{
				heroSkillsLinesTable.ReserveChildren(Hero.LocalPlayerActiveRecruitedHeroes.Count, heroSkillsLinePrefab, "HeroStatPadItem");
				heroSkillsLinesTable.RefreshChildrenArray(Hero.LocalPlayerActiveRecruitedHeroes.ToArray(), RefreshHeroSkillsLine);
			}
		}
	}

	protected override IEnumerator OnHide(bool instant)
	{
		Services.GetService<IGameEventService>().OnHeroListChanged -= RefreshContent;
		yield return base.OnHide(instant);
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		Services.GetService<IGameEventService>().OnHeroListChanged += RefreshContent;
		RefreshContent();
	}

	private void RefreshHeroSkillsLine(AgeTransform tableItem, Hero hero, int index)
	{
		HeroSkillsPadLine component = tableItem.GetComponent<HeroSkillsPadLine>();
		component.Bind(hero, index, tooltipDock);
		component.RefreshContent();
	}
}
public class TabHeroesStatsPanel : TabBasePanel
{
	public const float TypeWriterSpeed = 60f;

	[SerializeField]
	private AgeTransform heroTable;

	[SerializeField]
	private Transform heroStatPrefab;

	[SerializeField]
	private AgePrimitiveLabel healCostLabel;

	[SerializeField]
	private AgePrimitiveLabel restCostLabel;

	[SerializeField]
	private AgePrimitiveLabel dismissCostLabel;

	[SerializeField]
	private AgeTransform healButton;

	[SerializeField]
	private AgeTransform restButton;

	[SerializeField]
	private AgeTransform dismissButton;

	[SerializeField]
	private AgeTransform levelUpGroup;

	[SerializeField]
	private AgePrimitiveLabel levelUpCostLabel;

	[SerializeField]
	protected AgeTransform biographyButton;

	[SerializeField]
	protected AgeTransform closeBiographyButton;

	[SerializeField]
	protected AgeTransform buttonTable;

	[SerializeField]
	protected AgeTransform attributesKeyGroup;

	[SerializeField]
	protected AgeTransform biographyGroup;

	[SerializeField]
	protected AgePrimitiveImage biographyImage;

	[SerializeField]
	protected AgePrimitiveLabel biographyText;

	[SerializeField]
	protected AgeModifierTypewriter biographyTextModifier;

	private SelectableManager selectableManager;

	private IInputService inputService;

	private Hero heroForDismiss;

	private Hero heroForBiography;

	private Hero heroToReselect;

	private bool firstRefreshBiography;

	private bool biographyMode;

	private bool doUpdate;

	public bool BiographyMode
	{
		get
		{
			return biographyMode;
		}
		set
		{
			biographyMode = value;
			if (!biographyMode)
			{
				if (heroForBiography != null)
				{
					heroToReselect = heroForBiography;
				}
				heroForBiography = null;
			}
			else
			{
				heroForBiography = GetSelectedHero();
			}
			RefreshContent();
		}
	}

	public bool IsDismissing
	{
		get
		{
			return heroForDismiss != null && SingletonManager.Get<RequesterPanel>().IsVisible;
		}
		private set
		{
		}
	}

	public override bool CanNavigate()
	{
		return !IsDismissing;
	}

	public HeroStatsPadLine GetSelectedStatPanel()
	{
		Selectable currentCategorySelectedElement = selectableManager.GetCurrentCategorySelectedElement();
		if (currentCategorySelectedElement != null)
		{
			return currentCategorySelectedElement.GetComponent<HeroStatsPadLine>();
		}
		return null;
	}

	public Hero GetSelectedHero()
	{
		HeroStatsBasePanel selectedStatPanel = GetSelectedStatPanel();
		if (selectedStatPanel != null)
		{
			return selectedStatPanel.BoundHero;
		}
		return null;
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		if (!base.IsVisible)
		{
			return;
		}
		biographyButton.Visible = !BiographyMode;
		closeBiographyButton.Visible = BiographyMode;
		attributesKeyGroup.Visible = BiographyMode;
		biographyGroup.Visible = BiographyMode;
		List<HeroStatsPadLine> children = heroTable.GetChildren<HeroStatsPadLine>();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Unbind();
		}
		heroTable.DestroyAllChildren();
		if (!BiographyMode)
		{
			if (Hero.LocalPlayerActiveRecruitedHeroes.Count > 0)
			{
				heroTable.ReserveChildren(Hero.LocalPlayerActiveRecruitedHeroes.Count, heroStatPrefab, "HeroStatPadItem");
				heroTable.RefreshChildrenArray(Hero.LocalPlayerActiveRecruitedHeroes.ToArray(), RefreshHeroStatLine);
				if (heroToReselect != null)
				{
					bool flag = false;
					for (int j = 0; j < heroTable.GetChildren().Count; j++)
					{
						HeroStatsBasePanel component = heroTable.GetChildren()[j].GetComponent<HeroStatsBasePanel>();
						if (heroToReselect == component.BoundHero)
						{
							flag = true;
							component.GetComponent<AGESelectable>().Select();
							break;
						}
					}
					if (!flag)
					{
						heroToReselect = null;
					}
				}
				biographyButton.Enable = true;
			}
			else if (GetSelectedHero() == null)
			{
				healButton.Enable = false;
				restButton.Enable = false;
				dismissButton.Enable = false;
				levelUpGroup.Enable = false;
				biographyButton.Enable = false;
			}
		}
		else
		{
			if (!(heroForBiography != null))
			{
				return;
			}
			Hero[] refTable = new Hero[1]
			{
				heroForBiography
			};
			heroTable.ReserveChildren(1, heroStatPrefab, "HeroStatPadItem");
			heroTable.RefreshChildrenArray(refTable, RefreshHeroStatLine);
			if (base.GuiService.GuiPanelHelper.TryGetGuiElement(heroForBiography.Config.Name, out GuiElement guiElement))
			{
				if (base.GuiService.GuiPanelHelper.TryGetTextureFromIcon(guiElement, IconSize.Large, out Texture2D texture))
				{
					biographyImage.Image = texture;
				}
				if (firstRefreshBiography)
				{
					HeroStatsBasePanel component2 = heroTable.GetChildren()[0].GetComponent<HeroStatsBasePanel>();
					biographyText.ForceText(AgeLocalizer.Instance.LocalizeString(guiElement.Description) + component2.GetBackstories());
					biographyTextModifier.Duration = (float)biographyText.Text.Length / 60f;
					biographyTextModifier.StartAnimation();
					firstRefreshBiography = false;
				}
			}
		}
	}

	protected override void Awake()
	{
		base.Awake();
		selectableManager = SingletonManager.Get<SelectableManager>();
		inputService = Services.GetService<IInputService>();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		Services.GetService<IGameEventService>().OnHeroListChanged -= RefreshContent;
		doUpdate = false;
		heroForBiography = null;
		heroToReselect = null;
		if (IsDismissing)
		{
			SingletonManager.Get<RequesterPanel>().Hide(instant: true);
			heroForDismiss = null;
		}
		HeroStatsPadLine heroPanel = GetSelectedStatPanel();
		if (heroPanel != null && heroPanel.IsMouseOverLevelUpButton)
		{
			heroPanel.OnLevelUpButtonLeave();
			levelUpGroup.ResetAllModifiers();
		}
		yield return base.OnHide(instant);
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		biographyMode = false;
		RefreshContent();
		StartCoroutine(UpdateLoop());
		Services.GetService<IGameEventService>().OnHeroListChanged += RefreshContent;
	}

	private void TableButtonsVisible()
	{
		buttonTable.DirtyPosition = true;
		buttonTable.ArrangeChildren();
	}

	private void RefreshHeroStatLine(AgeTransform tableItem, Hero hero, int index)
	{
		HeroStatsPadLine component = tableItem.GetComponent<HeroStatsPadLine>();
		component.Bind(hero, index, healButton, healCostLabel, restButton, restCostLabel, dismissButton, dismissCostLabel, levelUpGroup, levelUpCostLabel, biographyButton, closeBiographyButton);
	}

	private IEnumerator UpdateLoop()
	{
		doUpdate = true;
		while (doUpdate)
		{
			bool levelInProgress = false;
			HeroStatsPadLine heroPanel = GetSelectedStatPanel();
			if (heroPanel != null)
			{
				levelInProgress = heroPanel.IsMouseOverLevelUpButton;
			}
			if (!levelInProgress && !IsDismissing && TryActionAndFeedback(Control.HeroHeal, healButton, actWhenDisabled: false))
			{
				Hero hero2 = GetSelectedHero();
				if (hero2 != null)
				{
					heroToReselect = hero2;
					hero2.Heal();
				}
			}
			else if (!levelInProgress && !IsDismissing && TryActionAndFeedback(Control.HeroRest, restButton, actWhenDisabled: false))
			{
				Hero hero = GetSelectedHero();
				if (hero != null)
				{
					heroToReselect = hero;
					hero.Rest();
				}
			}
			else if (!levelInProgress && !IsDismissing && TryActionAndFeedback(Control.HeroDismiss, dismissButton, actWhenDisabled: false))
			{
				heroForDismiss = GetSelectedHero();
				if (heroForDismiss != null)
				{
					SingletonManager.Get<RequesterPanel>().Display("%DismissHeroConfirm", OnDismissHeroConfirmResult, RequesterPanel.ButtonsMode.YesNo);
				}
			}
			else if (!IsDismissing && TryActionAndFeedback(Control.HeroLevelUp, levelUpGroup, actWhenDisabled: false))
			{
				if (levelInProgress)
				{
					heroPanel.OnLevelUpButtonPressed();
					heroPanel.OnLevelUpButtonLeave();
					RefreshContent();
				}
				else
				{
					heroToReselect = GetSelectedHero();
					heroPanel.OnLevelUpButtonPressed();
					biographyButton.Visible = false;
					closeBiographyButton.Visible = false;
				}
			}
			else if (!levelInProgress && !IsDismissing && !SingletonManager.Get<RequesterPanel>().IsVisible && !biographyMode && TryActionAndFeedback(Control.HeroBiography, biographyButton, actWhenDisabled: false))
			{
				firstRefreshBiography = true;
				BiographyMode = true;
				RefreshContent();
			}
			yield return null;
		}
	}

	private void OnDismissHeroConfirmResult(RequesterPanel.Result result)
	{
		if (result == RequesterPanel.Result.Yes)
		{
			heroForDismiss.Dismiss();
			if (BiographyMode)
			{
				BiographyMode = false;
			}
			RefreshContent();
		}
		heroForDismiss = null;
	}

	private bool TryActionAndFeedback(Control control, AgeTransform ageTransform, bool actWhenDisabled)
	{
		if (inputService.GetControlDown(control))
		{
			if (ageTransform.Enable || actWhenDisabled)
			{
				ageTransform.StartAllModifiers();
				return true;
			}
			IAudioEventService service = Services.GetService<IAudioEventService>();
			service.Play2DEvent("Master/GUI/ErrorActionMenu");
			return false;
		}
		return false;
	}
}
public class TabPlayerListPanel : TabBasePanel
{
	[SerializeField]
	private Transform playerTransferLinePfb;

	[SerializeField]
	private AgeTransform playerTransferLinesTable;

	[SerializeField]
	private AgeTransform resourceTransferButton;

	[SerializeField]
	private AgeTransform heroTransferButton;

	[SerializeField]
	private AgeTransform banPlayerButton;

	private bool doUpdate;

	private GameNetworkManager gameNetManager;

	private IInputService inputService;

	private IGameEventService gameEventService;

	private ulong localPlayerID;

	private int currentLine = -1;

	private bool resourceSelected;

	private bool heroSelected;

	private bool isKickingPlayer;

	public override bool CanNavigate()
	{
		return !isKickingPlayer;
	}

	public void OnSelectResource(int lineNumber)
	{
		currentLine = lineNumber;
		resourceSelected = true;
		RefreshSelection();
	}

	public void OnUnselectResource(int lineNumber)
	{
		currentLine = lineNumber;
		resourceSelected = false;
		RefreshSelection();
	}

	public void OnSelectHero(int lineNumber)
	{
		currentLine = lineNumber;
		heroSelected = true;
		RefreshSelection();
	}

	public void OnUnselectHero(int lineNumber)
	{
		currentLine = lineNumber;
		heroSelected = false;
		RefreshSelection();
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		localPlayerID = gameNetManager.GetLocalPlayerID();
		ulong[] lobbyPlayerIDs = gameNetManager.GetLobbyPlayerIDs();
		List<ulong> list = new List<ulong>();
		for (int i = 0; i < lobbyPlayerIDs.Length; i++)
		{
			if (lobbyPlayerIDs[i] != localPlayerID)
			{
				list.Add(lobbyPlayerIDs[i]);
			}
		}
		if (list.Count == 0)
		{
			Hide(instant: true);
		}
		UnbindPlayerFIDSTransferLines();
		playerTransferLinesTable.Height = 0f;
		playerTransferLinesTable.ReserveChildren(list.Count, playerTransferLinePfb, "PlayerTransferLine");
		playerTransferLinesTable.RefreshChildrenIList(list, RefreshPlayerLines);
		playerTransferLinesTable.ArrangeChildren();
		if (currentLine >= list.Count)
		{
			currentLine = list.Count - 1;
		}
		RefreshSelection();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		Services.GetService<IGameEventService>().OnDungeonFIDSChanged += RefreshContent;
		gameNetManager.OnPlayerLeft += OnPlayerLeft;
		gameNetManager.OnServerLeft += OnServerLeft;
		currentLine = -1;
		resourceSelected = false;
		heroSelected = false;
		isKickingPlayer = false;
		RefreshContent();
		StartCoroutine(UpdateLoop());
	}

	protected override IEnumerator OnHide(bool instant)
	{
		doUpdate = false;
		Services.GetService<IGameEventService>().OnDungeonFIDSChanged -= RefreshContent;
		gameNetManager.OnPlayerLeft -= OnPlayerLeft;
		gameNetManager.OnServerLeft -= OnServerLeft;
		UnbindPlayerFIDSTransferLines();
		yield return base.OnHide(instant);
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
		inputService = Services.GetService<IInputService>();
	}

	protected override void OnUnload()
	{
		gameNetManager = null;
		base.OnUnload();
	}

	private void OnBanPlayerConfirmResult(RequesterPanel.Result result)
	{
		isKickingPlayer = true;
		RefreshSelection();
	}

	private void OnPlayerLeft(ulong playerID, StaticString playerLeftName)
	{
		RefreshContent();
	}

	private void OnServerLeft(ulong playerID, StaticString playerLeftName)
	{
		RefreshContent();
	}

	private void UnbindPlayerFIDSTransferLines()
	{
		for (int i = 0; i < playerTransferLinesTable.GetChildren().Count; i++)
		{
			PlayerTransferLine component = playerTransferLinesTable.GetChildren()[i].GetComponent<PlayerTransferLine>();
			component.Unbind();
		}
	}

	private void RefreshPlayerLines(AgeTransform tableItem, ulong playerID, int index)
	{
		PlayerTransferLine component = tableItem.GetComponent<PlayerTransferLine>();
		component.Bind(playerID, index);
		component.RefreshContent();
	}

	private void RefreshSelection()
	{
		for (int i = 0; i < playerTransferLinesTable.GetChildren().Count; i++)
		{
			PlayerTransferLine component = playerTransferLinesTable.GetChildren()[i].GetComponent<PlayerTransferLine>();
			component.PlayerHighlight.Visible = (i == currentLine);
		}
		resourceTransferButton.Visible = resourceSelected;
		heroTransferButton.Visible = heroSelected;
		banPlayerButton.Visible = (gameNetManager != null && gameNetManager.IsServer() && !isKickingPlayer);
	}

	private IEnumerator UpdateLoop()
	{
		doUpdate = true;
		while (doUpdate)
		{
			if (!isKickingPlayer && currentLine >= 0 && currentLine < playerTransferLinesTable.ComputeVisibleChildren() && gameNetManager.IsServer() && inputService.GetControlDown(Control.KickPlayer))
			{
				isKickingPlayer = true;
				RefreshSelection();
				PlayerTransferLine playerTransferLine = playerTransferLinesTable.GetChildren()[currentLine].GetComponent<PlayerTransferLine>();
				RequesterPanel requesterPanel = SingletonManager.Get<RequesterPanel>();
				requesterPanel.Display(AgeLocalizer.Instance.LocalizeString("%KickPlayerFromGameConfirmationMessage").Replace("$PlayerName", playerTransferLine.PlayerName), delegate(RequesterPanel.Result result)
				{
					if (result == RequesterPanel.Result.Yes)
					{
						gameNetManager.KickPlayer(playerTransferLine.PlayerID, PlayerKickReason.InGame);
					}
					else
					{
						RefreshSelection();
					}
					isKickingPlayer = false;
				}, RequesterPanel.ButtonsMode.YesNo);
			}
			yield return null;
		}
	}
}
public class TabSystemPanel : TabBasePanel
{
	[SerializeField]
	private AgeTransform buttonsFrame;

	[SerializeField]
	private AgeControlButton saveQuitButton;

	[SerializeField]
	private AgeControlButton tutorialButton;

	[SerializeField]
	private AgePrimitiveLabel xboxCurrentUserLabel;

	[SerializeField]
	private AgeTooltip switchUserTooltip;

	private IGameControlService gameControlService;

	private SelectableManager selectableManager;

	protected override void Awake()
	{
		base.Awake();
		gameControlService = Services.GetService<IGameControlService>();
		selectableManager = SingletonManager.Get<SelectableManager>();
	}

	public void OnAlbumButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<Album>().Focus(display: true);
	}

	public void OnControlsOverviewButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<ControlsOverviewPanel>().Show();
	}

	public void OnMainMenuButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<RequesterPanel>().Display("%GoToMainMenuConfirm", OnMainMenuConfirmResult, RequesterPanel.ButtonsMode.YesNo);
	}

	public void OnOptionsButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<OptionsPanel>().Show();
	}

	public void OnSaveQuitButtonClick(GameObject gameObject)
	{
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		dungeon.SaveAndQuit();
	}

	public void OnTutorialButtonClick(GameObject gameObject)
	{
		SingletonManager.Get<TutorialManager>().TriggerTutorial();
		gameControlService.SetHeroStatsPanelDisplay(on: false);
		selectableManager.SetCategory(SelectionCategory.RoomForMove);
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		buttonsFrame.Height = 0f;
		buttonsFrame.ArrangeChildren();
		buttonsFrame.PixelOffsetTop = -0.5f * buttonsFrame.Height;
		if (saveQuitButton != null)
		{
			List<GuiError> guiErrors = new List<GuiError>();
			if (SingletonManager.Get<Dungeon>().CanSaveDungeon(guiErrors))
			{
				saveQuitButton.AgeTransform.Enable = true;
				saveQuitButton.GetComponent<AgeTooltip>().Content = "%SaveQuitOKTooltip";
			}
			else
			{
				saveQuitButton.AgeTransform.Enable = false;
				saveQuitButton.GetComponent<AgeTooltip>().Content = GuiError.FirstLocalizedMessage(guiErrors, "Tooltip");
			}
		}
		if (SingletonManager.Get<GameNetworkManager>().IsMultiplayerSession())
		{
			tutorialButton.AgeTransform.Enable = false;
			tutorialButton.AgeTransform.AgeTooltip.Content = "%TutorialForbiddenInMultiplayerTooltip";
		}
		else
		{
			tutorialButton.AgeTransform.Enable = true;
			tutorialButton.AgeTransform.AgeTooltip.Content = "%TutorialTooltip";
		}
	}

	public override void Show(params object[] parameters)
	{
		base.Show(parameters);
		RefreshContent();
	}

	private void OnMainMenuConfirmResult(RequesterPanel.Result result)
	{
		if (result == RequesterPanel.Result.Yes)
		{
			gameControlService.GoBackToMainMenu();
		}
	}
}
public class TransferableHero : MonoBehaviour
{
	[SerializeField]
	private AgeControlButton transferButton;

	[SerializeField]
	private AgePrimitiveImage portrait;

	[SerializeField]
	private AgePrimitiveLabel title;

	public Hero BoundHero
	{
		get;
		private set;
	}

	public void Bind(Hero hero, GameObject callbackClient)
	{
		BoundHero = hero;
		transferButton.OnActivateDataObject = BoundHero;
		transferButton.OnActivateObject = callbackClient;
	}

	public void RefreshContent()
	{
		IGuiPanelHelper guiPanelHelper = Services.GetService<IGuiService>().GuiPanelHelper;
		if (guiPanelHelper.TryGetGuiElement(BoundHero.Config.Name, out GuiElement guiElement))
		{
			if (guiPanelHelper.TryGetTextureFromIcon(guiElement, GuiPanel.IconSize.Small, out Texture2D texture))
			{
				portrait.Image = texture;
			}
			title.Text = BoundHero.LocalizedName;
		}
	}

	public void Unbind()
	{
		transferButton.OnActivateDataObject = null;
		BoundHero = null;
	}
}
public class TurnPanel : GuiPanel
{
	[SerializeField]
	private AgePrimitiveLabel turnCountLabel;

	[SerializeField]
	private AgePrimitiveLabel levelNumberLabel;

	[SerializeField]
	private AgeModifier glowMod;

	[SerializeField]
	private AgeModifier actionModeMod;

	[SerializeField]
	private AgeModifier actionModeEndMod;

	[SerializeField]
	private AgeControlToggleRadial pauseToggle;

	[SerializeField]
	private AgeModifierColorSwitch pauseToggleColorSwitch;

	[SerializeField]
	private AgeTransform xboxIcon;

	public AgeTransform XboxIcon => xboxIcon;

	public override void RefreshContent()
	{
		base.RefreshContent();
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		levelNumberLabel.Text = dungeon.Level.ToString();
		turnCountLabel.Text = AgeLocalizer.Instance.LocalizeString("%TurnCount").Replace("$Turn", (dungeon.Turn - 1).ToString());
		if (dungeon.CurrentGamePhase == GamePhase.Action)
		{
			if (!actionModeMod.IsStarted() || !actionModeMod.Repeating)
			{
				actionModeMod.AgeTransform.Visible = true;
				actionModeMod.StartAnimation();
			}
			actionModeMod.Repeating = true;
		}
		else if (actionModeMod.IsStarted())
		{
			actionModeMod.Repeating = false;
		}
		IGameControlService service = Services.GetService<IGameControlService>();
		List<GuiError> guiErrors = new List<GuiError>();
		if (service.CanPauseGame(guiErrors))
		{
			pauseToggle.AgeTransform.Enable = true;
			pauseToggle.State = (Time.timeScale == 0f);
			pauseToggle.AgeTransform.AgeTooltip.Content = null;
		}
		else
		{
			pauseToggle.AgeTransform.Enable = false;
			pauseToggle.State = false;
			pauseToggle.AgeTransform.AgeTooltip.Content = GuiError.FirstLocalizedMessage(guiErrors, "Tooltip");
		}
	}

	public override void Load()
	{
		base.Load();
		IGameEventService service = Services.GetService<IGameEventService>();
		service.OnDungeonTurnChanged += OnDungeonTurnChanged;
		service.OnGamePhaseChanged += OnGamePhaseChanged;
		pauseToggleColorSwitch.TimeScaleDependant = false;
	}

	public override void Unload()
	{
		base.Unload();
		IGameEventService service = Services.GetService<IGameEventService>();
		service.OnDungeonTurnChanged -= OnDungeonTurnChanged;
		service.OnGamePhaseChanged -= OnGamePhaseChanged;
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		RefreshContent();
	}

	private void Update()
	{
		if (actionModeMod.AgeTransform.Visible && !actionModeMod.Repeating && actionModeMod.IsComplete())
		{
			actionModeMod.AgeTransform.Visible = false;
		}
	}

	private void OnDungeonTurnChanged()
	{
		RefreshContent();
		glowMod.StartAnimation();
	}

	private void OnGamePhaseChanged()
	{
		RefreshContent();
	}

	private void OnTogglePause()
	{
		IGameControlService service = Services.GetService<IGameControlService>();
		if (service.CanPauseGame())
		{
			service.ToggleGamePause();
		}
	}
}
public class TutorialInteractivePanel : GuiPanel
{
	[SerializeField]
	private float panelCenterRightPercent;

	[SerializeField]
	private float panelCenterTopPercent;

	[SerializeField]
	private AgeControlButton nextButton;

	[SerializeField]
	private AgeControlButton playButton;

	[SerializeField]
	private AgeControlButton skipButton;

	[SerializeField]
	private AgePrimitiveLabel textLabel;

	[SerializeField]
	private AgePrimitiveLabel numberLabel;

	[SerializeField]
	private AgePrimitiveLabel actionLabel;

	[SerializeField]
	private AgeTransform panelFrame;

	[SerializeField]
	private AgeTransform contentGroup;

	[SerializeField]
	private AgeTransform actionGroup;

	public EventHandler<EventArgs> OnNextClicked;

	private IInputService inputManager;

	private HeroListPanel heroListPanel;

	public float PanelCenterRightPercent => panelCenterRightPercent;

	public float PanelCenterTopPercent => panelCenterTopPercent;

	protected override void Awake()
	{
		base.Awake();
		inputManager = Services.GetService<IInputService>();
	}

	public void UpdateContent(string text, bool nextButtonVisible, int instructionNum, int instructionsCount)
	{
		textLabel.Text = text;
		nextButton.AgeTransform.Visible = (nextButtonVisible && instructionNum != instructionsCount);
		playButton.AgeTransform.Visible = (instructionsCount == instructionNum);
		actionLabel.AgeTransform.Visible = (!playButton.AgeTransform.Visible && !nextButton.AgeTransform.Visible);
		numberLabel.Text = instructionNum.ToString() + "/" + instructionsCount.ToString();
		skipButton.AgeTransform.Visible = (instructionNum != instructionsCount);
		float num = textLabel.AgeTransform.PixelMarginTop + textLabel.AgeTransform.Height + textLabel.AgeTransform.PixelMarginBottom;
		panelFrame.Height = contentGroup.PixelMarginTop + num + actionGroup.Height;
	}

	private void OnNextButtonClick()
	{
		if (OnNextClicked != null)
		{
			OnNextClicked(this, new EventArgs());
		}
	}

	private void OnSkipButtonClick()
	{
		TutorialManager tutorialManager = SingletonManager.Get<TutorialManager>();
		if (tutorialManager != null)
		{
			tutorialManager.StopTutorial();
		}
	}

	private void Update()
	{
		if (base.IsVisible && inputManager != null)
		{
			if (inputManager.GetControlDown(Control.TutorialNextPage))
			{
				OnNextButtonClick();
			}
			else if (inputManager.GetControlDown(Control.TutorialPreviousPage))
			{
				OnSkipButtonClick();
			}
		}
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		RefreshHeroListPanel();
	}

	protected override IEnumerator OnHide(bool instant)
	{
		yield return base.OnHide(instant);
		RefreshHeroListPanel();
	}

	private void RefreshHeroListPanel()
	{
		if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			if (heroListPanel == null)
			{
				heroListPanel = SingletonManager.Get<HeroListPanel>();
			}
			heroListPanel.RefreshContent();
		}
	}
}
public class TutorialPagePanel : GuiPanel
{
	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		base.AgeTransform.StartAllModifiers(forward: true, recursive: true);
	}

	protected override IEnumerator OnHide(bool instant)
	{
		yield return base.OnHide(instant);
		base.AgeTransform.ResetAllModifiers(toStart: true, recursive: true);
	}
}
public class TutorialPanel : GuiPanel
{
	[SerializeField]
	private AgeControlButton previousButton;

	[SerializeField]
	private AgeControlButton nextButton;

	[SerializeField]
	private AgeControlButton skipButton;

	[SerializeField]
	private AgeControlButton playButton;

	[SerializeField]
	private AgePrimitiveLabel pageNumLabel;

	[SerializeField]
	private AgePrimitiveLabel pageLabel;

	[SerializeField]
	private string textLoc = "%TutorialText";

	public EventHandler<EventArgs> OnNextClicked;

	private int currentPageIndex;

	private int pageCount = -1;

	private Dungeon dungeon;

	private IInputService inputManager;

	public void StartTutorial(float delay = 0f)
	{
		if (pageCount < 0)
		{
			string b;
			while (AgeLocalizer.Instance.LocalizeString(b = textLoc + (pageCount + 1).ToString()) != b)
			{
				pageCount++;
			}
		}
		currentPageIndex = 0;
		UpdatePagesDisplay();
		Show();
	}

	public void StopTutorial()
	{
		Hide();
	}

	public void ToggleTutorial()
	{
		if (base.IsVisible)
		{
			StopTutorial();
		}
		else
		{
			StartTutorial();
		}
	}

	private void UpdatePagesDisplay()
	{
		pageLabel.Text = AgeLocalizer.Instance.LocalizeString(textLoc + (currentPageIndex + 1).ToString());
		pageNumLabel.Text = currentPageIndex + 1 + "/" + pageCount;
		previousButton.AgeTransform.Visible = (currentPageIndex > 0);
		nextButton.AgeTransform.Visible = (currentPageIndex < pageCount - 1);
		playButton.AgeTransform.Visible = (currentPageIndex >= pageCount - 1);
	}

	private void OnNextButtonClick()
	{
		if (OnNextClicked != null)
		{
			OnNextClicked(this, new EventArgs());
		}
	}

	private void GoToNextPage()
	{
		if (currentPageIndex >= pageCount - 1)
		{
			Diagnostics.LogError("Already reached last page");
			StopTutorial();
		}
		else
		{
			currentPageIndex++;
			UpdatePagesDisplay();
		}
	}

	private void OnPreviousButtonClick()
	{
		GoToPreviousPage();
	}

	private void GoToPreviousPage()
	{
		if (currentPageIndex <= 0)
		{
			Diagnostics.LogError("Already reached first page");
			return;
		}
		currentPageIndex--;
		UpdatePagesDisplay();
	}

	private void OnSkipButtonClick()
	{
		StopTutorial();
	}

	private void OnPlayButtonClick()
	{
		StopTutorial();
	}

	private void Update()
	{
		if (inputManager == null)
		{
			inputManager = Services.GetService<IInputService>();
			if (inputManager == null)
			{
				return;
			}
		}
		if (dungeon == null)
		{
			dungeon = SingletonManager.Get<Dungeon>(mandatory: false);
			if (dungeon == null)
			{
				return;
			}
		}
		if (!dungeon.IsDisplayed)
		{
			return;
		}
		if (inputManager.GetControlDown(Control.TutorialToggle))
		{
			ToggleTutorial();
		}
		if (base.IsVisible)
		{
			if (inputManager.GetControlDown(Control.TutorialPreviousPage))
			{
				GoToPreviousPage();
			}
			else if (inputManager.GetControlDown(Control.TutorialNextPage))
			{
				GoToNextPage();
			}
		}
	}
}
public class VictoryPanel : GuiPanel
{
	[SerializeField]
	private AgePrimitiveLabel scoreLabel;

	[SerializeField]
	private AgePrimitiveLabel totalTimeLabel;

	[SerializeField]
	private AgePrimitiveLabel informationLabel;

	[SerializeField]
	private DynamicTextureLoader bgImageLoader;

	[SerializeField]
	private DynamicTextureLoader[] heroImageLoaders;

	[SerializeField]
	private string heroImagesPath;

	[SerializeField]
	private AgeTransform whiteFade;

	[SerializeField]
	private ChatPanelVictory chatPanelVictory;

	private GameNetworkManager gameNetManager;

	private IInputService inputManager;

	private DynamicTextureLoader victoryImageLoader;

	public override void Show(params object[] parameters)
	{
		base.Show(parameters);
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		DungeonStatistics statistics = dungeon.Statistics;
		if (gameNetManager == null)
		{
			gameNetManager = SingletonManager.Get<GameNetworkManager>();
		}
		whiteFade.StartAllModifiers();
		chatPanelVictory.ShowIfAvailable();
		scoreLabel.Text = Mathf.Floor(dungeon.GetScore()).ToString();
		totalTimeLabel.Text = statistics.GetStat(DungeonStatistics.Stat_GameTime).DurationToString();
		string localizedName = dungeon.ShipConfig.GetLocalizedName();
		string text = AgeLocalizer.Instance.LocalizeString("%Difficulty" + dungeon.Difficulty + "Title");
		string text2 = Amplitude.Unity.Framework.Application.Version.Major + "." + Amplitude.Unity.Framework.Application.Version.Minor + "." + Amplitude.Unity.Framework.Application.Version.Revision;
		informationLabel.Text = localizedName + " - " + text + " - " + text2;
		IAudioLayeredMusicService service = Services.GetService<IAudioLayeredMusicService>();
		service.StopAllMusics();
		service.PlayLayeredMusic("MusicVictory", "MusicVictory", 0);
		bgImageLoader.Load();
		List<Hero> list = new List<Hero>();
		list.AddRange(Hero.LocalPlayerActiveRecruitedHeroes);
		list.AddRange(Hero.RemotePlayersActiveRecruitedHeroes);
		list = list.Where((Hero hero) => hero.WasInExitRoomAtExitTime).ToList();
		for (int i = 0; i < heroImageLoaders.Length; i++)
		{
			DynamicTextureLoader dynamicTextureLoader = heroImageLoaders[i];
			AgeTransform component = dynamicTextureLoader.GetComponent<AgeTransform>();
			if (list.Count > i)
			{
				dynamicTextureLoader.Load(heroImagesPath + "Victory_" + list[i].Config.Name, forceReload: true);
				component.Visible = true;
			}
			else
			{
				component.Visible = false;
			}
		}
		SingletonManager.Get<AchievementManagerDOTE>().Commit();
	}

	public override void Hide(bool instant = false)
	{
		base.Hide(instant);
		chatPanelVictory.Hide(instant);
	}

	private void OnClick()
	{
		Services.GetService<IGameControlService>().GoBackToMainMenu();
		if (UserProfile.CurrentGameIsNewHighscore && gameNetManager != null)
		{
			SingletonManager.Get<JournalPanel>().Show(gameNetManager.IsMultiplayerSession());
		}
		Hide();
	}

	private void Update()
	{
		if (inputManager == null)
		{
			inputManager = Services.GetService<IInputService>();
		}
		if (base.IsVisible)
		{
			if (inputManager.KeyboardShortcutEnabled && inputManager.GetControlDown(Control.Chat))
			{
				chatPanelVictory.Focus();
			}
			else if (inputManager.CurrentControlScheme == ControlScheme.XBoxOneController && (inputManager.GetControlDown(Control.ConfirmSelectable) || inputManager.GetControlDown(Control.EscapeBehavior)))
			{
				OnClick();
			}
		}
	}
}
public class WarningPanel : GuiModalPanel, IPopupMenuPanel
{
	[SerializeField]
	private AgePrimitiveLabel titleLabel;

	[SerializeField]
	private AgePrimitiveLabel messageLabel;

	[SerializeField]
	private AgeTransform okButton;

	public void SetContentAndShow(string message, string title)
	{
		titleLabel.Text = AgeLocalizer.Instance.LocalizeString(title);
		messageLabel.Text = AgeLocalizer.Instance.LocalizeString(message);
		Show();
	}

	public virtual void OnEscapeBehavior()
	{
		Hide();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		PopupMenuPanel.RegisterPopupMenuPanel(this);
	}

	protected override IEnumerator OnHide(bool instant)
	{
		yield return base.OnHide(instant);
		PopupMenuPanel.UnregisterPopupMenuPanel(this);
	}

	protected override void Awake()
	{
		base.Awake();
		SingletonManager.RegisterInstance(this);
	}

	private void OnOkButtonClicked()
	{
		Hide();
	}
}
public class WorldPosGUI : MonoBehaviour
{
	[SerializeField]
	private GameObject guiPfb;

	[SerializeField]
	private Vector2 screenOffset;

	[SerializeField]
	private Vector3 worldOffset;

	[SerializeField]
	private bool xboxControlsOnly;

	[SerializeField]
	private bool defaultVisibility = true;

	private AgeTransform guiGOAgeTfm;

	private bool visibility;

	protected virtual void Awake()
	{
		visibility = defaultVisibility;
	}

	private void Start()
	{
		if (!xboxControlsOnly || Services.GetService<IInputService>().CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(guiPfb, Vector3.zero, Quaternion.identity);
			gameObject.transform.parent = SingletonManager.Get<MainGameScreen>().WorldPosGUIContainer;
			GameToScreenPositionSync component = gameObject.GetComponent<GameToScreenPositionSync>();
			component.GameEntityTfm = base.transform;
			component.ScreenOffset = screenOffset;
			component.WorldOffset = worldOffset;
			guiGOAgeTfm = gameObject.GetComponent<AgeTransform>();
			guiGOAgeTfm.Visible = visibility;
		}
	}

	public void SetVisibility(bool visibility)
	{
		this.visibility = visibility;
		if (guiGOAgeTfm != null)
		{
			guiGOAgeTfm.Visible = this.visibility;
		}
	}

	private void OnDestroy()
	{
		if (guiGOAgeTfm != null)
		{
			UnityEngine.Object.Destroy(guiGOAgeTfm.gameObject);
		}
	}
}
public class XboxMainMenuPanel : GuiPanel
{
	public AgePrimitiveLabel preMenuLabel;

	public AgePrimitiveLabel menuLabel;

	public AgePrimitiveLabel currentUserLabel;

	public MainMenuPanel mainMenuPanel;

	public bool IsFirstPrompt = true;

	public StaticString MessageOnShow;

	private bool isBeforeMenu;

	private bool isActive;

	private IInputService inputService;

	private IPlatformService platformService;

	private SelectableManager selectableManager;

	private IXboxGameControlService xboxGameControlService;

	private INetworkingService networkingService;

	private IXboxUserService xboxUserService;

	private RequesterPanel requesterPanel;

	private Album album;

	public bool AuthorizeUnsignedUser
	{
		get;
		private set;
	}

	protected override void Awake()
	{
		base.Awake();
		networkingService = Services.GetService<INetworkingService>();
		networkingService.ConnectionStateChanged += NetworkingService_ConnectionStateChanged;
	}

	public void Display(bool preMenu = true)
	{
		isBeforeMenu = (preMenu || IsFirstPrompt);
		if (platformService == null)
		{
			platformService = Services.GetService<IPlatformService>();
		}
		if (inputService == null)
		{
			inputService = Services.GetService<IInputService>();
		}
		if (requesterPanel == null)
		{
			requesterPanel = SingletonManager.Get<RequesterPanel>();
		}
		if (selectableManager == null)
		{
			selectableManager = SingletonManager.Get<SelectableManager>();
		}
		if (xboxGameControlService == null)
		{
			xboxGameControlService = Services.GetService<IXboxGameControlService>();
		}
		if (xboxUserService == null)
		{
			xboxUserService = Services.GetService<IXboxUserService>();
		}
		if (album == null)
		{
			album = SingletonManager.Get<Album>();
		}
		RefreshContent();
		Show();
	}

	public override void Show(params object[] parameters)
	{
		base.Show(parameters);
		isActive = string.IsNullOrEmpty(MessageOnShow);
		if (!IsFirstPrompt)
		{
			HookEvents();
		}
		if (!isActive)
		{
			isActive = false;
			requesterPanel.Display(MessageOnShow, OnMessageOnShowConfirmed);
			MessageOnShow = string.Empty;
			xboxGameControlService.UserChangePolicy = UserChangePolicy.Normal;
		}
	}

	public override void Hide(bool instant = false)
	{
		base.Hide(instant);
		UnhookEvents();
		isActive = false;
	}

	private void UnhookEvents()
	{
		platformService.OnUserSignInMenuClosed -= XboxUserService_UserSignInComplete;
		platformService.OnUserChanged -= XboxUserService_OnUserChanged;
		platformService.OnCurrentUserChanged -= XboxUserService_OnCurrentUserChanged;
		platformService.OnUserSignOutStarted -= PlatformManager_OnUserSignedOutStarted;
		UsersManager.OnUserSignIn -= UsersManager_OnUserSignIn;
	}

	public override void RefreshContent()
	{
		bool flag = !IsFirstPrompt && xboxUserService.CurrentUser != null && UsersManager.IsSomeoneSignedIn;
		base.RefreshContent();
		preMenuLabel.AgeTransform.Visible = (isBeforeMenu || !flag);
		preMenuLabel.Text = ((!IsFirstPrompt || UsersManager.Users.Count <= 0 || !UsersManager.IsSomeoneSignedIn) ? "%XboxMenuNeedSignIn" : "%XboxMenuStart");
		menuLabel.AgeTransform.Visible = !preMenuLabel.AgeTransform.Visible;
		menuLabel.Text = "%XboxMenuSwitchProfile";
		if (flag)
		{
			currentUserLabel.AgeTransform.Visible = true;
			StaticString xboxCurrentUserString = GetXboxCurrentUserString(currentUserLabel.Font);
			if (!string.IsNullOrEmpty(xboxCurrentUserString))
			{
				currentUserLabel.Text = xboxCurrentUserString;
			}
		}
		else
		{
			currentUserLabel.AgeTransform.Visible = false;
		}
	}

	public static StaticString GetXboxCurrentUserString(AgeFont ageFont = null, IXboxUserService xboxUserService = null)
	{
		IXboxUserService xboxUserService2 = xboxUserService ?? Services.GetService<IXboxUserService>();
		StaticString currentUserGamertag = xboxUserService2.CurrentUserGamertag;
		if (!string.IsNullOrEmpty(currentUserGamertag))
		{
			return string.Format(AgeLocalizer.Instance.LocalizeString("%XboxCurrentUser"), currentUserGamertag);
		}
		return string.Empty;
	}

	private int UserSorter(User user1, User user2)
	{
		int num = user1.IsSignedIn.CompareTo(user2.IsSignedIn);
		if (num == 0)
		{
			num = user1.pairedControllerIds.Count.CompareTo(user2.pairedControllerIds.Count);
			if (num == 0)
			{
				num = user1.Index.CompareTo(user2.Index);
			}
		}
		return -num;
	}

	private void UsersManager_OnUserSignIn(int id)
	{
		AuthorizeUnsignedUser = false;
		User user = UsersManager.FindUserById(id);
		if (id != -1 && (user == null || user.IsSignedIn))
		{
			isBeforeMenu = false;
		}
		if (!SingletonManager.Get<GameSelectionPanel>().IsVisible)
		{
			if (IsFirstPrompt)
			{
				EndOfFirstPrompt();
			}
			mainMenuPanel.Show();
		}
	}

	private void XboxUserService_UserSignInComplete(object sender, SignInCompleteEventArgs e)
	{
		if (e.ResultType > 0)
		{
			AuthorizeUnsignedUser = false;
			if (IsFirstPrompt)
			{
				EndOfFirstPrompt();
			}
			RefreshContent();
		}
	}

	public void EndOfFirstPrompt()
	{
		IsFirstPrompt = false;
		xboxGameControlService.UserChangePolicy = UserChangePolicy.Normal;
		mainMenuPanel.Show();
	}

	private void XboxUserService_OnUserChanged(object sender, UserChangedEventArgs e)
	{
		if (e.WasAdded)
		{
			AuthorizeUnsignedUser = false;
		}
		else if (!UsersManager.IsSomeoneSignedIn)
		{
			mainMenuPanel.Show();
		}
	}

	private void HookEvents()
	{
		UnhookEvents();
		platformService.OnUserSignInMenuClosed += XboxUserService_UserSignInComplete;
		platformService.OnUserChanged += XboxUserService_OnUserChanged;
		platformService.OnCurrentUserChanged += XboxUserService_OnCurrentUserChanged;
		platformService.OnUserSignedOut += PlatformManager_OnUserSignedOutStarted;
		UsersManager.OnUserSignIn += UsersManager_OnUserSignIn;
	}

	public void DisplayUnsigned()
	{
		isBeforeMenu = false;
		mainMenuPanel.Hide(instant: true);
		RefreshContent();
	}

	private void OnMessageOnShowConfirmed(RequesterPanel.Result result)
	{
		isActive = true;
	}

	private void XboxUserService_OnCurrentUserChanged(object sender, EventArgs e)
	{
		RefreshContent();
	}

	private void PlatformManager_OnUserSignedOutStarted(object sender, UserChangedEventArgs e)
	{
		IsFirstPrompt = true;
		if (!base.IsVisible)
		{
			Show();
		}
		RefreshContent();
		mainMenuPanel.Hide();
	}

	private void NetworkingService_ConnectionStateChanged(object sender, ConnectionStateChangedEventArgs e)
	{
		if (e.OnlineState == XboxOneOnlineState.Online && string.IsNullOrEmpty(xboxUserService.CurrentUserGamertag))
		{
			xboxUserService.CurrentUser = xboxUserService.CurrentUser;
		}
	}
}
public class XboxModalErrorPanel : GuiModalPanel, IPopupMenuPanel
{
	[SerializeField]
	private AgePrimitiveLabel titleLabel;

	[SerializeField]
	private AgePrimitiveLabel messageLabel;

	private IInputService inputService;

	private IGameControlService gameControlService;

	private Album album;

	public void Display(string message, string title = "%XboxModalErrorPanelTitle")
	{
		titleLabel.Text = title;
		messageLabel.Text = message;
		if (inputService == null)
		{
			inputService = Services.GetService<IInputService>();
		}
		if (album == null)
		{
			album = SingletonManager.Get<Album>();
		}
		if (album != null && album.IsDisplayed)
		{
			album.Focus(display: false);
		}
		Show();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		if (gameControlService == null)
		{
			gameControlService = Services.GetService<IGameControlService>();
		}
		PopupMenuPanel.RegisterPopupMenuPanel(this);
		inputService.BlockControls = true;
		if (gameControlService.CanPauseGame())
		{
			gameControlService.SetGamePause(paused: true);
		}
	}

	protected override IEnumerator OnHide(bool instant)
	{
		yield return base.OnHide(instant);
		PopupMenuPanel.UnregisterPopupMenuPanel(this);
		inputService.BlockControls = false;
	}

	public void OnEscapeBehavior()
	{
	}
}
public class XboxMoviePanel : MoviePanel
{
}
public class GameLoadingScreen : GuiScreen
{
	[SerializeField]
	private LoadingPanel loadingPanel;

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		EndLevelPanel endLevelPanel = SingletonManager.Get<EndLevelPanel>();
		if (endLevelPanel != null)
		{
			endLevelPanel.Hide();
		}
		loadingPanel.Show();
	}
}
public class MainGameScreen : GuiScreen
{
	[SerializeField]
	private DustBarPanel dustBarPanel;

	[SerializeField]
	private TurnPanel turnPanel;

	[SerializeField]
	private HeroListPanel heroListPanel;

	[SerializeField]
	private NotificationPanel notificationPanel;

	[SerializeField]
	private GameOverPanel gameOverPanel;

	[SerializeField]
	private PlayerListPanel playerListPanel;

	[SerializeField]
	private AgePrimitiveLabel foodStockLabel;

	[SerializeField]
	private AgePrimitiveLabel foodProdLabel;

	[SerializeField]
	private AgePrimitiveLabel[] foodFeedbackLabels;

	[SerializeField]
	private AgeModifier foodGlowMod;

	[SerializeField]
	private AgePrimitiveLabel industryStockLabel;

	[SerializeField]
	private AgePrimitiveLabel industryProdLabel;

	[SerializeField]
	private AgePrimitiveLabel[] industryFeedbackLabels;

	[SerializeField]
	private AgeModifier industryGlowMod;

	[SerializeField]
	private AgePrimitiveLabel scienceStockLabel;

	[SerializeField]
	private AgePrimitiveLabel scienceProdLabel;

	[SerializeField]
	private AgePrimitiveLabel[] scienceFeedbackLabels;

	[SerializeField]
	private AgeModifier scienceGlowMod;

	[SerializeField]
	private AgePrimitiveLabel dustStockLabel;

	[SerializeField]
	private AgePrimitiveLabel dustProdLabel;

	[SerializeField]
	private AgePrimitiveLabel[] dustFeedbackLabels;

	[SerializeField]
	private AgeModifier dustGlowMod;

	[SerializeField]
	private GameObject fidsLootFeedbackPfb;

	[SerializeField]
	private AgeControlToggle inventoryToggle;

	[SerializeField]
	private StelePanel stelePanel;

	[SerializeField]
	private Transform moduleSlotHighlightsContainer;

	[SerializeField]
	private Transform steleTimersContainer;

	[SerializeField]
	private Transform heroPlayerNameContainer;

	[SerializeField]
	private Transform situationDialogPnaelContainer;

	[SerializeField]
	private HeroActiveSkillsPanel heroActiveSkillsPanel;

	[SerializeField]
	private HeroPanel heroStatsPanel;

	[SerializeField]
	private LogPanel logPanel;

	[SerializeField]
	private CrystalLiftPanel crystalLiftPanel;

	[SerializeField]
	private ChatPanelInGame chatPanelInGame;

	[SerializeField]
	private float fidsFeedbackDelay;

	[SerializeField]
	private Transform worldPosGUIContainer;

	[SerializeField]
	private AgeTransform xboxRoomPowerIcon;

	private InventoryPanel sharedInventoryPanel;

	private InventoryPanel backPackInventoryPanel;

	private ConstructionPanel constructionPanel;

	private ConstructionControlPanel constructionControlPanel;

	private MerchantPanel merchantPanel;

	private int foodFeedbackLabelIndex;

	private int industryFeedbackLabelIndex;

	private int dustFeedbackLabelIndex;

	private int scienceFeedbackLabelIndex;

	private IInputService inputService;

	private EndLevelPanel endLevelPanel;

	public static InventoryPanel CurrentInventoryPanel
	{
		get;
		set;
	}

	public Transform ModuleSlotHighlightsContainerTfm => moduleSlotHighlightsContainer;

	public Transform HeroPlayerNameContainerTfm => heroPlayerNameContainer;

	public Transform WorldPosGUIContainer => worldPosGUIContainer;

	public Transform SituationDialogPanelContainer => situationDialogPnaelContainer;

	public Transform SteleTimersContainer => steleTimersContainer;

	public InventoryPanel BackpackInventoryPanel => backPackInventoryPanel;

	public InventoryPanel SharedInventoryPanel => sharedInventoryPanel;

	public MerchantPanel MerchantPanel => merchantPanel;

	public AgeTransform XboxRoomPowerIcon => xboxRoomPowerIcon;

	protected override void Awake()
	{
		base.Awake();
		inputService = Services.GetService<IInputService>();
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		if (dungeon == null)
		{
			Diagnostics.LogError("Trying to refresh MainGameScreen while there is no Dungeon");
			return;
		}
		foodStockLabel.Text = Mathf.Floor(Player.LocalPlayer.FoodStock).ToString();
		foodProdLabel.Text = "+ " + dungeon.GetFoodProd().ToString();
		industryStockLabel.Text = Mathf.Floor(Player.LocalPlayer.IndustryStock).ToString();
		industryProdLabel.Text = "+ " + dungeon.GetIndustryProd().ToString();
		scienceStockLabel.Text = Mathf.Floor(Player.LocalPlayer.ScienceStock).ToString();
		scienceProdLabel.Text = "+ " + dungeon.GetScienceProd().ToString();
		dustStockLabel.Text = Mathf.Floor(dungeon.DustStock).ToString();
		float dustProd = dungeon.GetDustProd();
		dustProdLabel.Text = ((!(dustProd > 0f)) ? string.Empty : ("+ " + dustProd.ToString()));
	}

	public void AddFIDSFeedback(float bonusValue, FIDS fidsType)
	{
		DisplayFIDSFeedback(bonusValue, fidsType);
	}

	public void DisplayFIDSGameFeedback(float bonusValue, StaticString fidsType, Transform gameTfm)
	{
		DisplayFIDSGameFeedback(((!(bonusValue > 0f)) ? string.Empty : "+") + bonusValue.ToString(), fidsType, gameTfm);
	}

	public void DisplayFIDSGameFeedback(string bonusValueStr, StaticString fidsType, Transform gameTfm)
	{
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(fidsLootFeedbackPfb, Vector3.zero, Quaternion.identity);
		gameObject.transform.parent = base.transform;
		gameObject.GetComponent<FIDSLootFeedbackItem>().Init(bonusValueStr, fidsType, gameTfm);
	}

	public void OnMenuButtonClick()
	{
		SingletonManager.Get<GameMenuPanel>().ToggleVisibility(false);
	}

	public void OnInventoryButtonClick()
	{
		Services.GetService<IGameControlService>().SetHeroStatsPanelDisplay(inventoryToggle.State, inventoryToggle.State);
	}

	public void OnPlayerListButtonClick()
	{
		if (playerListPanel.IsVisible)
		{
			playerListPanel.Hide();
		}
		else
		{
			playerListPanel.Show();
		}
	}

	public void CloseConcurrentInventoryPanel(InventoryPanel panel)
	{
		if (CurrentInventoryPanel != null && panel != CurrentInventoryPanel)
		{
			CurrentInventoryPanel.Hide();
		}
	}

	public void DisplayInventoryPanel(InventoryPanel panel, params object[] parameters)
	{
		EquipmentSlot[] item = null;
		if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard && Hero.SelectedHeroes.Count == 1)
		{
			item = Hero.SelectedHeroes[0].EquipmentSlots;
		}
		List<object> list = parameters.ToList();
		list.Add(item);
		parameters = list.ToArray();
		if (CurrentInventoryPanel != null)
		{
			if (panel == CurrentInventoryPanel)
			{
				panel.Bind(parameters);
				panel.RefreshContent();
			}
			else
			{
				CurrentInventoryPanel.Hide();
				panel.ShowWhenFinishedHiding(parameters);
			}
		}
		else
		{
			panel.ShowWhenFinishedHiding(parameters);
		}
	}

	public void ToggleSharedInventoryPanel()
	{
		SetSharedInventoryPanelDisplay(!inventoryToggle.State);
	}

	public void SetSharedInventoryPanelDisplay(bool display)
	{
		if (CurrentInventoryPanel == null || CurrentInventoryPanel == SharedInventoryPanel)
		{
			if (inventoryToggle.State != display)
			{
				inventoryToggle.State = display;
			}
			Services.GetService<IGameControlService>().SetSharedInventoryPanelDisplay(inventoryToggle.State);
		}
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		heroListPanel.Show(parameters);
		dustBarPanel.Show(parameters);
		turnPanel.Show(parameters);
		if ((bool)constructionPanel)
		{
			constructionPanel.Show(parameters);
		}
		else if ((bool)constructionControlPanel)
		{
			constructionControlPanel.Show(parameters);
		}
		notificationPanel.Show(parameters);
		logPanel.Show(parameters);
		chatPanelInGame.ShowIfAvailable();
		gameOverPanel.Hide();
		IGameEventService gameEventManager = Services.GetService<IGameEventService>();
		gameEventManager.OnDungeonFIDSChanged += OnDungeonFIDSChanged;
		base.NeedRefresh = true;
	}

	protected override IEnumerator OnHide(bool instant)
	{
		base.NeedRefresh = false;
		yield return base.OnHide(instant);
		heroListPanel.Hide(instant);
		dustBarPanel.Hide(instant);
		turnPanel.Hide(instant);
		if (constructionPanel != null)
		{
			constructionPanel.Hide(instant);
		}
		else if (constructionControlPanel != null)
		{
			constructionControlPanel.Hide(instant);
		}
		crystalLiftPanel.Hide(instant);
		logPanel.Hide(instant);
		chatPanelInGame.Hide(instant);
		heroStatsPanel.Hide(instant);
		if (endLevelPanel == null)
		{
			endLevelPanel = SingletonManager.Get<EndLevelPanel>();
		}
		if (!endLevelPanel.IsVisible)
		{
			notificationPanel.Hide(instant);
		}
	}

	protected override IEnumerator OnLoad()
	{
		sharedInventoryPanel = SingletonManager.Get<InventoryPanel>();
		backPackInventoryPanel = sharedInventoryPanel.GetComponentInChildren<SubInventoryPanel>();
		base.UseRefreshLoop = true;
		base.RefreshDelay = 0.25f;
		dustBarPanel.Load();
		heroListPanel.Load();
		turnPanel.Load();
		notificationPanel.Load();
		gameOverPanel.Load();
		sharedInventoryPanel.Load();
		playerListPanel.Load();
		if (BackpackInventoryPanel != null)
		{
			BackpackInventoryPanel.Load();
		}
		merchantPanel = SingletonManager.Get<MerchantPanel>();
		merchantPanel.Load();
		SingletonManager.Get<ResearchPanel>().Load();
		SingletonManager.Get<ResearchingPanel>().Load();
		stelePanel.Load();
		heroActiveSkillsPanel.Load();
		heroStatsPanel.Load();
		logPanel.Load();
		crystalLiftPanel.Load();
		if (inputService.CurrentControlScheme == ControlScheme.MouseAndKeyboard)
		{
			constructionPanel = SingletonManager.Get<ConstructionPanel>();
		}
		else if (inputService.CurrentControlScheme == ControlScheme.XBoxOneController)
		{
			constructionControlPanel = SingletonManager.Get<ConstructionControlPanel>();
		}
		inventoryToggle.State = false;
		yield return base.OnLoad();
	}

	private void DisplayFIDSFeedback(float bonusValue, AgePrimitiveLabel label, AgeModifier glowMod)
	{
		label.Text = bonusValue.RoundWithDecimals(2).ToString("+######0.##;-######0.##;+0");
		label.AgeTransform.ResetAllModifiers();
		label.AgeTransform.StartAllModifiers();
		glowMod.StartAnimation();
	}

	private void DisplayFIDSFeedback(float bonusValue, FIDS fidsType)
	{
		AgePrimitiveLabel label = null;
		AgeModifier glowMod = null;
		switch (fidsType)
		{
		case FIDS.Dust:
			label = dustFeedbackLabels[dustFeedbackLabelIndex];
			dustFeedbackLabelIndex = (dustFeedbackLabelIndex + 1) % dustFeedbackLabels.Length;
			glowMod = dustGlowMod;
			break;
		case FIDS.Food:
			label = foodFeedbackLabels[foodFeedbackLabelIndex];
			foodFeedbackLabelIndex = (foodFeedbackLabelIndex + 1) % foodFeedbackLabels.Length;
			glowMod = foodGlowMod;
			break;
		case FIDS.Industry:
			label = industryFeedbackLabels[industryFeedbackLabelIndex];
			industryFeedbackLabelIndex = (industryFeedbackLabelIndex + 1) % industryFeedbackLabels.Length;
			glowMod = industryGlowMod;
			break;
		case FIDS.Science:
			label = scienceFeedbackLabels[scienceFeedbackLabelIndex];
			scienceFeedbackLabelIndex = (scienceFeedbackLabelIndex + 1) % scienceFeedbackLabels.Length;
			glowMod = scienceGlowMod;
			break;
		}
		DisplayFIDSFeedback(bonusValue, label, glowMod);
	}

	private void OnDungeonFIDSChanged()
	{
		base.NeedRefresh = true;
	}
}
public class MainMenuScreen : GuiScreen
{
	[SerializeField]
	private MainMenuPanel mainMenuPanel;

	[SerializeField]
	private XboxMainMenuPanel mainMenuPanelXbox;

	private IGameCameraService gameCameraService;

	protected override IEnumerator OnLoad()
	{
		mainMenuPanel.Load();
		yield return base.OnLoad();
		if (DungeonsApplication.CommandLineArguments.ConnectLobby != 0L)
		{
			Steamworks.SteamID steamIDLobby = new Steamworks.SteamID(DungeonsApplication.CommandLineArguments.ConnectLobby);
			if (steamIDLobby.IsValid)
			{
				IGameControlService gameControlManager = Services.GetService<IGameControlService>();
				gameControlManager.JoinMultiplayerGame(steamIDLobby, checkLobbyType: false);
				DungeonsApplication.CommandLineArguments.ConnectLobby = 0uL;
			}
		}
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		while (DungeonsApplication.IsFreeingMemory)
		{
			Diagnostics.Log("Waiting for application memory to be freed...");
			yield return null;
		}
		if (gameCameraService == null)
		{
			gameCameraService = Services.GetService<IGameCameraService>();
		}
		if (gameCameraService.IsTacticalMapActive())
		{
			gameCameraService.SwitchToGameCamera();
		}
		if (!SingletonManager.Get<GameSelectionPanel>().IsVisible && !SingletonManager.Get<JournalPanel>().IsVisible)
		{
			mainMenuPanel.Show();
		}
		Diagnostics.Log("Show main menu screen");
		CommunityEventConfig activeCommEventCfg = SingletonManager.Get<PrivateGameConfigManager>().GetActiveCommunityEventConfig();
		if (activeCommEventCfg != null && !string.IsNullOrEmpty(activeCommEventCfg.disclaimerAckRegistryKey) && !Amplitude.Unity.Framework.Application.Registry.GetValue(activeCommEventCfg.disclaimerAckRegistryKey, defaultValue: false))
		{
			SingletonManager.Get<DisclaimerPanel>().Display(AgeLocalizer.Instance.LocalizeString(activeCommEventCfg.disclaimerTitle), AgeLocalizer.Instance.LocalizeString(activeCommEventCfg.disclaimerMessage), activeCommEventCfg.disclaimerMoreInfoURL);
			Amplitude.Unity.Framework.Application.Registry.SetValue(activeCommEventCfg.disclaimerAckRegistryKey, value: true);
		}
		if (Steamworks.SteamAPI.SteamUtils == null)
		{
			SingletonManager.Get<WarningPanel>().SetContentAndShow("%NoSteam_Message", "%NoSteam_Title");
		}
		if (HashManager.IsHashDifferent)
		{
			SingletonManager.Get<WarningPanel>().SetContentAndShow("%DifferentHash_Message", "%DifferentHash_Title");
		}
	}
}
public class SkillEffectItem : MonoBehaviour
{
	[SerializeField]
	private AgePrimitiveLabel label;

	public void RefreshContent(string effectStr)
	{
		label.AgeTransform.Height = 0f;
		label.ForceText(effectStr);
		GetComponent<AgeTransform>().Height = label.AgeTransform.Height + label.AgeTransform.PixelMarginTop + label.AgeTransform.PixelMarginBottom;
	}
}
public class SkillEffectPanel : GuiPanel
{
	[SerializeField]
	private AgePrimitiveLabel label;

	private string effectStr;

	public void Bind(string effectStr)
	{
		this.effectStr = effectStr;
	}

	public override void RefreshContent()
	{
		base.RefreshContent();
		label.Text = effectStr;
		label.ComputeText();
		base.AgeTransform.Height = label.Font.LineHeight * (float)label.TextLines.Count + label.AgeTransform.PixelMarginTop;
	}
}
public class TextMeshModifier : MonoBehaviour
{
	[SerializeField]
	private string locKey;

	[SerializeField]
	private int maxLineLength = -1;

	private TextMesh textMesh;

	[ContextMenu("Format text")]
	public void FormatText()
	{
		textMesh = GetComponent<TextMesh>();
		textMesh.text = AgeLocalizer.Instance.LocalizeString(locKey);
		if (maxLineLength <= 0)
		{
			return;
		}
		char c = ' ';
		char c2 = '\n';
		string[] array = textMesh.text.Split(c);
		textMesh.text = string.Empty;
		string text = string.Empty;
		foreach (string text2 in array)
		{
			if (text.Length + text2.Length > maxLineLength)
			{
				TextMesh obj = textMesh;
				obj.text = obj.text + text + c2;
				text = string.Empty;
			}
			text = text + text2 + c;
		}
		TextMesh obj2 = textMesh;
		obj2.text = obj2.text + text + c2;
	}
}
public class GuiBluePrintTooltip : GuiPanelFeature
{
	[SerializeField]
	private AgePrimitiveLabel titleLabel;

	[SerializeField]
	private AgeTransform titleContainer;

	[SerializeField]
	private AgeTransform effectsContainer;

	[SerializeField]
	private Transform effectPrefab;

	[SerializeField]
	private AgePrimitiveLabel descriptionLabel;

	[SerializeField]
	private AgeTransform descriptionContainer;

	[SerializeField]
	private AgePrimitiveLabel buildCostLabel;

	[SerializeField]
	private AgeTransform buildCostContainer;

	[SerializeField]
	private int maxDecimals;

	private BluePrintConfig bluePrintContext;

	public override StaticString InternalName
	{
		get
		{
			return "BluePrint";
		}
		protected set
		{
		}
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		bluePrintContext = (context as BluePrintConfig);
		if (!base.GuiService.GuiPanelHelper.TryGetGuiElement(bluePrintContext.Name, out GuiElement guiElement))
		{
			titleLabel.Text = "Missing GuiElement: " + bluePrintContext.Name;
			Hide(instant: true);
			yield break;
		}
		base.AgeTransform.Height = base.AgeTransform.VerticalMargin;
		RefreshTitle(guiElement);
		RefreshEffectsList();
		RefreshDescription(guiElement);
		RefreshBuildCost();
		base.AgeTransform.Height = base.AgeTransform.Height - base.AgeTransform.VerticalSpacing + base.AgeTransform.VerticalMargin;
		yield return base.OnShow(parameters);
	}

	protected override IEnumerator OnHide(bool instant)
	{
		bluePrintContext = null;
		yield return base.OnHide(instant);
	}

	private List<string> GetEffectListFromSim()
	{
		List<string> list = new List<string>();
		SimulationObject moduleSimObj = bluePrintContext.GetModuleSimObj();
		foreach (SimulationProperty property in moduleSimObj.Properties)
		{
			string text = AgeLocalizer.Instance.LocalizeStringDefaults("%Module_Prop_" + property.Name, null);
			if (!string.IsNullOrEmpty(text))
			{
				float num = property.Value;
				if (num != property.BaseValue)
				{
					if (property.Name.ToString().EndsWith("Percent"))
					{
						num = GenericUtilities.RoundHalfAwayFromZero(100f * num);
					}
					list.Add(text.Replace("$Value", ((float)Math.Round(num, maxDecimals)).ToString()));
				}
			}
		}
		if (!string.IsNullOrEmpty(bluePrintContext.AdditionalLocalizationKey))
		{
			list.Add(AgeTooltip.ParseEffectString(bluePrintContext.AdditionalLocalizationKey, moduleSimObj));
		}
		return list;
	}

	private void RefreshTitle(GuiElement guiElement)
	{
		titleLabel.Text = AgeLocalizer.Instance.LocalizeString(guiElement.Title);
		titleContainer.Y = base.AgeTransform.Height;
		base.AgeTransform.Height += titleContainer.Height + base.AgeTransform.VerticalSpacing;
	}

	private void RefreshEffectsList()
	{
		List<string> effectListFromSim = GetEffectListFromSim();
		effectsContainer.Height = 0f;
		effectsContainer.ReserveChildren(effectListFromSim.Count, effectPrefab, "Effect");
		effectsContainer.RefreshChildrenIList(effectListFromSim, RefreshEffect);
		effectsContainer.Height = effectsContainer.Height - effectsContainer.VerticalSpacing + effectsContainer.VerticalMargin;
		effectsContainer.Y = base.AgeTransform.Height;
		base.AgeTransform.Height += effectsContainer.Height + base.AgeTransform.VerticalSpacing;
	}

	private void RefreshDescription(GuiElement guiElement)
	{
		descriptionLabel.Text = AgeLocalizer.Instance.LocalizeString(guiElement.Description);
		descriptionContainer.Height = descriptionLabel.AgeTransform.Height + descriptionLabel.AgeTransform.PixelMarginTop + descriptionLabel.AgeTransform.PixelMarginBottom;
		descriptionContainer.Y = base.AgeTransform.Height;
		base.AgeTransform.Height += descriptionContainer.Height + base.AgeTransform.VerticalSpacing;
	}

	private void RefreshBuildCost()
	{
		float industryCost = bluePrintContext.GetModuleConfig().GetIndustryCost();
		buildCostLabel.Text = AgeLocalizer.Instance.LocalizeString("%BluePrintBuildCostTitle").Replace("$industryCost", industryCost.ToString());
		buildCostContainer.Y = base.AgeTransform.Height;
		base.AgeTransform.Height += buildCostContainer.Height + base.AgeTransform.VerticalSpacing;
	}

	private void RefreshEffect(AgeTransform tableItem, string effectStr, int index)
	{
		SkillEffectItem component = tableItem.GetComponent<SkillEffectItem>();
		component.RefreshContent(effectStr);
		tableItem.Y = effectsContainer.Height;
		effectsContainer.Height += tableItem.Height + effectsContainer.VerticalSpacing;
	}
}
public class GuiHeroSelectionTooltip : GuiPanelFeature
{
	[SerializeField]
	private CompetitorSlot competitorSlot;

	private HeroGameStatsData heroGameStats;

	public override StaticString InternalName
	{
		get
		{
			return "HeroSelection";
		}
		protected set
		{
		}
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		heroGameStats = UserProfile.Data.HeroesGameStats.FirstOrDefault((HeroGameStatsData s) => s.ConfigName == content);
		competitorSlot.UpdateHero(heroGameStats, tooltipMode: true);
		yield return base.OnShow(parameters);
	}
}
public class GuiItemHeroTooltip : GuiPanelFeature
{
	public AgePrimitiveLabel ItemName;

	public AgePrimitiveLabel ItemDescription;

	public AgeTransform ItemEffectsTable;

	public Transform ItemEffectPrefab;

	public AgeTransform NameContainer;

	public AgeTransform DescriptionContainer;

	private InventoryItem itemContext;

	public override StaticString InternalName
	{
		get
		{
			return "ItemHero";
		}
		protected set
		{
		}
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		itemContext = (context as InventoryItem);
		IGuiPanelHelper helper = base.GuiService.GuiPanelHelper;
		GuiElement itemElement = null;
		DescriptionContainer.Height = 0f;
		if (helper.TryGetGuiElement((!itemContext.IsGift) ? itemContext.ItemConfig.Name.ToString() : "Gift", out itemElement))
		{
			ItemName.Text = AgeLocalizer.Instance.LocalizeString(itemElement.Title);
			ItemDescription.Text = AgeLocalizer.Instance.LocalizeString(itemElement.Description);
		}
		List<SimulationProperty> propertiesToDisplay = new List<SimulationProperty>();
		if (!itemContext.IsGift)
		{
			for (int i = 0; i < itemContext.SimulationObject.Properties.Count; i++)
			{
				if (!(itemContext.SimulationObject.Properties.Data[i].Name == SimulationProperties.Cost) && !(itemContext.SimulationObject.Properties.Data[i].Name == SimulationProperties.SellingCost) && !(itemContext.SimulationObject.Properties.Data[i].Name == SimulationProperties.AttackRange) && itemContext.SimulationObject.Properties.Data[i].ModifierProviders != null && itemContext.SimulationObject.Properties.Data[i].ModifierProviders.Count > 0)
				{
					propertiesToDisplay.Add(itemContext.SimulationObject.Properties.Data[i]);
				}
			}
		}
		ItemEffectsTable.Height = 0f;
		ItemEffectsTable.ReserveChildren(propertiesToDisplay.Count, ItemEffectPrefab, "ItemEffect");
		ItemEffectsTable.RefreshChildrenIList(propertiesToDisplay, RefreshItemEffect);
		if (!string.IsNullOrEmpty(ItemDescription.Text))
		{
			ItemDescription.ComputeText();
			DescriptionContainer.Height = ItemDescription.AgeTransform.Height + ItemDescription.AgeTransform.PixelMarginTop + ItemDescription.AgeTransform.PixelMarginBottom;
			base.AgeTransform.Height = NameContainer.Height + DescriptionContainer.Height + ItemEffectsTable.Height - ItemEffectsTable.VerticalSpacing;
			DescriptionContainer.Visible = true;
		}
		else
		{
			base.AgeTransform.Height = NameContainer.Height + ItemEffectsTable.Height;
			DescriptionContainer.Visible = false;
		}
		yield return base.OnShow(parameters);
	}

	protected override IEnumerator OnHide(bool instant)
	{
		itemContext = null;
		yield return base.OnHide(instant);
	}

	private void RefreshItemEffect(AgeTransform tableItem, SimulationProperty property, int index)
	{
		GuiItemHeroEffectPanel component = tableItem.GetComponent<GuiItemHeroEffectPanel>();
		if (component != null)
		{
			component.Bind(property);
			component.RefreshContent();
			ItemEffectsTable.Height += tableItem.Height + ItemEffectsTable.VerticalSpacing;
		}
	}
}
public class GuiSkillTooltip : GuiPanelFeature
{
	[SerializeField]
	private AgePrimitiveLabel titleLabel;

	[SerializeField]
	private AgeTransform titleContainer;

	[SerializeField]
	private AgeTransform effectsContainer;

	[SerializeField]
	private Transform effectPrefab;

	[SerializeField]
	private AgePrimitiveLabel descriptionLabel;

	[SerializeField]
	private AgeTransform descriptionContainer;

	[SerializeField]
	private AgePrimitiveLabel durationLabel;

	[SerializeField]
	private AgeTransform durationContainer;

	[SerializeField]
	private AgePrimitiveLabel cooldownLabel;

	[SerializeField]
	private AgeTransform cooldownContainer;

	private Skill skillContext;

	public override StaticString InternalName
	{
		get
		{
			return "Skill";
		}
		protected set
		{
		}
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		skillContext = (context as Skill);
		if (!base.GuiService.GuiPanelHelper.TryGetGuiElement(skillContext.Config.BaseName, out GuiElement guiElement))
		{
			titleLabel.Text = "Missing GuiElement: " + skillContext.Config.BaseName;
			Hide(instant: true);
			yield break;
		}
		base.AgeTransform.Height = base.AgeTransform.VerticalMargin;
		RefreshTitle(guiElement);
		RefreshEffectsList();
		RefreshDuration();
		RefreshCoolDown();
		RefreshDescription(guiElement);
		base.AgeTransform.Height = base.AgeTransform.Height - base.AgeTransform.VerticalSpacing + base.AgeTransform.VerticalMargin;
		yield return base.OnShow(parameters);
	}

	protected override IEnumerator OnHide(bool instant)
	{
		skillContext = null;
		yield return base.OnHide(instant);
	}

	private List<string> GetEffectListFromSim(SimulationObject skillSimObj, SimulationDescriptor simDesc, string forcedPath = null)
	{
		List<string> list = new List<string>();
		Dictionary<StaticString, float> dictionary = new Dictionary<StaticString, float>();
		SimulationModifierDescriptor[] simulationModifierDescriptors = simDesc.SimulationModifierDescriptors;
		foreach (SimulationModifierDescriptor simulationModifierDescriptor in simulationModifierDescriptors)
		{
			float num = simulationModifierDescriptor.ComputeValue(skillSimObj, skillSimObj, SimulationPropertyRefreshContext.GetContext());
			if (simulationModifierDescriptor.Operation == SimulationModifierDescriptor.ModifierOperation.Percent)
			{
				num = GenericUtilities.RoundHalfAwayFromZero(100f * num);
			}
			string text = simulationModifierDescriptor.TargetPropertyName + "_" + simulationModifierDescriptor.Path;
			if (dictionary.ContainsKey(text))
			{
				Diagnostics.LogError("Tooltip value already present: key=" + text + ", value=" + num);
			}
			else
			{
				dictionary.Add(text, num);
			}
		}
		SimulationModifierDescriptor[] simulationModifierDescriptors2 = simDesc.SimulationModifierDescriptors;
		foreach (SimulationModifierDescriptor simulationModifierDescriptor2 in simulationModifierDescriptors2)
		{
			string text2 = AgeLocalizer.Instance.LocalizeStringDefaults("%Skill_Effect_" + (string)simulationModifierDescriptor2.TargetPropertyName + "_" + simulationModifierDescriptor2.Operation, null);
			if (string.IsNullOrEmpty(text2))
			{
				continue;
			}
			string text3 = AgeLocalizer.Instance.LocalizeString("%Skill_Effect_On_" + ((forcedPath == null) ? simulationModifierDescriptor2.Path.ToString() : forcedPath));
			text3 = text3.Replace("$ModEffect", text2);
			while (text3.Contains("$Value_"))
			{
				int num2 = text3.IndexOf("$Value_");
				int num3 = text3.IndexOf(' ', num2);
				if (num3 == -1)
				{
					num3 = text3.IndexOf(')', num2);
				}
				string text4 = (num3 <= -1) ? text3.Substring(num2) : text3.Substring(num2, num3 - num2);
				string text5 = text4.Replace("$Value_", string.Empty) + "_" + simulationModifierDescriptor2.Path;
				if (dictionary.ContainsKey(text5))
				{
					text3 = text3.Replace(text4, dictionary[text5].ToString());
				}
				else
				{
					Diagnostics.LogError("GuiSkillTooltip.GetEffectListFromSim: unable to find value for key \"" + text5 + "\"");
				}
			}
			string text6 = (string)simulationModifierDescriptor2.TargetPropertyName + "_" + simulationModifierDescriptor2.Path;
			if (dictionary.ContainsKey(text6))
			{
				float num = dictionary[text6];
				string text7 = num.ToString();
				SimulationModifierDescriptor.ModifierOperation operation = simulationModifierDescriptor2.Operation;
				if (operation == SimulationModifierDescriptor.ModifierOperation.Addition || operation == SimulationModifierDescriptor.ModifierOperation.Percent)
				{
					text7 = ((!(num > 0f)) ? string.Empty : "+") + text7;
				}
				text3 = text3.Replace("$Value", text7);
			}
			else
			{
				Diagnostics.LogError("GuiSkillTooltip.GetEffectListFromSim: unable to find value for key \"" + text6 + "\"");
			}
			list.Add(text3);
		}
		if (!string.IsNullOrEmpty(skillContext.Config.AdditionalLocalizationKey))
		{
			list.Add(AgeTooltip.ParseEffectString(skillContext.Config.AdditionalLocalizationKey, skillSimObj));
		}
		return list;
	}

	private void RefreshTitle(GuiElement guiElement)
	{
		titleLabel.Text = AgeLocalizer.Instance.LocalizeString(guiElement.Title);
		if (skillContext.Config.Level > 1)
		{
			AgePrimitiveLabel agePrimitiveLabel = titleLabel;
			agePrimitiveLabel.Text = agePrimitiveLabel.Text + " " + skillContext.Config.Level.ToString();
		}
		titleContainer.Y = base.AgeTransform.Height;
		base.AgeTransform.Height += titleContainer.Height + base.AgeTransform.VerticalSpacing;
	}

	private void RefreshEffectsList()
	{
		List<string> list = new List<string>();
		SimulationObject simObj = skillContext.GetSimObj();
		if (skillContext.OwnerSimDesc != null)
		{
			list.AddRange(GetEffectListFromSim(simObj, skillContext.OwnerSimDesc));
		}
		if (skillContext.TargetSimDesc != null)
		{
			list.AddRange(GetEffectListFromSim(simObj, skillContext.TargetSimDesc, "Target"));
		}
		effectsContainer.Height = 0f;
		effectsContainer.ReserveChildren(list.Count, effectPrefab, "Effect");
		effectsContainer.RefreshChildrenIList(list, RefreshEffect);
		effectsContainer.Height = effectsContainer.Height - effectsContainer.VerticalSpacing + effectsContainer.VerticalMargin;
		effectsContainer.Y = base.AgeTransform.Height;
		base.AgeTransform.Height += effectsContainer.Height + base.AgeTransform.VerticalSpacing;
	}

	private void RefreshDuration()
	{
		if (skillContext.Config.Duration > 0f)
		{
			durationLabel.Text = AgeLocalizer.Instance.LocalizeString("%DurationFormat").Replace("$Value", skillContext.Config.Duration.ToString());
			durationContainer.Visible = true;
			durationContainer.Y = base.AgeTransform.Height;
			base.AgeTransform.Height += durationContainer.Height + base.AgeTransform.VerticalSpacing;
		}
		else
		{
			durationContainer.Visible = false;
		}
	}

	private void RefreshCoolDown()
	{
		if (skillContext.Config.CooldownTurnsCount > 0)
		{
			cooldownLabel.Text = AgeLocalizer.Instance.LocalizeString("%TurnCount").Replace("$Turn", skillContext.Config.CooldownTurnsCount.ToString());
			cooldownContainer.Visible = true;
			cooldownContainer.Y = base.AgeTransform.Height;
			base.AgeTransform.Height += cooldownContainer.Height + base.AgeTransform.VerticalSpacing;
		}
		else
		{
			cooldownContainer.Visible = false;
		}
	}

	private void RefreshDescription(GuiElement guiElement)
	{
		descriptionLabel.ForceText(AgeLocalizer.Instance.LocalizeString(guiElement.Description));
		descriptionContainer.Height = descriptionLabel.AgeTransform.Height + descriptionLabel.AgeTransform.PixelMarginTop + descriptionLabel.AgeTransform.PixelMarginBottom;
		descriptionContainer.Y = base.AgeTransform.Height;
		base.AgeTransform.Height += descriptionContainer.Height + base.AgeTransform.VerticalSpacing;
	}

	private void RefreshEffect(AgeTransform tableItem, string effectDescription, int index)
	{
		SkillEffectItem component = tableItem.GetComponent<SkillEffectItem>();
		component.RefreshContent(effectDescription);
		tableItem.Y = effectsContainer.Height;
		effectsContainer.Height += tableItem.Height + effectsContainer.VerticalSpacing;
	}
}
public interface IDescriptionFeatureProvider
{
	string Description
	{
		get;
	}
}
public class PanelFeatureDescription : GuiPanelFeature
{
	public AgePrimitiveLabel Description;

	public override StaticString InternalName
	{
		get
		{
			return "Description";
		}
		protected set
		{
		}
	}

	public float DefaultWidth
	{
		get;
		set;
	}

	protected override void Awake()
	{
		base.Awake();
		DefaultWidth = base.AgeTransform.Width;
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		Description.AgeTransform.Height = 0f;
		Description.AgeTransform.Width = DefaultWidth - Description.AgeTransform.PixelMarginLeft - Description.AgeTransform.PixelMarginRight;
		if (content.StartsWith("%"))
		{
			Description.ForceText(AgeLocalizer.Instance.LocalizeString(content));
		}
		else if (context is IDescriptionFeatureProvider)
		{
			Description.ForceText(AgeLocalizer.Instance.LocalizeString((context as IDescriptionFeatureProvider).Description));
		}
		else
		{
			IGuiEntity guiEntity = context as IGuiEntity;
			GuiElement guiElement;
			if (context != null && guiEntity != null && guiEntity.Gui != null)
			{
				Description.ForceText(AgeLocalizer.Instance.LocalizeString(guiEntity.Gui.Description));
			}
			else if (base.GuiService.GuiPanelHelper.TryGetGuiElement(content, out guiElement))
			{
				Description.ForceText(AgeLocalizer.Instance.LocalizeString(guiElement.Description));
			}
			else
			{
				Description.ForceText(AgeLocalizer.Instance.LocalizeString(content));
			}
		}
		if (!string.IsNullOrEmpty(Description.Text))
		{
			base.AgeTransform.Height = Description.AgeTransform.Height + Description.AgeTransform.PixelMarginTop + Description.AgeTransform.PixelMarginBottom;
			if (Description.TextLines.Count == 1)
			{
				base.AgeTransform.Width = Description.Font.ComputeTextWidth(Description.TextLines[0]) + Description.AgeTransform.PixelMarginLeft + Description.AgeTransform.PixelMarginRight;
			}
			else
			{
				base.AgeTransform.Width = DefaultWidth;
			}
		}
		yield return base.OnShow(parameters);
	}
}
public class GuiEffectItem : MonoBehaviour
{
	public AgePrimitiveLabel Value;

	public void SetContent(EffectDescription elementDescription)
	{
		Value.AgeTransform.Height = 0f;
		Value.Text = string.Empty;
		if (elementDescription != null)
		{
			Value.Text = elementDescription.ToString();
		}
	}
}
public class GuiEffectMapper : MonoBehaviour
{
	public AgeTransform EffectsList;

	public float HorizontalMargin = 8f;

	public Transform EffectPrefab;

	protected float height;

	protected AgeTransform.RefreshTableItem<EffectDescription> refreshEffectMapperElementDelegate;

	public IGuiService GuiService
	{
		get;
		set;
	}

	public void Initialize(IGuiService guiService)
	{
		GuiService = guiService;
		refreshEffectMapperElementDelegate = RefreshEffectMapperElement;
	}

	public virtual void LoadEffects(List<EffectDescription> effectMapperElements)
	{
		if (effectMapperElements != null && effectMapperElements.Count > 0)
		{
			height = 0f;
			EffectsList.ReserveChildren(effectMapperElements.Count, EffectPrefab);
			EffectsList.RefreshChildrenIList(effectMapperElements, refreshEffectMapperElementDelegate);
			EffectsList.Height = height;
		}
		else
		{
			UnloadEffects();
		}
	}

	public void UnloadEffects()
	{
		EffectsList.Height = 0f;
		List<AgeTransform> children = EffectsList.GetChildren();
		for (int i = 0; i < children.Count; i++)
		{
			children[i].Alpha = 0f;
		}
	}

	public void ParseTooltipEffects(GuiElement guiElement)
	{
	}

	protected virtual void RefreshEffectMapperElement(AgeTransform tableitem, EffectDescription elementDescription, int index)
	{
		GuiEffectItem component = tableitem.GetComponent<GuiEffectItem>();
		component.SetContent(elementDescription);
		component.Value.AgeTransform.X = HorizontalMargin;
		component.Value.AgeTransform.Y = height;
		height += component.Value.AgeTransform.Height;
		float num = Mathf.Floor(component.Value.AgeTransform.Height * 0.5f);
		if (num * 2f != component.Value.AgeTransform.Height)
		{
			height += 1f;
		}
	}
}
public interface IDescriptorEffectProvider
{
	StaticString DefaultClass
	{
		get;
	}

	IEnumerable<SimulationDescriptor> GetDescriptors();
}
public class PanelFeatureEffects : GuiPanelFeature
{
	public AgePrimitiveLabel Title;

	public GuiEffectMapper EffectMapper;

	protected SimulationEffectParser simulationEffectParser;

	public bool DisplayTitle
	{
		get;
		set;
	}

	public override StaticString InternalName
	{
		get
		{
			return "Effects";
		}
		protected set
		{
		}
	}

	protected override IEnumerator OnLoad()
	{
		yield return base.OnLoad();
		DisplayTitle = true;
		EffectMapper.Initialize(base.GuiService);
		simulationEffectParser = new SimulationEffectParser
		{
			GuiService = base.GuiService
		};
		Enable();
	}

	protected override IEnumerator OnShow(params object[] parameters)
	{
		if (DisplayTitle && !Title.AgeTransform.Visible)
		{
			EffectMapper.EffectsList.PixelMarginTop += Title.AgeTransform.Height;
			Title.AgeTransform.Visible = true;
		}
		else if (!DisplayTitle && Title.AgeTransform.Visible)
		{
			EffectMapper.EffectsList.PixelMarginTop -= Title.AgeTransform.Height;
			Title.AgeTransform.Visible = false;
		}
		base.AgeTransform.Height = EffectMapper.EffectsList.PixelOffsetTop + EffectMapper.EffectsList.PixelMarginTop + EffectMapper.EffectsList.Height + EffectMapper.EffectsList.PixelMarginBottom + EffectMapper.EffectsList.PixelOffsetBottom;
		if (EffectMapper.EffectsList.Height == 0f)
		{
			Title.Text = AgeLocalizer.Instance.LocalizeString("%FeatureNoEffectsTitle");
		}
		else
		{
			Title.Text = AgeLocalizer.Instance.LocalizeString("%FeatureEffectsTitle");
		}
		yield return base.OnShow(parameters);
	}
}
public class PanelFeatureEffects_DescriptorProvider : PanelFeatureEffects
{
	private List<EffectDescription> simulationEffectMapperElements = new List<EffectDescription>();

	protected override IEnumerator OnShow(params object[] parameters)
	{
		simulationEffectMapperElements.Clear();
		if (context is IDescriptorEffectProvider)
		{
			IDescriptorEffectProvider provider = context as IDescriptorEffectProvider;
			if (StaticString.IsNullOrEmpty(provider.DefaultClass))
			{
				Diagnostics.LogWarning("Empty default class.... {0}", provider.GetType().ToString());
			}
			IEnumerable<SimulationDescriptor> descriptors = provider.GetDescriptors();
			if (descriptors != null)
			{
				foreach (SimulationDescriptor descriptor2 in descriptors)
				{
					simulationEffectParser.ParseSimulationDescriptor(descriptor2, simulationEffectMapperElements, provider.DefaultClass);
				}
			}
		}
		else
		{
			IDatabase<SimulationDescriptor> descriptorDatabase = Databases.GetDatabase<SimulationDescriptor>();
			if (descriptorDatabase.TryGetValue(content, out SimulationDescriptor descriptor))
			{
				simulationEffectParser.ParseSimulationDescriptor(descriptor, simulationEffectMapperElements, "ClassHero");
			}
			if (content.Contains("_LVL"))
			{
				string descriptorName = content.Substring(0, content.IndexOf("_LVL"));
				if (descriptorDatabase.TryGetValue(descriptorName, out descriptor))
				{
					simulationEffectParser.ParseSimulationDescriptor(descriptor, simulationEffectMapperElements, "ClassHero");
				}
			}
		}
		if (simulationEffectMapperElements.Count > 0)
		{
			EffectMapper.LoadEffects(simulationEffectMapperElements);
		}
		else
		{
			EffectMapper.UnloadEffects();
		}
		yield return base.OnShow(parameters);
	}
}
public class SimulationEffectParser : Amplitude.Unity.Gui.SimulationEffect.SimulationEffectParser
{
}
public class VisibilityToggleGuiPanel : GuiPanel
{
	[SerializeField]
	private AgeControlToggle visibilityToggle;

	protected override IEnumerator OnShow(params object[] parameters)
	{
		yield return base.OnShow(parameters);
		if (visibilityToggle != null)
		{
			visibilityToggle.State = true;
		}
	}

	protected override IEnumerator OnHide(bool instant)
	{
		yield return base.OnHide(instant);
		if (visibilityToggle != null)
		{
			visibilityToggle.State = false;
		}
	}
}
[Serializable]
public class LocalizationManager : Amplitude.Unity.Localization.LocalizationManager
{
}
public class GameNetworkManager : MonoBehaviour
{
	public delegate void PlayerLeftHandler(ulong playerID, StaticString playerName);

	public delegate void ServerLeftHandler(ulong playerID, StaticString playerName);

	private bool monitorPlayerLeft;

	private List<ulong> monitoredPlayerIDs;

	private bool monitorServerLeft;

	private ulong monitoredServerID;

	private ulong[] _lobbyPlayerIDs;

	private ulong _serverID;

	[SerializeField]
	private bool debugRPCs;

	[SerializeField]
	private int lagSampleCount;

	[SerializeField]
	private float maxAverageLagBeforeKick;

	private Dictionary<ulong, float> lastLagByPlayer = new Dictionary<ulong, float>();

	private Dictionary<ulong, float> maxLagByPlayer = new Dictionary<ulong, float>();

	private Dictionary<ulong, float[]> lagSamplesByPlayer = new Dictionary<ulong, float[]>();

	private Dictionary<ulong, int> nextLagSampleIndexByPlayer = new Dictionary<ulong, int>();

	[NonSerialized]
	public Dictionary<string, int> RPCCountByName = new Dictionary<string, int>();

	[NonSerialized]
	public Dictionary<string, int> RPCSizeByName = new Dictionary<string, int>();

	private List<ulong> alreadyKickedPlayers = new List<ulong>();

	private List<ulong> _remotePlayerIDs = new List<ulong>();

	private ulong _localPlayerID;

	private ulong _remotePlayerID;

	private Message _rpcMessage;

	private string _serializedArgs;

	private GameClientRPCMessage _gcRPCMessage;

	private object[] _args;

	private string _stringParam1;

	private string _stringParam2;

	private string _stringParam3;

	private StaticString _staticStringParam1;

	private StaticString _staticStringParam2;

	private object[] _objectsParam;

	private JSON _json = new JSON();

	[SerializeField]
	private bool debugRPCProxies;

	private UnityEngine.Component _uniqueComp;

	private UnityEngine.Component _component;

	private Type _componentType;

	private StaticString _methodName;

	private MethodInfo _rpcMethod;

	private ParameterInfo[] _paramInfos;

	private AITarget[] _aiTargets;

	private AITarget _aiTarget;

	private Type _aiTargetType = typeof(AITarget);

	private Dictionary<UnityEngine.Component, Dictionary<string, UnityEngine.Component>> cachedComponents = new Dictionary<UnityEngine.Component, Dictionary<string, UnityEngine.Component>>();

	private Dictionary<UnityEngine.Component, AITarget[]> cachedAITargets = new Dictionary<UnityEngine.Component, AITarget[]>();

	private Dictionary<AITargetRPC, string> aiTargetRPCStrings = new Dictionary<AITargetRPC, string>();

	private Dictionary<Type, Dictionary<StaticString, MethodInfo>> cachedMethods = new Dictionary<Type, Dictionary<StaticString, MethodInfo>>();

	[SerializeField]
	private Steamworks.SteamNetworking.EP2PSend reliableP2PSendMode = Steamworks.SteamNetworking.EP2PSend.k_EP2PSendReliable;

	[SerializeField]
	private Steamworks.SteamNetworking.EP2PSend unreliableP2PSendMode;

	private ISessionService sessionManager;

	private IMessageBox messageBox;

	private ITimeSynchronizationService timeSyncManager;

	private IGameService gameManager;

	private ulong localPlayerID = ulong.MaxValue;

	private static List<Type> _paramTypes = new List<Type>();

	private ulong[] _getPlayerIDsResult;

	public event PlayerLeftHandler OnPlayerLeft;

	public event ServerLeftHandler OnServerLeft;

	public void StartMonitorPlayerLeft()
	{
		if (!monitorPlayerLeft)
		{
			if (!IsMultiplayerSession())
			{
				Diagnostics.LogError("GameNetworkManager.MonitorPlayerLeft: not in multiplayer session!");
				return;
			}
			Diagnostics.Log("StartMonitorPlayerLeft");
			monitorPlayerLeft = true;
			monitoredPlayerIDs = new List<ulong>(GetLobbyPlayerIDs());
		}
	}

	public void StopMonitorPlayerLeft()
	{
		if (monitorPlayerLeft)
		{
			Diagnostics.Log("StopMonitorPlayerLeft");
			monitorPlayerLeft = false;
			this.OnPlayerLeft = null;
		}
	}

	public void StartMonitorServerLeft()
	{
		if (!monitorServerLeft)
		{
			if (!IsMultiplayerSession())
			{
				Diagnostics.LogError("GameNetworkManager.MonitorServerLeft: not in multiplayer session!");
				return;
			}
			Diagnostics.Log("StartMonitorServerLeft");
			monitorServerLeft = true;
			monitoredServerID = GetServerPlayerID();
		}
	}

	public void StopMonitorServerLeft()
	{
		if (monitorServerLeft)
		{
			Diagnostics.Log("StopMonitorServerLeft");
			monitorServerLeft = false;
			this.OnServerLeft = null;
		}
	}

	private void MonitoringUpdate()
	{
		if (gameManager == null)
		{
			gameManager = Services.GetService<IGameService>();
		}
		if (monitorServerLeft && this.OnServerLeft != null)
		{
			_serverID = GetServerPlayerID();
			bool flag = false;
			if (_serverID != monitoredServerID)
			{
				Diagnostics.Log("Server not in lobby anymore");
				flag = true;
			}
			else
			{
				Session session = GetSession();
				if (session == null)
				{
					Diagnostics.Log("Server not in player list anymore (session is null)");
					flag = true;
				}
				else if (session.HasPlayerTimedOut(_serverID))
				{
					Diagnostics.Log("Server timed out");
					flag = true;
				}
				else
				{
					IGameClient gameClient = GetSession().GameClient;
					if (gameClient == null)
					{
						Diagnostics.Log("Server not in player list anymore (gameClient is null)");
						flag = true;
					}
					else
					{
						FiniteState currentState = gameClient.CurrentState;
						if (currentState is GameClientState_DisconnectedFromServer)
						{
							Diagnostics.Log("Server not in player list anymore (GameClientState={0})", currentState);
							flag = true;
						}
					}
				}
			}
			if (flag)
			{
				Diagnostics.LogWarning("OnServerLeft");
				this.OnServerLeft(monitoredServerID, null);
				StopMonitorPlayerLeft();
				StopMonitorServerLeft();
			}
		}
		if (!monitorPlayerLeft || this.OnPlayerLeft == null)
		{
			return;
		}
		_lobbyPlayerIDs = GetLobbyPlayerIDs();
		int num = 0;
		ulong num2;
		while (true)
		{
			if (num >= monitoredPlayerIDs.Count)
			{
				return;
			}
			num2 = monitoredPlayerIDs[num];
			bool flag2 = false;
			if (!_lobbyPlayerIDs.Contains(num2))
			{
				Diagnostics.Log("Player #{0} not in lobby anymore", num2);
				flag2 = true;
			}
			else
			{
				Session session2 = GetSession();
				if (session2 == null)
				{
					Diagnostics.Log("Player #{0} not in player list anymore (session is null)", num2);
					flag2 = true;
				}
				else if (session2.HasPlayerTimedOut(num2))
				{
					Diagnostics.Log("Server timed out");
					flag2 = true;
				}
				else
				{
					IGameClient gameClient2 = GetSession().GameClient;
					if (gameClient2 == null)
					{
						Diagnostics.Log("Player #{0} not in player list anymore (gameClient is null)", num2);
						flag2 = true;
					}
					else
					{
						FiniteState currentState2 = gameClient2.CurrentState;
						if (currentState2 is GameClientState_DisconnectedFromServer)
						{
							Diagnostics.Log("Player #{0} not in player list anymore (GameClientState={0})", num2, currentState2);
							flag2 = true;
						}
					}
				}
			}
			if (flag2)
			{
				break;
			}
			num++;
		}
		Diagnostics.LogWarning("OnPlayerLeft id={0}", num2);
		this.OnPlayerLeft(num2, null);
		monitoredPlayerIDs.RemoveAt(num);
	}

	public void ResetRPCAndLagMonitoring()
	{
		Diagnostics.Log("[GNM] ResetRPCAndLagMonitoring");
		alreadyKickedPlayers.Clear();
	}

	private void AssertLagForPlayerIsDefined(ulong playerID)
	{
		if (!lagSamplesByPlayer.ContainsKey(playerID))
		{
			lagSamplesByPlayer.Add(playerID, new float[lagSampleCount]);
			for (int i = 0; i < lagSampleCount; i++)
			{
				lagSamplesByPlayer[playerID][i] = -1f;
			}
		}
		if (!nextLagSampleIndexByPlayer.ContainsKey(playerID))
		{
			nextLagSampleIndexByPlayer.Add(playerID, 0);
		}
		if (!lastLagByPlayer.ContainsKey(playerID))
		{
			lastLagByPlayer.Add(playerID, -1f);
		}
		if (!maxLagByPlayer.ContainsKey(playerID))
		{
			maxLagByPlayer.Add(playerID, -1f);
		}
	}

	private void AddLagForPlayer(ulong playerID, float lag)
	{
		AssertLagForPlayerIsDefined(playerID);
		lagSamplesByPlayer[playerID][nextLagSampleIndexByPlayer[playerID]] = lag;
		lastLagByPlayer[playerID] = lag;
		maxLagByPlayer[playerID] = Mathf.Max(maxLagByPlayer[playerID], lag);
		Dictionary<ulong, int> dictionary;
		Dictionary<ulong, int> dictionary2 = dictionary = nextLagSampleIndexByPlayer;
		ulong key;
		ulong key2 = key = playerID;
		int num = dictionary[key];
		dictionary2[key2] = num + 1;
		if (nextLagSampleIndexByPlayer[playerID] >= lagSampleCount)
		{
			nextLagSampleIndexByPlayer[playerID] = 0;
		}
		float averageLagForPlayer = GetAverageLagForPlayer(playerID);
		if (averageLagForPlayer > maxAverageLagBeforeKick && IsServer() && !alreadyKickedPlayers.Contains(playerID))
		{
			Dungeon dungeon = SingletonManager.Get<Dungeon>(mandatory: false);
			if (dungeon != null && dungeon.IsStarted && dungeon.IsDisplayed)
			{
				Diagnostics.LogWarning("[GNM] Player #{0} is lagging: averageLag={1}s => KICK!", playerID, averageLagForPlayer);
				KickPlayer(playerID, PlayerKickReason.CriticalLag);
				alreadyKickedPlayers.Add(playerID);
			}
		}
	}

	public float GetAverageLagForPlayer(ulong playerID)
	{
		AssertLagForPlayerIsDefined(playerID);
		float num = 0f;
		int num2 = 0;
		for (int i = 0; i < lagSampleCount; i++)
		{
			if (lagSamplesByPlayer[playerID][i] >= 0f)
			{
				num += lagSamplesByPlayer[playerID][i];
			}
			num2++;
		}
		if (num2 == lagSampleCount)
		{
			return num / (float)num2;
		}
		return -1f;
	}

	public float GetLastLagForPlayer(ulong playerID)
	{
		AssertLagForPlayerIsDefined(playerID);
		return lastLagByPlayer[playerID];
	}

	public float GetMaxLagForPlayer(ulong playerID)
	{
		AssertLagForPlayerIsDefined(playerID);
		return maxLagByPlayer[playerID];
	}

	public void SendRPCToAll(RPCProxyName rpcProxyName, params object[] args)
	{
		SendRPC(rpcProxyName, RPCMode.All, 0uL, reliableP2PSendMode, args);
	}

	public void SendUnreliableRPCToAll(RPCProxyName rpcProxyName, params object[] args)
	{
		SendRPC(rpcProxyName, RPCMode.All, 0uL, unreliableP2PSendMode, args);
	}

	public void SendRPCToOthers(RPCProxyName rpcProxyName, params object[] args)
	{
		SendRPC(rpcProxyName, RPCMode.Others, 0uL, reliableP2PSendMode, args);
	}

	public void SendUnreliableRPCToOthers(RPCProxyName rpcProxyName, params object[] args)
	{
		SendRPC(rpcProxyName, RPCMode.Others, 0uL, unreliableP2PSendMode, args);
	}

	public void SendRPCToServer(RPCProxyName rpcProxyName, params object[] args)
	{
		SendRPC(rpcProxyName, RPCMode.Server, 0uL, reliableP2PSendMode, args);
	}

	public void SendUnreliableRPCToServer(RPCProxyName rpcProxyName, params object[] args)
	{
		SendRPC(rpcProxyName, RPCMode.Server, 0uL, unreliableP2PSendMode, args);
	}

	public void SendRPCToPlayer(ulong playerID, RPCProxyName rpcProxyName, params object[] args)
	{
		SendRPC(rpcProxyName, RPCMode.Player, playerID, reliableP2PSendMode, args);
	}

	public void SendUnreliableRPCToPlayer(ulong playerID, RPCProxyName rpcProxyName, params object[] args)
	{
		SendRPC(rpcProxyName, RPCMode.Player, playerID, unreliableP2PSendMode, args);
	}

	private void SendRPC(RPCProxyName rpcProxyName, RPCMode mode, ulong playerID, Steamworks.SteamNetworking.EP2PSend sendMode, params object[] args)
	{
		if (timeSyncManager == null)
		{
			timeSyncManager = Services.GetService<ITimeSynchronizationService>();
		}
		_remotePlayerIDs.Clear();
		_localPlayerID = GetLocalPlayerID();
		bool flag = false;
		switch (mode)
		{
		case RPCMode.All:
			_remotePlayerIDs.AddRange(GetLobbyPlayerIDs());
			_remotePlayerIDs.Remove(_localPlayerID);
			flag = true;
			break;
		case RPCMode.Others:
			_remotePlayerIDs.AddRange(GetLobbyPlayerIDs());
			_remotePlayerIDs.Remove(_localPlayerID);
			break;
		case RPCMode.Server:
			if (IsServerOrSinglePlayer())
			{
				flag = true;
			}
			else
			{
				_remotePlayerIDs.Add(GetServerPlayerID());
			}
			break;
		case RPCMode.Player:
			if (playerID == _localPlayerID)
			{
				flag = true;
			}
			else
			{
				_remotePlayerIDs.Add(playerID);
			}
			break;
		}
		_serializedArgs = null;
		if (_remotePlayerIDs.Count > 0)
		{
			if (_serializedArgs == null)
			{
				_serializedArgs = Serialize(args);
			}
			for (int i = 0; i < _remotePlayerIDs.Count; i++)
			{
				_remotePlayerID = _remotePlayerIDs[i];
				_rpcMessage = new GameClientRPCMessage(rpcProxyName, timeSyncManager.Time.RoundWithDecimals(2), _serializedArgs);
				SendRPCMessage(_rpcMessage, _remotePlayerID, sendMode);
				string text = null;
				switch (rpcProxyName)
				{
				case RPCProxyName.UniqueID_RPC:
					text = ((int)args[2]).ToEnum<UniqueIDRPC>().ToString();
					break;
				case RPCProxyName.Singleton_RPC:
					text = ((int)args[0]).ToEnum<SingletonRPC>().ToString();
					break;
				case RPCProxyName.AITarget_RPC:
					text = ((int)args[3]).ToEnum<AITargetRPC>().ToString();
					break;
				}
				string text2 = text;
				text = text2 + "(" + (int)sendMode + ")";
				if (!RPCCountByName.ContainsKey(text))
				{
					RPCCountByName.Add(text, 0);
				}
				Dictionary<string, int> rPCCountByName;
				Dictionary<string, int> dictionary = rPCCountByName = RPCCountByName;
				string key = text2 = text;
				int num = rPCCountByName[text2];
				dictionary[key] = num + 1;
				if (!RPCSizeByName.ContainsKey(text))
				{
					RPCSizeByName.Add(text, 0);
				}
				Dictionary<string, int> rPCSizeByName;
				Dictionary<string, int> dictionary2 = rPCSizeByName = RPCSizeByName;
				string key2 = text2 = text;
				num = rPCSizeByName[text2];
				dictionary2[key2] = num + _serializedArgs.Length;
			}
		}
		if (flag)
		{
			DoProcessRPCMessage(rpcProxyName, args, convertParameters: false);
		}
	}

	private void SendRPCMessage(Message rpcMessage, ulong remoteSteamID, Steamworks.SteamNetworking.EP2PSend sendMode)
	{
		if (debugRPCs)
		{
			_gcRPCMessage = (rpcMessage as GameClientRPCMessage);
			Diagnostics.Log("[GNM] SendRPCMessage: rpc={0} serial={1} remote={2}", _gcRPCMessage.RPCProxyName, _gcRPCMessage.SerializedArgs, remoteSteamID.ToString());
		}
		if (AssertMessageBoxIsSet())
		{
			Steamworks.SteamNetworking.EP2PSend steamNetworkingSendMode = messageBox.SteamNetworkingSendMode;
			messageBox.SteamNetworkingSendMode = sendMode;
			messageBox.SendMessage(ref rpcMessage, remoteSteamID);
			messageBox.SteamNetworkingSendMode = steamNetworkingSendMode;
		}
	}

	public void OnRPCMessageReceived(GameClientRPCMessage rpcMessage, ulong senderID, bool fakeLagged = false)
	{
		if (timeSyncManager == null)
		{
			timeSyncManager = Services.GetService<ITimeSynchronizationService>();
		}
		float lag = timeSyncManager.Time.RoundWithDecimals(2) - rpcMessage.SendingTime;
		AddLagForPlayer(senderID, lag);
		if (debugRPCs)
		{
			Diagnostics.Log("[GNM] Received rpc={0} sender={1} serial={2}", rpcMessage.RPCProxyName, senderID, rpcMessage.SerializedArgs);
		}
		ProcessRPCMessage(rpcMessage, senderID);
	}

	public void ProcessRPCMessage(GameClientRPCMessage rpcMessage, ulong senderID)
	{
		RPCProxyName rPCProxyName = rpcMessage.RPCProxyName;
		_args = Deserialize(rpcMessage.SerializedArgs);
		DoProcessRPCMessage(rPCProxyName, _args);
	}

	public void DoProcessRPCMessage(RPCProxyName rpcProxyName, object[] args, bool convertParameters = true)
	{
		switch (rpcProxyName)
		{
		case RPCProxyName.UniqueID_RPC:
			_staticStringParam1 = ConvertParameter<StaticString>(args[0]);
			_objectsParam = ConvertParameter<object[]>(args[3]);
			UniqueID_RPCProxy(_staticStringParam1, ConvertParameter<int>(args[1]), ConvertParameter<int>(args[2]), ref _objectsParam);
			break;
		case RPCProxyName.Singleton_RPC:
			_objectsParam = ConvertParameter<object[]>(args[1]);
			Singleton_RPCProxy(ConvertParameter<int>(args[0]), ref _objectsParam);
			break;
		case RPCProxyName.AITarget_RPC:
			_staticStringParam1 = ConvertParameter<StaticString>(args[0]);
			_staticStringParam2 = ConvertParameter<StaticString>(args[2]);
			_objectsParam = ConvertParameter<object[]>(args[4]);
			AITarget_RPCProxy(_staticStringParam1, ConvertParameter<int>(args[1]), _staticStringParam2, ConvertParameter<int>(args[3]).ToEnum<AITargetRPC>(), ref _objectsParam);
			break;
		default:
			Diagnostics.LogError("[GNM] Invalid RPC called ('{0}')", rpcProxyName);
			break;
		}
	}

	private void ConvertArgForSerialization(ref object arg)
	{
		if (arg == null)
		{
			return;
		}
		if (arg is ulong)
		{
			arg = ((ulong)arg).ToString("x16");
		}
		else if (arg is bool)
		{
			arg = (((bool)arg) ? 1 : 0);
		}
		else if (arg.GetType() == typeof(object[]))
		{
			object[] array = (object[])arg;
			for (int i = 0; i < array.Length; i++)
			{
				ConvertArgForSerialization(ref array[i]);
			}
		}
	}

	private string Serialize(object[] args)
	{
		for (int i = 0; i < args.Length; i++)
		{
			ConvertArgForSerialization(ref args[i]);
		}
		_json["a"] = args;
		string serialized = _json.serialized;
		return serialized.Substring(6, serialized.Length - 8);
	}

	private object[] Deserialize(string serial)
	{
		serial = $"{{\"a\":[{serial}]}}";
		_json.serialized = serial;
		return _json.ToArray<object>("a");
	}

	public void ResetCachedComponents()
	{
		cachedComponents.Clear();
	}

	public void ClearCachedComponents(UnityEngine.Component component)
	{
		if (cachedComponents.ContainsKey(component))
		{
			cachedComponents.Remove(component);
		}
	}

	private UnityEngine.Component GetCachedComponent(UnityEngine.Component component, string componentTypeName)
	{
		if (!cachedComponents.ContainsKey(component))
		{
			cachedComponents.Add(component, new Dictionary<string, UnityEngine.Component>());
		}
		if (!cachedComponents[component].ContainsKey(componentTypeName))
		{
			cachedComponents[component].Add(componentTypeName, component.GetComponent(componentTypeName));
		}
		return cachedComponents[component][componentTypeName];
	}

	public void ResetCachedAITargets()
	{
		cachedAITargets.Clear();
	}

	public void ClearCachedAITargets(UnityEngine.Component component)
	{
		if (cachedAITargets.ContainsKey(component))
		{
			cachedAITargets.Remove(component);
		}
	}

	private AITarget[] GetCachedAITargets(UnityEngine.Component component)
	{
		if (!cachedAITargets.ContainsKey(component))
		{
			cachedAITargets.Add(component, component.GetComponents<AITarget>());
		}
		return cachedAITargets[component];
	}

	private string GetAITargetRPCString(AITargetRPC rpc)
	{
		string value = null;
		if (!aiTargetRPCStrings.TryGetValue(rpc, out value))
		{
			value = $"RPC_{rpc.ToString()}";
			aiTargetRPCStrings.Add(rpc, value);
		}
		return value;
	}

	private MethodInfo GetMethod(Type type, StaticString methodName)
	{
		Dictionary<StaticString, MethodInfo> value = null;
		if (!cachedMethods.TryGetValue(type, out value))
		{
			value = new Dictionary<StaticString, MethodInfo>();
			cachedMethods.Add(type, value);
		}
		MethodInfo value2 = null;
		if (!value.TryGetValue(methodName, out value2))
		{
			value2 = type.GetMethod(methodName, BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy);
			value.Add(methodName, value2);
		}
		return value2;
	}

	private void UniqueID_RPCProxy(string netSyncCategory, int netSyncID, int rpcID, ref object[] args)
	{
		if (rpcID == -1)
		{
			return;
		}
		UniqueIDNetSyncElement.GetRPCDataFromID(rpcID, out string typeName, out StaticString rpcName);
		if (debugRPCProxies)
		{
			Diagnostics.Log("[GNM] UniqueID_RPC {0}#{1} componentTypeName={2} rpcName={3}", netSyncCategory, netSyncID, typeName, rpcName);
		}
		_uniqueComp = UniqueIDManager.Get(netSyncCategory, netSyncID, out UniqueIDGetError error, logError: false);
		if (_uniqueComp == null)
		{
			if (error == UniqueIDGetError.ObjectIsNull)
			{
				Diagnostics.Log("[GNM] UniqueID_RPC({0}): Unable to find {1}#{2} (already dead&destroyed)", rpcName, netSyncCategory, netSyncID);
			}
			else
			{
				Diagnostics.LogError("[GNM] UniqueID_RPC({0}): Unable to find {1}#{2} (error={3})", rpcName, netSyncCategory, netSyncID, error);
			}
			return;
		}
		_component = GetCachedComponent(_uniqueComp, typeName);
		if (_component == null)
		{
			Diagnostics.LogError("[GNM] UniqueID_RPC({0}): Unable to find {1} component on {2}", rpcName, typeName, _uniqueComp.name);
			return;
		}
		_componentType = Type.GetType(typeName);
		_methodName = rpcName;
		_rpcMethod = GetMethod(_componentType, _methodName);
		if (_rpcMethod == null)
		{
			Diagnostics.LogError("[GNM] UniqueID_RPC({0}): no {1} method found on {2} type!", rpcName, _methodName, typeName);
			return;
		}
		_paramInfos = _rpcMethod.GetParameters();
		ConvertParameters(ref args, _paramInfos);
		_rpcMethod.Invoke(_component, args);
	}

	private void Singleton_RPCProxy(int rpcID, ref object[] args)
	{
		if (rpcID == -1)
		{
			return;
		}
		SingletonNetSyncElement.GetRPCDataFromID(rpcID, out string typeName, out StaticString rpcName);
		if (debugRPCProxies)
		{
			Diagnostics.Log("[GNM] Singleton_RPC singletonTypeName={0} rpcName={1}", typeName, rpcName);
		}
		_componentType = Type.GetType(typeName);
		_uniqueComp = SingletonManager.Get(_componentType);
		if (_uniqueComp == null)
		{
			Diagnostics.LogError("[GNM] Singleton_RPC({0}): Unable to find {1} singleton", rpcName, _componentType);
			return;
		}
		_methodName = rpcName;
		_rpcMethod = GetMethod(_componentType, _methodName);
		if (_rpcMethod == null)
		{
			Diagnostics.LogError("[GNM] Singleton_RPC({0}): no {1} method found on {2} type!", rpcName, _methodName, typeName);
			return;
		}
		_paramInfos = _rpcMethod.GetParameters();
		ConvertParameters(ref args, _paramInfos);
		_rpcMethod.Invoke(_uniqueComp, args);
	}

	private void AITarget_RPCProxy(StaticString targetCategory, int targetID, StaticString targetKey, AITargetRPC rpc, ref object[] args)
	{
		string aITargetRPCString = GetAITargetRPCString(rpc);
		if (debugRPCProxies)
		{
			Diagnostics.Log("[GNM] AITarget_RPC targetCategory={0} targetID={1} targetKey={2} rpcName={3}", targetCategory, targetID, targetKey, aITargetRPCString);
		}
		_uniqueComp = UniqueIDManager.Get(targetCategory, targetID, out UniqueIDGetError error, logError: false);
		if (_uniqueComp == null)
		{
			if (error == UniqueIDGetError.ObjectIsNull)
			{
				Diagnostics.Log("[GNM] AITarget_RPC({0}): Unable to find target {1}#{2} (already dead&destroyed)", aITargetRPCString, targetCategory, targetID);
			}
			else
			{
				Diagnostics.LogError("[GNM] AITarget_RPC({0}): Unable to find target {1}#{2} (error={3})", aITargetRPCString, targetCategory, targetID, error);
			}
			return;
		}
		_aiTargets = GetCachedAITargets(_uniqueComp);
		if (_aiTargets.Length == 0)
		{
			Diagnostics.LogError("[GNM] AITarget_RPC({0}): Unable to find any AI target on {1}", aITargetRPCString, _uniqueComp.name);
			return;
		}
		int num = _aiTargets.Length;
		_aiTarget = null;
		for (int i = 0; i < num; i++)
		{
			_aiTarget = _aiTargets[i];
			if (_aiTarget.TargetKey == targetKey)
			{
				break;
			}
		}
		if (_aiTarget == null)
		{
			Diagnostics.LogError("[GNM] AITarget_RPC({0}): Unable to find AITarget", aITargetRPCString);
			return;
		}
		_methodName = aITargetRPCString;
		_rpcMethod = GetMethod(_aiTargetType, _methodName);
		if (_rpcMethod == null)
		{
			Diagnostics.LogError("[GNM] AITarget_RPC{0}: no {1} method found on AITarget!", aITargetRPCString, _methodName);
			return;
		}
		_paramInfos = _rpcMethod.GetParameters();
		ConvertParameters(ref args, _paramInfos);
		_rpcMethod.Invoke(_aiTarget, args);
	}

	public static void ConvertParameters(ref object[] args, ParameterInfo[] paramInfos)
	{
		int num = paramInfos.Length;
		_paramTypes.Clear();
		for (int i = 0; i < num; i++)
		{
			_paramTypes.Add(paramInfos[i].ParameterType);
		}
		ConvertParameters(ref args, _paramTypes);
	}

	public static void ConvertParameters(ref object[] args, List<Type> paramTypes)
	{
		if (args.Length != paramTypes.Count)
		{
			Diagnostics.LogError("ConvertParameters: mismatch between arguments and method parameters counts (" + args.Length + " != " + paramTypes.Count + ")");
			return;
		}
		for (int i = 0; i < args.Length; i++)
		{
			args[i] = ConvertParameter(args[i], paramTypes[i]);
		}
	}

	public static T ConvertParameter<T>(object param)
	{
		return (T)ConvertParameter(param, typeof(T));
	}

	public static object ConvertParameter(object param, Type targetType)
	{
		//Discarded unreachable code: IL_04cc
		if (param == null)
		{
			return null;
		}
		Type type = param.GetType();
		if (type == targetType)
		{
			return param;
		}
		if (targetType.IsEnum && type == typeof(string))
		{
			return Enum.Parse(targetType, (string)param);
		}
		if (targetType == typeof(StaticString) && type == typeof(string))
		{
			return new StaticString((string)param);
		}
		if (targetType == typeof(HeroItemData) && type == typeof(string))
		{
			return new HeroItemData((string)param);
		}
		if (targetType == typeof(HeroItemData[]) && type == typeof(List<object>))
		{
			return ((List<object>)param).ConvertAll((object o) => new HeroItemData((string)o)).ToArray();
		}
		if (targetType == typeof(InventoryItemData) && type == typeof(string))
		{
			return new InventoryItemData((string)param);
		}
		if (targetType == typeof(InventoryItemData[]) && type == typeof(List<object>))
		{
			return ((List<object>)param).ConvertAll((object o) => new InventoryItemData((string)o)).ToArray();
		}
		if (type == typeof(List<InventoryItemData>) && targetType == typeof(InventoryItemData[]))
		{
			return ((List<InventoryItemData>)param).ToList();
		}
		if (type == typeof(List<object>) && targetType == typeof(List<InventoryItemData>))
		{
			return ((List<object>)param).ConvertAll((object o) => new InventoryItemData((string)o));
		}
		if (targetType == typeof(MobSaveData) && type == typeof(string))
		{
			return new MobSaveData((string)param);
		}
		if (targetType == typeof(HeroActiveSkillData) && type == typeof(string))
		{
			return new HeroActiveSkillData((string)param);
		}
		if (targetType == typeof(HeroActiveSkillData[]) && type == typeof(List<object>))
		{
			return ((List<object>)param).ConvertAll((object o) => new HeroActiveSkillData((string)o)).ToArray();
		}
		if (targetType == typeof(StaticString[]) && type == typeof(List<object>))
		{
			return ((List<object>)param).ConvertAll((object o) => new StaticString((string)o)).ToArray();
		}
		if (targetType == typeof(Vector3) && type == typeof(string))
		{
			return GenericUtilities.StringToVector3((string)param);
		}
		if (targetType == typeof(Vector3[]) && type == typeof(List<object>))
		{
			return ((List<object>)param).ConvertAll((object o) => GenericUtilities.StringToVector3((string)o)).ToArray();
		}
		if (targetType == typeof(Int2Position) && type == typeof(string))
		{
			return GenericUtilities.StringToInt2Position((string)param);
		}
		if (targetType == typeof(Int2Position[]) && type == typeof(List<object>))
		{
			return ((List<object>)param).ConvertAll((object o) => GenericUtilities.StringToInt2Position((string)o)).ToArray();
		}
		if (targetType == typeof(object[]) && type == typeof(List<object>))
		{
			return ((List<object>)param).ToArray();
		}
		if (targetType == typeof(string[]) && type == typeof(List<object>))
		{
			return ((List<object>)param).ConvertAll((object o) => (string)o).ToArray();
		}
		if (targetType == typeof(ulong) && type == typeof(string))
		{
			return Convert.ToUInt64((string)param, 16);
		}
		try
		{
			return Convert.ChangeType(param, targetType);
		}
		catch (InvalidCastException ex)
		{
			Diagnostics.LogError("ConvertParameter: unable to convert param '" + param + "' (" + type + ") to " + targetType + " type!\n" + ex.Message);
		}
		return null;
	}

	private bool AssertSessionManagerIsSet(bool isSessionMandatory = false)
	{
		if (sessionManager == null)
		{
			sessionManager = Services.GetService<ISessionService>();
			if (sessionManager == null)
			{
				if (isSessionMandatory)
				{
					Diagnostics.LogError("No session service found!");
				}
				return false;
			}
		}
		if (sessionManager.Session == null)
		{
			if (isSessionMandatory)
			{
				Diagnostics.LogError("No session found!");
			}
			return false;
		}
		return true;
	}

	private bool AssertMessageBoxIsSet()
	{
		if (messageBox == null)
		{
			NetworkingProxy networkingProxy = new NetworkingProxy(server: false);
			if (networkingProxy == null)
			{
				Diagnostics.LogError("No steam networking proxy found!");
				return false;
			}
			messageBox = new MessageBox(networkingProxy);
			if (messageBox == null)
			{
				Diagnostics.LogError("No message box found!");
				return false;
			}
		}
		return true;
	}

	public bool IsMultiplayerSession()
	{
		if (!AssertSessionManagerIsSet())
		{
			return false;
		}
		return sessionManager.Session.SessionMode != 0 && sessionManager.Session.IsOpened && !sessionManager.Session.IsAborted;
	}

	public bool IsServer()
	{
		if (!AssertSessionManagerIsSet())
		{
			return false;
		}
		return sessionManager.Session.IsHosting;
	}

	public bool IsServerOrSinglePlayer()
	{
		return IsServer() || !IsMultiplayerSession();
	}

	public Session GetSession()
	{
		if (!AssertSessionManagerIsSet())
		{
			return null;
		}
		return (Session)sessionManager.Session;
	}

	public ulong GetLocalPlayerID()
	{
		if (!AssertSessionManagerIsSet())
		{
			localPlayerID = ulong.MaxValue;
			if (Steamworks.SteamAPI.SteamUser != null)
			{
				localPlayerID = Steamworks.SteamAPI.SteamUser.SteamID;
			}
			return localPlayerID;
		}
		if ((localPlayerID == ulong.MaxValue || localPlayerID != sessionManager.Session.UserID) && Steamworks.SteamAPI.SteamUser != null)
		{
			localPlayerID = Steamworks.SteamAPI.SteamUser.SteamID;
		}
		return localPlayerID;
	}

	public int GetPlayerSlotIndex(ulong playerID)
	{
		if (!AssertSessionManagerIsSet())
		{
			return -1;
		}
		if (IsMultiplayerSession())
		{
			object lobbyDataObject = sessionManager.Session.GetLobbyDataObject(string.Format(SessionBase.LOBBYDATA_SLOT_INDEX_BY_PLAYER_ID, playerID.ToString()));
			if (lobbyDataObject != null)
			{
				string s = lobbyDataObject.ToString();
				return int.Parse(s);
			}
			Diagnostics.LogError("GNM.GetPlayerSlotIndex: couldn't get #{0} player slot index from lobby data!", playerID);
			return -1;
		}
		return 0;
	}

	public int GetLocalPlayerSlotIndex()
	{
		return GetPlayerSlotIndex(GetLocalPlayerID());
	}

	public ulong GetSlotPlayerID(int slotIndex)
	{
		if (!AssertSessionManagerIsSet())
		{
			return ulong.MaxValue;
		}
		if (IsMultiplayerSession())
		{
			string playerIdFromSlotIndex = sessionManager.Session.GetPlayerIdFromSlotIndex(slotIndex);
			if (!string.IsNullOrEmpty(playerIdFromSlotIndex))
			{
				Diagnostics.Log("GNM.GetSlotPlayerID: playerIDStr={0}", playerIdFromSlotIndex.ToString());
				ulong result = 0uL;
				if (!ulong.TryParse(playerIdFromSlotIndex, out result))
				{
					Diagnostics.LogError("GNM.GetSlotPlayerID: couldn't cast player ID string to ulong!");
				}
			}
			return 0uL;
		}
		return GetLocalPlayerID();
	}

	public ulong GetServerPlayerID()
	{
		if (!AssertSessionManagerIsSet())
		{
			return ulong.MaxValue;
		}
		if (IsMultiplayerSession())
		{
			return sessionManager.Session.GetOwnerId();
		}
		return GetLocalPlayerID();
	}

	public int GetMultiplayerMinPlayerCount()
	{
		return GameConfig.GetGameConfig().MultiplayerMinPlayerCount;
	}

	public int GetMultiplayerMaxPlayerCount()
	{
		return GameConfig.GetGameConfig().MultiplayerMaxPlayerCount;
	}

	public int GetPlayerCount()
	{
		if (!AssertSessionManagerIsSet(IsMultiplayerSession()))
		{
			return 1;
		}
		if (IsMultiplayerSession())
		{
			return GetLobbyPlayerIDs().Length;
		}
		return 1;
	}

	public ulong[] GetLobbyPlayerIDs()
	{
		if (!AssertSessionManagerIsSet())
		{
			_getPlayerIDsResult = new ulong[1]
			{
				GetLocalPlayerID()
			};
			return _getPlayerIDsResult;
		}
		if (IsMultiplayerSession())
		{
			_getPlayerIDsResult = sessionManager.Session.GetActiveLobbyMembers();
			return _getPlayerIDsResult;
		}
		_getPlayerIDsResult = new ulong[1]
		{
			GetLocalPlayerID()
		};
		return _getPlayerIDsResult;
	}

	public string GetPlayerName(ulong playerID)
	{
		if (!AssertSessionManagerIsSet())
		{
			return null;
		}
		return sessionManager.Session.GetPlayerName(playerID);
	}

	public void KickPlayer(ulong playerID, PlayerKickReason reason)
	{
		if (AssertSessionManagerIsSet() && IsServer())
		{
			Session session = GetSession();
			int playerSlotIndex = GetPlayerSlotIndex(playerID);
			string x = string.Format(SessionBase.LOBBYDATA_KICK_BY_SLOT_INDEX, playerSlotIndex);
			session.SetLobbyData(x, reason.ToString());
		}
	}
}
public enum RPCMode
{
	All,
	Others,
	Server,
	Player
}
public enum RPCProxyName
{
	UniqueID_RPC,
	Singleton_RPC,
	AITarget_RPC
}
public struct DelayedRPCDispatch
{
	public Message Message;

	public float DispatchTime;

	public ulong SenderID;

	public Steamworks.SteamNetworking.EP2PSend SendMode;
}
public struct DelayedRPCReception
{
	public GameClientRPCMessage Message;

	public float ReceptionTime;

	public ulong SenderID;
}
public enum PlayerKickReason
{
	Lobby,
	InGame,
	CriticalLag
}
public class LobbyDescription
{
	public int MaximumNumberOfPlayers
	{
		get;
		private set;
	}

	public int NumberOfLobbyMembers
	{
		get;
		private set;
	}

	public string Name
	{
		get;
		private set;
	}

	public ulong LobbyID
	{
		get;
		private set;
	}

	public ulong HostID
	{
		get;
		private set;
	}

	public string Version
	{
		get;
		private set;
	}

	public string Checksum
	{
		get;
		private set;
	}

	public string SaveKey
	{
		get;
		private set;
	}

	public ulong[] PlayerIDs
	{
		get;
		private set;
	}

	public LobbyType LobbyType
	{
		get;
		private set;
	}

	public LobbyDescription(IMatchMakingService matchMakingService, ulong lobbyID)
	{
		LobbyID = lobbyID;
		Name = matchMakingService.GetLobbyData(lobbyID, Session.LOBBYDATA_GAME_NAME);
		HostID = matchMakingService.GetLobbyOwnerId(lobbyID);
		SaveKey = matchMakingService.GetLobbyData(lobbyID, Session.LOBBYDATA_SAVE_KEY);
		if (!string.IsNullOrEmpty(SaveKey))
		{
			string lobbyData = matchMakingService.GetLobbyData(lobbyID, Session.LOBBYDATA_PLAYER_IDS);
			string[] array = lobbyData.Split(Session.LOBBYDATA_PLAYER_IDS_SEPARATOR);
			PlayerIDs = new ulong[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				PlayerIDs[i] = ulong.Parse(array[i]);
			}
			MaximumNumberOfPlayers = array.Length;
		}
		else
		{
			MaximumNumberOfPlayers = matchMakingService.GetLobbyMaxPlayerCount(lobbyID, SingletonManager.Get<GameNetworkManager>().GetMultiplayerMaxPlayerCount());
		}
		NumberOfLobbyMembers = matchMakingService.GetLobbyPresentMemberCount(lobbyID);
		string lobbyData2 = matchMakingService.GetLobbyData(lobbyID, Session.LOBBYDATA_LOBBY_TYPE);
		LobbyType = ((!string.IsNullOrEmpty(lobbyData2)) ? lobbyData2.ToEnum<LobbyType>() : LobbyType.Private);
		Version = matchMakingService.GetLobbyData(lobbyID, SessionBase.LOBBYDATA_APPLICATIONVERSION);
		Checksum = matchMakingService.GetLobbyData(lobbyID, Session.LOBBYDATA_APPLICATION_CHECKSUM);
	}

	public bool IsJoinable(bool checkLobbyType = true, bool reportErrors = false)
	{
		if (Version != Amplitude.Unity.Framework.Application.Version.ToString())
		{
			Diagnostics.Log("#{0} lobby not joinable: invalid version ({1} != {2})", LobbyID, Version, Amplitude.Unity.Framework.Application.Version.ToString());
			if (reportErrors)
			{
				SingletonManager.Get<RequesterPanel>().Display("%Error_LobbyJoinFail_InvalidVersion");
			}
			return false;
		}
		if (NumberOfLobbyMembers >= MaximumNumberOfPlayers)
		{
			return false;
		}
		ulong localPlayerID = SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID();
		bool flag = false;
		if (!string.IsNullOrEmpty(SaveKey))
		{
			for (int i = 0; i < PlayerIDs.Length; i++)
			{
				if (PlayerIDs[i] == localPlayerID)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				if (reportErrors)
				{
					SingletonManager.Get<RequesterPanel>().Display("%Error_LobbyJoinFail_SaveMPGame");
				}
				return false;
			}
			return true;
		}
		if (checkLobbyType)
		{
			switch (LobbyType)
			{
			case LobbyType.Private:
				if (reportErrors)
				{
					SingletonManager.Get<RequesterPanel>().Display("%Error_LobbyJoinFail_PrivateGame");
				}
				return false;
			case LobbyType.Friends:
			{
				Steamworks.SteamID steamID = new Steamworks.SteamID(HostID);
				Steamworks.EFriendRelationship friendRelationship = Steamworks.SteamAPI.SteamFriends.GetFriendRelationship(steamID);
				if (friendRelationship != Steamworks.EFriendRelationship.k_EFriendRelationshipFriend)
				{
					if (reportErrors)
					{
						SingletonManager.Get<RequesterPanel>().Display("%Error_LobbyJoinFail_FriendsOnlyGame");
					}
					return false;
				}
				break;
			}
			}
		}
		return true;
	}
}
public abstract class NetSyncElement : MonoBehaviour
{
	public delegate void OwnerChangedHandler();

	public delegate void OwnerLeftHandler();

	protected GameNetworkManager gameNetManager;

	protected Session session;

	public ulong NextOwnerPlayerID
	{
		get;
		private set;
	}

	public ulong OwnerPlayerID
	{
		get;
		private set;
	}

	public event OwnerChangedHandler OnOwnerChanged;

	public event OwnerLeftHandler OnOwnerLeft;

	public virtual void SetOwner(ulong ownerPlayerID)
	{
		OwnerPlayerID = ownerPlayerID;
		if (gameNetManager.IsMultiplayerSession())
		{
			ulong[] lobbyPlayerIDs = gameNetManager.GetLobbyPlayerIDs();
			int num = Array.IndexOf(lobbyPlayerIDs, ownerPlayerID);
			int num2 = (num + 1) % lobbyPlayerIDs.Length;
			NextOwnerPlayerID = lobbyPlayerIDs[num2];
		}
		if (ownerPlayerID == gameNetManager.GetLocalPlayerID())
		{
			base.name += "[local]";
		}
		else
		{
			base.name = base.name.Replace("[local]", string.Empty);
		}
		if (gameNetManager.IsMultiplayerSession())
		{
			gameNetManager.OnPlayerLeft -= OnPlayerLeft;
			gameNetManager.OnPlayerLeft += OnPlayerLeft;
		}
	}

	public Player GetOwnerPlayer()
	{
		return Player.GetPlayerByID(OwnerPlayerID);
	}

	private void OnPlayerLeft(ulong playerID, StaticString playerLeftName)
	{
		if (playerID == OwnerPlayerID)
		{
			if (this.OnOwnerLeft != null)
			{
				this.OnOwnerLeft();
			}
			ChangeOwner(NextOwnerPlayerID);
		}
	}

	public void ChangeOwner(ulong newOwnerPlayerID)
	{
		Diagnostics.Log("{0} > Changing owner from {1} to {2}", base.name, OwnerPlayerID, newOwnerPlayerID);
		if (newOwnerPlayerID == OwnerPlayerID)
		{
			Diagnostics.LogWarning(base.name + " > Already owned by net player #" + OwnerPlayerID);
			return;
		}
		SetOwner(newOwnerPlayerID);
		if (this.OnOwnerChanged != null)
		{
			this.OnOwnerChanged();
		}
	}

	public bool IsOwnedByLocalPlayer()
	{
		return gameNetManager.GetLocalPlayerID() == OwnerPlayerID || OwnerPlayerID == ulong.MaxValue;
	}

	public bool IsOwnedByServerPlayer()
	{
		return gameNetManager.GetServerPlayerID() == OwnerPlayerID;
	}

	public abstract void SendRPCToAll(Type type, string rpcName, params object[] args);

	public abstract void SendUnreliableRPCToAll(Type type, string rpcName, params object[] args);

	public abstract void SendRPCToOthers(Type type, string rpcName, params object[] args);

	public abstract void SendUnreliableRPCToOthers(Type type, string rpcName, params object[] args);

	public abstract void SendRPCToServer(Type type, string rpcName, params object[] args);

	public abstract void SendRPCToPlayer(Type type, ulong playerID, string rpcName, params object[] args);

	protected virtual void Awake()
	{
		OwnerPlayerID = ulong.MaxValue;
		gameNetManager = SingletonManager.Get<GameNetworkManager>();
		if (!gameNetManager.IsMultiplayerSession())
		{
			return;
		}
		ISessionService service = Services.GetService<ISessionService>();
		if (service == null)
		{
			Diagnostics.LogError("No session manager found!");
			return;
		}
		session = (Session)service.Session;
		if (session == null)
		{
			Diagnostics.LogError("No session found!");
		}
	}

	private void Update()
	{
	}

	private void OnDisable()
	{
		if (gameNetManager.IsMultiplayerSession())
		{
			gameNetManager.OnPlayerLeft -= OnPlayerLeft;
		}
	}
}
public enum SingletonRPC
{
	Dungeon_EnqueueEventNotification = 0,
	Dungeon_InstantiateGameStartHero = 1,
	Dungeon_OnCrystalPluggedOnExitSlot = 2,
	Dungeon_DoLevelOver = 3,
	Dungeon_HeartBeat = 4,
	Dungeon_ShowVictoryPanel = 5,
	Dungeon_IncrementDynamicRoomEventCount = 6,
	Dungeon_DoSpawnItem = 7,
	Dungeon_DoSpawnHero = 8,
	Dungeon_DoSpawnNPC = 9,
	Dungeon_InstantiateMob = 10,
	Dungeon_DoSpawnExit = 11,
	Dungeon_DoSpecialModuleSpawnFeedback = 12,
	Dungeon_DoSpawnToxicCloud = 13,
	Dungeon_BuildBackpackInventoryItem = 14,
	Dungeon_InstantiateLevelPersistentHero = 0xF,
	Dungeon_InstantiateSavedHero = 0x10,
	Dungeon_DoAddDust = 17,
	Dungeon_DoSaveAndQuit = 18,
	Dungeon_RequestMoveItemToBackpackInventory = 19,
	Dungeon_DoMoveItemToBackpackInventory = 20,
	Dungeon_RequestMoveItemToSharedInventory = 21,
	Dungeon_DoMoveItemToSharedInventory = 22,
	Dungeon_SetResearchableBPByCategory = 23,
	Dungeon_RequestResearchesReset = 24,
	Dungeon_DoResearchesReset = 25,
	Dungeon_InstantiateTamedMob = 26,
	Dungeon_TameMob = 27,
	Dungeon_DoRemoveItem = 28,
	INVALID = 10000
}
public class SingletonNetSyncElement : NetSyncElement
{
	private static readonly char RPC_TYPE_NAME_SEPARATOR = '_';

	private static Dictionary<int, string> rpcTypeNameByID = new Dictionary<int, string>();

	private static Dictionary<int, StaticString> rpcNameByID = new Dictionary<int, StaticString>();

	private string singletonTypeStr;

	private static SingletonRPC GetRPC(string singletonTypeStr, string rpcName)
	{
		//Discarded unreachable code: IL_0043
		string text = $"{singletonTypeStr}{RPC_TYPE_NAME_SEPARATOR}{rpcName}";
		try
		{
			return text.ToEnum<SingletonRPC>();
		}
		catch
		{
			Diagnostics.LogError("SingletonRPC.{0} not defined!", text);
			return SingletonRPC.INVALID;
		}
	}

	public static void GetRPCDataFromID(int rpcID, out string typeName, out StaticString rpcName)
	{
		SingletonRPC singletonRPC = rpcID.ToEnum<SingletonRPC>();
		if (!rpcTypeNameByID.ContainsKey(rpcID))
		{
			string[] array = singletonRPC.ToString().Split(RPC_TYPE_NAME_SEPARATOR);
			typeName = array[0];
			rpcName = new StaticString($"RPC_{array[1]}");
			rpcTypeNameByID.Add(rpcID, typeName);
			rpcNameByID.Add(rpcID, rpcName);
		}
		else
		{
			typeName = rpcTypeNameByID[rpcID];
			rpcName = rpcNameByID[rpcID];
		}
	}

	public override void SendRPCToAll(Type type, string rpcName, params object[] args)
	{
		SendRPCToAll(GetRPC(singletonTypeStr, rpcName), args);
	}

	public void SendRPCToAll(SingletonRPC rpc, params object[] args)
	{
		gameNetManager.SendRPCToAll(RPCProxyName.Singleton_RPC, (int)rpc, args);
	}

	public override void SendUnreliableRPCToAll(Type type, string rpcName, params object[] args)
	{
		SendUnreliableRPCToAll(GetRPC(singletonTypeStr, rpcName), args);
	}

	public void SendUnreliableRPCToAll(SingletonRPC rpc, params object[] args)
	{
		gameNetManager.SendUnreliableRPCToAll(RPCProxyName.Singleton_RPC, (int)rpc, args);
	}

	public override void SendRPCToOthers(Type type, string rpcName, params object[] args)
	{
		SendRPCToOthers(GetRPC(singletonTypeStr, rpcName), args);
	}

	public void SendRPCToOthers(SingletonRPC rpc, params object[] args)
	{
		gameNetManager.SendRPCToOthers(RPCProxyName.Singleton_RPC, (int)rpc, args);
	}

	public override void SendUnreliableRPCToOthers(Type type, string rpcName, params object[] args)
	{
		SendUnreliableRPCToOthers(GetRPC(singletonTypeStr, rpcName), args);
	}

	public void SendUnreliableRPCToOthers(SingletonRPC rpc, params object[] args)
	{
		gameNetManager.SendUnreliableRPCToOthers(RPCProxyName.Singleton_RPC, (int)rpc, args);
	}

	public override void SendRPCToServer(Type type, string rpcName, params object[] args)
	{
		SendRPCToServer(GetRPC(singletonTypeStr, rpcName), args);
	}

	public void SendRPCToServer(SingletonRPC rpc, params object[] args)
	{
		gameNetManager.SendRPCToServer(RPCProxyName.Singleton_RPC, (int)rpc, args);
	}

	public override void SendRPCToPlayer(Type type, ulong playerID, string rpcName, params object[] args)
	{
		SendRPCToPlayer(playerID, GetRPC(singletonTypeStr, rpcName), args);
	}

	public void SendRPCToPlayer(ulong playerID, SingletonRPC rpc, params object[] args)
	{
		gameNetManager.SendRPCToPlayer(playerID, RPCProxyName.Singleton_RPC, (int)rpc, args);
	}

	protected override void Awake()
	{
		base.Awake();
		Singleton component = GetComponent<Singleton>();
		singletonTypeStr = component.Instance.GetType().ToString();
	}
}
public enum UniqueIDRPC
{
	Room_DoAddCrystalSlot = 0,
	Room_RequestBuildModuleAtPosition = 1,
	Room_DoBuildMajorModule = 2,
	MajorModule_DoOnBuildComplete = 3,
	Room_ModuleBuildRequestResponse = 4,
	Hero_DoLevelUp = 5,
	Health_SetHealthValue = 6,
	Hero_DoRecruit = 7,
	Hero_DoCancelItemGathering = 8,
	Mover_DoFollowPath = 9,
	Mover_DoStopMove = 10,
	Hero_DisplayDoorOpening = 11,
	Door_RequestOpenByHeroOrMob = 12,
	Door_DoOpenByHeroOrMob = 13,
	Hero_DisplayDoorOpeningStop = 14,
	Attacker_DoSetTarget = 0xF,
	Room_RequestPower = 0x10,
	Room_RequestUnpower = 17,
	Room_DoBuildMinorModule = 18,
	Attacker_DisplayAttack = 19,
	Room_DoPower = 20,
	MinorModule_DoOnBuildComplete = 21,
	Health_DoTriggerDeath = 22,
	Health_DoHit = 23,
	ActiveSkill_DoActivate = 24,
	Hero_DoStartItemGathering = 25,
	Room_DoAutoPower = 26,
	Attacker_DoRegisterTargetKill = 27,
	NPCMerchant_FillInventory = 28,
	Room_DoDisplayWaveOffscreenMarker = 29,
	Artifact_DoOnBuildComplete = 30,
	Artifact_RequestResearchBluePrint = 0x1F,
	Hero_RequestUnplugCrystal = 0x20,
	Hero_DoUnplugCrystal = 33,
	Door_DoOpenForCrystalPhase = 34,
	Door_DoOpenForSaveRestore = 35,
	Hero_DoPlayLevelSuccessCinematic = 36,
	Hero_DoPlugCrystal = 37,
	Hero_RequestRecruit = 38,
	Hero_RequestEquipItemFromEquipmentSlot = 39,
	Hero_RequestBuyItemFromEquipmentSlot = 40,
	NPCMerchant_RequestSellItemFromMerchantPanel = 41,
	Artifact_DoResearchBluePrint = 42,
	Stele_DoOnBuildComplete = 43,
	Stele_DoSetType = 44,
	DustFactory_DoOnBuildComplete = 45,
	DustFactory_RunInteraction = 46,
	DustFactory_RunInteractionEnd = 47,
	CryoCapsule_DoOnBuildComplete = 48,
	CryoCapsule_RunInteraction = 49,
	CryoCapsule_RunInteractionEnd = 50,
	DustFactory_RunActivation = 51,
	CryoCapsule_RunActivation = 52,
	Hero_DoBuyItemFromEquipmentSlot = 53,
	Hero_EquipItemOnSlot = 54,
	DustFactory_ProduceDustLoot = 55,
	NPCMerchant_RequestBuyItemFromMerchantPanel = 56,
	Hero_UnequipItemFromSlot = 57,
	NPCMerchant_DoSellItemFromMerchantPanel = 58,
	Hero_InstantiateDeadHeroItem = 59,
	Hero_DoDismiss = 60,
	MajorModule_DoUpdateLevelToBP = 61,
	Hero_StartModuleOperating = 62,
	Hero_StopModuleOperating = 0x3F,
	NPCMerchant_DoBuyItemFromMerchantPanel = 0x40,
	Mover_UpdatePosition = 65,
	Room_DoUnpower = 66,
	Hero_StartModuleRepairing = 67,
	Hero_StopModuleRepairing = 68,
	Energy_SetHealthValue = 69,
	CryoCapsule_SpawnToxicCloud = 70,
	Room_ClearAllModuleSlotsRefs = 71,
	DustFactory_Explode = 72,
	MinorModule_DoUpdateLevelToBP = 73,
	Room_DoApplyEMP = 74,
	Hero_RequestLevelUp = 75,
	Mob_DoLevelUp = 76,
	MinorModule_DoSwitchLureMode = 77,
	Energy_DoHit = 78,
	Player_DoAddFood = 79,
	Player_DoAddIndustry = 80,
	Player_DoAddScience = 81,
	Hero_GiveToPlayer = 82,
	Player_DungeonCreated = 83,
	Player_DungeonPreFilled = 84,
	Player_DungeonFilled = 85,
	Module_DoRemove = 86,
	Mob_ApplyTameLevelUp = 87,
	Door_OnAttackerDied = 88,
	Hero_TameMob = 89,
	INVALID = 10000
}
[RequireComponent(typeof(UniqueID))]
public class UniqueIDNetSyncElement : NetSyncElement
{
	private static readonly char RPC_TYPE_NAME_SEPARATOR = '_';

	private static Dictionary<int, string> rpcTypeNameByID = new Dictionary<int, string>();

	private static Dictionary<int, StaticString> rpcNameByID = new Dictionary<int, StaticString>();

	private UniqueID uniqueID;

	private static UniqueIDRPC GetRPC(Type type, string rpcName)
	{
		//Discarded unreachable code: IL_0048
		string text = $"{type.ToString()}{RPC_TYPE_NAME_SEPARATOR}{rpcName}";
		try
		{
			return text.ToEnum<UniqueIDRPC>();
		}
		catch
		{
			Diagnostics.LogError("UniqueIDRPC.{0} not defined!", text);
			return UniqueIDRPC.INVALID;
		}
	}

	public static void GetRPCDataFromID(int rpcID, out string typeName, out StaticString rpcName)
	{
		UniqueIDRPC uniqueIDRPC = rpcID.ToEnum<UniqueIDRPC>();
		if (!rpcTypeNameByID.ContainsKey(rpcID))
		{
			string[] array = uniqueIDRPC.ToString().Split(RPC_TYPE_NAME_SEPARATOR);
			typeName = array[0];
			rpcName = new StaticString($"RPC_{array[1]}");
			rpcTypeNameByID.Add(rpcID, typeName);
			rpcNameByID.Add(rpcID, rpcName);
		}
		else
		{
			typeName = rpcTypeNameByID[rpcID];
			rpcName = rpcNameByID[rpcID];
		}
	}

	public override void SetOwner(ulong ownerPlayerID)
	{
		base.SetOwner(ownerPlayerID);
		if (uniqueID.ID == 0)
		{
			uniqueID.RequestUniqueIDForPlayer(ownerPlayerID);
		}
	}

	public override void SendRPCToAll(Type type, string rpcName, params object[] args)
	{
		SendRPCToAll(GetRPC(type, rpcName), args);
	}

	public void SendRPCToAll(UniqueIDRPC rpc, params object[] args)
	{
		gameNetManager.SendRPCToAll(RPCProxyName.UniqueID_RPC, uniqueID.GetCategory(), uniqueID.ID, (int)rpc, args);
	}

	public override void SendUnreliableRPCToAll(Type type, string rpcName, params object[] args)
	{
		SendUnreliableRPCToAll(GetRPC(type, rpcName), args);
	}

	public void SendUnreliableRPCToAll(UniqueIDRPC rpc, params object[] args)
	{
		gameNetManager.SendUnreliableRPCToAll(RPCProxyName.UniqueID_RPC, uniqueID.GetCategory(), uniqueID.ID, (int)rpc, args);
	}

	public override void SendRPCToOthers(Type type, string rpcName, params object[] args)
	{
		SendRPCToOthers(GetRPC(type, rpcName), args);
	}

	public void SendRPCToOthers(UniqueIDRPC rpc, params object[] args)
	{
		gameNetManager.SendRPCToOthers(RPCProxyName.UniqueID_RPC, uniqueID.GetCategory(), uniqueID.ID, (int)rpc, args);
	}

	public override void SendUnreliableRPCToOthers(Type type, string rpcName, params object[] args)
	{
		SendUnreliableRPCToOthers(GetRPC(type, rpcName), args);
	}

	public void SendUnreliableRPCToOthers(UniqueIDRPC rpc, params object[] args)
	{
		gameNetManager.SendUnreliableRPCToOthers(RPCProxyName.UniqueID_RPC, uniqueID.GetCategory(), uniqueID.ID, (int)rpc, args);
	}

	public override void SendRPCToServer(Type type, string rpcName, params object[] args)
	{
		SendRPCToServer(GetRPC(type, rpcName), args);
	}

	public void SendRPCToServer(UniqueIDRPC rpc, params object[] args)
	{
		gameNetManager.SendRPCToServer(RPCProxyName.UniqueID_RPC, uniqueID.GetCategory(), uniqueID.ID, (int)rpc, args);
	}

	public override void SendRPCToPlayer(Type type, ulong playerID, string rpcName, params object[] args)
	{
		SendRPCToPlayer(playerID, GetRPC(type, rpcName), args);
	}

	public void SendRPCToPlayer(ulong playerID, UniqueIDRPC rpc, params object[] args)
	{
		gameNetManager.SendRPCToPlayer(playerID, RPCProxyName.UniqueID_RPC, uniqueID.GetCategory(), uniqueID.ID, (int)rpc, args);
	}

	protected override void Awake()
	{
		base.Awake();
		uniqueID = GetComponent<UniqueID>();
	}
}
public class Runtime : Amplitude.Unity.Runtime.Runtime
{
	public static ushort SteamPort = 8766;

	public static ushort GamePort = 27015;

	public static ushort QueryPort = 27016;

	public static string ModDir = "dungeonoftheendless";

	public static string Version = "1.0.0.0";

	public Runtime()
	{
		base.FiniteStateMachine.RegisterInitialState(new RuntimeState_OutGame());
		base.FiniteStateMachine.RegisterState(new RuntimeState_Lobby());
	}
}
[Serializable]
public class RuntimeManager : Amplitude.Unity.Runtime.RuntimeManager
{
	public RuntimeManager()
	{
		base.RuntimeClass = typeof(Runtime);
	}
}
public class RuntimeState : FiniteState
{
	private IPlatformService SteamService
	{
		get;
		set;
	}

	public RuntimeState()
	{
		SteamService = Services.GetService<IPlatformService>();
		Diagnostics.Assert(SteamService != null);
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		SteamService.SteamGameLobbyJoinRequested += SteamService_SteamGameLobbyJoinRequested;
	}

	public override void End(bool abort)
	{
		base.End(abort);
		SteamService.SteamGameLobbyJoinRequested -= SteamService_SteamGameLobbyJoinRequested;
	}

	protected virtual void OnGameLobbyJoinRequested(object sender, SteamGameLobbyJoinRequestedEventArgs e)
	{
		Steamworks.GameLobbyJoinRequested message = e.Message;
		object arg = message.m_steamIDLobby;
		Steamworks.GameLobbyJoinRequested message2 = e.Message;
		Diagnostics.Log($"[Social] OnGameLobbyJoinRequested lobby={arg} user={message2.m_steamIDFriend}.");
	}

	private void SteamService_SteamGameLobbyJoinRequested(object sender, SteamGameLobbyJoinRequestedEventArgs e)
	{
		OnGameLobbyJoinRequested(sender, e);
	}
}
public class RuntimeState_Game : RuntimeState
{
	private ISessionService sessionService;

	public object[] Parameters
	{
		get;
		private set;
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Parameters = parameters;
		sessionService = Services.GetService<ISessionService>();
		if (sessionService != null)
		{
			sessionService.SessionChange += SessionService_SessionChange;
			sessionService.ReleaseSession();
			sessionService.CreateSession();
		}
	}

	public override void End(bool abort)
	{
		base.End(abort);
		if (sessionService != null)
		{
			sessionService.SessionChange -= SessionService_SessionChange;
			sessionService.ReleaseSession();
			sessionService = null;
		}
	}

	private void SessionService_SessionChange(object sender, SessionChangeEventArgs e)
	{
		if (e.Action == SessionChangeAction.Created)
		{
			Diagnostics.Log("The session has been created; opening the session in 'Single' mode (default)...");
			e.Session.Open(SessionMode.Single, 1);
		}
	}
}
public class RuntimeState_Lobby : RuntimeState
{
	private Session session;

	private bool isLobbyFull;

	private ISteamMatchMakingService matchMakingManager;

	private GameNetworkManager gameNetworkManager;

	[Service]
	private ISessionService SessionService;

	private ulong steamIDLobbyToJoin;

	private SessionMode sessionModeToOpenWith;

	private string saveKey;

	private int slotCount = -1;

	private Session Session
	{
		get
		{
			return session;
		}
		set
		{
			if (session != value)
			{
				if (session != null)
				{
					Session.LobbyDataChange -= Session_LobbyDataChange;
					Session.LobbyChatUpdate -= Session_LobbyChatUpdate;
					Session.LobbyEnter -= Session_LobbyEnter;
				}
				session = value;
				if (session != null)
				{
					Session.LobbyDataChange += Session_LobbyDataChange;
					Session.LobbyChatUpdate += Session_LobbyChatUpdate;
					Session.LobbyEnter += Session_LobbyEnter;
				}
			}
		}
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		sessionModeToOpenWith = SessionMode.Single;
		steamIDLobbyToJoin = 0uL;
		saveKey = null;
		slotCount = -1;
		if (parameters != null)
		{
			for (int i = 0; i < parameters.Length; i++)
			{
				if (parameters[i] is ulong)
				{
					steamIDLobbyToJoin = (ulong)parameters[i];
				}
				else if (parameters[i] is SessionMode)
				{
					sessionModeToOpenWith = (SessionMode)(int)parameters[i];
				}
				else if (parameters[i] is string)
				{
					saveKey = (string)parameters[i];
				}
				else if (parameters[i] is int)
				{
					slotCount = (int)parameters[i];
				}
			}
		}
		SessionService = Services.GetService<ISessionService>();
		matchMakingManager = Services.GetService<ISteamMatchMakingService>();
		gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
		if (SessionService != null)
		{
			SessionService.SessionChange += SessionService_SessionChange;
			SessionService.ReleaseSession();
			SessionService.CreateSession();
		}
	}

	public override void End(bool abort)
	{
		base.End(abort);
		if (Session != null)
		{
			Session = null;
		}
		if (SessionService != null)
		{
			SessionService.SessionChange -= SessionService_SessionChange;
			SessionService.ReleaseSession();
			SessionService = null;
		}
	}

	protected override void OnGameLobbyJoinRequested(object sender, SteamGameLobbyJoinRequestedEventArgs e)
	{
		base.OnGameLobbyJoinRequested(sender, e);
		Steamworks.GameLobbyJoinRequested message = e.Message;
		if (message.m_steamIDLobby != steamIDLobbyToJoin)
		{
			SingletonManager.Get<RequesterPanel>().Display(AgeLocalizer.Instance.LocalizeString("%ConfirmLobbyJoinRequest"), delegate(RequesterPanel.Result result)
			{
				if (result == RequesterPanel.Result.Yes)
				{
					if (Session.GameClient != null)
					{
						Session.GameClient.Disconnect(GameDisconnectionReason.ClientLeft, 64);
					}
					Session.Close();
					IRuntimeService service = Services.GetService<IRuntimeService>();
					if (service != null)
					{
						FiniteStateMachine finiteStateMachine = service.Runtime.FiniteStateMachine;
						Type typeFromHandle = typeof(RuntimeState_OutGame);
						object[] array = new object[1];
						Steamworks.GameLobbyJoinRequested message2 = e.Message;
						array[0] = message2.m_steamIDLobby;
						finiteStateMachine.PostStateChange(typeFromHandle, array);
					}
				}
			}, RequesterPanel.ButtonsMode.YesNo);
		}
	}

	private void Session_LobbyChatUpdate(object sender, LobbyChatUpdateEventArgs e)
	{
		string playerName = session.GetPlayerName(e.SteamIDUserChanged);
		switch (e.ChatMemberStateChange)
		{
		case (LobbyChatUpdateStateChange)3u:
		case (LobbyChatUpdateStateChange)5u:
		case (LobbyChatUpdateStateChange)6u:
		case (LobbyChatUpdateStateChange)7u:
			break;
		case LobbyChatUpdateStateChange.Entered:
		{
			Diagnostics.Log("[Lobby] Player '{0}' has joined the lobby", playerName);
			if (!Session.IsHosting)
			{
				break;
			}
			int lobbyDataInt2 = Session.GetLobbyDataInt(SessionBase.LOBBYDATA_MAXPLAYERCOUNT, gameNetworkManager.GetMultiplayerMaxPlayerCount());
			bool alreadyInLobby;
			int num = Session.AddPlayerToLobby((uint)lobbyDataInt2, e.SteamIDUserChanged.UInt64AccountID, playerName, out alreadyInLobby);
			if (alreadyInLobby)
			{
				break;
			}
			if (num >= lobbyDataInt2)
			{
				if (!isLobbyFull)
				{
					isLobbyFull = true;
					Diagnostics.Log(lobbyDataInt2 - num + " available lobby slots: setting lobby as PRIVATE");
					matchMakingManager.SteamMatchMaking.SetLobbyType(Session.SteamIDLobby, Steamworks.SteamMatchMaking.ELobbyType.k_ELobbyTypePrivate);
				}
			}
			else if (isLobbyFull)
			{
				isLobbyFull = false;
				Diagnostics.Log(lobbyDataInt2 - num + " available lobby slots: setting lobby as PUBLIC");
				matchMakingManager.SteamMatchMaking.SetLobbyType(Session.SteamIDLobby, Steamworks.SteamMatchMaking.ELobbyType.k_ELobbyTypePublic);
			}
			break;
		}
		case LobbyChatUpdateStateChange.Left:
		{
			Diagnostics.Log("[Lobby] Player '{0}' has left the lobby.", playerName);
			if (!Session.IsHosting)
			{
				break;
			}
			int lobbyDataInt = Session.GetLobbyDataInt(SessionBase.LOBBYDATA_MAXPLAYERCOUNT, gameNetworkManager.GetMultiplayerMaxPlayerCount());
			if (Session.RemoveUserFromLobby((uint)lobbyDataInt, e.SteamIDUserChanged.UInt64AccountID.ToString(), playerName) && isLobbyFull)
			{
				isLobbyFull = false;
				Diagnostics.Log("Player left: setting lobby as PUBLIC");
				if (Session.CurrentState is SessionState_Opened)
				{
					matchMakingManager.SteamMatchMaking.SetLobbyType(Session.SteamIDLobby, Steamworks.SteamMatchMaking.ELobbyType.k_ELobbyTypePublic);
				}
			}
			break;
		}
		case LobbyChatUpdateStateChange.Disconnected:
			Diagnostics.LogWarning("[Lobby] player '{0}' has disconnected from the lobby", playerName);
			break;
		case LobbyChatUpdateStateChange.Kicked:
			Diagnostics.LogWarning("[Lobby] player '{0}' has been kicked from the lobby", playerName);
			break;
		}
	}

	private void Session_LobbyDataChange(object sender, LobbyDataChangeEventArgs e)
	{
		if (Session == null || !e.Key.ToString().EndsWith(SessionBase.LOBBYDATA_KICK_SUFFIX))
		{
			return;
		}
		ulong[] lobbyPlayerIDs = gameNetworkManager.GetLobbyPlayerIDs();
		ulong localPlayerID = gameNetworkManager.GetLocalPlayerID();
		foreach (ulong num in lobbyPlayerIDs)
		{
			bool flag = num == localPlayerID;
			int playerSlotIndex = gameNetworkManager.GetPlayerSlotIndex(num);
			string x = string.Format(SessionBase.LOBBYDATA_KICK_BY_SLOT_INDEX, playerSlotIndex);
			if (!(e.Key == x) || e.Data == null || !(e.Data is string))
			{
				continue;
			}
			string text = e.Data as string;
			if (!string.IsNullOrEmpty(text))
			{
				if (flag)
				{
					Diagnostics.LogWarning("You've just been kicked out of the lobby. You mad?");
					SingletonManager.Get<RequesterPanel>().Display(AgeLocalizer.Instance.LocalizeString("%LocalPlayerKickedMessage_" + text));
					SingletonManager.Get<GameSelectionPanel>().QuitLobby();
				}
				else
				{
					string playerName = gameNetworkManager.GetPlayerName(num);
					Diagnostics.LogWarning("{0} has been kicked out of the lobby", playerName);
					string message = AgeLocalizer.Instance.LocalizeString("%PlayerKickedChatMessage_" + text).Replace("$PlayerName", playerName);
					SingletonManager.Get<ChatManager>().WriteLocalMessage(message);
				}
			}
		}
	}

	private void Session_LobbyEnter(object sender, LobbyEnterEventArgs e)
	{
		Diagnostics.Log("[RuntimeState_Lobby] Lobby Entered.");
		Session.SetLobbyMemberData(Session.MEMBERDATA_IS_READY, false);
	}

	private void SessionService_SessionChange(object sender, SessionChangeEventArgs e)
	{
		switch (e.Action)
		{
		case SessionChangeAction.Opening:
		case SessionChangeAction.Closed:
		case SessionChangeAction.Reopening:
			break;
		case SessionChangeAction.Created:
			Session = (e.Session as Session);
			if (steamIDLobbyToJoin != 0L)
			{
				Diagnostics.Log("The session has been created; opening the session in 'Public' mode");
				e.Session.Open(steamIDLobbyToJoin);
			}
			else
			{
				Diagnostics.Log("The session has been created; opening the session in '{0}' mode...", sessionModeToOpenWith);
				e.Session.Open(sessionModeToOpenWith, gameNetworkManager.GetMultiplayerMaxPlayerCount());
			}
			break;
		case SessionChangeAction.Opened:
			Diagnostics.Log("The session has been opened.");
			if (Session.IsHosting)
			{
				string localPlayerName = Session.GetLocalPlayerName();
				Session.SetLobbyData(SessionBase.LOBBYDATA_APPLICATIONVERSION, Amplitude.Unity.Framework.Application.Version.ToString());
				Session.SetLobbyData(Session.LOBBYDATA_APPLICATION_CHECKSUM, HashManager.GetCurrentHash());
				string text = null;
				if (!string.IsNullOrEmpty(saveKey))
				{
					Session.SetLobbyData(Session.LOBBYDATA_SAVE_KEY, saveKey);
					SaveInfo saveInfo = UserProfile.Data.GetSaveInfo(saveKey);
					string text2 = string.Empty;
					for (int i = 0; i < saveInfo.PlayerIDs.Length; i++)
					{
						text2 += saveInfo.PlayerIDs[i].ToString();
						if (i < saveInfo.PlayerIDs.Length - 1)
						{
							text2 += Session.LOBBYDATA_PLAYER_IDS_SEPARATOR;
						}
					}
					Session.SetLobbyData(Session.LOBBYDATA_PLAYER_IDS, text2);
					text = saveInfo.GetMPSaveName();
				}
				else
				{
					text = localPlayerName;
				}
				Session.SetLobbyData(Session.LOBBYDATA_GAME_NAME, text);
				Session.SetLobbyData(SessionBase.LOBBYDATA_MAXPLAYERCOUNT, gameNetworkManager.GetMultiplayerMaxPlayerCount());
				int lobbyDataInt = Session.GetLobbyDataInt(SessionBase.LOBBYDATA_MAXPLAYERCOUNT);
				Diagnostics.Assert(lobbyDataInt > 0);
				Diagnostics.Assert(lobbyDataInt <= 32);
				for (int j = 0; j < lobbyDataInt; j++)
				{
					string x = string.Format(SessionBase.LOBBYDATA_HERO_BY_SLOT_INDEX, j);
					string x2 = string.Format(SessionBase.LOBBYDATA_SLOT_INDEX_BY_PLAYER_ID, Session.UserID.ToString());
					if (j == 0)
					{
						Session.SetPlayerIdForSlotIndex(j, Session.UserID.ToString());
						Session.SetLobbyData(x, string.Empty);
						Session.SetLobbyData(x2, j.ToString());
					}
				}
				if (Session.SessionMode == SessionMode.Single)
				{
					Session.LocalPlayerReady = true;
				}
			}
			if (Session.SessionMode != 0)
			{
				SingletonManager.Get<GameSelectionPanel>().Display(isMultiplayer: true, saveKey, slotCount);
			}
			break;
		case SessionChangeAction.Reopened:
			Diagnostics.Log("The session has been reopened.");
			break;
		case SessionChangeAction.Releasing:
		case SessionChangeAction.Released:
			Session = null;
			break;
		}
	}
}
public class RuntimeState_OutGame : RuntimeState
{
	private IGuiService guiService;

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Services.GetService<IViewService>()?.PostViewChange(typeof(OutGameView));
		if (AgeLocalizer.Instance != null)
		{
			SetRichPresenceStatus();
		}
		else
		{
			guiService = Services.GetService<IGuiService>();
			Diagnostics.Assert(guiService != null);
			guiService.GuiSceneStateChange += IGuiService_GuiSceneStateChange;
		}
		if (parameters.Length == 1 && parameters[0] is ulong)
		{
			Steamworks.SteamID steamID = new Steamworks.SteamID((ulong)parameters[0]);
			if (steamID.IsValid)
			{
				IGameControlService service = Services.GetService<IGameControlService>();
				service.JoinMultiplayerGame(steamID, checkLobbyType: false);
			}
		}
	}

	public override void End(bool abort)
	{
		base.End(abort);
		if (guiService != null)
		{
			guiService.GuiSceneStateChange -= IGuiService_GuiSceneStateChange;
			guiService = null;
		}
	}

	protected override void OnGameLobbyJoinRequested(object sender, SteamGameLobbyJoinRequestedEventArgs e)
	{
		base.OnGameLobbyJoinRequested(sender, e);
		Steamworks.GameLobbyJoinRequested message = e.Message;
		Steamworks.SteamID steamID = new Steamworks.SteamID(message.m_steamIDLobby);
		if (steamID.IsValid)
		{
			GameSelectionPanel gameSelectionPanel = SingletonManager.Get<GameSelectionPanel>();
			if (gameSelectionPanel.IsVisible)
			{
				gameSelectionPanel.QuitLobby(instantHide: true);
			}
			IGameControlService service = Services.GetService<IGameControlService>();
			service.JoinMultiplayerGame(steamID, checkLobbyType: false);
		}
	}

	private void SetRichPresenceStatus()
	{
		Steamworks.SteamAPI.SteamFriends.SetRichPresence("status", AgeLocalizer.Instance.LocalizeString("%RichPresenceInMainMenu"));
	}

	private void IGuiService_GuiSceneStateChange(object sender, GuiSceneStateChangedEventArgs e)
	{
		if (e.NewState == GuiSceneStateChangedEventArgs.GuiSceneState.Loaded)
		{
			SetRichPresenceStatus();
		}
	}
}
public class DataFileManager
{
	private static readonly string CryptoKey;

	private static readonly string CryptoIV;

	private static readonly string ArchiveSubFileName;

	public static UTF8Encoding UTF8Encoder;

	private static readonly XmlWriterSettings xmlWriterSettings;

	private static XmlAttributeOverrides xmlSerializationAttributeOverrides;

	static DataFileManager()
	{
		xmlWriterSettings = new XmlWriterSettings
		{
			Encoding = Encoding.UTF8,
			Indent = true,
			IndentChars = "  ",
			NewLineChars = "\r\n",
			NewLineHandling = NewLineHandling.Replace,
			OmitXmlDeclaration = false
		};
		CryptoKey = "547yM-4f6S5sfM.6Fx4T4s46scjv34_d";
		CryptoIV = "polkcjvD0735sf4D";
		ArchiveSubFileName = "DOTE.bin";
		UTF8Encoder = new UTF8Encoding();
		xmlSerializationAttributeOverrides = new XmlAttributeOverrides();
		XmlAttributes attributes = new XmlAttributes
		{
			XmlIgnore = true
		};
		xmlSerializationAttributeOverrides.Add(typeof(DungeonPersistentGameData), "FoodStock", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(DungeonPersistentGameData), "IndustryStock", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(DungeonPersistentGameData), "ScienceStock", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(DungeonPersistentGameData), "PreviousLevelSelectedMobConfigs", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(DungeonGenerationSaveData), "FoodStock", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(DungeonGenerationSaveData), "IndustryStock", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(DungeonGenerationSaveData), "ScienceStock", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(DungeonGenerationSaveData), "PreviousLevelSelectedMobConfigs", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(DungeonGenerationSaveData), "ShipIndex", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(GameSaveData), "FoodStock", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(GameSaveData), "IndustryStock", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(GameSaveData), "ScienceStock", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(GameSaveData), "PreviousLevelSelectedMobConfigs", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(GameSaveData), "ShipIndex", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(UserProfileData), "SaveValidationKey", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(UserProfileData), "UserSaveValidationKey", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(UserProfileData), "AutoSaveValidationKey", attributes);
		xmlSerializationAttributeOverrides.Add(typeof(UserProfileData), "IsInGame", attributes);
	}

	public static bool TryGetClearFileContent(string filePath, out string clearContentStr, out bool oldSerialization)
	{
		clearContentStr = null;
		oldSerialization = false;
		if (!File.Exists(filePath))
		{
			Diagnostics.LogError(filePath + " file does not exist!");
			return false;
		}
		byte[] buffer = File.ReadAllBytes(filePath);
		byte[] bytes = null;
		bool flag = false;
		try
		{
			CryptoUtils cryptoUtils = new CryptoUtils(CryptoKey, CryptoIV);
			bytes = cryptoUtils.Decrypt(buffer);
			flag = true;
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("{0} decryption failed: {1}\n{2}", filePath, ex.ToString(), ex.StackTrace);
			Diagnostics.LogWarning("Trying to import data file as old format...");
			if (TryGetClearFileContent_OLD(filePath, out clearContentStr))
			{
				EncryptAndWriteContentToFile(filePath, clearContentStr);
				oldSerialization = true;
				return true;
			}
		}
		if (!flag)
		{
			Diagnostics.LogWarning("Deleting {0}", filePath);
			GenericUtilities.MoveFileSafe(filePath, filePath + ".decrypt.ko");
			return false;
		}
		clearContentStr = UTF8Encoder.GetString(bytes);
		return true;
	}

	public static bool TryGetClearFileContent_OLD(string filePath, out string clearContentStr)
	{
		clearContentStr = null;
		if (!File.Exists(filePath))
		{
			Diagnostics.LogError(filePath + " file does not exist!");
			return false;
		}
		Archive archive = null;
		MemoryStream stream = null;
		byte[] array = null;
		bool flag = false;
		try
		{
			archive = Archive.Open(filePath, ArchiveMode.Open);
			if (archive.TryGet(ArchiveSubFileName, out stream))
			{
				array = new byte[stream.Length];
				stream.Read(array, 0, (int)stream.Length);
				flag = true;
			}
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("{0} OLD decryption failed: {1}\n{2}", filePath, ex.ToString(), ex.StackTrace);
		}
		finally
		{
			archive?.Close();
			stream?.Close();
		}
		if (!flag)
		{
			return false;
		}
		clearContentStr = UTF8Encoder.GetString(array);
		return true;
	}

	public static bool TryDeserializeData<T>(string serial, short minSerial, out T data, bool checkUserID = true) where T : SerializableData
	{
		data = (T)null;
		bool flag = false;
		byte[] bytes = UTF8Encoder.GetBytes(serial);
		MemoryStream memoryStream = new MemoryStream(bytes);
		XmlReader xmlReader = null;
		XmlSerializer xmlSerializer = new XmlSerializer(typeof(T));
		try
		{
			using (xmlReader = XmlReader.Create(memoryStream))
			{
				xmlReader.ReadToDescendant(typeof(T).FullName);
				data = (xmlSerializer.Deserialize(xmlReader) as T);
				flag = true;
			}
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("XML deserialization failed: {0}\n{1}", ex.Message, ex.StackTrace);
		}
		finally
		{
			memoryStream?.Dispose();
			xmlReader?.Close();
		}
		if (!flag)
		{
			return false;
		}
		if (minSerial >= 0 && data.Version.Serial < minSerial)
		{
			Diagnostics.LogError("Serial version mismatch (" + data.Version.Serial + " < " + minSerial + ")!");
			return false;
		}
		if (checkUserID && data.Version.Serial >= 19 && data.SteamUserID != (ulong)Steamworks.SteamAPI.SteamUser.SteamID)
		{
			Diagnostics.LogError("Steam user ID mismatch (" + data.SteamUserID + " != " + Steamworks.SteamAPI.SteamUser.SteamID + ")!");
			return false;
		}
		return true;
	}

	public static bool TryGetDataFromFile<T>(string filePath, short minSerial, short oldMinSerial, out T data, out bool oldSerialization) where T : SerializableData
	{
		data = (T)null;
		if (!TryGetClearFileContent(filePath, out string clearContentStr, out oldSerialization))
		{
			return false;
		}
		return TryDeserializeData(clearContentStr, (!oldSerialization) ? minSerial : oldMinSerial, out data);
	}

	public static void EncryptAndWriteContentToFile(string filePath, string content)
	{
		//Discarded unreachable code: IL_004a
		byte[] bytes = UTF8Encoder.GetBytes(content);
		byte[] array = null;
		try
		{
			CryptoUtils cryptoUtils = new CryptoUtils(CryptoKey, CryptoIV);
			array = cryptoUtils.Encrypt(bytes);
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Serialization failed: {0}", ex.ToString());
			return;
		}
		string directoryName = System.IO.Path.GetDirectoryName(filePath);
		if (!Directory.Exists(directoryName))
		{
			Directory.CreateDirectory(directoryName);
		}
		File.WriteAllBytes(filePath, array);
	}

	public static string SerializeData<T>(T data) where T : SerializableData
	{
		string result = null;
		MemoryStream memoryStream = new MemoryStream();
		XmlWriter xmlWriter = null;
		XmlSerializer xmlSerializer = new XmlSerializer(typeof(T), xmlSerializationAttributeOverrides);
		try
		{
			using (xmlWriter = XmlWriter.Create(memoryStream, xmlWriterSettings))
			{
				xmlWriter.WriteStartDocument();
				xmlSerializer.Serialize(xmlWriter, data);
				byte[] bytes = memoryStream.ToArray();
				result = UTF8Encoder.GetString(bytes);
				return result;
			}
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("XML serialization failed: {0}\n{1}", ex.Message, ex.StackTrace);
			return result;
		}
		finally
		{
			xmlWriter?.Close();
		}
	}

	public static void WriteDataToFile<T>(string filePath, T data, bool useCrypto = true) where T : SerializableData
	{
		if (data == null)
		{
			Diagnostics.LogError("WriteXMLDataFile: data is null!");
			return;
		}
		data.Version = Amplitude.Unity.Framework.Application.Version;
		data.SteamUserID = Steamworks.SteamAPI.SteamUser.SteamID;
		string text = SerializeData(data);
		if (text != null)
		{
			EncryptAndWriteContentToFile(filePath, text);
		}
	}
}
public struct ArtifactSaveData
{
	public int RoomID;

	public float Health;

	public StaticString ResearchedBPName;

	public int ResearchStartTurn;
}
public struct BackstoryData
{
	public string HeroName;

	public string StoryName;

	public int StepIndex;

	public string Text;
}
public struct BluePrintSaveData
{
	public StaticString BluePrintName;
}
public struct DoorOpeningData
{
	public int DoorID;

	public int OpeningRoomID;
}
public class DungeonGenerationSaveData : DungeonPersistentGameData
{
	public int Level;

	public StaticString ShipName;

	public GameDifficulty GameDifficulty;

	public int ShipIndex
	{
		private get
		{
			Diagnostics.LogError("DungeonGenerationSaveData.ShipIndex shouldn't be accessed!");
			return -1;
		}
		set
		{
			if (value >= 0)
			{
				Diagnostics.LogWarning("Converting DungeonGenerationSaveData.ShipIndex to DungeonGenerationSaveData.ShipName!");
				ShipName = Databases.GetDatabase<ShipConfig>().GetValues()[value].Name;
			}
		}
	}
}
public class DungeonPersistentGameData : SerializableData
{
	public float DustStock;

	public PlayerSaveData[] Players;

	public StaticString[] StatisticsKeys;

	public float[] StatisticsValues;

	public int Score;

	public int ResetResearchesCount;

	public int TotalMissedDoorCount;

	public StaticString[] HeroConfigNamePool;

	public HeroPersistentData[] HeroesPersistent;

	public BluePrintSaveData[] UnlockedBluePrints;

	public BluePrintSaveData[] ResearchableBluePrints;

	public string[] LockedBluePrints;

	public InventoryItemData[] BackpackInventoryItems;

	public TemporarySimDescriptor[] TempSimDescs;

	public StorySaveData[] StoriesInProgress;

	public string LastStoryPlayed;

	public StaticString[][] HeroGroups;

	public StaticString[] PreviousLevelSelectedMobNames;

	public float FoodStock
	{
		private get
		{
			Diagnostics.LogError("DungeonPersistentGameData.FoodStock shouldn't be accessed!");
			return -1f;
		}
		set
		{
			if (Version.Serial < 18)
			{
				Diagnostics.LogWarning("Converting DungeonGenerationSaveData.FoodStock to DungeonGenerationSaveData.Player.FoodStock!");
				if (Players == null)
				{
					Players = new PlayerSaveData[1];
					Players[0].ID = SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID();
				}
				Players[0].FoodStock = value;
			}
		}
	}

	public float IndustryStock
	{
		private get
		{
			Diagnostics.LogError("DungeonPersistentGameData.IndustryStock shouldn't be accessed!");
			return -1f;
		}
		set
		{
			if (Version.Serial < 18)
			{
				Diagnostics.LogWarning("Converting DungeonGenerationSaveData.IndustryStock to DungeonGenerationSaveData.Player.IndustryStock!");
				if (Players == null)
				{
					Players = new PlayerSaveData[1];
					Players[0].ID = SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID();
				}
				Players[0].IndustryStock = value;
			}
		}
	}

	public float ScienceStock
	{
		private get
		{
			Diagnostics.LogError("DungeonPersistentGameData.ScienceStock shouldn't be accessed!");
			return -1f;
		}
		set
		{
			if (Version.Serial < 18)
			{
				Diagnostics.LogWarning("Converting DungeonGenerationSaveData.ScienceStock to DungeonGenerationSaveData.Player.ScienceStock!");
				if (Players == null)
				{
					Players = new PlayerSaveData[1];
					Players[0].ID = SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID();
				}
				Players[0].ScienceStock = value;
			}
		}
	}

	public MobConfig[] PreviousLevelSelectedMobConfigs
	{
		get
		{
			Diagnostics.LogError("Shouldn't have to get DungeonPersistentGameData.PreviousLevelSelectedMobConfigs (DEPRECATED, replaced by DungeonPersistentGameData.PreviousLevelSelectedMobNames)");
			return null;
		}
		set
		{
			if (value != null)
			{
				Diagnostics.LogWarning("Converting DungeonPersistentGameData.PreviousLevelSelectedMobConfigs to DungeonPersistentGameData.PreviousLevelSelectedMobNames!");
				PreviousLevelSelectedMobNames = new StaticString[value.Length];
				for (int i = 0; i < value.Length; i++)
				{
					PreviousLevelSelectedMobNames[i] = value[i].Name;
				}
			}
		}
	}

	public int GetStillConnectedPlayerCount()
	{
		int num = 0;
		for (int i = 0; i < Players.Length; i++)
		{
			if (Players[i].IsStillConnected)
			{
				num++;
			}
		}
		return num;
	}
}
public struct DustLootSaveData
{
	public Vector3 Position;

	public float Amount;

	public int ParentRoomID;
}
public struct DynamicRoomEventCountData
{
	public RoomEvent RoomEvent;

	public int Count;
}
public struct ExitSaveData
{
	public int RoomID;
}
public class GameSaveData : DungeonGenerationSaveData
{
	public int DungeonGeneratorRandomSeed;

	public int DungeonPostGenerationRandomSeed;

	public int Turn;

	public float CurrentLevelDifficulty;

	public int ExitWaveNumber;

	public SelectedMobSaveData[] LevelSelectedMobs;

	public float CurrentLevelTime;

	public Vector3 CameraSupportPosition;

	public RoomPowerData[] PoweredRooms;

	public DoorOpeningData[] OpenedDoorsHistory;

	public int[] RoomsCleanedFromModuleSlotsIDs;

	public HeroSaveData[] Heroes;

	public int[] SelectedHeroIndexes;

	public MerchantSaveData[] Merchants;

	public MinorModuleSaveData[] MinorModules;

	public MajorModuleSaveData[] MajorModules;

	public ModuleSlotSaveData[] ModuleSlots;

	public ArtifactSaveData[] Artifacts;

	public SteleSaveData[] Steles;

	public InventoryItemData[] GeneralInventoryItems;

	public LootItemSaveData[] LootItems;

	public DustLootSaveData[] DustLoots;

	public ExitSaveData[] Exits;

	public ProbabilityConfigOccurrenceCountData[] ProbabilityConfigOccurrenceCounts;

	public DynamicRoomEventCountData[] DynamicRoomEventCounts;

	public MaxedProbabilityConfigPickedElementCountData[] MaxedProbabilityConfigPickedElementCounts;

	public bool ReducedLogPanel;

	public int SelectedRoomId;

	public DungeonGenerationSaveData ConvertToAutoSave()
	{
		DungeonGenerationSaveData dungeonGenerationSaveData = new DungeonGenerationSaveData();
		dungeonGenerationSaveData.Level = Level - 1;
		dungeonGenerationSaveData.ShipName = ShipName;
		dungeonGenerationSaveData.GameDifficulty = GameDifficulty;
		dungeonGenerationSaveData.Players = Players;
		dungeonGenerationSaveData.StatisticsKeys = StatisticsKeys;
		dungeonGenerationSaveData.StatisticsValues = StatisticsValues;
		dungeonGenerationSaveData.Score = Score;
		dungeonGenerationSaveData.ResetResearchesCount = ResetResearchesCount;
		dungeonGenerationSaveData.TotalMissedDoorCount = TotalMissedDoorCount;
		dungeonGenerationSaveData.HeroConfigNamePool = HeroConfigNamePool;
		dungeonGenerationSaveData.HeroesPersistent = HeroesPersistent;
		dungeonGenerationSaveData.HeroesPersistent = new HeroPersistentData[Heroes.Length];
		for (int i = 0; i < Heroes.Length; i++)
		{
			dungeonGenerationSaveData.HeroesPersistent[i].OwnerPlayerID = SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID();
			dungeonGenerationSaveData.HeroesPersistent[i].HeroDescName = Heroes[i].SimDescName;
			dungeonGenerationSaveData.HeroesPersistent[i].Level = Heroes[i].Level;
			dungeonGenerationSaveData.HeroesPersistent[i].UnlockLevel = Heroes[i].UnlockLevel;
			dungeonGenerationSaveData.HeroesPersistent[i].Items = Heroes[i].Items;
			dungeonGenerationSaveData.HeroesPersistent[i].HasOperatingBonus = Heroes[i].HasOperatingBonus;
			dungeonGenerationSaveData.HeroesPersistent[i].FloorRecruited = Heroes[i].FloorRecruited;
			dungeonGenerationSaveData.HeroesPersistent[i].IsStartingHero = Heroes[i].IsStartingHero;
			dungeonGenerationSaveData.HeroesPersistent[i].PermanentDescriptors = Heroes[i].PermanentDescriptors;
		}
		dungeonGenerationSaveData.UnlockedBluePrints = UnlockedBluePrints;
		dungeonGenerationSaveData.ResearchableBluePrints = ResearchableBluePrints;
		dungeonGenerationSaveData.LockedBluePrints = LockedBluePrints;
		dungeonGenerationSaveData.PreviousLevelSelectedMobNames = PreviousLevelSelectedMobNames;
		dungeonGenerationSaveData.BackpackInventoryItems = BackpackInventoryItems;
		dungeonGenerationSaveData.TempSimDescs = TempSimDescs;
		dungeonGenerationSaveData.StoriesInProgress = StoriesInProgress;
		dungeonGenerationSaveData.LastStoryPlayed = LastStoryPlayed;
		dungeonGenerationSaveData.HeroGroups = HeroGroups;
		dungeonGenerationSaveData.Version = Version;
		dungeonGenerationSaveData.SteamUserID = SteamUserID;
		return dungeonGenerationSaveData;
	}
}
public class HeroActiveSkillData
{
	public StaticString SkillName;

	public int LastActivityTurn;

	private readonly char serializationSeparator = ';';

	public HeroActiveSkillData()
	{
	}

	public HeroActiveSkillData(string serial)
	{
		string[] array = serial.Split(serializationSeparator);
		SkillName = array[0];
		LastActivityTurn = int.Parse(array[1]);
	}

	public override string ToString()
	{
		return (string)SkillName + serializationSeparator + LastActivityTurn;
	}
}
public enum HeroStatus
{
	Unknown,
	Discovered,
	Unlocked
}
public struct HeroGameStatsData
{
	public StaticString ConfigName;

	public HeroStatus Status;

	public int RecruitCount;

	public int DeathCount;

	public int VictoryCount;
}
public class HeroItemData
{
	public StaticString CategoryName;

	public StaticString ItemDescName;

	public StaticString RarityDescName;

	private readonly char serializationSeparator = ';';

	public HeroItemData()
	{
	}

	public HeroItemData(string serial)
	{
		string[] array = serial.Split(serializationSeparator);
		CategoryName = array[0];
		ItemDescName = array[1];
		RarityDescName = array[2];
	}

	public override string ToString()
	{
		return (string)CategoryName + serializationSeparator + (string)ItemDescName + serializationSeparator + (string)RarityDescName;
	}
}
public struct HeroPersistentData
{
	public ulong OwnerPlayerID;

	public StaticString HeroDescName;

	public int Level;

	public int UnlockLevel;

	public HeroItemData[] Items;

	public bool HasOperatingBonus;

	public int FloorRecruited;

	public bool IsStartingHero;

	public StaticString[] PermanentDescriptors;

	public MobSaveData TamedMobData;

	public int CurrentRespawnRoomCount;
}
public struct HeroSaveData
{
	public ulong OwnerPlayerID;

	public Vector3 Position;

	public int ParentRoomID;

	public StaticString SimDescName;

	public int Level;

	public int UnlockLevel;

	public bool IsRecruited;

	public bool HasOperatingBonus;

	public float HealthValue;

	public float PermanantHealthMalus;

	public int FloorRecruited;

	public bool IsStartingHero;

	public int CurrentRespawnRoomCount;

	public bool IsUnrecruitable;

	public MobSaveData TamedMob;

	public StaticString[] PermanentDescriptors;

	public HeroItemData[] Items;

	public HeroActiveSkillData[] ActiveSkills;
}
public class HighscoreData
{
	public double Time;

	public bool Victory;

	public int Floor;

	public int Score;

	public StaticString ShipName;

	public GameDifficulty Difficulty;

	public StaticString[] HeroesUsed;
}
public class InventoryItemData
{
	public StaticString ItemDescName;

	public StaticString RarityDescName;

	public ulong OwnerPlayerID;

	public bool IsGift;

	private readonly char serializationSeparator = ';';

	public InventoryItemData()
	{
	}

	public InventoryItemData(string serial)
	{
		string[] array = serial.Split(serializationSeparator);
		ItemDescName = array[0];
		RarityDescName = array[1];
		OwnerPlayerID = (ulong)((!string.IsNullOrEmpty(array[2])) ? ((long)ulong.Parse(array[2])) : (-1L));
		IsGift = bool.Parse(array[3]);
	}

	public InventoryItemData(StaticString itemDescName, StaticString rarityDescName, ulong ownerPlayerId, bool isGift)
	{
		ItemDescName = itemDescName;
		RarityDescName = rarityDescName;
		OwnerPlayerID = ownerPlayerId;
		IsGift = isGift;
	}

	public override string ToString()
	{
		return string.Concat(ItemDescName, serializationSeparator, RarityDescName, serializationSeparator, OwnerPlayerID, serializationSeparator, IsGift);
	}
}
public struct ItemPersistentData
{
	public StaticString ItemDescName;

	public StaticString RarityDescName;
}
public struct LocalStatData
{
	public string Name;

	public float Value;
}
public struct LootItemSaveData
{
	public Vector3 Position;

	public int ParentRoomID;

	public StaticString ItemName;

	public ItemType Type;

	public InventoryItemData[] ChestItems;
}
public struct MajorModuleSaveData
{
	public string BPName;

	public float Health;

	public int RoomID;

	public ulong OwnerPlayerID;
}
public struct MaxedProbabilityConfigPickedElementCountData
{
	public string TypeName;

	public StaticString Name;

	public int Count;
}
public struct MerchantSaveData
{
	public Vector3 Position;

	public int ParentRoomID;

	public float Health;

	public InventoryItemData[] Items;

	public CurrencyConfig CurrencyConfig;

	public string ConfigName;

	public bool IsInShop;

	public float GiftCost;
}
public struct MinorModuleSaveData
{
	public string BPName;

	public float Health;

	public int SlotID;

	public ulong OwnerPlayerID;

	public int KillCount;
}
public class MobSaveData
{
	public Vector3 Position;

	public int ParentRoomID;

	public StaticString SimDescName;

	public int Level;

	public int TameKillCount;

	public float HealthValue;

	private readonly char serializationSeparator = ';';

	public MobSaveData()
	{
	}

	public MobSaveData(string serial)
	{
		string[] array = serial.Split(serializationSeparator);
		Position = new Vector3(float.Parse(array[0]), float.Parse(array[1]), float.Parse(array[2]));
		ParentRoomID = int.Parse(array[3]);
		SimDescName = array[4];
		Level = int.Parse(array[5]);
		TameKillCount = int.Parse(array[6]);
		HealthValue = float.Parse(array[7]);
	}

	public override string ToString()
	{
		return string.Concat(Position.x, serializationSeparator, Position.y, serializationSeparator, Position.z, serializationSeparator, ParentRoomID, serializationSeparator, SimDescName, serializationSeparator, Level, serializationSeparator, TameKillCount, serializationSeparator, HealthValue);
	}
}
public struct ModuleSlotSaveData
{
	public int SlotID;

	public StaticString SlotCategory;

	public ModuleCategory ModuleCategory;

	public string ModuleConfigName;

	public int ModuleLevel;
}
public struct PlayerSaveData
{
	public ulong ID;

	public float FoodStock;

	public float IndustryStock;

	public float ScienceStock;

	public bool IsStillConnected;
}
public struct ProbabilityConfigOccurrenceCountData
{
	public string TypeName;

	public string Name;

	public int Count;
}
public class RoomPowerData
{
	public int RoomID;

	public ulong NEW_PowerPlayerID;

	public bool IsPowered = true;

	public bool IsUnpoweringWithDelay;

	public bool IsPowerForced;

	public bool IsPowerForcedFromEvent;

	public int EmpTurnsRemaining;

	[XmlIgnore]
	public Steamworks.SteamID PowerPlayerID
	{
		get
		{
			Diagnostics.LogError("Shouldn't have to get RoomPowerData.PowerPlayerID (DEPRECATED, replaced by NEW_PowerPlayerID)");
			return null;
		}
		set
		{
			NEW_PowerPlayerID = value.UInt64AccountID;
		}
	}
}
public class SaveInfo
{
	public string Key;

	public ulong[] PlayerIDs;

	public string[] PlayerNames;

	public bool IsAutoSave;

	public bool IsMultiplayer;

	public bool IsInGame;

	public string GetMPSaveName()
	{
		DungeonGenerationSaveData bestSaveData = GameSave.GetBestSaveData(Key, multiplayer: true);
		if (bestSaveData == null)
		{
			return null;
		}
		string text = string.Empty;
		if (PlayerNames != null)
		{
			for (int i = 0; i < PlayerNames.Length; i++)
			{
				text += PlayerNames[i];
				if (i < PlayerNames.Length - 1)
				{
					text += ", ";
				}
			}
		}
		else
		{
			GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
			for (int j = 0; j < PlayerIDs.Length; j++)
			{
				text += gameNetworkManager.GetPlayerName(PlayerIDs[j]);
				if (j < PlayerIDs.Length - 1)
				{
					text += ", ";
				}
			}
		}
		string key = (!IsAutoSave) ? "%MPUserSaveName" : "%MPAutoSaveName";
		return AgeLocalizer.Instance.LocalizeString(key).Replace("$PlayerNames", text).Replace("$ShipName", AgeLocalizer.Instance.LocalizeString("%ShipTitle_" + bestSaveData.ShipName))
			.Replace("$FloorNumber", ((!IsAutoSave) ? bestSaveData.Level : (bestSaveData.Level + 1)).ToString());
	}
}
public struct SelectedMobSaveData
{
	public StaticString MobClassName;

	public bool IsNew;
}
public class SerializableData
{
	public Amplitude.Unity.Framework.Version Version;

	public ulong SteamUserID;
}
public struct SteleSaveData
{
	public int RoomID;

	public float Health;

	public string SteleTypeName;
}
public struct StorySaveData
{
	public string StoryName;

	public int StepIndex;
}
public struct StoryStepSaveData
{
	public string StepName;

	public int OccurrenceCount;
}
public struct UnlockingHeroData
{
	public StaticString ConfigName;

	public int UnlockLevel;
}
public class UserProfileData : SerializableData
{
	public List<SaveInfo> SaveInfos = new List<SaveInfo>();

	public List<HeroGameStatsData> HeroesGameStats = new List<HeroGameStatsData>();

	public List<LocalStatData> LocalAchievementStats = new List<LocalStatData>();

	public List<string> SeenAlbumPictures = new List<string>();

	public List<HighscoreData> HighscoresSP = new List<HighscoreData>();

	public List<HighscoreData> HighscoresMP = new List<HighscoreData>();

	public List<StoryStepSaveData> StoryStepStats = new List<StoryStepSaveData>();

	public List<BackstoryData> BackstoriesUnlocked = new List<BackstoryData>();

	public string SaveValidationKey
	{
		private get
		{
			Diagnostics.LogError("UserProfileData.SaveValidationKey shouldn't be accessed!");
			return null;
		}
		set
		{
			if (!string.IsNullOrEmpty(value))
			{
				Diagnostics.LogWarning("Converting UserProfileData.SaveValidationKey to UserProfileData.UserSaveValidationKey!");
				UserSaveValidationKey = value;
			}
		}
	}

	public string UserSaveValidationKey
	{
		private get
		{
			Diagnostics.LogError("UserProfileData.UserSaveValidationKey shouldn't be accessed!");
			return null;
		}
		set
		{
			if (!string.IsNullOrEmpty(value))
			{
				Diagnostics.LogWarning("Converting UserProfileData.UserSaveValidationKey to user save!");
				GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
				ulong localPlayerID = gameNetworkManager.GetLocalPlayerID();
				ulong[] playerIDs = new ulong[1]
				{
					localPlayerID
				};
				string[] playerNames = new string[1]
				{
					gameNetworkManager.GetPlayerName(localPlayerID)
				};
				SaveInfo saveInfo = new SaveInfo();
				saveInfo.PlayerIDs = playerIDs;
				saveInfo.PlayerNames = playerNames;
				saveInfo.Key = value;
				SaveInfo item = saveInfo;
				SaveInfos.Add(item);
			}
		}
	}

	public string AutoSaveValidationKey
	{
		private get
		{
			Diagnostics.LogError("UserProfileData.AutoSaveValidationKey shouldn't be accessed!");
			return null;
		}
		set
		{
			if (!string.IsNullOrEmpty(value))
			{
				Diagnostics.LogWarning("Converting UserProfileData.AutoSaveValidationKey to auto save!");
				GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
				ulong localPlayerID = gameNetworkManager.GetLocalPlayerID();
				ulong[] playerIDs = new ulong[1]
				{
					localPlayerID
				};
				string[] playerNames = new string[1]
				{
					gameNetworkManager.GetPlayerName(localPlayerID)
				};
				SaveInfo saveInfo = new SaveInfo();
				saveInfo.PlayerIDs = playerIDs;
				saveInfo.PlayerNames = playerNames;
				saveInfo.Key = value;
				saveInfo.IsAutoSave = true;
				SaveInfo item = saveInfo;
				SaveInfos.Add(item);
			}
		}
	}

	public bool IsInGame
	{
		private get
		{
			Diagnostics.LogError("UserProfileData.IsInGame shouldn't be accessed!");
			return false;
		}
		set
		{
			if (Version.Serial >= 19)
			{
				return;
			}
			for (int i = 0; i < SaveInfos.Count; i++)
			{
				SaveInfo saveInfo = SaveInfos[i];
				if (saveInfo.IsAutoSave && !saveInfo.IsMultiplayer)
				{
					saveInfo.IsInGame = value;
					return;
				}
			}
			Diagnostics.LogError("Unable to find a solo auto save to set IsInGame flag!");
		}
	}

	public SaveInfo GetSaveInfo(ulong[] playerIDs, bool multiplayer, bool autoSave)
	{
		List<ulong> list = new List<ulong>();
		for (int i = 0; i < SaveInfos.Count; i++)
		{
			SaveInfo saveInfo = SaveInfos[i];
			if (saveInfo.IsMultiplayer != multiplayer || saveInfo.IsAutoSave != autoSave || saveInfo.PlayerIDs.Length != playerIDs.Length)
			{
				continue;
			}
			list.Clear();
			list.AddRange(saveInfo.PlayerIDs);
			bool flag = false;
			for (int j = 0; j < playerIDs.Length; j++)
			{
				if (!list.Contains(playerIDs[j]))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return saveInfo;
			}
		}
		return null;
	}

	public SaveInfo GetSaveInfo(string key)
	{
		for (int i = 0; i < SaveInfos.Count; i++)
		{
			SaveInfo saveInfo = SaveInfos[i];
			if (saveInfo.Key == key)
			{
				return saveInfo;
			}
		}
		return null;
	}

	public List<SaveInfo> GetMPSaveKeys()
	{
		List<SaveInfo> list = new List<SaveInfo>();
		for (int i = 0; i < SaveInfos.Count; i++)
		{
			SaveInfo saveInfo = SaveInfos[i];
			if (saveInfo.IsMultiplayer && (!saveInfo.IsAutoSave || (saveInfo.IsAutoSave && saveInfo.IsInGame)))
			{
				list.Add(saveInfo);
			}
		}
		return list;
	}
}
public class GameSave
{
	private static readonly string FileExtension = ".sav";

	private static readonly string FileNameValidChars = "abcdefghijklmnopqrstuvwxzABCDEFGHIJKLMNOPQRSTUVWXZ0123456789()[]-_";

	private static readonly int SaveKeyLength = 32;

	public static readonly short OLD_UserSaveMinSerial = 15;

	public static readonly short UserSaveMinSerial = 16;

	public static readonly short AutoSaveMinSerial = 15;

	public static string GenerateSaveKey()
	{
		string text = string.Empty;
		for (int i = 0; i < SaveKeyLength; i++)
		{
			text += FileNameValidChars[RandomGenerator.RangeInt(0, FileNameValidChars.Length)];
		}
		return text;
	}

	public static SaveInfo GetSPAutoSaveInfo()
	{
		if (UserProfile.Data == null)
		{
			return null;
		}
		GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
		ulong[] playerIDs = new ulong[1]
		{
			gameNetworkManager.GetLocalPlayerID()
		};
		return UserProfile.Data.GetSaveInfo(playerIDs, multiplayer: false, autoSave: true);
	}

	public static string GetSaveFilePath(string saveKey)
	{
		return System.IO.Path.Combine(Amplitude.Unity.Framework.Application.UserDirectory, saveKey + FileExtension);
	}

	private static string GetSaveFilePath(ulong[] playerIDs, bool multiplayer, bool autoSave)
	{
		if (UserProfile.Data == null)
		{
			return null;
		}
		SaveInfo saveInfo = UserProfile.Data.GetSaveInfo(playerIDs, multiplayer, autoSave);
		if (saveInfo == null)
		{
			return null;
		}
		return GetSaveFilePath(saveInfo.Key);
	}

	public static bool HasSPUserSaveFile()
	{
		ulong[] playerIDs = new ulong[1]
		{
			SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID()
		};
		string saveFilePath = GetSaveFilePath(playerIDs, multiplayer: false, autoSave: false);
		return saveFilePath != null && SaveFileExists(saveFilePath);
	}

	public static bool HasSPAutoSaveFile()
	{
		ulong[] playerIDs = new ulong[1]
		{
			SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID()
		};
		string saveFilePath = GetSaveFilePath(playerIDs, multiplayer: false, autoSave: true);
		return saveFilePath != null && SaveFileExists(saveFilePath);
	}

	public static bool HasSinglePlayerSaveFile()
	{
		if (HasSPUserSaveFile())
		{
			return true;
		}
		SaveInfo sPAutoSaveInfo = GetSPAutoSaveInfo();
		if (sPAutoSaveInfo != null && sPAutoSaveInfo.IsInGame && HasSPAutoSaveFile())
		{
			return true;
		}
		return false;
	}

	public static bool HasSaveFile(string saveKey)
	{
		string saveFilePath = GetSaveFilePath(saveKey);
		return SaveFileExists(saveFilePath);
	}

	public static bool SaveFileExists(string saveFilePath)
	{
		return File.Exists(saveFilePath);
	}

	public static DungeonGenerationSaveData GetBestSPSaveData(bool reportErrors = true)
	{
		ulong[] playerIDs = new ulong[1]
		{
			SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID()
		};
		string saveKey = null;
		return GetBestSaveData(playerIDs, ref saveKey, multiplayer: false, reportErrors);
	}

	public static DungeonGenerationSaveData GetBestSPSaveData(ref string saveKey, bool reportErrors = true)
	{
		ulong[] playerIDs = new ulong[1]
		{
			SingletonManager.Get<GameNetworkManager>().GetLocalPlayerID()
		};
		return GetBestSaveData(playerIDs, ref saveKey, multiplayer: false, reportErrors);
	}

	public static DungeonGenerationSaveData GetBestSaveData(string saveKey, bool multiplayer, bool reportErrors = true)
	{
		return GetBestSaveData(null, ref saveKey, multiplayer, reportErrors);
	}

	private static DungeonGenerationSaveData GetBestSaveData(ulong[] playerIDs, ref string saveKey, bool multiplayer, bool reportErrors = true)
	{
		string text = null;
		if (playerIDs != null)
		{
			SaveInfo saveInfo = UserProfile.Data.GetSaveInfo(playerIDs, multiplayer, autoSave: false);
			if (saveInfo != null)
			{
				saveKey = saveInfo.Key;
			}
		}
		if (saveKey != null)
		{
			for (int i = 0; i < UserProfile.Data.SaveInfos.Count; i++)
			{
				SaveInfo saveInfo2 = UserProfile.Data.SaveInfos[i];
				if (!saveInfo2.IsAutoSave && saveInfo2.Key == saveKey)
				{
					text = GetSaveFilePath(saveKey);
					break;
				}
			}
		}
		if (text != null && SaveFileExists(text))
		{
			if (DataFileManager.TryGetDataFromFile(text, UserSaveMinSerial, OLD_UserSaveMinSerial, out GameSaveData data, out bool oldSerialization))
			{
				if (!oldSerialization)
				{
					Diagnostics.Log("Using {0} user save", text);
					return data;
				}
				Diagnostics.LogWarning("Old user save detected: converting to auto save");
				DungeonGenerationSaveData data2 = data.ConvertToAutoSave();
				WriteAutoSaveToFile(data2, playerIDs, multiplayer, isInGame: false);
				GenericUtilities.MoveFileSafe(text, text + ".oldusersav.bac");
			}
			else if (reportErrors)
			{
				SingletonManager.Get<RequesterPanel>().Display("%InvalidUserSaveMessage");
			}
		}
		text = null;
		if (playerIDs != null)
		{
			SaveInfo saveInfo3 = UserProfile.Data.GetSaveInfo(playerIDs, multiplayer, autoSave: true);
			if (saveInfo3 != null)
			{
				saveKey = saveInfo3.Key;
			}
		}
		if (saveKey != null)
		{
			for (int j = 0; j < UserProfile.Data.SaveInfos.Count; j++)
			{
				SaveInfo saveInfo4 = UserProfile.Data.SaveInfos[j];
				if (saveInfo4.IsAutoSave && saveInfo4.Key == saveKey)
				{
					text = GetSaveFilePath(saveKey);
					break;
				}
			}
		}
		if (text != null && SaveFileExists(text))
		{
			if (DataFileManager.TryGetDataFromFile(text, AutoSaveMinSerial, AutoSaveMinSerial, out DungeonGenerationSaveData data3, out bool _))
			{
				Diagnostics.Log("Using {0} auto save", text);
				return data3;
			}
			if (reportErrors)
			{
				SingletonManager.Get<RequesterPanel>().Display("%InvalidAutoSaveMessage");
			}
		}
		Diagnostics.LogError("Unable to load saved game from file!");
		if (reportErrors)
		{
			SingletonManager.Get<RequesterPanel>().Display("%NoValidSaveMessage");
		}
		saveKey = null;
		return null;
	}

	public static SaveInfo WriteAutoSaveToFile<T>(T data, ulong[] playerIDs, bool multiplayer, bool isInGame, string saveKey = null) where T : DungeonPersistentGameData
	{
		return WriteSaveToFile(data, playerIDs, multiplayer, autoSave: true, isInGame, saveKey);
	}

	public static SaveInfo WriteUserSaveToFile<T>(T data, ulong[] playerIDs, bool multiplayer, string saveKey = null) where T : DungeonPersistentGameData
	{
		return WriteSaveToFile(data, playerIDs, multiplayer, autoSave: false, isInGame: false, saveKey);
	}

	private static SaveInfo WriteSaveToFile<T>(T data, ulong[] playerIDs, bool multiplayer, bool autoSave, bool isInGame, string saveKey = null) where T : DungeonPersistentGameData
	{
		DeleteSave(playerIDs, multiplayer, autoSave);
		if (string.IsNullOrEmpty(saveKey))
		{
			saveKey = GenerateSaveKey();
		}
		GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
		string[] array = new string[playerIDs.Length];
		for (int i = 0; i < playerIDs.Length; i++)
		{
			array[i] = gameNetworkManager.GetPlayerName(playerIDs[i]);
		}
		SaveInfo saveInfo = new SaveInfo();
		saveInfo.PlayerIDs = playerIDs;
		saveInfo.PlayerNames = array;
		saveInfo.Key = saveKey;
		saveInfo.IsMultiplayer = multiplayer;
		saveInfo.IsAutoSave = autoSave;
		saveInfo.IsInGame = isInGame;
		SaveInfo saveInfo2 = saveInfo;
		UserProfile.Data.SaveInfos.Add(saveInfo2);
		UserProfile.SaveToFile();
		string saveFilePath = GetSaveFilePath(saveKey);
		DataFileManager.WriteDataToFile(saveFilePath, data);
		Diagnostics.Log("Saved {0} in {1} (mp={2}, auto={3})", saveKey, saveFilePath, multiplayer, autoSave);
		return saveInfo2;
	}

	public static void DeleteAutoSave(ulong[] playerIDs, bool multiplayer, bool keepBackup = false, string backupExtension = ".bac")
	{
		DeleteSave(playerIDs, multiplayer, autoSave: true, keepBackup, backupExtension);
	}

	public static void DeleteUserSave(ulong[] playerIDs, bool multiplayer, bool keepBackup = false, string backupExtension = ".bac")
	{
		DeleteSave(playerIDs, multiplayer, autoSave: false, keepBackup, backupExtension);
	}

	private static void DeleteSave(ulong[] playerIDs, bool multiplayer, bool autoSave, bool keepBackup = false, string backupExtension = ".bac")
	{
		SaveInfo saveInfo = UserProfile.Data.GetSaveInfo(playerIDs, multiplayer, autoSave);
		if (saveInfo == null)
		{
			return;
		}
		string saveFilePath = GetSaveFilePath(saveInfo.Key);
		if (SaveFileExists(saveFilePath))
		{
			if (keepBackup)
			{
				GenericUtilities.MoveFileSafe(saveFilePath, saveFilePath + backupExtension);
			}
			else
			{
				File.Delete(saveFilePath);
			}
		}
		UserProfile.Data.SaveInfos.Remove(saveInfo);
		UserProfile.SaveToFile();
	}
}
[Serializable]
public class SerializationManager : Amplitude.Unity.Serialization.SerializationManager
{
}
public class UserProfile
{
	private static readonly string FileName = "UserProfile.pfl";

	private static readonly short OLD_MinSerial = 15;

	public static readonly short MinSerial = 15;

	private static readonly int HighScoreMaxCount = 10;

	private static UserProfileData data;

	private static bool isLoaded;

	private static ulong currentUserID;

	public static bool CurrentGameIsNewHighscore
	{
		get;
		set;
	}

	public static UserProfileData Data
	{
		get
		{
			AssertIsLoaded();
			return data;
		}
		set
		{
			AssertIsLoaded();
			data = value;
		}
	}

	public static HeroGameStatsData[] GetSelectableHeroes(bool hiddenHeroesOnly = false)
	{
		DLCController dLCController = SingletonManager.Get<DLCController>();
		HeroConfig[] values = Databases.GetDatabase<HeroConfig>().GetValues();
		List<HeroGameStatsData> list = new List<HeroGameStatsData>();
		foreach (HeroConfig heroConfig in values)
		{
			if (hiddenHeroesOnly != heroConfig.IsHidden())
			{
				continue;
			}
			HeroGameStatsData item = default(HeroGameStatsData);
			for (int j = 0; j < Data.HeroesGameStats.Count; j++)
			{
				HeroGameStatsData heroGameStatsData = Data.HeroesGameStats[j];
				if (heroGameStatsData.ConfigName == heroConfig.Name)
				{
					item = Data.HeroesGameStats[j];
					break;
				}
			}
			if (!heroConfig.IsCommunityEventHero() || heroConfig.IsCommunityEventActive() || item.Status == HeroStatus.Unlocked)
			{
				if (string.IsNullOrEmpty(item.ConfigName))
				{
					Diagnostics.LogError("UserProfile.GetAvailableHeroes: unable to find {0} hero in user profile stats!", heroConfig.Name);
				}
				else if (dLCController.IsObjectAvailable(DLCObjectType.Hero, heroConfig.Name))
				{
					list.Add(item);
				}
			}
		}
		return list.ToArray();
	}

	public static void AddHighScore(bool victory, bool solo)
	{
		if (HashManager.IsHashDifferent)
		{
			return;
		}
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		int num = GenericUtilities.RoundHalfAwayFromZeroToInt(dungeon.GetScore());
		List<HighscoreData> list = (!solo) ? data.HighscoresMP : data.HighscoresSP;
		if (list.Count < HighScoreMaxCount || list.OrderBy((HighscoreData h) => h.Score).ToArray()[0].Score < num)
		{
			HighscoreData highscoreData = new HighscoreData();
			highscoreData.Victory = victory;
			highscoreData.Floor = dungeon.Level;
			highscoreData.Score = num;
			highscoreData.ShipName = dungeon.ShipConfig.Name;
			highscoreData.Difficulty = dungeon.Difficulty;
			List<StaticString> list2 = new List<StaticString>();
			for (int i = 0; i < Hero.LocalPlayerActiveRecruitedHeroes.Count; i++)
			{
				if (list2.Count >= 4)
				{
					break;
				}
				list2.Add(Hero.LocalPlayerActiveRecruitedHeroes[i].Config.Name);
			}
			if (!solo)
			{
				for (int j = 0; j < Hero.RemotePlayersActiveRecruitedHeroes.Count; j++)
				{
					if (list2.Count >= 4)
					{
						break;
					}
					list2.Add(Hero.RemotePlayersActiveRecruitedHeroes[j].Config.Name);
				}
			}
			int num2 = Hero.DeadHeroes.Count - 1;
			while (num2 >= 0 && list2.Count < 4)
			{
				if (!list2.Contains(Hero.DeadHeroes[num2].Config.Name))
				{
					list2.Add(Hero.DeadHeroes[num2].Config.Name);
				}
				num2--;
			}
			highscoreData.HeroesUsed = list2.ToArray();
			highscoreData.Time = GenericUtilities.GetSystemTimestamp();
			SingletonManager.Get<HighscoresPanel>().LatestHighscoreTime = highscoreData.Time;
			list.Add(highscoreData);
			Diagnostics.Log("New high score: " + num);
			if (list.Count > HighScoreMaxCount)
			{
				list = list.OrderByDescending((HighscoreData h) => h.Score).ToList().GetRange(0, HighScoreMaxCount);
			}
			dungeon.EnqueueNotification("%Notification_NewHighScore");
			CurrentGameIsNewHighscore = true;
		}
		try
		{
			Diagnostics.Log("score={0}", num);
			ulong num3 = Steamworks.SteamAPI.SteamUserStats.FindLeaderboard("BEST_SCORE");
			Diagnostics.Log("leaderboard={0}", num3);
			int scoreDetails = 0;
			ulong num4 = Steamworks.SteamAPI.SteamUserStats.UploadLeaderboardScore(num3, ELeaderboardUploadScoreMethod.k_ELeaderboardUploadScoreMethodNone, num, ref scoreDetails, 0);
			Diagnostics.Log("upload={0}", num4);
		}
		catch (Exception ex)
		{
			Diagnostics.LogError("Exception raised during steam leaderboard score upload: {0}\n{1}", ex.Message, ex.StackTrace);
		}
	}

	public static string GetFilePath()
	{
		return System.IO.Path.Combine(Amplitude.Unity.Framework.Application.UserDirectory, FileName);
	}

	public static bool UserProfileFileExists()
	{
		return File.Exists(GetFilePath());
	}

	private static void AssertIsLoaded()
	{
		if (!isLoaded || currentUserID != Amplitude.Unity.Framework.Application.UserUniqueID)
		{
			Load();
			isLoaded = true;
			currentUserID = Amplitude.Unity.Framework.Application.UserUniqueID;
		}
	}

	public static void Load()
	{
		Diagnostics.Log("Loading user profile from file for #{0} user", Amplitude.Unity.Framework.Application.UserUniqueID);
		bool flag = false;
		bool flag2 = false;
		bool oldSerialization;
		if (Amplitude.Unity.Framework.Application.UserUniqueID == ulong.MaxValue)
		{
			Diagnostics.LogWarning("Creating default profile for unsigned user");
			flag = true;
		}
		else if (!UserProfileFileExists())
		{
			Diagnostics.LogWarning("Creating default profile for new user {0}", Amplitude.Unity.Framework.Application.UserUniqueID);
			flag = true;
		}
		else if (!DataFileManager.TryGetDataFromFile(GetFilePath(), MinSerial, OLD_MinSerial, out data, out oldSerialization))
		{
			Diagnostics.LogWarning("Invalid profile: reseting to default profile for user {0}", Amplitude.Unity.Framework.Application.UserUniqueID);
			flag = true;
			RequesterPanel requesterPanel = SingletonManager.Get<RequesterPanel>();
			if (requesterPanel != null)
			{
				requesterPanel.Display("%UserProfileResetMessage");
			}
		}
		if (flag)
		{
			data = new UserProfileData();
		}
		flag2 = true;
		HeroConfig[] values = Databases.GetDatabase<HeroConfig>().GetValues();
		HeroConfig[] array = values;
		HeroConfig heroConfig;
		HeroGameStatsData heroGameStatsData;
		for (int i = 0; i < array.Length; i++)
		{
			heroConfig = array[i];
			int num = data.HeroesGameStats.FindIndex((HeroGameStatsData h) => h.ConfigName == heroConfig.Name);
			if (num < 0)
			{
				Diagnostics.Log("{0} not found in profile: adding it as Unknown", heroConfig.Name);
				heroGameStatsData = default(HeroGameStatsData);
				HeroGameStatsData heroGameStatsData2 = heroGameStatsData;
				heroGameStatsData2.ConfigName = heroConfig.Name;
				heroGameStatsData = heroGameStatsData2;
				data.HeroesGameStats.Add(heroGameStatsData);
				flag2 = true;
			}
		}
		GameConfig gameConfig = GameConfig.GetGameConfig();
		string[] initUnlockedHeroes = gameConfig.InitUnlockedHeroes;
		string initUnlockedHeroName;
		for (int j = 0; j < initUnlockedHeroes.Length; j++)
		{
			initUnlockedHeroName = initUnlockedHeroes[j];
			int num = data.HeroesGameStats.FindIndex((HeroGameStatsData h) => h.ConfigName == initUnlockedHeroName);
			if (num >= 0)
			{
				heroGameStatsData = data.HeroesGameStats[num];
				if (heroGameStatsData.Status != HeroStatus.Unlocked)
				{
					Diagnostics.Log("Forcing " + initUnlockedHeroName + "'s status to Unlocked!");
					heroGameStatsData.Status = HeroStatus.Unlocked;
					data.HeroesGameStats[num] = heroGameStatsData;
					flag2 = true;
				}
			}
			else
			{
				Diagnostics.LogError(initUnlockedHeroName + " not found in game stats!");
			}
		}
		if (flag2)
		{
			SaveToFile();
		}
	}

	public static void SaveToFile()
	{
		Diagnostics.Log("Saving user profile to file");
		DataFileManager.WriteDataToFile(GetFilePath(), data);
	}
}
public interface IGameCameraService : IService
{
	bool IsSwitchingCamera
	{
		get;
	}

	Camera GameCamera
	{
		get;
	}

	event Action<bool> OnEndTacticalMapCameraToggle;

	event Action<bool> OnBeginTacticalMapCameraToggle;

	void ActivateCamera(bool on);

	Vector3 WorldToScreenPoint(Vector3 worldPos, Camera camera = null);

	Vector3 ScreenToWorldPoint(Vector3 screenPos);

	Ray ScreenPointToRay(Vector3 screenPos);

	Vector2 GetGameMousePosition();

	Vector2 GetGameMouseNormalizedPosition();

	Vector3 GetCamPosition();

	Vector3 GetCamSupportPosition();

	void Focus(Vector3 targetPos, LerpType lerpType = LerpType.Smoothed, float moveSpeed = -1f);

	void ZoomIn(LerpType lerpType = LerpType.Smoothed, ZoomEndHandler onZoomEnd = null);

	void ZoomOut(LerpType lerpType = LerpType.Smoothed, ZoomEndHandler onZoomEnd = null);

	void Unzoom(ZoomEndHandler onZoomEnd = null);

	void SwitchToTacticalMapCamera();

	void SwitchToGameCamera(bool goBackToPosBeforeZoomOut = false);

	void SwitchToGameCamera(Vector3 focusPos);

	bool IsTacticalMapActive();

	void ToggleTacticalMapCamera();

	void Lock();

	void Unlock();

	void MoveToward(Vector3 direction);

	void MoveByWorldDelta(Vector3 delta);

	void MoveByPixelDelta(Vector3 delta);

	void MoveTo(Vector3 position, bool cancelStick = true);

	void StickTo(Transform tfm);

	void AssertVisibility(Vector3 targetPos);

	void AnchorSupport(Transform parentTfm);

	void UnAnchorSupport();

	void AddVisibleZone(Rect visibleZone);

	void ResetVisibleZone();
}
public interface IHashService : IService
{
	string HashGame(bool resetHash = true);

	string GetCurrentHash();
}
public enum GameDisconnectionReason
{
	Default = 0,
	ClientLeft = 1,
	HostLeft = 2,
	SteamFailure = 3,
	P2PFailure = 4,
	SteamServerFailure = 5,
	AuthFailure = 6,
	ConnectionTimeout = 7,
	_Debug = 0xFF
}
public abstract class GameInterface : IDisposable, IGameInterface
{
	protected Dictionary<Type, OrderProcessorInfo> orderProcessorInfoByType = new Dictionary<Type, OrderProcessorInfo>();

	private bool disposed;

	private bool disposing;

	private Dictionary<ulong, List<Ticket>> ticketsByOrderID = new Dictionary<ulong, List<Ticket>>();

	public FiniteState CurrentState
	{
		get
		{
			if (FiniteStateMachine != null)
			{
				return FiniteStateMachine.CurrentState;
			}
			return null;
		}
	}

	public Game Game
	{
		get;
		private set;
	}

	public IMessageBox MessageBox
	{
		get;
		protected set;
	}

	public ulong UserID
	{
		get;
		private set;
	}

	internal Session Session
	{
		get;
		private set;
	}

	protected IGameService GameService
	{
		get;
		private set;
	}

	protected FiniteStateMachine FiniteStateMachine
	{
		get;
		private set;
	}

	public event EventHandler<FiniteStateChangeEventArgs> StateChange;

	public GameInterface(Session session)
	{
		Diagnostics.Assert(session != null);
		Session = session;
		Session.SessionChange += Session_SessionChange;
		UserID = ulong.MaxValue;
		IPlatformService service = Services.GetService<IPlatformService>();
		if (service.IsPlatformSpecificRunning)
		{
			UserID = Session.UserID;
		}
		FiniteStateMachine = new FiniteStateMachine();
		FiniteStateMachine.StateChange += FiniteStateMachine_StateChange;
		GameService = Services.GetService<IGameService>();
		if (GameService != null)
		{
			GameService.GameChange += GameService_GameChange;
			GameService.CreateGameComplete += GameService_CreateGameComplete;
		}
		else
		{
			Diagnostics.LogError("The game service is missing.");
		}
		OrderProcessorAttribute[] array = GetType().GetCustomAttributes(typeof(OrderProcessorAttribute), inherit: true) as OrderProcessorAttribute[];
		for (int i = 0; i < array.Length; i++)
		{
			OrderProcessorInfo orderProcessorInfo = new OrderProcessorInfo();
			orderProcessorInfo.Initialize(this, array[i]);
			orderProcessorInfoByType.Add(array[i].OrderType, orderProcessorInfo);
		}
	}

	~GameInterface()
	{
		Dispose(disposing: false);
		Session = null;
	}

	public void Dispose()
	{
		Dispose(disposing: true);
	}

	public void PostStateChange(Type type, params object[] parameters)
	{
		FiniteStateMachine.PostStateChange(type, parameters);
	}

	public void SendMessage(ref Message message, params ulong[] steamIDRemotes)
	{
		if (MessageBox != null)
		{
			MessageBox.SendMessage(ref message, steamIDRemotes);
		}
	}

	public abstract void SendMessageToServer(ref Message message);

	public void Trace(Amplitude.Unity.Game.Orders.Order order, out Ticket ticket, EventHandler<TicketRaisedEventArgs> eventHandler)
	{
		if (order == null)
		{
			throw new ArgumentNullException("order");
		}
		ticket = new Ticket(order, eventHandler);
		List<Ticket> value = null;
		if (!ticketsByOrderID.TryGetValue(order.TicketNumber, out value))
		{
			value = new List<Ticket>();
			ticketsByOrderID.Add(order.TicketNumber, value);
		}
		value.Add(ticket);
	}

	public virtual void Update()
	{
		FiniteStateMachine.Update();
		UpdateMessageBoxAndProcessOrders();
	}

	public virtual void UpdateMessageBoxAndProcessOrders()
	{
		if (MessageBox != null)
		{
			IMessage message;
			ulong steamIDRemote;
			while (MessageBox.TryReceiveMessage(out message, out steamIDRemote))
			{
				ProcessMessage(ref message, ref steamIDRemote);
			}
		}
		ProcessOrders();
	}

	public virtual void UpdateSession()
	{
		if (MessageBox != null)
		{
			IMessage message;
			ulong steamIDRemote;
			while (MessageBox.TryReceiveMessage(out message, out steamIDRemote))
			{
				ProcessMessage(ref message, ref steamIDRemote);
			}
		}
	}

	protected virtual void Dispose(bool disposing)
	{
		if (disposed)
		{
			return;
		}
		if (!this.disposing && disposing)
		{
			this.disposing = disposing;
			FiniteStateMachine.Abort();
			FiniteStateMachine.Clear();
			if (GameService != null)
			{
				GameService.GameChange -= GameService_GameChange;
				GameService.CreateGameComplete -= GameService_CreateGameComplete;
			}
			if (MessageBox != null)
			{
				MessageBox.Dispose();
				MessageBox = null;
			}
		}
		ticketsByOrderID.Clear();
		orderProcessorInfoByType.Clear();
		FiniteStateMachine = null;
		GameService = null;
		MessageBox = null;
		Session = null;
		Game = null;
		disposed = true;
	}

	protected virtual void FiniteStateMachine_StateChange(object sender, FiniteStateChangeEventArgs e)
	{
		if (this.StateChange != null)
		{
			this.StateChange(sender, e);
		}
	}

	protected virtual void GameService_GameChange(object sender, GameChangeEventArgs e)
	{
		Diagnostics.Log("The game interface ({0}) has recieved the game change notification: '{1}'.", GetType().ToString(), e.Action.ToString());
		switch (e.Action)
		{
		case GameChangeAction.Created:
			Diagnostics.Assert(Game == null, "The interface should not have a non-null game at this stage.");
			Game = (e.Game as Game);
			Diagnostics.Assert(Game != null, "The game that was just created is null.");
			break;
		case GameChangeAction.Releasing:
		case GameChangeAction.Released:
			Diagnostics.Assert(Game == null || Game == e.Game);
			Game = null;
			break;
		}
	}

	protected virtual void ProcessMessage(ref IMessage message, ref ulong steamIDRemote)
	{
	}

	protected virtual void ProcessOrders()
	{
	}

	protected virtual void Session_SessionChange(object sender, SessionChangeEventArgs e)
	{
		SessionChangeAction action = e.Action;
		if (action == SessionChangeAction.Releasing)
		{
			Diagnostics.Assert(e.Session == Session);
			Session.SessionChange -= Session_SessionChange;
		}
	}

	protected void OnTicketRaised(ulong ticketNumber, PostOrderResponse action, Amplitude.Unity.Game.Orders.Order order)
	{
		List<Ticket> value = null;
		if (ticketsByOrderID.TryGetValue(ticketNumber, out value))
		{
			for (int i = 0; i < value.Count; i++)
			{
				value[i].Order = order;
				value[i].Raise(action);
			}
			ticketsByOrderID.Remove(ticketNumber);
		}
	}

	private void GameService_CreateGameComplete(object sender, CreateGameCompleteEventArgs e)
	{
	}
}
public class GameState : FiniteState
{
}
public interface IGameInterface : IDisposable
{
	FiniteState CurrentState
	{
		get;
	}

	ulong UserID
	{
		get;
	}

	Game Game
	{
		get;
	}

	event EventHandler<FiniteStateChangeEventArgs> StateChange;

	void PostStateChange(Type type, params object[] parameters);

	void SendMessageToServer(ref Message message);

	void Trace(Amplitude.Unity.Game.Orders.Order order, out Ticket ticket, EventHandler<TicketRaisedEventArgs> eventHandler = null);
}
public interface IGameStateUpdatable<T> where T : GameState
{
	void Update(GameInterface gameInterface);
}
public class GameClient : GameInterface, IDisposable, IDumpable, IGameInterface, IGameClient
{
	public delegate void ProcessingOrderEventHandler(object sender, object order, int? empireIndex);

	public delegate void SendingMessageToServerEventHandler(object sender, object order, int? empireIndex);

	private const int MaxOrderProcessingTicksPerFrame = 10;

	private bool disposed;

	private GameClientConnectionState connectionState = GameClientConnectionState.DisconnectedFromServer;

	private uint authTicketHandle;

	private Queue<Amplitude.Unity.Game.Orders.Order> orderQueue = new Queue<Amplitude.Unity.Game.Orders.Order>();

	private Amplitude.Coroutine orderProcessing;

	private ISteamClientService steamClientService;

	private NetworkingProxy steamNetworkingProxy;

	private Queue<Amplitude.Unity.Game.Orders.Order> ordersHistory;

	private GameNetworkManager gameNetworkManager;

	private GameClientRPCMessage _rpcMessage;

	public GameClientConnectionState GameClientConnectionState
	{
		get
		{
			return connectionState;
		}
		protected set
		{
			if (connectionState != value)
			{
				connectionState = value;
				OnGameClientConnectionStateChange(new GameClientConnectionStateChangeEventArgs(connectionState));
			}
		}
	}

	public ulong ServerID
	{
		get;
		private set;
	}

	public bool HasPendingOrders => orderQueue.Count > 0;

	public event ProcessingOrderEventHandler OnProcessingOrder;

	public event SendingMessageToServerEventHandler OnSendingMessageToServer;

	public event EventHandler<GameClientConnectionStateChangeEventArgs> GameClientConnectionStateChange;

	public GameClient(Session session)
		: base(session)
	{
		ServerID = ulong.MaxValue;
		base.FiniteStateMachine.RegisterInitialState(new GameClientState_WaitingForServer(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_ConnectingToServer(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_Authentication(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_AuthenticationFailed(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_ConnectedToServer(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_DisconnectedFromServer(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_DownloadGame(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_LaunchGame(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_GameLaunched(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_GameLaunchedAndReady(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_AllDungeonsInstantiated(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_AllDungeonsCreated(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_AllDungeonsPreFilled(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_AllDungeonsFilled(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_DungeonCreated(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_DungeonPreFilled(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_DungeonFilled(this));
		base.FiniteStateMachine.RegisterState(new GameClientState_RestartGame(this));
		PostStateChange(typeof(GameClientState_WaitingForServer));
		INetworkingService service = Services.GetService<INetworkingService>();
		service.RegisterMessageClass<GameServerInitiateConnectionResponseMessage>();
		service.RegisterMessageClass<GameServerAuthTicketResponseMessage>();
		service.RegisterMessageClass<GameServerLeaveMessage>();
		service.RegisterMessageClass<GameServerPlayerUpdateMessage>();
		service.RegisterMessageClass<GameServerDownloadGameResponseMessage>();
		service.RegisterMessageClass<GameServerPostStateChangeMessage>();
		service.RegisterMessageClass<GameClientRPCMessage>();
		ordersHistory = new Queue<Amplitude.Unity.Game.Orders.Order>();
	}

	public void DumpAsText(StringBuilder content, string indent)
	{
		int num = 0;
		foreach (Amplitude.Unity.Game.Orders.Order item in ordersHistory)
		{
			content.AppendFormat("{0}{1:D3} {2} {3}\r\n", indent, num++, item.GetType(), (!(item is Order)) ? string.Empty : $"(Empire#{((Order)item).EmpireIndex.ToString()})");
		}
		ordersHistory.Clear();
	}

	public byte[] DumpAsBytes()
	{
		MemoryStream memoryStream = new MemoryStream();
		using (System.IO.BinaryWriter binaryWriter = new System.IO.BinaryWriter(memoryStream))
		{
			foreach (Amplitude.Unity.Game.Orders.Order item in ordersHistory)
			{
				Order order = item as Order;
				if (order != null)
				{
					binaryWriter.Write(order.EmpireIndex);
				}
				binaryWriter.Write(item.GetType().ToString());
				item.Pack(binaryWriter);
			}
		}
		ordersHistory.Clear();
		byte[] result = memoryStream.ToArray();
		memoryStream.Close();
		return result;
	}

	~GameClient()
	{
		Dispose(disposing: false);
		Diagnostics.Log("Game client has been deleted.");
	}

	public void Disconnect(GameDisconnectionReason reason = GameDisconnectionReason.Default, int errorCode = 0)
	{
		if (base.Session.SessionMode == SessionMode.Single)
		{
			GameClientConnectionState = GameClientConnectionState.DisconnectedFromServer;
		}
		else
		{
			if (GameClientConnectionState == GameClientConnectionState.DisconnectedFromServer)
			{
				return;
			}
			Diagnostics.Log("[GameClient][Net] Disconnecting... reason={0}", reason);
			if ((GameClientConnectionState == GameClientConnectionState.AuthenticatingToServer || GameClientConnectionState == GameClientConnectionState.AuthenticatedToServer) && authTicketHandle != 0)
			{
				Diagnostics.Log("[GameClient][Net] Disconnecting, cancel auth ticket {0}", authTicketHandle);
				IPlatformService service = Services.GetService<IPlatformService>();
				Steamworks.SteamUser steamUser = service.SteamUser;
				steamUser.CancelAuthTicket(authTicketHandle);
				authTicketHandle = 0u;
				GameClientConnectionState = GameClientConnectionState.ConnectedToServer;
			}
			if (GameClientConnectionState == GameClientConnectionState.ConnectedToServer || GameClientConnectionState == GameClientConnectionState.ConnectingToServer || GameClientConnectionState == GameClientConnectionState.AuthenticationHasFailed)
			{
				if (base.Session.IsServerIdValid())
				{
					Diagnostics.Log("[GameClient][Net] Closing P2PSession with server.");
					if (reason == GameDisconnectionReason.ClientLeft)
					{
						Message message = new GameClientLeaveMessage();
						base.MessageBox.SendMessage(ref message);
					}
					steamNetworkingProxy.CloseP2PSessionWithUser(ServerID);
				}
				GameClientConnectionState = GameClientConnectionState.DisconnectedFromServer;
			}
			if (ServerID != ulong.MaxValue)
			{
				SessionSteam.IgnoreP2PSessionConnectFail = new Steamworks.SteamID(ServerID);
			}
			Diagnostics.Log("[GameClient][Net] Disconnected.");
			PostStateChange(typeof(GameClientState_DisconnectedFromServer), GameClientConnectionState, reason, errorCode);
		}
	}

	public void OnSteamGameServerReady()
	{
		steamNetworkingProxy = new NetworkingProxy(server: false);
		base.MessageBox = new MessageBox(steamNetworkingProxy);
		steamClientService = Services.GetService<ISteamClientService>();
		steamClientService.ClientP2PSessionRequest += ISteamClientService_P2PSessionRequest;
		steamClientService.ClientP2PSessionConnectFail += ISteamClientService_P2PSessionConnectFail;
	}

	public override void SendMessageToServer(ref Message message)
	{
		if (message.ID == 2101)
		{
			GameClientPostOrderMessage gameClientPostOrderMessage = message as GameClientPostOrderMessage;
			Diagnostics.Assert(gameClientPostOrderMessage != null);
			switch (base.Session.SessionMode)
			{
			case SessionMode.Private:
			case SessionMode.Protected:
			case SessionMode.Public:
			{
				GameClientState gameClientState = base.FiniteStateMachine.CurrentState as GameClientState;
				if (gameClientState != null && !gameClientState.CanSendOrder)
				{
					Diagnostics.LogWarning("[Net,Client] Dropped order {0} ({1})", gameClientPostOrderMessage.Order.GetType(), gameClientState.GetType());
					OnTicketRaised(gameClientPostOrderMessage.Order.TicketNumber, PostOrderResponse.Blocked, gameClientPostOrderMessage.Order);
					return;
				}
				break;
			}
			default:
				throw new ArgumentOutOfRangeException();
			case SessionMode.Single:
				break;
			}
		}
		if (base.MessageBox != null)
		{
			base.MessageBox.SendMessage(ref message, ServerID);
		}
	}

	public override void UpdateMessageBoxAndProcessOrders()
	{
		base.UpdateMessageBoxAndProcessOrders();
		int num = 10;
		while (HasPendingOrders && num-- > 0)
		{
			ProcessOrders();
		}
		if (HasPendingOrders)
		{
			Diagnostics.LogWarning("[Net,Orders] Max ticks per frame reached. Processing will be resumed next frame.");
		}
	}

	public void ProcessDownloadGameResponse(GameServerDownloadGameResponseMessage message)
	{
		if (message != null)
		{
			Diagnostics.Log("Download game message has been responded to by server.");
			if (!(CurrentState is GameClientState_DownloadGame))
			{
				Diagnostics.LogWarning("Download game message has been responded to by server but current client state is " + CurrentState.GetType());
				return;
			}
			Dungeon.SetGenerationParams(message.GenerationParams);
			PostStateChange(typeof(GameClientState_LaunchGame));
		}
	}

	internal void Authentify()
	{
		switch (GameClientConnectionState)
		{
		case GameClientConnectionState.ConnectingToServer:
		case GameClientConnectionState.ConnectionToServerHasFailed:
		case GameClientConnectionState.ConnectionToServerHasTimedOut:
		case GameClientConnectionState.AuthenticatingToServer:
		case GameClientConnectionState.AuthenticatedToServer:
		case GameClientConnectionState.AuthenticationHasFailed:
		case GameClientConnectionState.DisconnectedFromServer:
			Diagnostics.LogError("[Net][Auth] Wrong state to authentify.");
			break;
		case GameClientConnectionState.ConnectedToServer:
		{
			byte[] pTicket = new byte[1024];
			uint pcbTicket = 0u;
			IPlatformService service = Services.GetService<IPlatformService>();
			Steamworks.SteamUser steamUser = service.SteamUser;
			authTicketHandle = steamUser.GetAuthSessionTicket(ref pTicket, (uint)pTicket.Length, out pcbTicket);
			Diagnostics.Log("[Net][Auth] TicketHandle={2}, TicketLength = {0}, Ticket={1}", pcbTicket, GameClientState_Authentication.TicketToString(pTicket, pcbTicket), authTicketHandle);
			Message message = new GameClientAuthTicketMessage(pTicket, pcbTicket);
			SendMessageToServer(ref message);
			GameClientConnectionState = GameClientConnectionState.AuthenticatingToServer;
			break;
		}
		default:
			throw new ArgumentOutOfRangeException();
		}
	}

	internal void Connect()
	{
		ServerID = ulong.MaxValue;
		if (base.Session.IsServerIdValid())
		{
			ServerID = base.Session.ServerId;
		}
		switch (GameClientConnectionState)
		{
		case GameClientConnectionState.ConnectedToServer:
		case GameClientConnectionState.ConnectingToServer:
			break;
		case GameClientConnectionState.ConnectionToServerHasFailed:
		case GameClientConnectionState.ConnectionToServerHasTimedOut:
		case GameClientConnectionState.DisconnectedFromServer:
		{
			if (base.Session.IsHosting)
			{
				ServerID = UserID;
				GameServer gameServer = base.Session.GameServer as GameServer;
				if (gameServer == null)
				{
					Diagnostics.LogError("The game server is null.");
					GameClientConnectionState = GameClientConnectionState.ConnectionToServerHasFailed;
					break;
				}
				base.MessageBox.Connect(UserID, gameServer.MessageBox.MessagePipe);
			}
			Diagnostics.Log("Initiate connection to game server");
			Message message = new GameClientInitiateConnectionMessage();
			SendMessageToServer(ref message);
			GameClientConnectionState = GameClientConnectionState.ConnectingToServer;
			break;
		}
		default:
			throw new NotImplementedException();
		}
	}

	protected override void Dispose(bool disposing)
	{
		if (!disposed)
		{
			if (disposing)
			{
				Disconnect(GameDisconnectionReason.ClientLeft);
				if (steamClientService != null)
				{
					steamClientService.ClientP2PSessionRequest -= ISteamClientService_P2PSessionRequest;
					steamClientService.ClientP2PSessionConnectFail -= ISteamClientService_P2PSessionConnectFail;
					steamClientService = null;
				}
				Services.GetService<IGameService>()?.ReleaseGame();
				orderQueue.Clear();
				ordersHistory.Clear();
			}
			disposed = true;
		}
		base.Dispose(disposing);
	}

	protected virtual void OnGameClientConnectionStateChange(GameClientConnectionStateChangeEventArgs e)
	{
		if (this.GameClientConnectionStateChange != null)
		{
			this.GameClientConnectionStateChange(this, e);
		}
	}

	protected override void ProcessMessage(ref IMessage message, ref ulong steamIDRemote)
	{
		//Discarded unreachable code: IL_01fe
		switch (message.ID)
		{
		case 1001:
			Diagnostics.Log("[Net] [GameClient] Got initiate connection response from server.");
			GameClientConnectionState = GameClientConnectionState.ConnectedToServer;
			break;
		case 1002:
			Diagnostics.Log("[Net] [GameServer] The host has left the game.");
			Disconnect(GameDisconnectionReason.HostLeft);
			break;
		case 1010:
		{
			GameServerAuthTicketResponseMessage gameServerAuthTicketResponseMessage = message as GameServerAuthTicketResponseMessage;
			Diagnostics.Assert(gameServerAuthTicketResponseMessage != null, "Invalid message type. Expected GameServerAuthTicketResponseMessage.");
			switch (gameServerAuthTicketResponseMessage.Response)
			{
			case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseOK:
				Diagnostics.Log("[Net] [GameClient,Auth] Received an auth ticket response from server, we're good to go.");
				GameClientConnectionState = GameClientConnectionState.AuthenticatedToServer;
				break;
			case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseUserNotConnectedToSteam:
			case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseNoLicenseOrExpired:
			case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseVACBanned:
			case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseLoggedInElseWhere:
			case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseVACCheckTimedOut:
			case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseAuthTicketCanceled:
			case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseAuthTicketInvalidAlreadyUsed:
			case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseAuthTicketInvalid:
				Diagnostics.LogWarning("[Net] [GameClient,Auth] Received an auth ticket response from server, it's failed (error: 0x{0:x4}).", (int)gameServerAuthTicketResponseMessage.Response);
				Disconnect(GameDisconnectionReason.AuthFailure);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
			break;
		}
		case 1101:
		{
			Diagnostics.Assert(message is GameServerPostOrderMessage, "Invalid message type. {0}", message.GetType());
			GameServerPostOrderMessage gameServerPostOrderMessage = message as GameServerPostOrderMessage;
			Amplitude.Unity.Game.Orders.Order order = gameServerPostOrderMessage.Order;
			orderQueue.Enqueue(order);
			break;
		}
		case 1102:
		{
			Diagnostics.Assert(message is GameServerPostOrderResponseMessage, "Invalid message type");
			GameServerPostOrderResponseMessage gameServerPostOrderResponseMessage = message as GameServerPostOrderResponseMessage;
			OnTicketRaised(gameServerPostOrderResponseMessage.Order.TicketNumber, gameServerPostOrderResponseMessage.Response, gameServerPostOrderResponseMessage.Order);
			break;
		}
		case 1103:
		{
			GameServerPostStateChangeMessage gameServerPostStateChangeMessage = message as GameServerPostStateChangeMessage;
			try
			{
				Type type = Type.GetType(gameServerPostStateChangeMessage.AssemblyQualifiedName);
				PostStateChange(type);
			}
			catch
			{
				throw;
			}
			break;
		}
		case 1104:
			if (Game != null && Game.HasBeenInitialized)
			{
				GameServerPlayerUpdateMessage gameServerPlayerUpdateMessage = message as GameServerPlayerUpdateMessage;
				if (gameServerPlayerUpdateMessage != null)
				{
					ProcessPlayerUpdateMessage(gameServerPlayerUpdateMessage);
				}
			}
			break;
		case 1301:
		{
			GameServerDownloadGameResponseMessage message2 = message as GameServerDownloadGameResponseMessage;
			ProcessDownloadGameResponse(message2);
			break;
		}
		case 2104:
			Diagnostics.Assert(message is GameClientRPCMessage, "Invalid message type. {0}", message.GetType());
			_rpcMessage = (message as GameClientRPCMessage);
			if (gameNetworkManager == null)
			{
				gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
			}
			gameNetworkManager.OnRPCMessageReceived(_rpcMessage, steamIDRemote);
			break;
		}
	}

	protected override void ProcessOrders()
	{
		if (orderProcessing == null)
		{
			if (orderQueue.Count > 0)
			{
				Amplitude.Unity.Game.Orders.Order order = orderQueue.Dequeue();
				orderProcessing = Amplitude.Coroutine.StartCoroutine(ProcessOrder(order));
			}
		}
		else
		{
			orderProcessing.Run();
		}
		if (orderProcessing != null)
		{
			if (orderProcessing.LastException != null)
			{
				Diagnostics.LogError("The order processing has raised an exception. Exception: {0}.", orderProcessing.LastException.ToString());
				orderProcessing = null;
			}
			else if (orderProcessing.IsFinished)
			{
				orderProcessing = null;
			}
		}
	}

	private IEnumerator ProcessOrder(Amplitude.Unity.Game.Orders.Order order)
	{
		if (base.Session.SessionMode != 0)
		{
			ordersHistory.Enqueue(order);
		}
		if (!(order is Order) && orderProcessorInfoByType.TryGetValue(order.GetType(), out OrderProcessorInfo orderProcessorInfo))
		{
			yield return orderProcessorInfo.Process(order);
		}
		Message aknowledge = new GameClientPostOrderResponseMessage(order.Serial);
		SendMessageToServer(ref aknowledge);
		OnTicketRaised(order.TicketNumber, PostOrderResponse.Processed, order);
	}

	private void ISteamClientService_P2PSessionRequest(object sender, P2PSessionRequestEventArgs e)
	{
		if (base.FiniteStateMachine != null && base.FiniteStateMachine.CurrentState.GetType() != typeof(GameClientState_DisconnectedFromServer))
		{
			object[] array = new object[1];
			Steamworks.P2PSessionRequest message = e.Message;
			array[0] = message.m_steamIDRemote;
			Diagnostics.Log("[Net] ISteamClientService_P2PSessionRequest SteamIDRemote=0x{0:x8}", array);
			Steamworks.SteamNetworking steamNetworking = Steamworks.SteamAPI.SteamNetworking;
			Steamworks.P2PSessionRequest message2 = e.Message;
			steamNetworking.AcceptP2PSessionWithUser(message2.m_steamIDRemote);
		}
	}

	private void ISteamClientService_P2PSessionConnectFail(object sender, P2PSessionConnectFailEventArgs e)
	{
		switch (GameClientConnectionState)
		{
		case GameClientConnectionState.ConnectionToServerHasFailed:
		case GameClientConnectionState.ConnectionToServerHasTimedOut:
		case GameClientConnectionState.AuthenticationHasFailed:
		case GameClientConnectionState.DisconnectedFromServer:
			break;
		case GameClientConnectionState.ConnectedToServer:
		case GameClientConnectionState.ConnectingToServer:
		case GameClientConnectionState.AuthenticatingToServer:
		case GameClientConnectionState.AuthenticatedToServer:
		{
			object[] array = new object[2];
			Steamworks.P2PSessionConnectFail message = e.Message;
			array[0] = message.m_steamIDRemote;
			Steamworks.P2PSessionConnectFail message2 = e.Message;
			array[1] = message2.m_eP2PSessionError;
			Diagnostics.Log("[Net] ISteamClientService_P2PSessionConnectFail SteamIDRemote=0x{0:x8} error=0x{1:x4}", array);
			Steamworks.P2PSessionConnectFail message3 = e.Message;
			if (message3.m_steamIDRemote == ServerID)
			{
				Steamworks.P2PSessionConnectFail message4 = e.Message;
				Disconnect(GameDisconnectionReason.P2PFailure, message4.m_eP2PSessionError);
			}
			break;
		}
		default:
			throw new ArgumentOutOfRangeException();
		}
	}

	private void ProcessPlayerUpdateMessage(GameServerPlayerUpdateMessage message)
	{
		switch (message.Action)
		{
		case GameServerPlayerUpdateMessage.PlayerAction.StateUpdate:
			break;
		case GameServerPlayerUpdateMessage.PlayerAction.Left:
			break;
		case GameServerPlayerUpdateMessage.PlayerAction.Joined:
			throw new NotImplementedException();
		case GameServerPlayerUpdateMessage.PlayerAction.None:
			Diagnostics.LogError("[GameClient] ProcessPlayerUpdateMessage: PlayerAction is unset.");
			break;
		default:
			throw new ArgumentOutOfRangeException();
		}
	}

	[Conditional("UNITY_EDITOR")]
	private void NotifyProcessingOrder(Amplitude.Unity.Game.Orders.Order order)
	{
		if (this.OnProcessingOrder != null)
		{
			int? empireIndex = null;
			if (order is Order)
			{
				empireIndex = (order as Order).EmpireIndex;
			}
			this.OnProcessingOrder(this, order, empireIndex);
		}
	}

	[Conditional("UNITY_EDITOR")]
	private void NotifySendingOrder(Amplitude.Unity.Game.Orders.Order order)
	{
		if (this.OnSendingMessageToServer != null)
		{
			int? empireIndex = null;
			if (order is Order)
			{
				empireIndex = (order as Order).EmpireIndex;
			}
			this.OnSendingMessageToServer(this, order, empireIndex);
		}
	}
}
public class GameClientConnection
{
	public GameClientConnectionFlags GameClientConnectionFlags
	{
		get;
		set;
	}

	public GameClientConnectionState GameClientConnectionState
	{
		get;
		set;
	}

	public string GameClientState
	{
		get;
		set;
	}

	public ulong SteamIDRemote
	{
		get;
		set;
	}

	public ulong LastAcknowledgedOrderSerial
	{
		get;
		set;
	}

	public static implicit operator ulong(GameClientConnection x)
	{
		return x.SteamIDRemote;
	}
}
[Flags]
public enum GameClientConnectionFlags
{
	Zero = 0x0,
	DownloadGameRequestReceived = 0x10,
	DownloadGameRequestAcknowledged = 0x20,
	DownloadGameRequestResponded = 0x40,
	DownloadGameRequestComplete = 0x80
}
public enum GameClientConnectionState
{
	ConnectedToServer,
	ConnectingToServer,
	ConnectionToServerHasFailed,
	ConnectionToServerHasTimedOut,
	AuthenticatingToServer,
	AuthenticatedToServer,
	AuthenticationHasFailed,
	DisconnectedFromServer
}
public class GameClientConnectionStateChangeEventArgs : EventArgs
{
	public GameClientConnectionState GameClientConnectionState
	{
		get;
		private set;
	}

	public GameClientConnectionStateChangeEventArgs(GameClientConnectionState gameClientConnectionState)
	{
		GameClientConnectionState = gameClientConnectionState;
	}
}
public abstract class GameClientMessage : Message
{
	public GameClientMessage(GameClientMessageID id)
		: base((short)id)
	{
	}
}
public enum GameClientMessageID
{
	InitiateConnection = 2001,
	LeaveGame = 2002,
	AuthTicket = 2010,
	PostOrder = 2101,
	PostOrderResponse = 2102,
	State = 2103,
	RPC = 2104,
	Chat = 2201,
	DownloadGame = 2301,
	GameDiagnosticsInfo = 2901,
	DumpDownloadResponse = 2902
}
public class GameClientAuthTicketMessage : GameClientMessage
{
	public byte[] Ticket
	{
		get;
		set;
	}

	public uint Length
	{
		get;
		set;
	}

	public GameClientAuthTicketMessage()
		: base(GameClientMessageID.AuthTicket)
	{
	}

	public GameClientAuthTicketMessage(byte[] ticket, uint length)
		: base(GameClientMessageID.AuthTicket)
	{
		Ticket = ticket;
		Length = length;
	}

	protected override void Pack(Amplitude.Unity.Messaging.BinaryWriter writer)
	{
		base.Pack(writer);
		writer.Write(Length);
		writer.Write(Ticket, 0, (int)Length);
	}

	protected override void Unpack(Amplitude.Unity.Messaging.BinaryReader reader)
	{
		base.Unpack(reader);
		Length = reader.ReadUInt32();
		Ticket = ((Length == 0) ? new byte[0] : reader.ReadBytes((int)Length));
	}
}
public class GameClientChatMessage : GameClientMessage
{
	public GameClientChatMessage()
		: base(GameClientMessageID.Chat)
	{
	}
}
public class GameClientDownloadGameMessage : GameClientMessage
{
	public GameClientDownloadGameMessage()
		: base(GameClientMessageID.DownloadGame)
	{
	}
}
public class GameClientInitiateConnectionMessage : GameClientMessage
{
	public GameClientInitiateConnectionMessage()
		: base(GameClientMessageID.InitiateConnection)
	{
	}
}
public class GameClientLeaveMessage : GameClientMessage
{
	public GameClientLeaveMessage()
		: base(GameClientMessageID.LeaveGame)
	{
	}
}
public class GameClientPostOrderMessage : GameClientMessage
{
	public Amplitude.Unity.Game.Orders.Order Order
	{
		get;
		private set;
	}

	public GameClientPostOrderMessage()
		: base(GameClientMessageID.PostOrder)
	{
	}

	public GameClientPostOrderMessage(Amplitude.Unity.Game.Orders.Order order)
		: base(GameClientMessageID.PostOrder)
	{
		Order = order;
	}

	protected override void Pack(Amplitude.Unity.Messaging.BinaryWriter writer)
	{
		base.Pack(writer);
		if (Order != null)
		{
			string assemblyQualifiedName = Order.GetType().AssemblyQualifiedName;
			writer.Write(assemblyQualifiedName);
			if (!string.IsNullOrEmpty(assemblyQualifiedName))
			{
				Order.Pack(writer);
			}
		}
		else
		{
			writer.Write(string.Empty);
		}
	}

	protected override void Unpack(Amplitude.Unity.Messaging.BinaryReader reader)
	{
		//Discarded unreachable code: IL_005d
		base.Unpack(reader);
		string text = reader.ReadString();
		if (!string.IsNullOrEmpty(text))
		{
			try
			{
				Type type = Type.GetType(text);
				if (type != null)
				{
					Order = (FormatterServices.GetUninitializedObject(type) as Amplitude.Unity.Game.Orders.Order);
					if (Order != null)
					{
						Order.Unpack(reader);
					}
				}
			}
			catch
			{
				Order = null;
				throw;
			}
		}
	}
}
public class GameClientPostOrderResponseMessage : GameClientMessage
{
	public ulong OrderSerial
	{
		get;
		private set;
	}

	public GameClientPostOrderResponseMessage()
		: base(GameClientMessageID.PostOrderResponse)
	{
	}

	public GameClientPostOrderResponseMessage(ulong orderSerial)
		: base(GameClientMessageID.PostOrderResponse)
	{
		OrderSerial = orderSerial;
	}

	protected override void Pack(Amplitude.Unity.Messaging.BinaryWriter writer)
	{
		base.Pack(writer);
		writer.Write(OrderSerial);
	}

	protected override void Unpack(Amplitude.Unity.Messaging.BinaryReader reader)
	{
		base.Unpack(reader);
		OrderSerial = reader.ReadUInt64();
	}
}
public class GameClientRPCMessage : GameClientMessage
{
	public RPCProxyName RPCProxyName
	{
		get;
		private set;
	}

	public string SerializedArgs
	{
		get;
		private set;
	}

	public float SendingTime
	{
		get;
		private set;
	}

	public GameClientRPCMessage()
		: base(GameClientMessageID.RPC)
	{
	}

	public GameClientRPCMessage(RPCProxyName rpcProxyName, float sendingTime, string serializedArgs)
		: base(GameClientMessageID.RPC)
	{
		RPCProxyName = rpcProxyName;
		SerializedArgs = serializedArgs;
		SendingTime = sendingTime;
	}

	protected override void Pack(Amplitude.Unity.Messaging.BinaryWriter writer)
	{
		base.Pack(writer);
		writer.Write((int)RPCProxyName);
		writer.Write(SerializedArgs);
		writer.Write(SendingTime);
	}

	protected override void Unpack(Amplitude.Unity.Messaging.BinaryReader reader)
	{
		base.Unpack(reader);
		RPCProxyName = reader.ReadInt32().ToEnum<RPCProxyName>();
		SerializedArgs = reader.ReadString();
		SendingTime = reader.ReadSingle();
	}
}
public class GameClientStateMessage : GameClientMessage
{
	public string AssemblyQualifiedName
	{
		get;
		private set;
	}

	public GameClientStateMessage()
		: base(GameClientMessageID.State)
	{
	}

	public GameClientStateMessage(Type type)
		: base(GameClientMessageID.State)
	{
		AssemblyQualifiedName = type.AssemblyQualifiedName;
	}

	protected override void Pack(Amplitude.Unity.Messaging.BinaryWriter writer)
	{
		base.Pack(writer);
		writer.Write(AssemblyQualifiedName);
	}

	protected override void Unpack(Amplitude.Unity.Messaging.BinaryReader reader)
	{
		base.Unpack(reader);
		AssemblyQualifiedName = reader.ReadString();
	}
}
public class GameClientState : GameState
{
	public bool CanSendOrder
	{
		get;
		protected set;
	}

	protected GameClient GameClient
	{
		get;
		private set;
	}

	public GameClientState(GameClient gameClient)
	{
		Diagnostics.Assert(gameClient != null);
		GameClient = gameClient;
	}

	~GameClientState()
	{
		GameClient = null;
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Message message = new GameClientStateMessage(GetType());
		GameClient.SendMessageToServer(ref message);
	}
}
public class GameClientState<T> : GameClientState where T : GameClientState<T>
{
	public GameClientState(GameClient gameClient)
		: base(gameClient)
	{
	}

	public override void Run()
	{
		base.Run();
	}
}
public class GameClientStateChangeEventArgs : EventArgs
{
	public Type GameClientStateType
	{
		get;
		private set;
	}

	public GameClientStateChangeEventArgs(GameClientState gameClientState)
	{
		GameClientStateType = gameClientState.GetType();
	}
}
public enum GameClientStateSynchronisationLevel
{
	Undefined,
	A,
	B,
	c
}
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
public class GameClientStateSynchronisationLevelAttribute : Attribute
{
	public int Level
	{
		get;
		private set;
	}

	public GameClientStateSynchronisationLevelAttribute(int level)
	{
		Level = level;
	}
}
public class GameClientState_AllDungeonsCreated : GameClientState
{
	private Amplitude.Coroutine coroutine;

	public GameClientState_AllDungeonsCreated(GameClient gameClient)
		: base(gameClient)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		coroutine = Amplitude.Coroutine.StartCoroutine(RunAsync());
	}

	public override void Run()
	{
		base.Run();
		coroutine.Run();
		if (coroutine.IsFinished)
		{
			base.GameClient.PostStateChange(typeof(GameClientState_DungeonPreFilled));
		}
	}

	private IEnumerator RunAsync()
	{
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		yield return dungeon.PreFillDungeonAsync();
	}

	public override void End(bool abort)
	{
		coroutine = null;
		base.End(abort);
	}
}
public class GameClientState_AllDungeonsFilled : GameClientState
{
	public GameClientState_AllDungeonsFilled(GameClient gameClient)
		: base(gameClient)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		dungeon.DisplayGame();
	}
}
public class GameClientState_AllDungeonsInstantiated : GameClientState
{
	private Amplitude.Coroutine coroutine;

	public GameClientState_AllDungeonsInstantiated(GameClient gameClient)
		: base(gameClient)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		coroutine = Amplitude.Coroutine.StartCoroutine(RunAsync());
	}

	public override void Run()
	{
		base.Run();
		coroutine.Run();
		if (coroutine.IsFinished)
		{
			base.GameClient.PostStateChange(typeof(GameClientState_DungeonCreated));
		}
	}

	private IEnumerator RunAsync()
	{
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		yield return dungeon.CreateDungeonAsync();
	}

	public override void End(bool abort)
	{
		coroutine = null;
		base.End(abort);
	}
}
public class GameClientState_AllDungeonsPreFilled : GameClientState
{
	private Amplitude.Coroutine coroutine;

	public GameClientState_AllDungeonsPreFilled(GameClient gameClient)
		: base(gameClient)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		coroutine = Amplitude.Coroutine.StartCoroutine(RunAsync());
	}

	public override void Run()
	{
		base.Run();
		coroutine.Run();
		if (coroutine.IsFinished)
		{
			base.GameClient.PostStateChange(typeof(GameClientState_DungeonFilled));
		}
	}

	private IEnumerator RunAsync()
	{
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		yield return dungeon.FillDungeonAsync();
	}

	public override void End(bool abort)
	{
		coroutine = null;
		base.End(abort);
	}
}
public class GameClientState_Authentication : GameClientState
{
	public GameClientState_Authentication(GameClient gameClient)
		: base(gameClient)
	{
	}

	public static string TicketToString(byte[] ticket, uint length)
	{
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < length; i++)
		{
			stringBuilder.Append(string.Format("{0}{1}", ticket[i].ToString("x2"), ((i + 1) % 4 != 0) ? string.Empty : "-"));
		}
		return stringBuilder.ToString();
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Diagnostics.Progress.SetProgress(0.3f, "Authenticating...", "NETWORKING");
		if (base.GameClient.GameClientConnectionState == GameClientConnectionState.ConnectedToServer)
		{
			base.GameClient.Authentify();
		}
	}

	public override void End(bool abort)
	{
		base.End(abort);
	}

	public override void Run()
	{
		base.Run();
		switch (base.GameClient.GameClientConnectionState)
		{
		case GameClientConnectionState.AuthenticatingToServer:
			break;
		case GameClientConnectionState.AuthenticatedToServer:
			base.GameClient.PostStateChange(typeof(GameClientState_DownloadGame));
			break;
		case GameClientConnectionState.AuthenticationHasFailed:
			base.GameClient.PostStateChange(typeof(GameClientState_AuthenticationFailed));
			break;
		default:
			throw new ArgumentOutOfRangeException();
		}
	}
}
public class GameClientState_AuthenticationFailed : GameClientState
{
	public GameClientState_AuthenticationFailed(GameClient gameClient)
		: base(gameClient)
	{
	}
}
public class GameClientState_ConnectedToServer : GameClientState
{
	public GameClientState_ConnectedToServer(GameClient gameClient)
		: base(gameClient)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		switch (base.GameClient.Session.SessionMode)
		{
		case SessionMode.Single:
			base.GameClient.PostStateChange(typeof(GameClientState_DownloadGame));
			break;
		case SessionMode.Private:
		case SessionMode.Protected:
		case SessionMode.Public:
		{
			base.GameClient.PostStateChange(typeof(GameClientState_Authentication));
			GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
			gameNetworkManager.StartMonitorPlayerLeft();
			gameNetworkManager.StartMonitorServerLeft();
			break;
		}
		default:
			throw new ArgumentOutOfRangeException();
		}
	}
}
public class GameClientState_ConnectingToServer : GameClientState
{
	private const float connectionTimeout = 10f;

	private float connectionStartTime;

	public GameClientState_ConnectingToServer(GameClient gameClient)
		: base(gameClient)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		switch (base.GameClient.GameClientConnectionState)
		{
		case GameClientConnectionState.ConnectionToServerHasFailed:
		case GameClientConnectionState.ConnectionToServerHasTimedOut:
			throw new NotImplementedException();
		case GameClientConnectionState.DisconnectedFromServer:
			base.GameClient.Connect();
			break;
		default:
			throw new NotImplementedException();
		case GameClientConnectionState.ConnectedToServer:
			break;
		}
		connectionStartTime = Time.realtimeSinceStartup;
	}

	public override void Run()
	{
		base.Run();
		switch (base.GameClient.GameClientConnectionState)
		{
		case GameClientConnectionState.ConnectedToServer:
			base.GameClient.PostStateChange(typeof(GameClientState_ConnectedToServer));
			break;
		case GameClientConnectionState.ConnectingToServer:
			if (Time.realtimeSinceStartup > connectionStartTime + 10f)
			{
				Diagnostics.LogWarning("GameClientState_ConnectingToServer > Connection timeout!");
				base.GameClient.Disconnect(GameDisconnectionReason.ConnectionTimeout);
			}
			break;
		case GameClientConnectionState.ConnectionToServerHasFailed:
		case GameClientConnectionState.ConnectionToServerHasTimedOut:
			base.GameClient.PostStateChange(typeof(GameClientState_DisconnectedFromServer));
			break;
		case GameClientConnectionState.DisconnectedFromServer:
			base.GameClient.PostStateChange(typeof(GameClientState_DisconnectedFromServer));
			break;
		default:
			throw new NotImplementedException();
		}
	}
}
public class GameClientState_DisconnectedFromServer : GameClientState
{
	private enum GuiRedirection
	{
		MainMenu,
		Lobby
	}

	private GuiRedirection guiRedirection;

	private bool acknowledged;

	public GameClientState_DisconnectedFromServer(GameClient gameClient)
		: base(gameClient)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		acknowledged = false;
		string text = string.Empty;
		int num = 0;
		GameDisconnectionReason gameDisconnectionReason = GameDisconnectionReason.Default;
		if (parameters.Length == 3)
		{
			GameClientConnectionState gameClientConnectionState = (GameClientConnectionState)(int)parameters[0];
			text = "state=" + gameClientConnectionState.ToString();
			gameDisconnectionReason = (GameDisconnectionReason)(int)parameters[1];
			text = text + ",reason=" + gameDisconnectionReason;
			num = (int)parameters[2];
			text = text + ",errcode=" + num;
		}
		Diagnostics.Log("GameClientState_DisconnectedFromServer {0}", text);
		switch (gameDisconnectionReason)
		{
		case GameDisconnectionReason.Default:
		case GameDisconnectionReason.ClientLeft:
			guiRedirection = GuiRedirection.MainMenu;
			break;
		case GameDisconnectionReason.HostLeft:
		{
			guiRedirection = GuiRedirection.MainMenu;
			GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
			ulong serverPlayerID = gameNetworkManager.GetServerPlayerID();
			string playerName = gameNetworkManager.GetPlayerName(serverPlayerID);
			string message = AgeLocalizer.Instance.LocalizeString("%HostLeftMessage").Replace("$PlayerName", playerName);
			SingletonManager.Get<RequesterPanel>().Display(message);
			acknowledged = true;
			break;
		}
		case GameDisconnectionReason.P2PFailure:
			guiRedirection = GuiRedirection.Lobby;
			acknowledged = true;
			break;
		case GameDisconnectionReason.SteamFailure:
		case GameDisconnectionReason.SteamServerFailure:
		case GameDisconnectionReason.AuthFailure:
		case GameDisconnectionReason.ConnectionTimeout:
		case GameDisconnectionReason._Debug:
			guiRedirection = GuiRedirection.MainMenu;
			acknowledged = true;
			break;
		default:
			throw new ArgumentOutOfRangeException();
		}
	}

	public override void Run()
	{
		base.Run();
		if (acknowledged)
		{
			acknowledged = false;
			switch (guiRedirection)
			{
			case GuiRedirection.MainMenu:
			{
				IRuntimeService service = Services.GetService<IRuntimeService>();
				Diagnostics.Assert(service != null);
				service.Runtime.FiniteStateMachine.PostStateChange(typeof(RuntimeState_OutGame));
				break;
			}
			case GuiRedirection.Lobby:
				base.GameClient.Session.ReturnToLobby = true;
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}
	}
}
public class GameClientState_DownloadGame : GameClientState
{
	public static readonly string DownloadSaveFileName = "%DownloadSaveFileName";

	public bool DownloadGameMessageAcknowledgedByServer
	{
		get;
		private set;
	}

	public double TimeWhenLastMessageWasSentToServer
	{
		get;
		private set;
	}

	[Service]
	private INetworkingService SteamNetworkingService
	{
		get;
		set;
	}

	public GameClientState_DownloadGame(GameClient gameClient)
		: base(gameClient)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		SteamNetworkingService = Services.GetService<INetworkingService>();
		Diagnostics.Assert(SteamNetworkingService != null);
		SteamNetworkingService.MessageReceived += SteamNetworkingService_MessageReceived;
		DownloadGameMessageAcknowledgedByServer = false;
		SendDownloadGameMessageToServer();
		Diagnostics.Progress.SetProgress(0.4f, "Waiting for game data...", "NETWORKING");
	}

	public override void End(bool abort)
	{
		if (SteamNetworkingService != null)
		{
			SteamNetworkingService.MessageReceived -= SteamNetworkingService_MessageReceived;
			SteamNetworkingService = null;
		}
		base.End(abort);
	}

	public override void Run()
	{
		base.Run();
		if (!DownloadGameMessageAcknowledgedByServer)
		{
			double num = Session.Time - TimeWhenLastMessageWasSentToServer;
			if (num >= 1.0)
			{
				SendDownloadGameMessageToServer();
			}
		}
	}

	private void SendDownloadGameMessageToServer()
	{
		Message message = new GameClientDownloadGameMessage();
		base.GameClient.SendMessageToServer(ref message);
		TimeWhenLastMessageWasSentToServer = Session.Time;
	}

	private void SteamNetworkingService_MessageReceived(object sender, NetworkingMessageReceivedEventArgs e)
	{
		short iD = e.Message.ID;
		if (iD == 1301)
		{
			Diagnostics.Log("Download game message has been acknowledged by server.");
			DownloadGameMessageAcknowledgedByServer = true;
			GameServerDownloadGameResponseMessage message = e.Message as GameServerDownloadGameResponseMessage;
			base.GameClient.ProcessDownloadGameResponse(message);
		}
	}
}
public class GameClientState_DungeonCreated : GameClientState
{
	public GameClientState_DungeonCreated(GameClient gameClient)
		: base(gameClient)
	{
	}
}
public class GameClientState_DungeonFilled : GameClientState
{
	public GameClientState_DungeonFilled(GameClient gameClient)
		: base(gameClient)
	{
	}
}
public class GameClientState_DungeonPreFilled : GameClientState
{
	public GameClientState_DungeonPreFilled(GameClient gameClient)
		: base(gameClient)
	{
	}
}
public class GameClientState_GameLaunched : GameClientState
{
	public GameClientState_GameLaunched(GameClient gameClient)
		: base(gameClient)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		ISessionService service = Services.GetService<ISessionService>();
		Diagnostics.Assert(service != null);
		Diagnostics.Assert(service.Session != null);
		Diagnostics.Assert(service.Session.IsOpened);
		Ticket.ResetCounter(0uL);
		base.GameClient.PostStateChange(typeof(GameClientState_GameLaunchedAndReady));
	}

	public override void End(bool abort)
	{
		base.End(abort);
	}
}
public class GameClientState_GameLaunchedAndReady : GameClientState
{
	public GameClientState_GameLaunchedAndReady(GameClient gameClient)
		: base(gameClient)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Diagnostics.Progress.SetProgress(1f, "Waiting for server...");
	}
}
public class GameClientState_LaunchGame : GameClientState
{
	private IGameService gameService;

	public GameClientState_LaunchGame(GameClient gameClient)
		: base(gameClient)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		gameService = Services.GetService<IGameService>();
		gameService.CreateGameComplete += GameService_CreateGameComplete;
		gameService.CreateGameProgressChange += GameService_CreateGameProgressChange;
		gameService.CreateGame();
	}

	public override void End(bool abort)
	{
		base.End(abort);
		gameService.CreateGameComplete -= GameService_CreateGameComplete;
		gameService.CreateGameProgressChange -= GameService_CreateGameProgressChange;
	}

	private void GameService_CreateGameComplete(object sender, CreateGameCompleteEventArgs e)
	{
		if (e.Cancelled)
		{
			throw new NotImplementedException("The game creation process was canceled.");
		}
		if (e.Exception != null)
		{
			throw e.Exception;
		}
		if (e.Game != null)
		{
			base.GameClient.PostStateChange(typeof(GameClientState_GameLaunched));
			return;
		}
		throw new NotImplementedException("The game creation process has failed unexpectedly.");
	}

	private void GameService_CreateGameProgressChange(object sender, CreateGameProgressChangeEventArgs e)
	{
	}
}
public class GameClientState_RestartGame : GameClientState
{
	public GameClientState_RestartGame(GameClient gameClient)
		: base(gameClient)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Dungeon.PrepareForNextLevel();
		Services.GetService<IGameService>()?.ReleaseGame();
		base.GameClient.PostStateChange(typeof(GameClientState_DownloadGame));
	}
}
public class GameClientState_WaitingForServer : GameClientState
{
	public GameClientState_WaitingForServer(GameClient gameClient)
		: base(gameClient)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Diagnostics.Progress.SetProgress(0.1f, "Waiting for server...", "NETWORKING");
		if (base.GameClient.Session.SessionMode == SessionMode.Single)
		{
			base.GameClient.OnSteamGameServerReady();
			base.GameClient.PostStateChange(typeof(GameClientState_ConnectingToServer));
		}
	}

	public override void Run()
	{
		base.Run();
		if (base.GameClient.Session.IsServerIdValid())
		{
			Diagnostics.Log("GameClientState_WaitingForServer, Steam server is valid ({0}).", base.GameClient.Session.ServerId.ToString());
			base.GameClient.OnSteamGameServerReady();
			base.GameClient.PostStateChange(typeof(GameClientState_ConnectingToServer));
		}
	}
}
public interface IGameClient : IDisposable, IGameInterface
{
	void Disconnect(GameDisconnectionReason reason = GameDisconnectionReason.Default, int errorCode = 0);
}
public interface IGameClientLauncher
{
	IGameClient GameClient
	{
		get;
	}

	void Launch();
}
public class Ticket
{
	private static ulong counter;

	public bool Raised
	{
		get;
		private set;
	}

	public PostOrderResponse PostOrderResponse
	{
		get;
		set;
	}

	public Amplitude.Unity.Game.Orders.Order Order
	{
		get;
		set;
	}

	private EventHandler<TicketRaisedEventArgs> EventHandler
	{
		get;
		set;
	}

	public Ticket(Amplitude.Unity.Game.Orders.Order order)
	{
		Order = order;
		Order.TicketNumber = ++counter;
		PostOrderResponse = PostOrderResponse.Undefined;
	}

	public Ticket(Amplitude.Unity.Game.Orders.Order order, EventHandler<TicketRaisedEventArgs> eventHandler)
		: this(order)
	{
		EventHandler = eventHandler;
	}

	public static void ResetCounter(ulong value = 0L)
	{
		counter = value;
	}

	public void Raise(PostOrderResponse response)
	{
		Raised = true;
		PostOrderResponse = response;
		if (EventHandler != null)
		{
			EventHandler(this, new TicketRaisedEventArgs(Order, response));
		}
	}
}
public class TicketRaisedEventArgs : EventArgs
{
	public Amplitude.Unity.Game.Orders.Order Order
	{
		get;
		private set;
	}

	public PostOrderResponse Result
	{
		get;
		private set;
	}

	public TicketRaisedEventArgs(Amplitude.Unity.Game.Orders.Order order, PostOrderResponse result)
	{
		Order = order;
		Result = result;
	}
}
public class GameServer : GameInterface, IDisposable, IGameInterface, IGameServer
{
	private bool disposed;

	private ulong nextPendingOrderSerial;

	private Steamworks.SteamGameServer steamGameServer;

	private IServerService steamServersService;

	private NetworkingProxy steamNetworkingProxy;

	private System.Guid dumpGuid;

	private GameNetworkManager gameNetworkManager;

	public Dictionary<ulong, GameClientConnection> GameClientConnections
	{
		get;
		private set;
	}

	public bool HasPendingOrder => PendingOrder != null;

	public bool HasPendingOrders
	{
		get
		{
			if (PendingOrders.Count > 0)
			{
				return true;
			}
			if (PendingOrder != null)
			{
				return true;
			}
			return false;
		}
	}

	public bool IsPublic => base.Session.SessionMode == SessionMode.Public || base.Session.SessionMode == SessionMode.Protected;

	public Type PendingOrderType => PendingOrder.GetType();

	private Amplitude.Unity.Game.Orders.Order PendingOrder
	{
		get;
		set;
	}

	private Queue<GameClientPostOrderMessage> PendingOrders
	{
		get;
		set;
	}

	public GameServer(Session session)
		: base(session)
	{
		if (base.Session.SessionMode != 0)
		{
			Diagnostics.Log("Starting game server: setting lobby as PRIVATE");
			ISteamMatchMakingService service = Services.GetService<ISteamMatchMakingService>();
			service.SteamMatchMaking.SetLobbyType(base.Session.SteamIDLobby, Steamworks.SteamMatchMaking.ELobbyType.k_ELobbyTypePrivate);
		}
		base.FiniteStateMachine.RegisterState(new GameServerState_InitializeServer(this));
		base.FiniteStateMachine.RegisterState(new GameServerState_LaunchGame(this));
		base.FiniteStateMachine.RegisterState(new GameServerState_GameLaunchedAndReady(this));
		base.FiniteStateMachine.RegisterState(new GameServerState_AllDungeonsInstantiated(this));
		base.FiniteStateMachine.RegisterState(new GameServerState_AllDungeonsCreated(this));
		base.FiniteStateMachine.RegisterState(new GameServerState_AllDungeonsPreFilled(this));
		base.FiniteStateMachine.RegisterState(new GameServerState_AllDungeonsFilled(this));
		base.FiniteStateMachine.RegisterState(new GameServerState_RestartGame(this));
		PostStateChange(typeof(GameServerState_InitializeServer));
		INetworkingService service2 = Services.GetService<INetworkingService>();
		service2.RegisterMessageClass<GameClientInitiateConnectionMessage>();
		service2.RegisterMessageClass<GameClientDownloadGameMessage>();
		service2.RegisterMessageClass<GameClientAuthTicketMessage>();
		service2.RegisterMessageClass<GameClientLeaveMessage>();
		service2.RegisterMessageClass<GameClientRPCMessage>();
		service2.RegisterMessageClass<GameClientStateMessage>();
		GameClientConnections = new Dictionary<ulong, GameClientConnection>();
		PendingOrders = new Queue<GameClientPostOrderMessage>();
		PendingOrder = null;
		nextPendingOrderSerial = 0uL;
	}

	~GameServer()
	{
		Dispose(disposing: false);
		Diagnostics.Log("Game server has been deleted.");
	}

	public void OnSteamGameServerCreated()
	{
		steamGameServer = Steamworks.SteamAPI.SteamGameServer;
		steamNetworkingProxy = new NetworkingProxy(server: true);
		base.MessageBox = new MessageBox(steamNetworkingProxy);
		steamServersService = Services.GetService<IServerService>();
		if (steamServersService != null)
		{
			steamServersService.ServerP2PSessionRequest += ISteamServersService_P2PSessionRequest;
			steamServersService.ServerP2PSessionConnectFail += ISteamServersService_P2PSessionConnectFail;
			steamServersService.ValidateAuthTicketResponse += ISteamServersService_ValidateAuthTicketResponse;
			steamServersService.ServerSteamServerConnectFailure += ISteamServersService_SteamServerConnectFailure;
		}
	}

	public void SendMessageToClients(ref Message message)
	{
		if (base.MessageBox != null)
		{
			ulong[] array = new ulong[GameClientConnections.Count];
			int num = 0;
			foreach (KeyValuePair<ulong, GameClientConnection> gameClientConnection in GameClientConnections)
			{
				if (gameClientConnection.Value.GameClientConnectionState != GameClientConnectionState.DisconnectedFromServer)
				{
					array[num++] = gameClientConnection.Value.SteamIDRemote;
				}
			}
			base.MessageBox.SendMessage(ref message, array);
		}
	}

	public override void SendMessageToServer(ref Message message)
	{
		if (base.MessageBox != null)
		{
			base.MessageBox.PushMessage(ref message, UserID);
		}
	}

	public void Disconnect()
	{
		if (steamGameServer != null)
		{
			Diagnostics.Log("[GameServer][Net] Disconnecting...");
			if (base.MessageBox != null)
			{
				Message message = new GameServerLeaveMessage();
				SendMessageToClients(ref message);
				Diagnostics.Log("[GameServer][Net] Leave message sent.");
			}
			foreach (KeyValuePair<ulong, GameClientConnection> gameClientConnection in GameClientConnections)
			{
				if (gameClientConnection.Key != UserID)
				{
					switch (gameClientConnection.Value.GameClientConnectionState)
					{
					case GameClientConnectionState.ConnectedToServer:
					case GameClientConnectionState.ConnectingToServer:
					case GameClientConnectionState.AuthenticatingToServer:
					case GameClientConnectionState.AuthenticatedToServer:
					case GameClientConnectionState.AuthenticationHasFailed:
						RemoveUserFromServer(gameClientConnection.Key, GameDisconnectionReason.HostLeft);
						break;
					default:
						throw new ArgumentOutOfRangeException();
					case GameClientConnectionState.ConnectionToServerHasFailed:
					case GameClientConnectionState.ConnectionToServerHasTimedOut:
					case GameClientConnectionState.DisconnectedFromServer:
						break;
					}
				}
			}
			GameClientConnections.Clear();
			Diagnostics.Log("[GameServer][Net] Logging off SteamGameServer.");
			steamGameServer.EnableHeartbeats(bActive: false);
			steamGameServer.LogOff();
			Diagnostics.Log("[GameServer][Net] Shutting down SteamGameServer.");
			Steamworks.SteamGameServer.Shutdown();
			steamGameServer = null;
			Diagnostics.Log("[GameServer][Net] Disconnected.");
		}
	}

	protected override void Dispose(bool disposing)
	{
		if (!disposed)
		{
			if (disposing)
			{
				Disconnect();
				if (steamServersService != null)
				{
					steamServersService.ServerP2PSessionRequest -= ISteamServersService_P2PSessionRequest;
					steamServersService.ServerP2PSessionConnectFail -= ISteamServersService_P2PSessionConnectFail;
					steamServersService.ValidateAuthTicketResponse -= ISteamServersService_ValidateAuthTicketResponse;
					steamServersService.ServerSteamServerConnectFailure -= ISteamServersService_SteamServerConnectFailure;
				}
				if (Game != null)
				{
				}
				PendingOrders.Clear();
				PendingOrder = null;
			}
			disposed = true;
		}
		base.Dispose(disposing);
	}

	protected override void ProcessMessage(ref IMessage message, ref ulong steamIDRemote)
	{
		switch (message.ID)
		{
		case 2001:
		{
			Diagnostics.Log("[Net] [GameServer] Initiate connection to server with steamIDRemote: '{0}', steamIDUser: '{1}'.", steamIDRemote.ToString(), UserID.ToString());
			if (!GameClientConnections.TryGetValue(steamIDRemote, out GameClientConnection value))
			{
				GameClientConnection gameClientConnection = new GameClientConnection();
				gameClientConnection.GameClientConnectionFlags = GameClientConnectionFlags.Zero;
				gameClientConnection.GameClientConnectionState = GameClientConnectionState.ConnectedToServer;
				gameClientConnection.GameClientState = string.Empty;
				gameClientConnection.SteamIDRemote = steamIDRemote;
				value = gameClientConnection;
				GameClientConnections.Add(steamIDRemote, value);
				if (steamIDRemote == UserID)
				{
					GameClient gameClient = base.Session.GameClient as GameClient;
					if (gameClient == null)
					{
						Diagnostics.LogError("The game client is null.");
						break;
					}
					base.MessageBox.Connect(steamIDRemote, gameClient.MessageBox.MessagePipe);
					value.GameClientConnectionState = GameClientConnectionState.AuthenticatedToServer;
				}
			}
			Message message2 = new GameServerInitiateConnectionResponseMessage();
			base.MessageBox.SendMessage(ref message2, steamIDRemote);
			break;
		}
		case 2002:
			Diagnostics.Log("[Net] [GameServer] User '{0}' has left the game.", steamIDRemote.ToString());
			RemoveUserFromServer(steamIDRemote, GameDisconnectionReason.ClientLeft);
			GameClientConnections.Remove(steamIDRemote);
			break;
		case 2010:
		{
			GameClientAuthTicketMessage gameClientAuthTicketMessage = message as GameClientAuthTicketMessage;
			Diagnostics.Assert(gameClientAuthTicketMessage != null, "Invalid message type. Expected GameClientAuthTicketMessage.");
			Diagnostics.Log("[Net] [GameServer,Auth] Received auth ticket from: '{0}', with length: {1}, ticket = {2}.", steamIDRemote.ToString(), gameClientAuthTicketMessage.Length, GameClientState_Authentication.TicketToString(gameClientAuthTicketMessage.Ticket, gameClientAuthTicketMessage.Length));
			Steamworks.SteamGameServer steamGameServer = Steamworks.SteamAPI.SteamGameServer;
			byte[] pAuthTicket = gameClientAuthTicketMessage.Ticket;
			Steamworks.EBeginAuthSessionResult eBeginAuthSessionResult = steamGameServer.BeginAuthSession(ref pAuthTicket, gameClientAuthTicketMessage.Length, steamIDRemote);
			switch (eBeginAuthSessionResult)
			{
			case Steamworks.EBeginAuthSessionResult.k_EBeginAuthSessionResultOK:
				Diagnostics.Log("[Net] [GameServer,Auth] BeginAuthSession succeeded for member: '{0}'.", steamIDRemote.ToString());
				break;
			case Steamworks.EBeginAuthSessionResult.k_EBeginAuthSessionResultInvalidTicket:
			case Steamworks.EBeginAuthSessionResult.k_EBeginAuthSessionResultDuplicateRequest:
			case Steamworks.EBeginAuthSessionResult.k_EBeginAuthSessionResultInvalidVersion:
			case Steamworks.EBeginAuthSessionResult.k_EBeginAuthSessionResultGameMismatch:
			case Steamworks.EBeginAuthSessionResult.k_EBeginAuthSessionResultExpiredTicket:
				Diagnostics.LogError("[Net] [GameServer,Auth] BeginAuthSession failed with error: 0x{0:x4}, for member '{1}'.", (int)eBeginAuthSessionResult, steamIDRemote.ToString());
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
			break;
		}
		case 2101:
			Diagnostics.Assert(message is GameClientPostOrderMessage, "Invalid message type. We expect a GameClienPostOrderMessage.");
			PendingOrders.Enqueue(message as GameClientPostOrderMessage);
			break;
		case 2102:
		{
			if (steamIDRemote == UserID)
			{
				OnTicketRaised(PendingOrder.TicketNumber, PostOrderResponse.Processed, PendingOrder);
				PendingOrder = null;
			}
			if (GameClientConnections.TryGetValue(steamIDRemote, out GameClientConnection value4))
			{
				GameClientPostOrderResponseMessage gameClientPostOrderResponseMessage = message as GameClientPostOrderResponseMessage;
				Diagnostics.Assert(value4.LastAcknowledgedOrderSerial == 0L || value4.LastAcknowledgedOrderSerial == gameClientPostOrderResponseMessage.OrderSerial - 1, $"[Net] Missing order(s) detected between serials {value4.LastAcknowledgedOrderSerial} and {gameClientPostOrderResponseMessage.OrderSerial}");
				value4.LastAcknowledgedOrderSerial = gameClientPostOrderResponseMessage.OrderSerial;
			}
			break;
		}
		case 2103:
		{
			if (GameClientConnections.TryGetValue(steamIDRemote, out GameClientConnection value3))
			{
				value3.GameClientState = (message as GameClientStateMessage).AssemblyQualifiedName;
				Message message4 = new GameServerPlayerUpdateMessage(steamIDRemote, (message as GameClientStateMessage).AssemblyQualifiedName);
				SendMessageToClients(ref message4);
			}
			break;
		}
		case 2301:
		{
			Diagnostics.Log("[Net] [GameServer] Download game request received from: '{0}'.", steamIDRemote.ToString());
			if (GameClientConnections.TryGetValue(steamIDRemote, out GameClientConnection value2))
			{
				value2.GameClientConnectionFlags |= GameClientConnectionFlags.DownloadGameRequestReceived;
				value2.GameClientConnectionFlags |= GameClientConnectionFlags.DownloadGameRequestAcknowledged;
				Message message3 = new GameServerDownloadGameResponseMessage(Dungeon.NextDungeonGenerationParams);
				base.MessageBox.SendMessage(ref message3, steamIDRemote);
				Diagnostics.Log("[Net] [GameServer] Download game request received from: '{0}', and acknowledged.", steamIDRemote.ToString());
			}
			break;
		}
		case 2104:
		{
			Diagnostics.Assert(message is GameClientRPCMessage, "Invalid message type. {0}", message.GetType());
			GameClientRPCMessage gameClientRPCMessage = message as GameClientRPCMessage;
			Diagnostics.LogError("RPC RECEIVED BY SERVER (" + gameClientRPCMessage.RPCProxyName + ")");
			if (gameNetworkManager == null)
			{
				gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
			}
			gameNetworkManager.OnRPCMessageReceived(gameClientRPCMessage, steamIDRemote);
			break;
		}
		}
	}

	protected override void ProcessOrders()
	{
		if (PendingOrder != null)
		{
			return;
		}
		Amplitude.Unity.Game.Orders.Order order;
		while (true)
		{
			if (PendingOrders.Count <= 0)
			{
				return;
			}
			GameClientPostOrderMessage gameClientPostOrderMessage = PendingOrders.Dequeue();
			order = gameClientPostOrderMessage.Order;
			if (order == null)
			{
				continue;
			}
			PostOrderResponse postOrderResponse = PostOrderResponse.Undefined;
			if (true)
			{
				bool flag = true;
				if (orderProcessorInfoByType.TryGetValue(order.GetType(), out OrderProcessorInfo value))
				{
					flag = value.Preprocess(order);
				}
				if (flag)
				{
					break;
				}
				postOrderResponse = PostOrderResponse.PreprocessHasFailed;
			}
			else
			{
				postOrderResponse = PostOrderResponse.AuthenticationHasFailed;
			}
			if (order.TicketNumber != 0L)
			{
				Message message = new GameServerPostOrderResponseMessage(order, postOrderResponse);
				SendMessageToClients(ref message);
				OnTicketRaised(order.TicketNumber, postOrderResponse, order);
			}
		}
		PendingOrder = order;
		PendingOrder.Serial = nextPendingOrderSerial++;
		Message message2 = new GameServerPostOrderMessage(PendingOrder);
		SendMessageToClients(ref message2);
	}

	private void RemoveUserFromServer(ulong steamIDUser, GameDisconnectionReason reason = GameDisconnectionReason.Default)
	{
		RemoveUserFromServer(new Steamworks.SteamID(steamIDUser), reason);
	}

	private void RemoveUserFromServer(Steamworks.SteamID steamIDUser, GameDisconnectionReason reason = GameDisconnectionReason.Default)
	{
		Message message = new GameServerPlayerUpdateMessage(steamIDUser, GameServerPlayerUpdateMessage.PlayerAction.Left);
		SendMessageToClients(ref message);
		if (!GameClientConnections.TryGetValue(steamIDUser, out GameClientConnection value))
		{
			Diagnostics.Log("[Net] RemoveUserFromServer 0x{0:x16} has no connection.", steamIDUser);
		}
		else if (value.GameClientConnectionState != GameClientConnectionState.DisconnectedFromServer)
		{
			Diagnostics.Log("[GameServer][Net] Removing user 0x{0:x16} from server. reason={1}.", steamIDUser, reason);
			if (value.GameClientConnectionState == GameClientConnectionState.AuthenticatedToServer || value.GameClientConnectionState == GameClientConnectionState.ConnectionToServerHasFailed)
			{
				Diagnostics.Log("[GameServer][Net] Ending auth session for user 0x{0:x16}.", steamIDUser);
				Steamworks.SteamAPI.SteamGameServer.EndAuthSession(steamIDUser);
			}
			Diagnostics.Log("[GameServer][Net] Closing P2P session for user 0x{0:x16}.", steamIDUser);
			steamNetworkingProxy.CloseP2PSessionWithUser(steamIDUser);
			value.GameClientConnectionState = GameClientConnectionState.DisconnectedFromServer;
		}
	}

	private void ISteamServersService_P2PSessionRequest(object sender, P2PSessionRequestEventArgs e)
	{
		object[] array = new object[1];
		Steamworks.P2PSessionRequest message = e.Message;
		array[0] = message.m_steamIDRemote;
		Diagnostics.Log("[Net] ISteamServersService_P2PSessionRequest SteamIDRemote=0x{0:x16}", array);
		Steamworks.SteamNetworking steamGameServerNetworking = Steamworks.SteamAPI.SteamGameServerNetworking;
		Steamworks.P2PSessionRequest message2 = e.Message;
		steamGameServerNetworking.AcceptP2PSessionWithUser(message2.m_steamIDRemote);
	}

	private void ISteamServersService_P2PSessionConnectFail(object sender, P2PSessionConnectFailEventArgs e)
	{
		object[] array = new object[2];
		Steamworks.P2PSessionConnectFail message = e.Message;
		array[0] = message.m_steamIDRemote;
		Steamworks.P2PSessionConnectFail message2 = e.Message;
		array[1] = message2.m_eP2PSessionError;
		Diagnostics.Log("[Net] ISteamServersService_P2PSessionConnectFail SteamIDRemote=0x{0:x16} error=0x{1:x4}", array);
		Dictionary<ulong, GameClientConnection> gameClientConnections = GameClientConnections;
		Steamworks.P2PSessionConnectFail message3 = e.Message;
		if (!gameClientConnections.TryGetValue(message3.m_steamIDRemote, out GameClientConnection value))
		{
			object[] array2 = new object[1];
			Steamworks.P2PSessionConnectFail message4 = e.Message;
			array2[0] = message4.m_steamIDRemote;
			Diagnostics.LogError("[Net] GameClient 0x{0:x16} has no connection.", array2);
		}
		else if (value.GameClientConnectionState != GameClientConnectionState.DisconnectedFromServer)
		{
			value.GameClientConnectionState = GameClientConnectionState.ConnectionToServerHasFailed;
			Steamworks.P2PSessionConnectFail message5 = e.Message;
			RemoveUserFromServer(message5.m_steamIDRemote, GameDisconnectionReason.P2PFailure);
		}
	}

	private void ISteamServersService_SteamServerConnectFailure(object sender, SteamServerConnectFailureEventArgs e)
	{
		object[] array = new object[1];
		Steamworks.SteamServerConnectFailure message = e.Message;
		array[0] = (int)message.m_eResult;
		Diagnostics.Log("[Net] ISteamServersService_SteamSererConnectFailure 0x{0:x4}", array);
		GameClient obj = (GameClient)base.Session.GameClient;
		Steamworks.SteamServerConnectFailure message2 = e.Message;
		obj.Disconnect(GameDisconnectionReason.SteamServerFailure, (int)message2.m_eResult);
		Disconnect();
	}

	private void ISteamServersService_ValidateAuthTicketResponse(object sender, ValidateAuthTicketResponseEventArgs e)
	{
		Dictionary<ulong, GameClientConnection> gameClientConnections = GameClientConnections;
		Steamworks.ValidateAuthTicketResponse message = e.Message;
		if (!gameClientConnections.TryGetValue(message.m_SteamID, out GameClientConnection value))
		{
			object[] array = new object[1];
			Steamworks.ValidateAuthTicketResponse message2 = e.Message;
			array[0] = message2.m_SteamID;
			Diagnostics.LogError("[Net][Auth] GameClient 0x{0:x16} has no connection.", array);
			return;
		}
		Steamworks.ValidateAuthTicketResponse message3 = e.Message;
		switch (message3.m_eAuthSessionResponse)
		{
		case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseOK:
		{
			object[] array4 = new object[2];
			Steamworks.ValidateAuthTicketResponse message10 = e.Message;
			array4[0] = (int)message10.m_eAuthSessionResponse;
			Steamworks.ValidateAuthTicketResponse message11 = e.Message;
			array4[1] = message11.m_SteamID;
			Diagnostics.Log("[Net][Auth] ValidateAuthTicketResponse OK for member 0x{1:x16}", array4);
			value.GameClientConnectionState = GameClientConnectionState.AuthenticatedToServer;
			break;
		}
		case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseAuthTicketCanceled:
		{
			object[] array3 = new object[2];
			Steamworks.ValidateAuthTicketResponse message7 = e.Message;
			array3[0] = (int)message7.m_eAuthSessionResponse;
			Steamworks.ValidateAuthTicketResponse message8 = e.Message;
			array3[1] = message8.m_SteamID;
			Diagnostics.Log("[Net][Auth] ValidateAuthTicketResponse Canceled for member 0x{1:x16}", array3);
			value.GameClientConnectionState = GameClientConnectionState.ConnectedToServer;
			Steamworks.ValidateAuthTicketResponse message9 = e.Message;
			RemoveUserFromServer(message9.m_SteamID, GameDisconnectionReason.ClientLeft);
			break;
		}
		case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseUserNotConnectedToSteam:
		case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseNoLicenseOrExpired:
		case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseVACBanned:
		case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseLoggedInElseWhere:
		case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseVACCheckTimedOut:
		case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseAuthTicketInvalidAlreadyUsed:
		case Steamworks.EAuthSessionResponse.k_EAuthSessionResponseAuthTicketInvalid:
		{
			object[] array2 = new object[2];
			Steamworks.ValidateAuthTicketResponse message4 = e.Message;
			array2[0] = (int)message4.m_eAuthSessionResponse;
			Steamworks.ValidateAuthTicketResponse message5 = e.Message;
			array2[1] = message5.m_SteamID;
			Diagnostics.Log("[Net][Auth] ValidateAuthTicketResponse Error 0x{0:x4} for member 0x{1:x16}", array2);
			value.GameClientConnectionState = GameClientConnectionState.AuthenticationHasFailed;
			Steamworks.ValidateAuthTicketResponse message6 = e.Message;
			RemoveUserFromServer(message6.m_SteamID, GameDisconnectionReason.AuthFailure);
			break;
		}
		default:
			throw new ArgumentOutOfRangeException();
		}
		Steamworks.ValidateAuthTicketResponse message12 = e.Message;
		Message message13 = new GameServerAuthTicketResponseMessage(message12.m_eAuthSessionResponse);
		ulong[] array5 = new ulong[1];
		Steamworks.ValidateAuthTicketResponse message14 = e.Message;
		array5[0] = message14.m_SteamID;
		SendMessage(ref message13, array5);
	}
}
public class GameServerMessage : Message
{
	public GameServerMessage(GameServerMessageID id)
		: base((short)id)
	{
	}
}
public enum GameServerMessageID
{
	InitiateConnectionResponse = 1001,
	LeaveGame = 1002,
	AuthTicketResponse = 1010,
	PostOrder = 1101,
	PostOrderResponse = 1102,
	PostStateChange = 1103,
	PlayerUpdate = 1104,
	Chat = 1201,
	DownloadGameResponse = 1301,
	DownloadDumpRequest = 1901
}
public class GameServerAuthTicketResponseMessage : GameServerMessage
{
	public Steamworks.EAuthSessionResponse Response
	{
		get;
		set;
	}

	public GameServerAuthTicketResponseMessage()
		: base(GameServerMessageID.AuthTicketResponse)
	{
	}

	public GameServerAuthTicketResponseMessage(Steamworks.EAuthSessionResponse response)
		: base(GameServerMessageID.AuthTicketResponse)
	{
		Response = response;
	}

	protected override void Pack(Amplitude.Unity.Messaging.BinaryWriter writer)
	{
		base.Pack(writer);
		writer.Write((int)Response);
	}

	protected override void Unpack(Amplitude.Unity.Messaging.BinaryReader reader)
	{
		base.Unpack(reader);
		Response = (Steamworks.EAuthSessionResponse)reader.ReadInt32();
	}
}
public class GameServerChatMessage : GameServerMessage
{
	public GameServerChatMessage()
		: base(GameServerMessageID.Chat)
	{
	}
}
public class GameServerDownloadGameResponseMessage : GameServerMessage
{
	private DungeonGenerationParams generationParams;

	public DungeonGenerationParams GenerationParams => generationParams;

	public GameServerDownloadGameResponseMessage()
		: base(GameServerMessageID.DownloadGameResponse)
	{
	}

	public GameServerDownloadGameResponseMessage(DungeonGenerationParams generationParams)
		: base(GameServerMessageID.DownloadGameResponse)
	{
		this.generationParams = generationParams;
	}

	protected override void Pack(Amplitude.Unity.Messaging.BinaryWriter writer)
	{
		base.Pack(writer);
		writer.Write(generationParams.GameType.ToString());
		writer.Write(generationParams.GenerationSeed);
		writer.Write(generationParams.PostGenerationSeed);
		writer.Write(generationParams.GameDifficulty.ToString());
		writer.Write(generationParams.Level);
		writer.Write(generationParams.ShipName);
		writer.Write(generationParams.SavedGame_SaveDataSerial);
	}

	protected override void Unpack(Amplitude.Unity.Messaging.BinaryReader reader)
	{
		base.Unpack(reader);
		generationParams.GameType = reader.ReadString().ToEnum<GameType>();
		generationParams.GenerationSeed = reader.ReadInt32();
		generationParams.PostGenerationSeed = reader.ReadInt32();
		generationParams.GameDifficulty = reader.ReadString().ToEnum<GameDifficulty>();
		generationParams.Level = reader.ReadInt32();
		generationParams.ShipName = reader.ReadString();
		generationParams.SavedGame_SaveDataSerial = reader.ReadString();
	}
}
public class GameServerInitiateConnectionResponseMessage : GameServerMessage
{
	public GameServerInitiateConnectionResponseMessage()
		: base(GameServerMessageID.InitiateConnectionResponse)
	{
	}
}
public class GameServerLeaveMessage : GameServerMessage
{
	public GameServerLeaveMessage()
		: base(GameServerMessageID.LeaveGame)
	{
	}
}
public class GameServerPlayerUpdateMessage : GameServerMessage
{
	public enum PlayerAction : byte
	{
		None,
		StateUpdate,
		Joined,
		Left
	}

	public ulong SteamIDUser
	{
		get;
		private set;
	}

	public PlayerAction Action
	{
		get;
		private set;
	}

	public string AssemblyQualifiedName
	{
		get;
		private set;
	}

	public GameServerPlayerUpdateMessage()
		: base(GameServerMessageID.PlayerUpdate)
	{
	}

	public GameServerPlayerUpdateMessage(ulong steamIDUser, string assemblyQualifiedName, PlayerAction action = PlayerAction.StateUpdate)
		: base(GameServerMessageID.PlayerUpdate)
	{
		SteamIDUser = steamIDUser;
		Action = action;
		AssemblyQualifiedName = assemblyQualifiedName;
	}

	public GameServerPlayerUpdateMessage(ulong steamIDUser, PlayerAction action)
		: base(GameServerMessageID.PlayerUpdate)
	{
		SteamIDUser = steamIDUser;
		Action = action;
		AssemblyQualifiedName = string.Empty;
	}

	protected override void Pack(Amplitude.Unity.Messaging.BinaryWriter writer)
	{
		base.Pack(writer);
		writer.Write(SteamIDUser);
		writer.Write((byte)Action);
		writer.Write(AssemblyQualifiedName);
	}

	protected override void Unpack(Amplitude.Unity.Messaging.BinaryReader reader)
	{
		base.Unpack(reader);
		SteamIDUser = reader.ReadUInt64();
		Action = (PlayerAction)reader.ReadByte();
		AssemblyQualifiedName = reader.ReadString();
	}
}
public class GameServerPostOrderMessage : GameServerMessage
{
	public Amplitude.Unity.Game.Orders.Order Order
	{
		get;
		private set;
	}

	public GameServerPostOrderMessage()
		: base(GameServerMessageID.PostOrder)
	{
	}

	public GameServerPostOrderMessage(Amplitude.Unity.Game.Orders.Order order)
		: base(GameServerMessageID.PostOrder)
	{
		Order = order;
	}

	protected override void Pack(Amplitude.Unity.Messaging.BinaryWriter writer)
	{
		base.Pack(writer);
		if (Order != null)
		{
			string assemblyQualifiedName = Order.GetType().AssemblyQualifiedName;
			writer.Write(assemblyQualifiedName);
			if (!string.IsNullOrEmpty(assemblyQualifiedName))
			{
				Order.Pack(writer);
			}
		}
		else
		{
			writer.Write(string.Empty);
		}
	}

	protected override void Unpack(Amplitude.Unity.Messaging.BinaryReader reader)
	{
		//Discarded unreachable code: IL_005d
		base.Unpack(reader);
		string text = reader.ReadString();
		if (!string.IsNullOrEmpty(text))
		{
			try
			{
				Type type = Type.GetType(text);
				if (type != null)
				{
					Order = (FormatterServices.GetUninitializedObject(type) as Amplitude.Unity.Game.Orders.Order);
					if (Order != null)
					{
						Order.Unpack(reader);
					}
				}
			}
			catch
			{
				Order = null;
				throw;
			}
		}
	}
}
public class GameServerPostOrderResponseMessage : GameServerMessage
{
	public Amplitude.Unity.Game.Orders.Order Order
	{
		get;
		private set;
	}

	public PostOrderResponse Response
	{
		get;
		private set;
	}

	public GameServerPostOrderResponseMessage()
		: base(GameServerMessageID.PostOrderResponse)
	{
	}

	public GameServerPostOrderResponseMessage(Amplitude.Unity.Game.Orders.Order order, PostOrderResponse result)
		: base(GameServerMessageID.PostOrderResponse)
	{
		Order = order;
		Response = result;
	}

	protected override void Pack(Amplitude.Unity.Messaging.BinaryWriter writer)
	{
		base.Pack(writer);
		if (Order != null)
		{
			string assemblyQualifiedName = Order.GetType().AssemblyQualifiedName;
			writer.Write(assemblyQualifiedName);
			if (!string.IsNullOrEmpty(assemblyQualifiedName))
			{
				Order.Pack(writer);
			}
		}
		else
		{
			writer.Write(string.Empty);
		}
		writer.Write((int)Response);
	}

	protected override void Unpack(Amplitude.Unity.Messaging.BinaryReader reader)
	{
		//Discarded unreachable code: IL_005d
		base.Unpack(reader);
		string text = reader.ReadString();
		if (!string.IsNullOrEmpty(text))
		{
			try
			{
				Type type = Type.GetType(text);
				if (type != null)
				{
					Order = (FormatterServices.GetUninitializedObject(type) as Amplitude.Unity.Game.Orders.Order);
					if (Order != null)
					{
						Order.Unpack(reader);
					}
				}
			}
			catch
			{
				Order = null;
				throw;
			}
		}
		Response = (PostOrderResponse)reader.ReadInt32();
	}
}
public class GameServerPostStateChangeMessage : GameServerMessage
{
	public string AssemblyQualifiedName
	{
		get;
		private set;
	}

	public GameServerPostStateChangeMessage()
		: base(GameServerMessageID.PostStateChange)
	{
	}

	public GameServerPostStateChangeMessage(Type type)
		: base(GameServerMessageID.PostStateChange)
	{
		AssemblyQualifiedName = type.AssemblyQualifiedName;
	}

	protected override void Pack(Amplitude.Unity.Messaging.BinaryWriter writer)
	{
		base.Pack(writer);
		writer.Write(AssemblyQualifiedName);
	}

	protected override void Unpack(Amplitude.Unity.Messaging.BinaryReader reader)
	{
		base.Unpack(reader);
		AssemblyQualifiedName = reader.ReadString();
	}
}
public class GameServerState : GameState
{
	private static readonly List<string> TypeNames = new List<string>();

	protected GameServer GameServer
	{
		get;
		private set;
	}

	public GameServerState(GameServer gameServer)
	{
		Diagnostics.Assert(gameServer != null);
		GameServer = gameServer;
	}

	~GameServerState()
	{
		GameServer = null;
	}

	protected void RespondToDownloadGameRequests()
	{
		foreach (GameClientConnection value in GameServer.GameClientConnections.Values)
		{
			GameClientConnectionState gameClientConnectionState = value.GameClientConnectionState;
			if (gameClientConnectionState == GameClientConnectionState.AuthenticatedToServer && (value.GameClientConnectionFlags & GameClientConnectionFlags.DownloadGameRequestReceived) != 0 && (value.GameClientConnectionFlags & GameClientConnectionFlags.DownloadGameRequestResponded) == 0)
			{
				value.GameClientConnectionFlags |= GameClientConnectionFlags.DownloadGameRequestResponded;
				Message message = new GameServerDownloadGameResponseMessage(Dungeon.NextDungeonGenerationParams);
				GameServer.SendMessage(ref message, value.SteamIDRemote);
				Diagnostics.Log("[Net] Download Game Request from {0} has been responded to.", value.SteamIDRemote);
			}
		}
	}

	protected bool VerifyGameClientOrderProcessingSynchronization()
	{
		if (!GameServer.GameClientConnections.TryGetValue(GameServer.UserID, out GameClientConnection value))
		{
			Diagnostics.LogError("[Net][GameServer] Cannot retrieve host's connection.");
			return false;
		}
		foreach (GameClientConnection value2 in GameServer.GameClientConnections.Values)
		{
			switch (value2.GameClientConnectionState)
			{
			case GameClientConnectionState.AuthenticatedToServer:
				if (value2.LastAcknowledgedOrderSerial != value.LastAcknowledgedOrderSerial)
				{
					return false;
				}
				break;
			default:
				return false;
			case GameClientConnectionState.DisconnectedFromServer:
				break;
			}
		}
		return true;
	}

	protected bool VerifyGameClientStateSynchronization<T>() where T : GameClientState
	{
		string assemblyQualifiedName = typeof(T).AssemblyQualifiedName;
		List<ulong> list = new List<ulong>();
		ulong[] lobbyPlayerIDs = SingletonManager.Get<GameNetworkManager>().GetLobbyPlayerIDs();
		for (int i = 0; i < lobbyPlayerIDs.Length; i++)
		{
			list.Add(lobbyPlayerIDs[i]);
		}
		foreach (GameClientConnection value in GameServer.GameClientConnections.Values)
		{
			if (!list.Contains(value.SteamIDRemote))
			{
				Diagnostics.LogWarning("GameServerState.VerifyGameClientStateSynchronization: Ignoring {0} user because it's not in lobby", value.SteamIDRemote);
			}
			else
			{
				switch (value.GameClientConnectionState)
				{
				case GameClientConnectionState.AuthenticatedToServer:
					if (value.GameClientState != assemblyQualifiedName)
					{
						return false;
					}
					break;
				default:
					return false;
				case GameClientConnectionState.DisconnectedFromServer:
					break;
				}
			}
		}
		return true;
	}

	protected bool VerifyGameClientStateSynchronization(params Type[] types)
	{
		TypeNames.Clear();
		for (int i = 0; i < types.Length; i++)
		{
			TypeNames.Add(types[i].AssemblyQualifiedName);
		}
		foreach (GameClientConnection value in GameServer.GameClientConnections.Values)
		{
			switch (value.GameClientConnectionState)
			{
			case GameClientConnectionState.AuthenticatedToServer:
				if (!TypeNames.Contains(value.GameClientState))
				{
					return false;
				}
				break;
			default:
				return false;
			case GameClientConnectionState.DisconnectedFromServer:
				break;
			}
		}
		return true;
	}
}
public class GameServerState<T> : GameServerState where T : GameServerState<T>
{
	public GameServerState(GameServer gameServer)
		: base(gameServer)
	{
	}

	public override void Run()
	{
		base.Run();
	}
}
public class GameServerState_AllDungeonsCreated : GameServerState
{
	private Amplitude.Coroutine coroutine;

	public GameServerState_AllDungeonsCreated(GameServer gameServer)
		: base(gameServer)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Message message = new GameServerPostStateChangeMessage(typeof(GameClientState_AllDungeonsCreated));
		base.GameServer.SendMessageToClients(ref message);
		coroutine = Amplitude.Coroutine.StartCoroutine(RunAsync());
	}

	public override void Run()
	{
		base.Run();
		coroutine.Run();
		if (coroutine.IsFinished)
		{
			base.GameServer.PostStateChange(typeof(GameServerState_AllDungeonsPreFilled));
		}
	}

	private IEnumerator RunAsync()
	{
		while (!Player.AreAllPlayersDungeonPreFilled())
		{
			yield return null;
		}
	}

	public override void End(bool abort)
	{
		coroutine = null;
		base.End(abort);
	}
}
public class GameServerState_AllDungeonsFilled : GameServerState
{
	public GameServerState_AllDungeonsFilled(GameServer gameServer)
		: base(gameServer)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Message message = new GameServerPostStateChangeMessage(typeof(GameClientState_AllDungeonsFilled));
		base.GameServer.SendMessageToClients(ref message);
	}
}
public class GameServerState_AllDungeonsInstantiated : GameServerState
{
	private Amplitude.Coroutine coroutine;

	public GameServerState_AllDungeonsInstantiated(GameServer gameServer)
		: base(gameServer)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Message message = new GameServerPostStateChangeMessage(typeof(GameClientState_AllDungeonsInstantiated));
		base.GameServer.SendMessageToClients(ref message);
		coroutine = Amplitude.Coroutine.StartCoroutine(RunAsync());
	}

	public override void Run()
	{
		base.Run();
		coroutine.Run();
		if (coroutine.IsFinished)
		{
			base.GameServer.PostStateChange(typeof(GameServerState_AllDungeonsCreated));
		}
	}

	private IEnumerator RunAsync()
	{
		while (!Player.AreAllPlayersDungeonCreated())
		{
			yield return null;
		}
		Diagnostics.Log("All clients are GameClientState_DungeonCreated!");
	}

	public override void End(bool abort)
	{
		coroutine = null;
		base.End(abort);
	}
}
public class GameServerState_AllDungeonsPreFilled : GameServerState
{
	private Amplitude.Coroutine coroutine;

	public GameServerState_AllDungeonsPreFilled(GameServer gameServer)
		: base(gameServer)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Message message = new GameServerPostStateChangeMessage(typeof(GameClientState_AllDungeonsPreFilled));
		base.GameServer.SendMessageToClients(ref message);
		coroutine = Amplitude.Coroutine.StartCoroutine(RunAsync());
	}

	public override void Run()
	{
		base.Run();
		coroutine.Run();
		if (coroutine.IsFinished)
		{
			base.GameServer.PostStateChange(typeof(GameServerState_AllDungeonsFilled));
		}
	}

	private IEnumerator RunAsync()
	{
		while (!Player.AreAllPlayersDungeonFilled())
		{
			yield return null;
		}
	}

	public override void End(bool abort)
	{
		coroutine = null;
		base.End(abort);
	}
}
public class GameServerState_GameLaunchedAndReady : GameServerState
{
	private Amplitude.Coroutine coroutine;

	public GameServerState_GameLaunchedAndReady(GameServer gameServer)
		: base(gameServer)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		coroutine = Amplitude.Coroutine.StartCoroutine(RunAsync());
	}

	public override void End(bool abort)
	{
		coroutine = null;
		base.End(abort);
	}

	public override void Run()
	{
		base.Run();
		coroutine.Run();
		if (coroutine.IsFinished)
		{
			base.GameServer.PostStateChange(typeof(GameServerState_AllDungeonsInstantiated));
		}
	}

	private IEnumerator RunAsync()
	{
		Diagnostics.Assert(base.GameServer != null);
		Diagnostics.Assert(base.GameServer.Session != null);
		switch (base.GameServer.Session.SessionMode)
		{
		case SessionMode.Private:
		case SessionMode.Protected:
		case SessionMode.Public:
			yield return SynchronizeOnClientConnections();
			break;
		case SessionMode.Single:
			while (base.GameServer.GameClientConnections.Count < 1)
			{
				yield return null;
			}
			break;
		}
		while (!VerifyGameClientStateSynchronization<GameClientState_GameLaunchedAndReady>())
		{
			RespondToDownloadGameRequests();
			yield return null;
		}
		Diagnostics.Log("All clients are GameClientState_GameLaunchedAndReady!");
	}

	private IEnumerator SynchronizeOnClientConnections()
	{
		while (base.GameServer.GameClientConnections.Count < base.GameServer.Session.GetActiveLobbyMembers().Length)
		{
			yield return null;
		}
	}
}
public class GameServerState_InitializeServer : GameServerState
{
	private IServerService serversService;

	private Steamworks.SteamGameServer steamGameServer;

	private bool connected;

	private bool bond;

	public GameServerState_InitializeServer(GameServer gameServer)
		: base(gameServer)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		connected = false;
		if (base.GameServer.Session.SessionMode == SessionMode.Single)
		{
			base.GameServer.OnSteamGameServerCreated();
			base.GameServer.PostStateChange(typeof(GameServerState_LaunchGame));
			connected = true;
		}
		else
		{
			InitializeServer();
		}
	}

	public override void End(bool abort)
	{
		base.End(abort);
		if (bond)
		{
			if (serversService != null)
			{
				serversService.ServerSteamServersConnected -= ISteamServerService_SteamServersConnected;
				serversService.ServerSteamServerConnectFailure -= ISteamServerService_SteamServerConnectFailure;
				serversService.ServerSteamServersDisconnected -= ISteamServerService_SteamServersDisconnected;
			}
			bond = false;
		}
	}

	public override void Run()
	{
		base.Run();
		if (connected)
		{
			Diagnostics.Log("----- READY TO LAUNCH -----");
			base.GameServer.PostStateChange(typeof(GameServerState_LaunchGame));
		}
	}

	private void InitializeServer()
	{
		if (Steamworks.SteamAPI.SteamGameServer != null)
		{
			base.GameServer.Disconnect();
		}
		Steamworks.SteamGameServer.Shutdown();
		serversService = Services.GetService<IServerService>();
		if (serversService != null)
		{
			serversService.ServerSteamServersConnected += ISteamServerService_SteamServersConnected;
			serversService.ServerSteamServerConnectFailure += ISteamServerService_SteamServerConnectFailure;
			serversService.ServerSteamServersDisconnected += ISteamServerService_SteamServersDisconnected;
		}
		bond = true;
		Steamworks.EServerMode eServerMode = Steamworks.EServerMode.eServerModeAuthenticationAndSecure;
		if (!Steamworks.SteamGameServer.Init(0u, Runtime.SteamPort, Runtime.GamePort, Runtime.QueryPort, eServerMode, Runtime.Version))
		{
			Diagnostics.LogError("SteamGameServer Initialization Failed.");
			Steamworks.SteamGameServer.Shutdown();
			SingletonManager.Get<RequesterPanel>().Display(AgeLocalizer.Instance.LocalizeString("%GameServerInitFailMessage"));
			Services.GetService<IGameControlService>().GoBackToMainMenu();
		}
		else
		{
			steamGameServer = Steamworks.SteamAPI.SteamGameServer;
			Diagnostics.Assert(steamGameServer != null);
			Diagnostics.Log("SteamGameServer Initialized.");
			steamGameServer.SetProduct(Amplitude.Unity.Framework.Application.Name);
			steamGameServer.SetModDir(Runtime.ModDir);
			steamGameServer.EnableHeartbeats(base.GameServer.IsPublic);
			steamGameServer.LogOnAnonymous();
		}
	}

	private void ISteamServerService_SteamServersConnected(object sender, SteamServersConnectedEventArgs e)
	{
		Diagnostics.Assert(steamGameServer.SteamID.IsValid);
		Diagnostics.Log("----- Serveur Connected -----");
		ISteamMatchMakingService service = Services.GetService<ISteamMatchMakingService>();
		service.SteamMatchMaking.SetLobbyGameServer(base.GameServer.Session.SteamIDLobby, 0u, 0, steamGameServer.SteamID);
		base.GameServer.OnSteamGameServerCreated();
		connected = true;
	}

	private void ISteamServerService_SteamServerConnectFailure(object sender, SteamServerConnectFailureEventArgs e)
	{
		object[] array = new object[1];
		Steamworks.SteamServerConnectFailure message = e.Message;
		array[0] = message.m_eResult;
		Diagnostics.LogError("----- Server Connect Failure {0} -----", array);
		Session session = base.GameServer.Session;
		Steamworks.SteamServerConnectFailure message2 = e.Message;
		session.OnError(SessionBase.ErrorLevel.Error, "%GameServerSteamServerConnectFailure", (int)message2.m_eResult);
	}

	private void ISteamServerService_SteamServersDisconnected(object sender, SteamServersDisconnectedEventArgs e)
	{
		object[] array = new object[1];
		Steamworks.SteamServersDisconnected message = e.Message;
		array[0] = message.m_eResult;
		Diagnostics.LogWarning("----- Server Disconnected {0} -----", array);
	}
}
public class GameServerState_LaunchGame : GameServerState
{
	private IGameService gameService;

	public GameServerState_LaunchGame(GameServer gameServer)
		: base(gameServer)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		base.GameServer.PostStateChange(typeof(GameServerState_GameLaunchedAndReady));
	}

	public override void End(bool abort)
	{
		base.End(abort);
	}

	private void GameService_CreateGameComplete(object sender, CreateGameCompleteEventArgs e)
	{
		IRuntimeService service;
		if (e.Cancelled)
		{
			service = Services.GetService<IRuntimeService>();
			if (service != null && service.Runtime != null)
			{
				service.Runtime.FiniteStateMachine.PostStateChange(typeof(RuntimeState_OutGame));
			}
		}
		else if (e.Exception != null)
		{
			service = Services.GetService<IRuntimeService>();
			if (service != null && service.Runtime != null)
			{
				service.Runtime.FiniteStateMachine.PostStateChange(typeof(RuntimeState_OutGame));
			}
			throw e.Exception;
		}
		if (e.Game != null)
		{
			base.GameServer.PostStateChange(typeof(GameServerState_GameLaunchedAndReady));
			return;
		}
		service = Services.GetService<IRuntimeService>();
		if (service != null && service.Runtime != null)
		{
			service.Runtime.FiniteStateMachine.PostStateChange(typeof(RuntimeState_OutGame));
		}
		throw new NotImplementedException("The game creation process has failed unexpectedly.");
	}

	private void GameService_CreateGameProgressChange(object sender, CreateGameProgressChangeEventArgs e)
	{
	}
}
public class GameServerState_RestartGame : GameServerState
{
	public GameServerState_RestartGame(GameServer gameServer)
		: base(gameServer)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Message message = new GameServerPostStateChangeMessage(typeof(GameClientState_RestartGame));
		base.GameServer.SendMessageToClients(ref message);
		base.GameServer.PostStateChange(typeof(GameServerState_LaunchGame));
	}
}
public interface IGameServer : IDisposable, IGameInterface
{
	void SendMessageToClients(ref Message message);
}
public interface IGameServerLauncher
{
	IGameServer GameServer
	{
		get;
	}

	void Launch();
}
public class Session : Amplitude.Unity.Session.Session, IGameClientLauncher, IGameServerLauncher
{
	public class LobbyReadyState
	{
		public bool IsReady
		{
			get;
			private set;
		}

		public double LaunchTime
		{
			get;
			private set;
		}

		public LobbyReadyState()
		{
			IsReady = false;
			LaunchTime = -1.0;
		}

		public LobbyReadyState(bool isReady, double launchTime = -1.0)
		{
			IsReady = isReady;
			LaunchTime = launchTime;
		}

		public static LobbyReadyState Parse(string lobbyData)
		{
			if (string.IsNullOrEmpty(lobbyData))
			{
				return new LobbyReadyState();
			}
			string[] array = lobbyData.Split(Amplitude.String.Separators);
			if (array.Length != 2)
			{
				throw new ArgumentException();
			}
			if (!bool.TryParse(array[0], out bool result) || !double.TryParse(array[1], out double result2))
			{
				throw new ArgumentException();
			}
			return new LobbyReadyState(result, result2);
		}

		public override string ToString()
		{
			return $"{IsReady};{LaunchTime}";
		}
	}

	public delegate void PlayerLeftHandler(Steamworks.SteamID playerID);

	private const string MEMBERDATA_P2P_PING = "P2PPing";

	private const double LOBBY_P2P_PING_PERIOD = 3.0;

	private const double INGAME_P2P_PING_PERIOD = 5.0;

	private const double LOBBY_P2P_PING_TIMEOUT = 20.0;

	private const double INGAME_P2P_PING_TIMEOUT = 30.0;

	public static readonly string LOBBYDATA_APPLICATION_CHECKSUM = "AppChecksum";

	public static readonly string LOBBYDATA_GAME_NAME = "GameName";

	public static readonly string LOBBYDATA_SAVE_KEY = "SaveKey";

	public static readonly string LOBBYDATA_IS_LOBBY_READY = "IsLobbyReady";

	public static readonly string LOBBYDATA_IS_GAME_LAUNCHING = "IsGameLaunching";

	public static readonly string LOBBYDATA_GAME_DIFFICULTY = "GameDifficulty";

	public static readonly string LOBBYDATA_LOBBY_TYPE = "LobbyType";

	public static readonly string LOBBYDATA_GAME_SHIP = "GameShip";

	public static readonly string LOBBYDATA_PLAYER_IDS = "PlayerIDs";

	public static readonly char LOBBYDATA_PLAYER_IDS_SEPARATOR = ',';

	public static readonly string LOBBYDATA_HERO_BY_PLAYER_ID = "#{0}PlayerHero";

	public static readonly string MEMBERDATA_HERO = "Hero";

	public static readonly string MEMBERDATA_IS_READY = "IsReady";

	private static ITimeSynchronizationService timeSynchronizationService;

	private double lastP2PPingTime;

	private bool localPlayerReady;

	public static double Time => (double)DateTime.Now.Ticks / 10000000.0;

	public IGameClient GameClient
	{
		get;
		private set;
	}

	public IGameServer GameServer
	{
		get;
		private set;
	}

	public IDumpable GameClientDumper => GameClient as IDumpable;

	public bool LocalPlayerReady
	{
		get
		{
			return localPlayerReady;
		}
		set
		{
			localPlayerReady = value;
		}
	}

	public bool ReturnToLobby
	{
		get;
		set;
	}

	private FiniteStateMachine FiniteStateMachine
	{
		get;
		set;
	}

	public FiniteState CurrentState
	{
		get
		{
			if (FiniteStateMachine != null)
			{
				return FiniteStateMachine.CurrentState;
			}
			return null;
		}
	}

	public event PlayerLeftHandler OnPlayerLeft;

	public Session()
	{
		timeSynchronizationService = Services.GetService<ITimeSynchronizationService>();
		if (timeSynchronizationService == null)
		{
			throw new NullReferenceException("ITimeSynchronizationService");
		}
		FiniteStateMachine = new FiniteStateMachine();
		FiniteStateMachine.RegisterInitialState(new SessionState_Opening(this));
		FiniteStateMachine.RegisterState(new SessionState_Opened(this));
		FiniteStateMachine.RegisterState(new SessionState_OpenedAndReady(this));
		FiniteStateMachine.RegisterState(new SessionState_OpenedAndCounting(this));
		FiniteStateMachine.RegisterState(new SessionState_OpenedAndLaunching(this));
		FiniteStateMachine.RegisterState(new SessionState_OpenedAndLaunched(this));
		FiniteStateMachine.RegisterState(new SessionState_ClientConnecting(this));
		FiniteStateMachine.RegisterState(new SessionState_ClientConnected(this));
		FiniteStateMachine.RegisterState(new SessionState_ClientDisconnected(this));
		FiniteStateMachine.RegisterState(new SessionState_Synchronizing(this));
		if (FiniteStateMachine.InitialStateType != null)
		{
			FiniteStateMachine.PostStateChange(FiniteStateMachine.InitialStateType);
		}
	}

	void IGameClientLauncher.Launch()
	{
		if (GameClient != null)
		{
			throw new InvalidOperationException("Cannot launch a game client while another is already running.");
		}
		Diagnostics.Log("Launching the game client...");
		GameClient = new GameClient(this);
	}

	void IGameServerLauncher.Launch()
	{
		if (!base.IsHosting)
		{
			throw new InvalidOperationException("The session cannot launch a game server when it is not hosting the game lobby.");
		}
		if (GameServer != null)
		{
			throw new InvalidOperationException("Cannot launch a game server while another is already running.");
		}
		Diagnostics.Log("Launching the game server...");
		GameServer = new GameServer(this);
	}

	public void PostStateChange(Type type, params object[] parameters)
	{
		FiniteStateMachine.PostStateChange(type, parameters);
	}

	protected override bool IsReadyToP2PPing()
	{
		return base.IsReadyToP2PPing() && !(CurrentState is SessionState_Opening) && !(CurrentState is SessionState_Synchronizing);
	}

	public override void Update()
	{
		base.Update();
		FiniteStateMachine.Update();
		if (ReturnToLobby)
		{
			if (GameServer != null)
			{
				GameServer.Dispose();
				GameServer = null;
			}
			if (GameClient != null)
			{
				GameClient.Dispose();
				GameClient = null;
			}
			PostStateChange(typeof(SessionState_Opened));
			base.ServerId = ulong.MaxValue;
			LocalPlayerReady = false;
			ReturnToLobby = false;
			return;
		}
		if (GameServer != null)
		{
			(GameServer as GameServer).Update();
		}
		if (GameClient != null)
		{
			(GameClient as GameClient).Update();
		}
		if (GameServer != null)
		{
			GameServer gameServer = GameServer as GameServer;
			for (int i = 0; i < 10000; i++)
			{
				if (!gameServer.HasPendingOrder)
				{
					break;
				}
				gameServer.Update();
				if (GameClient != null)
				{
					(GameClient as GameClient).UpdateMessageBoxAndProcessOrders();
				}
			}
		}
		if (!IsReadyToP2PPing())
		{
			return;
		}
		bool flag = GameClient != null && GameClient.CurrentState != null && GameClient.CurrentState is GameClientState_AllDungeonsFilled;
		double time = timeSynchronizationService.Time;
		double num = (!flag) ? 3.0 : 5.0;
		double num2 = (!flag) ? 20.0 : 30.0;
		if (!(time > lastP2PPingTime + num))
		{
			return;
		}
		SetLobbyMemberData("P2PPing", time.ToString());
		lastP2PPingTime = time;
		ulong[] activeLobbyMembers = GetActiveLobbyMembers();
		int num3 = 0;
		while (true)
		{
			if (num3 >= activeLobbyMembers.Length)
			{
				return;
			}
			ulong num4 = activeLobbyMembers[num3];
			if (num4 != base.UserID && (base.IsHosting || num4 == GetOwnerId()) && !timedOutPlayerIDs.Contains(num4))
			{
				double lobbyMemberData = GetLobbyMemberData(num4, "P2PPing", -1.0);
				if (!(lobbyMemberData < 0.0) && time - lobbyMemberData > num2)
				{
					Diagnostics.LogWarning("Ping timeout with #{0} player! (lastPeerPing={1}, t={2})", num4, lobbyMemberData, time);
					if (!base.IsHosting && num4 == base.ServerId)
					{
						break;
					}
					if (base.IsHosting)
					{
						RemoveUserFromLobby((uint)GetMaxNumberOfPlayers(0), num4.ToString(), GetPlayerName(num4));
					}
					networkService.CloseP2PSessionWithUser(num4, base.IsHosting);
					timedOutPlayerIDs.Add(num4);
				}
			}
			num3++;
		}
		OnError(ErrorLevel.Error, "%SessionP2PSessionConnectFail", 0, forceMainMenuReturn: true);
		Close();
	}

	public override int AddPlayerToLobby(uint lobbyDataMaximumNumberOfPlayers, ulong playerID, string userName, out bool alreadyInLobby)
	{
		int result = base.AddPlayerToLobby(lobbyDataMaximumNumberOfPlayers, playerID, userName, out alreadyInLobby);
		if (timedOutPlayerIDs.Contains(playerID))
		{
			Diagnostics.Log("AddPlayerToLobby playerID={0} > remove from timedout list", playerID);
			timedOutPlayerIDs.Remove(playerID);
		}
		return result;
	}

	protected override void Dispose(bool disposing)
	{
		FiniteStateMachine.Abort();
		if (GameServer != null)
		{
			GameServer.Dispose();
			GameServer = null;
		}
		if (GameClient != null)
		{
			GameClient.Dispose();
			GameClient = null;
		}
		base.Dispose(disposing);
	}

	protected override void OnLobbyChatUpdate(LobbyChatUpdateEventArgs e)
	{
		base.OnLobbyChatUpdate(e);
		if (!(base.SteamIDLobby == e.SteamIDLobby))
		{
			return;
		}
		string text = string.Empty;
		if ((e.ChatMemberStateChange & LobbyChatUpdateStateChange.Entered) == LobbyChatUpdateStateChange.Entered)
		{
			text = "Entered";
			IAudioEventService service = Services.GetService<IAudioEventService>();
			service.Play2DEvent("Master/GUI/Lobby/EnterLobby");
		}
		else if ((e.ChatMemberStateChange & LobbyChatUpdateStateChange.Left) == LobbyChatUpdateStateChange.Left)
		{
			text = "Left";
			IAudioEventService service2 = Services.GetService<IAudioEventService>();
			service2.Play2DEvent("Master/GUI/Lobby/QuitLobby");
			if (this.OnPlayerLeft != null)
			{
				this.OnPlayerLeft(e.SteamIDUserChanged);
			}
		}
		else if ((e.ChatMemberStateChange & LobbyChatUpdateStateChange.Disconnected) == LobbyChatUpdateStateChange.Disconnected)
		{
			text = "Disconnected";
			IAudioEventService service3 = Services.GetService<IAudioEventService>();
			service3.Play2DEvent("Master/GUI/Lobby/QuitLobby");
		}
		else if ((e.ChatMemberStateChange & LobbyChatUpdateStateChange.Kicked) == LobbyChatUpdateStateChange.Kicked)
		{
			text = "Kicked";
			IAudioEventService service4 = Services.GetService<IAudioEventService>();
			service4.Play2DEvent("Master/GUI/Lobby/QuitLobby");
		}
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		ILocalizationService service5 = Services.GetService<ILocalizationService>();
		if (service5 != null)
		{
			string text2 = $"%LobbyChat{text}";
			if ((ulong)e.SteamIDUserChanged == base.UserID)
			{
				text2 += "+";
			}
			string playerName = GetPlayerName(e.SteamIDUserChanged);
			string text3 = service5.Localize(text2).ToString().Replace("$Player", playerName);
			if (!string.IsNullOrEmpty(text3))
			{
				SingletonManager.Get<ChatManager>().WriteLocalMessage(text3);
			}
		}
	}

	protected override void OnLobbyOwnerChange(LobbyOwnerChangeEventArgs e)
	{
		base.OnLobbyOwnerChange(e);
		ILocalizationService service = Services.GetService<ILocalizationService>();
		if (service != null)
		{
			SendLocalChatMessage("s:/" + service.Localize("%LobbyOwnerChange+"));
		}
		SetLobbyData(LOBBYDATA_IS_LOBBY_READY, new LobbyReadyState(isReady: false, 0.0).ToString());
		SetLobbyData(LOBBYDATA_IS_GAME_LAUNCHING, false);
	}

	protected override void OnSessionChange(SessionChangeEventArgs e)
	{
		base.OnSessionChange(e);
		SessionChangeAction action = e.Action;
		if (action == SessionChangeAction.Opened)
		{
			FiniteStateMachine.PostStateChange(typeof(SessionState_Opened));
		}
	}

	protected override void SteamMatchMakingService_SteamLobbyDataUpdate(object sender, SteamLobbyDataUpdateEventArgs e)
	{
		bool hosting = base.hosting;
		base.SteamMatchMakingService_SteamLobbyDataUpdate(sender, e);
		if (!hosting && base.hosting)
		{
			string lobbyDataString = GetLobbyDataString(LOBBYDATA_SAVE_KEY);
			Diagnostics.LogWarning("Host migration: saveKey={0}", lobbyDataString);
			if (!string.IsNullOrEmpty(lobbyDataString))
			{
				SingletonManager.Get<RequesterPanel>().Display("%SavedMPGameHostLeftMessage");
				SingletonManager.Get<GameSelectionPanel>().QuitLobby();
				return;
			}
			Steamworks.SteamID steamID = new Steamworks.SteamID(base.UserID);
			string friendPersonaName = Steamworks.SteamAPI.SteamFriends.GetFriendPersonaName(steamID);
			string data = friendPersonaName;
			SetLobbyData(LOBBYDATA_GAME_NAME, data);
			SetLobbyMemberData(MEMBERDATA_IS_READY, false);
		}
	}

	public override void OnError(ErrorLevel errorLevel, string message, int errorCode = 0, bool forceMainMenuReturn = false)
	{
		base.OnError(errorLevel, message, errorCode, forceMainMenuReturn);
		message = AgeLocalizer.Instance.LocalizeString(message);
		Dungeon dungeon = SingletonManager.Get<Dungeon>(mandatory: false);
		if (dungeon != null && dungeon.IsDisplayed && !forceMainMenuReturn)
		{
			message = message + Environment.NewLine + AgeLocalizer.Instance.LocalizeString("%NetworkError_BackToMainMenuConfirm");
			SingletonManager.Get<RequesterPanel>().Display(message, delegate(RequesterPanel.Result result)
			{
				if (result == RequesterPanel.Result.Yes)
				{
					Services.GetService<IGameControlService>().GoBackToMainMenu();
				}
			}, RequesterPanel.ButtonsMode.YesNo, "%NetworkErrorTitle");
		}
		else
		{
			Services.GetService<IGameControlService>().GoBackToMainMenu();
			SingletonManager.Get<RequesterPanel>().Display(message, null, RequesterPanel.ButtonsMode.OK, "%NetworkErrorTitle");
		}
	}
}
public class SessionManager : Amplitude.Unity.Session.SessionManager
{
	public abstract class Preferences
	{
		private static float orderLagInSecond;

		public static float OrderExecutionLagInSecond => orderLagInSecond;

		static Preferences()
		{
			orderLagInSecond = 0.2f;
		}
	}

	public SessionManager()
	{
		base.SessionClass = typeof(Session);
	}
}
public class SessionState : FiniteState
{
	protected Session Session
	{
		get;
		private set;
	}

	public SessionState(Session session)
	{
		Diagnostics.Assert(session != null);
		Session = session;
		Session.SessionChange += Session_SessionChange;
	}

	~SessionState()
	{
		Session = null;
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Diagnostics.Log("[SessionState] " + GetType() + " Begin");
	}

	protected virtual void Session_SessionChange(object sender, SessionChangeEventArgs e)
	{
		SessionChangeAction action = e.Action;
		if (action == SessionChangeAction.Releasing)
		{
			Diagnostics.Assert(e.Session == Session);
			Session.SessionChange -= Session_SessionChange;
		}
	}
}
public class SessionState_ClientConnected : SessionState
{
	public SessionState_ClientConnected(Session session)
		: base(session)
	{
	}
}
public class SessionState_ClientConnecting : SessionState
{
	public SessionState_ClientConnecting(Session session)
		: base(session)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Diagnostics.Log("Connecting...");
	}
}
public class SessionState_ClientDisconnected : SessionState
{
	public SessionState_ClientDisconnected(Session session)
		: base(session)
	{
	}
}
public class SessionState_Opened : SessionState
{
	public static bool ThisIsAHackButIAmReady;

	private ITimeSynchronizationService timeSyncService;

	public SessionState_Opened(Session session)
		: base(session)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		base.Session.SetLobbyMemberData(Session.MEMBERDATA_IS_READY, false);
		timeSyncService = Services.GetService<ITimeSynchronizationService>();
		if (base.Session.SessionMode != 0 && base.Session.IsHosting)
		{
			GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
			base.Session.OpenLobby(gameNetworkManager.GetMultiplayerMaxPlayerCount());
		}
	}

	public override void Run()
	{
		if (base.Session.SessionMode != 0 && !base.Session.IsHosting && timeSyncService != null && !timeSyncService.PartiallySynchronized)
		{
			base.Session.PostStateChange(typeof(SessionState_Synchronizing));
			return;
		}
		Session.LobbyReadyState lobbyReadyState = Session.LobbyReadyState.Parse(base.Session.GetLobbyDataString(Session.LOBBYDATA_IS_LOBBY_READY));
		if (lobbyReadyState.IsReady && base.Session.ServerId != ulong.MaxValue)
		{
			base.Session.PostStateChange(typeof(SessionState_OpenedAndCounting));
		}
		else if (base.Session.LocalPlayerReady)
		{
			base.Session.PostStateChange(typeof(SessionState_OpenedAndReady));
		}
	}
}
public class SessionState_OpenedAndCounting : SessionState
{
	private Amplitude.Coroutine countdownCoroutine;

	private Session.LobbyReadyState lobbyReadyState;

	private bool notify;

	public SessionState_OpenedAndCounting(Session session)
		: base(session)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		lobbyReadyState = Session.LobbyReadyState.Parse(base.Session.GetLobbyDataString(Session.LOBBYDATA_IS_LOBBY_READY));
		notify = false;
		countdownCoroutine = Amplitude.Coroutine.StartCoroutine(Countdown());
		base.Session.LobbyDataChange += Session_LobbyDataChange;
		if (base.Session.GetLobbyDataBool(Session.LOBBYDATA_IS_GAME_LAUNCHING))
		{
			base.Session.PostStateChange(typeof(SessionState_OpenedAndLaunching));
		}
	}

	public override void End(bool abort)
	{
		base.End(abort);
		base.Session.LobbyDataChange -= Session_LobbyDataChange;
	}

	public override void Run()
	{
		switch (base.Session.SessionMode)
		{
		case SessionMode.Single:
			base.Session.PostStateChange(typeof(SessionState_OpenedAndLaunching));
			break;
		case SessionMode.Private:
		case SessionMode.Protected:
		case SessionMode.Public:
			if (base.Session.IsHosting && lobbyReadyState.IsReady && Session.Time > lobbyReadyState.LaunchTime && !notify)
			{
				base.Session.SetLobbyData(Session.LOBBYDATA_IS_GAME_LAUNCHING, true);
				notify = true;
			}
			if (!countdownCoroutine.IsFinished)
			{
				countdownCoroutine.Run();
			}
			break;
		default:
			throw new ArgumentOutOfRangeException();
		}
	}

	private IEnumerator Countdown()
	{
		double remainingSeconds = lobbyReadyState.LaunchTime - Session.Time;
		double threshold = GenericUtilities.RoundHalfAwayFromZeroToInt((float)remainingSeconds);
		ILocalizationService localizationService = Services.GetService<ILocalizationService>();
		while (remainingSeconds > 0.0)
		{
			remainingSeconds = lobbyReadyState.LaunchTime - Session.Time;
			if (threshold >= remainingSeconds)
			{
				string message = localizationService.Localize("%LobbyCountdownUpdate").ToString().Replace("$Seconds", GenericUtilities.RoundHalfAwayFromZeroToInt((float)remainingSeconds).ToString());
				base.Session.SendLocalChatMessage($"s:/{message}");
				threshold = GenericUtilities.RoundHalfAwayFromZeroToInt((float)remainingSeconds - 1f);
			}
			yield return null;
		}
	}

	private void Session_LobbyDataChange(object sender, LobbyDataChangeEventArgs e)
	{
		if (e.Key == Session.LOBBYDATA_IS_GAME_LAUNCHING && ((!(e.Data is bool)) ? Convert.ToBoolean(e.Data as string) : ((bool)e.Data)))
		{
			base.Session.PostStateChange(typeof(SessionState_OpenedAndLaunching));
		}
	}
}
public class SessionState_OpenedAndLaunched : SessionState
{
	public SessionState_OpenedAndLaunched(Session session)
		: base(session)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
	}
}
public class SessionState_OpenedAndLaunching : SessionState
{
	private Amplitude.Coroutine coroutine;

	public SessionState_OpenedAndLaunching(Session session)
		: base(session)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		coroutine = Amplitude.Coroutine.StartCoroutine(Launch());
	}

	public override void Run()
	{
		base.Run();
		coroutine.Run();
		if (coroutine.IsFinished)
		{
			base.Session.PostStateChange(typeof(SessionState_OpenedAndLaunched));
		}
	}

	private IEnumerator Launch()
	{
		if (base.Session.IsHosting)
		{
			((IGameServerLauncher)base.Session).Launch();
		}
		((IGameClientLauncher)base.Session).Launch();
		yield return null;
	}
}
public class SessionState_OpenedAndReady : SessionState
{
	private ITimeSynchronizationService timeSyncService;

	public SessionState_OpenedAndReady(Session session)
		: base(session)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		timeSyncService = Services.GetService<ITimeSynchronizationService>();
		if (timeSyncService != null)
		{
			Diagnostics.Assert(timeSyncService.PartiallySynchronized);
		}
		base.Session.LobbyMemberDataChange += Session_LobbyMemberDataChange;
		base.Session.LobbyDataChange += Session_LobbyDataChange;
		base.Session.SetLobbyMemberData(Session.MEMBERDATA_IS_READY, true);
	}

	public override void End(bool abort)
	{
		base.End(abort);
		base.Session.LobbyMemberDataChange -= Session_LobbyMemberDataChange;
		base.Session.LobbyDataChange -= Session_LobbyDataChange;
	}

	public override void Run()
	{
		switch (base.Session.SessionMode)
		{
		case SessionMode.Single:
			base.Session.PostStateChange(typeof(SessionState_OpenedAndCounting));
			break;
		case SessionMode.Private:
		case SessionMode.Protected:
		case SessionMode.Public:
			if (!base.Session.LocalPlayerReady)
			{
				Session.LobbyReadyState lobbyReadyState = Session.LobbyReadyState.Parse(base.Session.GetLobbyDataString(Session.LOBBYDATA_IS_LOBBY_READY));
				if (!lobbyReadyState.IsReady)
				{
					base.Session.PostStateChange(typeof(SessionState_Opened));
				}
			}
			break;
		default:
			throw new ArgumentOutOfRangeException();
		}
	}

	private void Session_LobbyDataChange(object sender, LobbyDataChangeEventArgs e)
	{
		if (e.Key == Session.LOBBYDATA_IS_LOBBY_READY)
		{
			Session.LobbyReadyState lobbyReadyState = (e.Data as Session.LobbyReadyState) ?? Session.LobbyReadyState.Parse(e.Data as string);
			if (lobbyReadyState.IsReady)
			{
				base.Session.PostStateChange(typeof(SessionState_OpenedAndCounting));
			}
		}
	}

	private void Session_LobbyMemberDataChange(object sender, LobbyMemberDataChangeEventArgs e)
	{
		if (base.Session.IsHosting)
		{
			GameSelectionPanel gameSelectionPanel = SingletonManager.Get<GameSelectionPanel>();
			bool[] lobbyMemberDataOfEveryone = base.Session.GetLobbyMemberDataOfEveryone(Session.MEMBERDATA_IS_READY, defaultValue: false);
			if (lobbyMemberDataOfEveryone.Length >= gameSelectionPanel.MPMinPlayerCount && lobbyMemberDataOfEveryone.All((bool b) => b))
			{
				base.Session.CloseLobby(lobbyMemberDataOfEveryone.Length);
				base.Session.SetLobbyData(Session.LOBBYDATA_IS_LOBBY_READY, new Session.LobbyReadyState(isReady: true, Session.Time).ToString());
			}
		}
	}
}
public class SessionState_Opening : SessionState
{
	public SessionState_Opening(Session session)
		: base(session)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		Diagnostics.Log("The session is being opened...");
	}
}
public class SessionState_Synchronizing : SessionState
{
	private ITimeSynchronizationService timeSyncService;

	public SessionState_Synchronizing(Session session)
		: base(session)
	{
	}

	public override void Begin(params object[] parameters)
	{
		base.Begin(parameters);
		timeSyncService = Services.GetService<ITimeSynchronizationService>();
		Diagnostics.Assert(timeSyncService != null);
		base.Session.SendLocalChatMessage("s:/Synchronizing...");
	}

	public override void End(bool abort)
	{
		base.End(abort);
		base.Session.SendLocalChatMessage("s:/Synchronized.");
	}

	public override void Run()
	{
		if (timeSyncService.PartiallySynchronized)
		{
			base.Session.PostStateChange(typeof(SessionState_Opened));
		}
	}
}
public class AIConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlArray("AITargetInteractionConfigs")]
	[XmlArrayItem(Type = typeof(AITargetInteractionConfig), ElementName = "AITargetInteractionConfig")]
	public AITargetInteractionConfig[] AITargetInteractionConfigs
	{
		get;
		set;
	}
}
public class AITargetInteractionConfig
{
	private StaticString cachedTargetKey;

	[XmlAttribute("TargetType")]
	public string XmlSerializableTargetType
	{
		get
		{
			return TargetType.ToString();
		}
		set
		{
			TargetType = value.ToEnum<AITargetType>();
		}
	}

	[XmlIgnore]
	public AITargetType TargetType
	{
		get;
		private set;
	}

	[XmlAttribute("Interaction")]
	public AIInteraction Interaction
	{
		get;
		private set;
	}

	[XmlAttribute("Weight")]
	public float Weight
	{
		get;
		private set;
	}

	[XmlAttribute("OverrideStayInRoom")]
	public int OverrideStayInRoom
	{
		get;
		private set;
	}

	[XmlAttribute("IgnoreSameRoomPriority")]
	public bool IgnoreSameRoomPriority
	{
		get;
		private set;
	}

	[XmlAttribute("IgnoreSameRoomPriority2")]
	public bool DontFavorSameRoom
	{
		get;
		private set;
	}

	[XmlAttribute("IgnoreFreeTargetPriority")]
	public bool IgnoreFreeTargetPriority
	{
		get;
		private set;
	}

	[XmlAttribute("SameRoomOnly")]
	public bool SameRoomOnly
	{
		get;
		private set;
	}

	[XmlAttribute("DifferentRoomOnly")]
	public bool DifferentRoomOnly
	{
		get;
		private set;
	}

	[XmlAttribute("Heuristic")]
	public AIHeuristic Heuristic
	{
		get;
		private set;
	}

	[XmlAttribute("MostPopulatedRoomSelectionRange")]
	public float MostPopulatedRoomSelectionRange
	{
		get;
		private set;
	}

	[XmlAttribute("ForbidAttack")]
	public bool ForbidAttack
	{
		get;
		private set;
	}

	[XmlAttribute("LocalEntityOnly")]
	public bool LocalEntityOnly
	{
		get;
		private set;
	}

	public AITargetInteractionConfig()
	{
		OverrideStayInRoom = -1;
		Heuristic = AIHeuristic.Closest;
	}

	public StaticString GetTargetKey()
	{
		if (cachedTargetKey == null)
		{
			cachedTargetKey = AITarget.GetTargetKey(TargetType, Interaction);
		}
		return cachedTargetKey;
	}
}
public class AttackTypeConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("UseProjectile")]
	public bool UseProjectile
	{
		get;
		private set;
	}

	[XmlAttribute("ProjectileSpeed")]
	public float ProjectileSpeed
	{
		get;
		private set;
	}

	[XmlAttribute("SFXPath")]
	public string SFXPath
	{
		get;
		private set;
	}

	[XmlAttribute("AttackLoopSFXPath")]
	public string AttackLoopSFXPath
	{
		get;
		private set;
	}

	[XmlAttribute("SelfDestruct")]
	public bool SelfDestruct
	{
		get;
		private set;
	}

	[XmlAttribute("InflictTrouble")]
	public bool InflictTrouble
	{
		get;
		private set;
	}

	[XmlAttribute("InflictPoison")]
	public bool InflictPoison
	{
		get;
		private set;
	}

	[XmlAttribute("ImpactFollowTarget")]
	public bool ImpactFollowTarget
	{
		get;
		private set;
	}

	[XmlAttribute("BurnVFXPath")]
	public string BurnVFXPath
	{
		get;
		private set;
	}

	[XmlAttribute("BurnSFXPath")]
	public string BurnSFXPath
	{
		get;
		private set;
	}

	[XmlAttribute("SimulationModifierName")]
	public string SimulationModifierName
	{
		get;
		private set;
	}

	[XmlIgnore]
	public SimulationDescriptor SimulationModifier
	{
		get;
		set;
	}
}
public class BackstoryConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Text")]
	public string Text
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("Hero")]
	public string Hero
	{
		get;
		private set;
	}
}
public enum ModuleCategory
{
	MajorModule,
	MinorModule_Support,
	MinorModule_Offense,
	MinorModule_Debuff,
	SpecialModule
}
public class BluePrintConfig : IDatatableElement
{
	private SimulationObject moduleSimObj;

	private bool isSimObjCached;

	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("ModuleCategory")]
	public ModuleCategory ModuleCategory
	{
		get;
		private set;
	}

	[XmlAttribute("ModuleName")]
	public string ModuleName
	{
		get;
		private set;
	}

	[XmlAttribute("ModuleLevel")]
	public int ModuleLevel
	{
		get;
		private set;
	}

	[XmlAttribute("ResearchScienceCost")]
	public float ResearchScienceCost
	{
		get;
		private set;
	}

	[XmlAttribute("AdditionalLocalizationKey")]
	public string AdditionalLocalizationKey
	{
		get;
		private set;
	}

	public ModuleConfig GetModuleConfig()
	{
		return Databases.GetDatabase<ModuleConfig>().GetValue(ModuleName);
	}

	public SimulationObject GetModuleSimObj()
	{
		if (!isSimObjCached)
		{
			ModuleConfig moduleConfig = GetModuleConfig();
			if (string.IsNullOrEmpty(moduleConfig.SimClass))
			{
				moduleSimObj = null;
			}
			else
			{
				IDatabase<SimulationDescriptor> simDescDatabase = SimMonoBehaviour.GetSimDescDatabase();
				moduleSimObj = new SimulationObject(Name);
				moduleSimObj.AddDescriptor(simDescDatabase.GetValue(moduleConfig.SimClass));
				moduleSimObj.AddDescriptor(simDescDatabase.GetValue(ModuleName));
				if (ModuleLevel > 1)
				{
					for (int i = 2; i <= ModuleLevel; i++)
					{
						moduleSimObj.AddDescriptor(simDescDatabase.GetValue(ModuleName + "_LVL" + i));
					}
				}
				moduleSimObj.Refresh();
			}
			isSimObjCached = true;
		}
		return moduleSimObj;
	}
}
public enum FIDS
{
	Food,
	Industry,
	Dust,
	Science
}
public class CurrencyConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlIgnore]
	public FIDS Currency
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
			Currency = value.ToEnum<FIDS>();
		}
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "MerchantProbWeight")]
	public CurveDefinedValue MerchantProbWeight
	{
		get;
		private set;
	}

	[XmlAttribute("ExchangeRate")]
	public float ExchangeRate
	{
		get;
		private set;
	}

	public static CurrencyConfig GetCurrencyConfig(FIDS currency)
	{
		IDatabase<CurrencyConfig> database = Databases.GetDatabase<CurrencyConfig>();
		return database.GetValue(new StaticString(currency.ToString()));
	}
}
public enum CurveAbscissa
{
	RoomDepth,
	RoomDepthPercent,
	RoomOpeningIndex,
	RoomOpeningIndexPercent,
	RoomSurface,
	IsMultiplayer,
	PlayerCount,
	Level,
	Difficulty,
	ExitWaveNumber,
	SpaceShip,
	CrystalPhaseStatus,
	PlayerWithoutHeroCount,
	ResetResearchesCount,
	EventForcingEnabled,
	CurrentCommunityEvent
}
public class Curve
{
	private bool arePointsSorted;

	private static Dungeon _dungeon;

	private static ShipConfig _shipConfig;

	private static IDatabase<ShipConfig> _shipConfigDB;

	private static GameNetworkManager _gameNetManager;

	private static List<ulong> _withHeroesPlayerIDs;

	private static ulong _playerID;

	private static CurvePoint _point;

	private static CurvePoint _nextPoint;

	private static PrivateGameConfigManager privateGameConfigManager;

	[XmlAttribute("Abscissa")]
	public CurveAbscissa Abscissa
	{
		get;
		private set;
	}

	[XmlAttribute("BaseValue")]
	public float BaseValue
	{
		get;
		private set;
	}

	[XmlAttribute("Min")]
	public float Min
	{
		get;
		private set;
	}

	[XmlAttribute("Max")]
	public float Max
	{
		get;
		private set;
	}

	[XmlElement("CurvePoint")]
	public List<CurvePoint> CurvePoints
	{
		get;
		private set;
	}

	[XmlAttribute("Debug")]
	public bool Debug
	{
		get;
		private set;
	}

	public Curve()
	{
		Min = float.NegativeInfinity;
		Max = float.PositiveInfinity;
	}

	private void AssertPointsAreSorted()
	{
		if (!arePointsSorted)
		{
			arePointsSorted = true;
		}
	}

	private float GetCappedValue(float value)
	{
		float num = Mathf.Max(Mathf.Min(value, Max), Min);
		if (Debug)
		{
			Diagnostics.LogWarning("Curve.GetCappedValue cappedValue=" + num);
		}
		return num;
	}

	public float GetValue(Room room = null)
	{
		if (_dungeon == null)
		{
			_dungeon = SingletonManager.Get<Dungeon>(mandatory: false);
		}
		float num = 0f;
		switch (Abscissa)
		{
		case CurveAbscissa.RoomDepth:
			if (room == null)
			{
				Diagnostics.LogError("Curve.GetValue: a room must be specified to get the RoomDepth!");
				return -1f;
			}
			num = room.Depth;
			break;
		case CurveAbscissa.RoomDepthPercent:
			if (room == null)
			{
				Diagnostics.LogError("Curve.GetValue: a room must be specified to get the RoomDepthPercent!");
				return -1f;
			}
			num = 100f * (float)room.Depth / (float)_dungeon.MaxDepth;
			break;
		case CurveAbscissa.RoomOpeningIndex:
			if (room == null)
			{
				Diagnostics.LogError("Curve.GetValue: a room must be specified to get the RoomOpeningIndex!");
				return -1f;
			}
			num = room.OpeningIndex;
			break;
		case CurveAbscissa.RoomOpeningIndexPercent:
			if (room == null)
			{
				Diagnostics.LogError("Curve.GetValue: a room must be specified to get the RoomOpeningIndexPercent!");
				return -1f;
			}
			num = 100f * (float)room.OpeningIndex / (float)(_dungeon.RoomCount - 2);
			break;
		case CurveAbscissa.RoomSurface:
			if (room == null)
			{
				Diagnostics.LogError("Curve.GetValue: a room must be specified to get the FloorSurface!");
				return -1f;
			}
			num = room.FloorSurface;
			break;
		case CurveAbscissa.IsMultiplayer:
			if (_gameNetManager == null)
			{
				_gameNetManager = SingletonManager.Get<GameNetworkManager>();
			}
			num = ((!_gameNetManager.IsMultiplayerSession()) ? 0f : 1f);
			break;
		case CurveAbscissa.PlayerCount:
			if (_gameNetManager == null)
			{
				_gameNetManager = SingletonManager.Get<GameNetworkManager>();
			}
			num = _gameNetManager.GetPlayerCount();
			break;
		case CurveAbscissa.Level:
			num = _dungeon.Level;
			break;
		case CurveAbscissa.Difficulty:
			num = (float)_dungeon.Difficulty;
			break;
		case CurveAbscissa.ExitWaveNumber:
			num = _dungeon.ExitWaveNumber;
			break;
		case CurveAbscissa.SpaceShip:
		{
			DungeonGenerationParams nextDungeonGenerationParams = Dungeon.NextDungeonGenerationParams;
			StaticString shipName = nextDungeonGenerationParams.ShipName;
			if (_dungeon != null)
			{
				shipName = _dungeon.ShipName;
			}
			if (_shipConfigDB == null)
			{
				_shipConfigDB = Databases.GetDatabase<ShipConfig>();
			}
			_shipConfig = _shipConfigDB.GetValue(shipName);
			num = _shipConfig.AbscissaValue;
			break;
		}
		case CurveAbscissa.CrystalPhaseStatus:
			num = ((!(_dungeon.ExitRoom != null)) ? 0f : ((_dungeon.CurrentCrystalState != 0) ? 2f : 1f));
			break;
		case CurveAbscissa.PlayerWithoutHeroCount:
		{
			num = 0f;
			if (_gameNetManager == null)
			{
				_gameNetManager = SingletonManager.Get<GameNetworkManager>();
			}
			if (!_gameNetManager.IsMultiplayerSession())
			{
				break;
			}
			num = _gameNetManager.GetPlayerCount();
			if (Hero.LocalPlayerActiveRecruitedHeroes.Count > 0)
			{
				num -= 1f;
			}
			if (_withHeroesPlayerIDs == null)
			{
				_withHeroesPlayerIDs = new List<ulong>();
			}
			else
			{
				_withHeroesPlayerIDs.Clear();
			}
			for (int j = 0; j < Hero.RemotePlayersActiveRecruitedHeroes.Count; j++)
			{
				_playerID = Hero.RemotePlayersActiveRecruitedHeroes[j].NetSyncElement.OwnerPlayerID;
				if (!_withHeroesPlayerIDs.Contains(_playerID))
				{
					_withHeroesPlayerIDs.Add(_playerID);
				}
			}
			num -= (float)_withHeroesPlayerIDs.Count;
			break;
		}
		case CurveAbscissa.ResetResearchesCount:
			num = _dungeon.ResetResearchesCount;
			break;
		case CurveAbscissa.EventForcingEnabled:
			num = ((_dungeon.GetSimPropertyValue(SimulationProperties.UpcomingPositiveEvents) > 0f) ? 1 : 0);
			break;
		case CurveAbscissa.CurrentCommunityEvent:
		{
			if (privateGameConfigManager == null)
			{
				privateGameConfigManager = SingletonManager.Get<PrivateGameConfigManager>();
			}
			for (int i = 0; i < privateGameConfigManager.CommunityEvents.Length; i++)
			{
				if (privateGameConfigManager.IsCommunityEventActive(privateGameConfigManager.CommunityEvents[i].Event))
				{
					num = i + 1;
					break;
				}
			}
			break;
		}
		default:
			Diagnostics.LogError("Curve.GetValue: invalid abscissa (" + Abscissa + ")");
			return -1f;
		}
		if (Debug)
		{
			Diagnostics.Log("Curve.GetValue this.Abscissa=" + Abscissa);
			Diagnostics.Log("Curve.GetValue abscissaValue=" + num);
		}
		if (Debug)
		{
			Diagnostics.Log("Curve.GetValue this.CurvePoints=" + CurvePoints);
		}
		if (CurvePoints != null)
		{
			if (Debug)
			{
				Diagnostics.Log("Curve.GetValue this.CurvePoints.Count=" + CurvePoints.Count);
			}
			AssertPointsAreSorted();
			for (int k = 0; k < CurvePoints.Count; k++)
			{
				_point = CurvePoints[k];
				if (num == _point.X)
				{
					if (Debug)
					{
						Diagnostics.Log("Curve.GetValue exact Curve._point found");
					}
					return GetCappedValue(_point.Y);
				}
				_nextPoint = ((k >= CurvePoints.Count - 1) ? null : CurvePoints[k + 1]);
				if (!(_point.X <= num) || (_nextPoint != null && !(_nextPoint.X > num)))
				{
					continue;
				}
				if (Debug)
				{
					Diagnostics.Log("Curve.GetValue range start = " + _point.X);
				}
				float num2 = 0f;
				if (_point.Factor != float.NegativeInfinity)
				{
					if (Debug)
					{
						Diagnostics.Log("Curve.GetValue factor set");
					}
					num2 = _point.Factor;
				}
				else
				{
					if (!_point.Link || _nextPoint == null)
					{
						if (Debug)
						{
							Diagnostics.Log("Curve.GetValue neither factor nor link = base value");
						}
						break;
					}
					if (Debug)
					{
						Diagnostics.Log("Curve.GetValue compute factor for link");
					}
					num2 = (_nextPoint.Y - _point.Y) / (_nextPoint.X - _point.X);
				}
				return GetCappedValue(_point.Y + num2 * (num - _point.X));
			}
		}
		return GetCappedValue(BaseValue);
	}
}
public class CurveDefinedValue
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(Curve), ElementName = "Curve")]
	public Curve Curve
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveOperation), ElementName = "CurveOperation")]
	public CurveOperation CurveOperation
	{
		get;
		private set;
	}

	[XmlAttribute("Debug")]
	public bool Debug
	{
		get;
		private set;
	}

	public float GetValue(Room room = null)
	{
		if (Debug)
		{
			Diagnostics.Log("CurveDefinedValue.GetValue room=" + room);
			Diagnostics.Log("CurveDefinedValue.GetValue this.Curve=" + ((Curve == null) ? "<NULL>" : Curve.ToString()));
			Diagnostics.Log("CurveDefinedValue.GetValue this.CurveOperation=" + ((CurveOperation == null) ? "<NULL>" : CurveOperation.ToString()));
		}
		if (Curve != null && CurveOperation != null)
		{
			Diagnostics.LogError("CurveOperation.GetValue: Curve AND CurveOperation defined!");
			return -1f;
		}
		if (Curve != null)
		{
			return Curve.GetValue(room);
		}
		if (CurveOperation != null)
		{
			return CurveOperation.GetValue(room);
		}
		Diagnostics.LogError("CurveOperation.GetValue: neither Curve nor CurveOperation defined!");
		return -1f;
	}
}
public enum CurveOperationType
{
	Addition,
	Multiplication
}
public class CurveOperation
{
	[XmlAttribute("Type")]
	public CurveOperationType Type
	{
		get;
		private set;
	}

	[XmlAttribute("Min")]
	public float Min
	{
		get;
		private set;
	}

	[XmlAttribute("Max")]
	public float Max
	{
		get;
		private set;
	}

	[XmlElement("Curve")]
	public List<Curve> Curves
	{
		get;
		private set;
	}

	[XmlElement("CurveOperation")]
	public List<CurveOperation> CurveOperations
	{
		get;
		private set;
	}

	[XmlAttribute("Debug")]
	public bool Debug
	{
		get;
		private set;
	}

	public CurveOperation()
	{
		Min = float.NegativeInfinity;
		Max = float.PositiveInfinity;
	}

	private float GetCappedValue(float value)
	{
		float num = Mathf.Max(Mathf.Min(value, Max), Min);
		if (Debug)
		{
			Diagnostics.LogWarning("CurveOperation.GetCappedValue cappedValue=" + num);
		}
		return num;
	}

	public float GetValue(Room room = null)
	{
		if (Debug)
		{
			Diagnostics.Log("CurveOperation.GetValue this.Type=" + Type);
		}
		float num = -1f;
		switch (Type)
		{
		case CurveOperationType.Addition:
			num = 0f;
			break;
		case CurveOperationType.Multiplication:
			num = 1f;
			break;
		default:
			Diagnostics.LogError("CurveOperation.GetValue: invalid operation type: " + Type + "!");
			return -1f;
		}
		List<float> list = new List<float>();
		if (Curves != null)
		{
			foreach (Curve curf in Curves)
			{
				float value = curf.GetValue(room);
				if (Debug)
				{
					Diagnostics.Log("CurveOperation.GetValue curveValue=" + value);
				}
				list.Add(value);
			}
		}
		if (CurveOperations != null)
		{
			foreach (CurveOperation curveOperation in CurveOperations)
			{
				float value2 = curveOperation.GetValue(room);
				if (Debug)
				{
					Diagnostics.Log("CurveOperation.GetValue curveOpValue=" + value2);
				}
				list.Add(value2);
			}
		}
		foreach (float item in list)
		{
			float num2 = item;
			switch (Type)
			{
			case CurveOperationType.Addition:
				num += num2;
				break;
			case CurveOperationType.Multiplication:
				num *= num2;
				break;
			default:
				Diagnostics.LogError("CurveOperation.GetValue: invalid operation type: " + Type + "!");
				return -1f;
			}
		}
		return GetCappedValue(num);
	}
}
public class CurvePoint
{
	private float factor = float.NegativeInfinity;

	[XmlAttribute("X")]
	public float X
	{
		get;
		private set;
	}

	[XmlAttribute("Y")]
	public float Y
	{
		get;
		private set;
	}

	[XmlAttribute("Factor")]
	public float Factor
	{
		get
		{
			return factor;
		}
		private set
		{
			factor = value;
		}
	}

	[XmlAttribute("Link")]
	public bool Link
	{
		get;
		private set;
	}
}
public class DepthRangeConfig : LevelRangeConfig
{
	[XmlAttribute("Start")]
	public int Start
	{
		get;
		private set;
	}

	public virtual float GetValue(int roomOpeningNumber = 0, float roomSurface = 0f, float currentTotalValue = 0f)
	{
		Diagnostics.LogError("GetValue method has to be implemented in child class");
		return -1f;
	}
}
public class DepthRangesConfig<T> where T : DepthRangeConfig
{
	[XmlArrayItem(ElementName = "DepthRange")]
	[XmlArray("DepthRanges")]
	public T[] DepthRanges
	{
		get;
		private set;
	}

	public virtual bool IsMatching(int dungeonLevel)
	{
		T[] depthRanges = DepthRanges;
		for (int i = 0; i < depthRanges.Length; i++)
		{
			T val = depthRanges[i];
			if (val.IsMatching(dungeonLevel))
			{
				return true;
			}
		}
		return false;
	}

	public virtual bool IsMatching(int dungeonLevelFrom, int dungeonLevelTo)
	{
		T[] depthRanges = DepthRanges;
		for (int i = 0; i < depthRanges.Length; i++)
		{
			T val = depthRanges[i];
			if (val.IsMatching(dungeonLevelFrom, dungeonLevelTo))
			{
				return true;
			}
		}
		return false;
	}

	public virtual float GetValue(int roomOpeningNumber = 0, float roomSurface = 0f, float currentTotalValue = 0f, int dungeonLevelFrom = 0, int dungeonLevelTo = 0)
	{
		T val = (T)null;
		T[] depthRanges = DepthRanges;
		for (int i = 0; i < depthRanges.Length; i++)
		{
			T val2 = depthRanges[i];
			if (val2.IsMatching(dungeonLevelFrom, dungeonLevelTo))
			{
				if (roomOpeningNumber < val2.Start)
				{
					break;
				}
				val = val2;
			}
		}
		if (val == null)
		{
			Diagnostics.LogError("No matching range found");
			return -1f;
		}
		return val.GetValue(roomOpeningNumber, roomSurface, currentTotalValue);
	}
}
public class DialogConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("Text")]
	public string Text
	{
		get;
		private set;
	}
}
public class DialogGameplayAddDescriptorConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name => "DialogGameplayAddDescriptorConfig" + Hero + Descriptor;

	[XmlAttribute("Name")]
	public string XmlSerializableName => Name;

	[XmlAttribute("Hero")]
	public string Hero
	{
		get;
		private set;
	}

	[XmlAttribute("Descriptor")]
	public string Descriptor
	{
		get;
		private set;
	}
}
public class DialogGameplayMurderConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name => "DialogGameplayMurderConfig" + Hero1 + Hero2 + Random.ToString();

	[XmlAttribute("Name")]
	public string XmlSerializableName => Name;

	[XmlAttribute("Hero1")]
	public string Hero1
	{
		get;
		private set;
	}

	[XmlAttribute("Hero2")]
	public string Hero2
	{
		get;
		private set;
	}

	[XmlAttribute("Random")]
	public bool Random
	{
		get;
		private set;
	}
}
public class DialogueSituationConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("Probabilty")]
	public float Probabilty
	{
		get;
		private set;
	}

	public void CheckSituationDialog(Hero speaker, float duration)
	{
		float num = RandomGenerator.RangeFloat(0f, 1f);
		if (num <= Probabilty && speaker.Config != null && speaker.Config.SituationDialogCount != null)
		{
			int num2 = RandomGenerator.RangeInt(0, speaker.Config.SituationDialogCount[Name]) + 1;
			string text = "%" + speaker.Config.Name + "_SituationDialog_" + Name + num2.ToString();
			string text2 = AgeLocalizer.Instance.LocalizeString(text);
			if (!(text2 == text))
			{
				speaker.DisplayDialogPanel(text2, duration);
				SingletonManager.Get<Dungeon>().EnqueueDialogNotification(text2, speaker.Config.Name);
			}
		}
	}
}
public class StatDialogConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("Condition")]
	public StatDialogCondition Condition
	{
		get;
		private set;
	}

	[XmlArrayItem("Sentence")]
	[XmlArray("Sentences")]
	public string[] Sentences
	{
		get;
		private set;
	}
}
public class StoryDialogConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlArray("Heroes")]
	[XmlArrayItem("HeroName")]
	public string[] Heroes
	{
		get;
		private set;
	}

	[XmlArrayItem(Type = typeof(StoryDialogStepConfig), ElementName = "Step")]
	[XmlArray("Steps")]
	public StoryDialogStepConfig[] Steps
	{
		get;
		set;
	}

	[XmlIgnore]
	public int CurrentStepIndex
	{
		get;
		set;
	}

	public StoryDialogConfig()
	{
		CurrentStepIndex = -1;
	}
}
public class StoryDialogStepConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("MinFloorTogether")]
	public int MinFloorTogether
	{
		get;
		private set;
	}

	[XmlArrayItem(Type = typeof(StorySentenceConfig), ElementName = "Sentence")]
	[XmlArray("Sentences")]
	public StorySentenceConfig[] Sentences
	{
		get;
		set;
	}

	[XmlArray("BackstoriesUnlocked")]
	[XmlArrayItem(Type = typeof(BackstoryConfig), ElementName = "Backstory")]
	public BackstoryConfig[] BackstoriesUnlocked
	{
		get;
		private set;
	}

	[XmlArray("NewDescriptors")]
	[XmlArrayItem(Type = typeof(DialogGameplayAddDescriptorConfig), ElementName = "NewDescriptor")]
	public DialogGameplayAddDescriptorConfig[] NewDescriptors
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(DialogGameplayMurderConfig), ElementName = "Murder")]
	public DialogGameplayMurderConfig Murder
	{
		get;
		private set;
	}
}
public class StorySentenceConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Text")]
	public string Text
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("Speaker")]
	public string Speaker
	{
		get;
		private set;
	}

	[XmlAttribute("OverridenDuration")]
	public float OverridenDuration
	{
		get;
		private set;
	}
}
public class EligibleMobConfig
{
	[XmlAttribute("MobClassName")]
	public string MobClassName
	{
		get;
		private set;
	}

	[XmlAttribute("MinOpenDoor")]
	public int MinOpenDoor
	{
		get;
		private set;
	}

	[XmlAttribute("MaxPerWave")]
	public int MaxPerWave
	{
		get;
		private set;
	}

	[XmlAttribute("MaxPerRoom")]
	public int MaxPerRoom
	{
		get;
		private set;
	}

	[XmlAttribute("SpawnProbWeight")]
	public float SpawnProbWeight
	{
		get;
		private set;
	}

	public EligibleMobConfig()
	{
		MaxPerRoom = int.MaxValue;
	}
}
public class EquipmentSlotConfig : ItemHeroConfig.ItemHeroCategoryParameters
{
	[XmlElement(Type = typeof(ItemDatatableReference), ElementName = "DefaultEquippedItem")]
	public ItemDatatableReference DefaultEquippedItem
	{
		get;
		private set;
	}
}
public class DynamicDungeonEventConfig : DynamicEventConfig
{
}
public class DynamicEventCombinationConfig
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "ProbWeight")]
	public CurveDefinedValue ProbWeight
	{
		get;
		private set;
	}
}
public class DynamicEventConfig
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "ProbWeight")]
	public CurveDefinedValue _ProbWeight
	{
		get;
		private set;
	}

	[XmlAttribute("LevelDifficultyImpact")]
	public int LevelDifficultyImpact
	{
		get;
		private set;
	}

	public virtual float GetProbWeightValue(Room room)
	{
		float num = _ProbWeight.GetValue(room);
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		if ((dungeon.ShouldDifficultyIncrease && LevelDifficultyImpact > 0) || (!dungeon.ShouldDifficultyIncrease && LevelDifficultyImpact < 0))
		{
			num *= 1f + dungeon.EventProbBonus;
		}
		return num;
	}
}
public class DynamicRoomEventConfig : DynamicEventConfig
{
	[XmlAttribute("ForbidDungeonEvent")]
	public bool ForbidDungeonEvent
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "CountMax")]
	public CurveDefinedValue CountMax
	{
		get;
		private set;
	}

	public override float GetProbWeightValue(Room room)
	{
		if (CountMax != null)
		{
			float value = CountMax.GetValue(room);
			if (value <= 0f)
			{
				return 0f;
			}
			RoomEvent key = base.Name.ToEnum<RoomEvent>();
			Dungeon dungeon = SingletonManager.Get<Dungeon>();
			if (dungeon.DynamicRoomEventCounts.ContainsKey(key) && (float)dungeon.DynamicRoomEventCounts[key] >= value)
			{
				return 0f;
			}
		}
		return base.GetProbWeightValue(room);
	}
}
public class EventConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("SFXJinglePath")]
	public string SFXJinglePath
	{
		get;
		private set;
	}

	[XmlAttribute("ForcedPositiveEvent")]
	public bool ForcedPositiveEvent
	{
		get;
		private set;
	}
}
public class StaticRoomEventConfig
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("ForbidDungeonEvent")]
	public bool ForbidDungeonEvent
	{
		get;
		private set;
	}

	[XmlAttribute("NeedMajorModuleSlot")]
	public bool NeedMajorModuleSlot
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "ProbWeight")]
	public CurveDefinedValue ProbWeight
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "CountMin")]
	public CurveDefinedValue CountMin
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "CountMax")]
	public CurveDefinedValue CountMax
	{
		get;
		private set;
	}
}
public class SteleTypeEventConfig : DynamicEventConfig
{
}
public class EvolutiveValueConfig
{
	[XmlAttribute("StartValue")]
	public float StartValue
	{
		get;
		private set;
	}

	[XmlAttribute("DepthBonus")]
	public float DepthBonus
	{
		get;
		private set;
	}

	[XmlAttribute("RoomSurfaceBonus")]
	public float RoomSurfaceBonus
	{
		get;
		private set;
	}

	[XmlAttribute("MaxValue")]
	public float MaxValue
	{
		get;
		private set;
	}

	[XmlAttribute("MinValue")]
	public float MinValue
	{
		get;
		private set;
	}

	public EvolutiveValueConfig()
	{
		DepthBonus = 0f;
		RoomSurfaceBonus = 0f;
		MinValue = -1f;
		MaxValue = -1f;
	}

	public float GetValue(int depth, float roomSurface)
	{
		float startValue = StartValue;
		startValue += (float)depth * DepthBonus;
		startValue += roomSurface * RoomSurfaceBonus;
		if (MinValue >= 0f && startValue < MinValue)
		{
			startValue = MinValue;
		}
		if (MaxValue >= 0f && startValue > MaxValue)
		{
			startValue = MaxValue;
		}
		return startValue;
	}
}
public class GameConfig : IDatatableElement
{
	private static Tileset randomTileset;

	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("HeroHealPct")]
	public float HeroHealPct
	{
		get;
		private set;
	}

	[XmlAttribute("MaxLevelCount")]
	public int MaxLevelCount
	{
		get;
		private set;
	}

	[XmlAttribute("ShortLongAttackRangeThreshold")]
	public float ShortLongAttackRangeThreshold
	{
		get;
		private set;
	}

	[XmlAttribute("BluePrintResearchTurnCount")]
	public int BluePrintResearchTurnCount
	{
		get;
		private set;
	}

	[XmlAttribute("NewBluePrintWeight")]
	public int NewBluePrintWeight
	{
		get;
		private set;
	}

	[XmlAttribute("LvlPlus1BluePrintWeight")]
	public int LvlPlus1BluePrintWeight
	{
		get;
		private set;
	}

	[XmlAttribute("LvlPlus2BluePrintWeight")]
	public int LvlPlus2BluePrintWeight
	{
		get;
		private set;
	}

	[XmlAttribute("OpenedDoorScore")]
	public float OpenedDoorScore
	{
		get;
		private set;
	}

	[XmlAttribute("ActionOpenedDoorScore")]
	public float ActionOpenedDoorScore
	{
		get;
		private set;
	}

	[XmlAttribute("GatheredFISScore")]
	public float GatheredFISScore
	{
		get;
		private set;
	}

	[XmlAttribute("KilledMobScore")]
	public float KilledMobScore
	{
		get;
		private set;
	}

	[XmlAttribute("LootedDustScore")]
	public float LootedDustScore
	{
		get;
		private set;
	}

	[XmlAttribute("LostHeroScore")]
	public float LostHeroScore
	{
		get;
		private set;
	}

	[XmlAttribute("LeftOverFISScore")]
	public float LeftOverFISScore
	{
		get;
		private set;
	}

	[XmlAttribute("SkillLevelScienceCoef")]
	public float SkillLevelScienceCoef
	{
		get;
		private set;
	}

	[XmlAttribute("DustFactoryActivationIndustryCost")]
	public float DustFactoryActivationIndustryCost
	{
		get;
		private set;
	}

	[XmlAttribute("DustFactoryMinDust")]
	public float DustFactoryMinDust
	{
		get;
		private set;
	}

	[XmlAttribute("DustFactoryMaxDust")]
	public float DustFactoryMaxDust
	{
		get;
		private set;
	}

	[XmlAttribute("DustFactoryExplosionProb")]
	public float DustFactoryExplosionProb
	{
		get;
		private set;
	}

	[XmlAttribute("CryoCapsuleActivationIndustryCost")]
	public float CryoCapsuleActivationIndustryCost
	{
		get;
		private set;
	}

	[XmlAttribute("CryoCapsuleHeroProbWeight")]
	public float CryoCapsuleHeroProbWeight
	{
		get;
		private set;
	}

	[XmlAttribute("CryoCapsuleFoodProbWeight")]
	public float CryoCapsuleFoodProbWeight
	{
		get;
		private set;
	}

	[XmlAttribute("CryoCapsuleToxicCloudProbWeight")]
	public float CryoCapsuleToxicCloudProbWeight
	{
		get;
		private set;
	}

	[XmlAttribute("CryoCapsuleMinFood")]
	public float CryoCapsuleMinFood
	{
		get;
		private set;
	}

	[XmlAttribute("CryoCapsuleMaxFood")]
	public float CryoCapsuleMaxFood
	{
		get;
		private set;
	}

	[XmlAttribute("CryoCapsuleToxicCloudTurnCount")]
	public int CryoCapsuleToxicCloudTurnCount
	{
		get;
		private set;
	}

	[XmlAttribute("MaxMobPerTile")]
	public float MaxMobPerTile
	{
		get;
		private set;
	}

	[XmlAttribute("MaxTotalMobCount")]
	public int MaxTotalMobCount
	{
		get;
		private set;
	}

	[XmlAttribute("DifficultyTarget")]
	public float DifficultyTarget
	{
		get;
		private set;
	}

	[XmlAttribute("EventProbWeightBonusMultiplier")]
	public float EventProbWeightBonusMultiplier
	{
		get;
		private set;
	}

	[XmlAttribute("MobSpawnLevelDifficultyBaseValue")]
	public float MobSpawnLevelDifficultyBaseValue
	{
		get;
		private set;
	}

	[XmlAttribute("HeroSpawnLevelDifficultyValue")]
	public float HeroSpawnLevelDifficultyValue
	{
		get;
		private set;
	}

	[XmlAttribute("HeroItemSpawnLevelDifficultyBaseValue")]
	public float HeroItemSpawnLevelDifficultyBaseValue
	{
		get;
		private set;
	}

	[XmlAttribute("FIDSItemSpawnLevelDifficultyBaseValue")]
	public float FIDSItemSpawnLevelDifficultyBaseValue
	{
		get;
		private set;
	}

	[XmlAttribute("RoomDustLootLevelDifficultyBaseValue")]
	public float RoomDustLootLevelDifficultyBaseValue
	{
		get;
		private set;
	}

	[XmlAttribute("MerchantSpawnLevelDifficultyValue")]
	public float MerchantSpawnLevelDifficultyValue
	{
		get;
		private set;
	}

	[XmlAttribute("ArtifactSpawnLevelDifficultyValue")]
	public float ArtifactSpawnLevelDifficultyValue
	{
		get;
		private set;
	}

	[XmlAttribute("SteleSpawnLevelDifficultyValue")]
	public float SteleSpawnLevelDifficultyValue
	{
		get;
		private set;
	}

	[XmlAttribute("DustFactorySpawnLevelDifficultyValue")]
	public float DustFactorySpawnLevelDifficultyValue
	{
		get;
		private set;
	}

	[XmlAttribute("CryoCapsuleSpawnLevelDifficultyValue")]
	public float CryoCapsuleSpawnLevelDifficultyValue
	{
		get;
		private set;
	}

	[XmlAttribute("ToxicCloudSpawnLevelDifficultyValue")]
	public float ToxicCloudSpawnLevelDifficultyValue
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "CrystalPhaseDoorOpeningDelayMin")]
	public CurveDefinedValue CrystalPhaseDoorOpeningDelayMin
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "CrystalPhaseDoorOpeningDelayMax")]
	public CurveDefinedValue CrystalPhaseDoorOpeningDelayMax
	{
		get;
		private set;
	}

	[XmlAttribute("DismissingFoodCoef")]
	public float DismissingFoodCoef
	{
		get;
		private set;
	}

	[XmlAttribute("HiringFoodCoef")]
	public float HiringFoodCoef
	{
		get;
		private set;
	}

	[XmlAttribute("RespawnFoodCoef")]
	public float RespawnFoodCoef
	{
		get;
		private set;
	}

	[XmlAttribute("WoundedDialogTriggerHealthRatio")]
	public float WoundedDialogTriggerHealthRatio
	{
		get;
		private set;
	}

	[XmlAttribute("TamedMobMaxLevel")]
	public int TamedMobMaxLevel
	{
		get;
		private set;
	}

	[XmlArrayItem("InitUnlockedHero")]
	[XmlArray("InitUnlockedHeroes")]
	public string[] InitUnlockedHeroes
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "Tileset")]
	public CurveDefinedValue XmlSerializableTileset
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "PlayerInitHeroCount")]
	public CurveDefinedValue PlayerInitHeroCount
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "PlayerMaxHeroCount")]
	public CurveDefinedValue PlayerMaxHeroCount
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "DungeonRoomCountMin")]
	public CurveDefinedValue DungeonRoomCountMin
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "DungeonRoomCountMax")]
	public CurveDefinedValue DungeonRoomCountMax
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "RoomMajorModuleSlotProbability")]
	public CurveDefinedValue RoomMajorModuleSlotProbability
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "RoomMinorModuleSlotProbability")]
	public CurveDefinedValue RoomMinorModuleSlotProbability
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "RoomMinorModuleSlotCountMin")]
	public CurveDefinedValue RoomMinorModuleSlotCountMin
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "RoomMinorModuleSlotCountMax")]
	public CurveDefinedValue RoomMinorModuleSlotCountMax
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "LevelMobClassCountMin")]
	public CurveDefinedValue LevelMobClassCountMin
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "LevelMobClassCountMax")]
	public CurveDefinedValue LevelMobClassCountMax
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "PreviousLevelMobClassCountMin")]
	public CurveDefinedValue PreviousLevelMobClassCountMin
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "PreviousLevelMobClassCountMax")]
	public CurveDefinedValue PreviousLevelMobClassCountMax
	{
		get;
		private set;
	}

	[XmlArrayItem("MobConfig")]
	[XmlArray("MobConfigs")]
	public MobConfig[] MobConfigs
	{
		get;
		private set;
	}

	[XmlIgnore]
	public MobConfig[] FilteredMobConfigs
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "RoomDifficultyMin")]
	public CurveDefinedValue RoomDifficultyMin
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "RoomDifficultyMax")]
	public CurveDefinedValue RoomDifficultyMax
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "WaveCountMin")]
	public CurveDefinedValue WaveCountMin
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "WaveCountMax")]
	public CurveDefinedValue WaveCountMax
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "WaveDifficultyMin")]
	public CurveDefinedValue WaveDifficultyMin
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "WaveDifficultyMax")]
	public CurveDefinedValue WaveDifficultyMax
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "ExitWaveCountMin")]
	public CurveDefinedValue ExitWaveCountMin
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "ExitWaveCountMax")]
	public CurveDefinedValue ExitWaveCountMax
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "ExitWaveDifficultyMin")]
	public CurveDefinedValue ExitWaveDifficultyMin
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "ExitWaveDifficultyMax")]
	public CurveDefinedValue ExitWaveDifficultyMax
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "ExitWaveDelayMin")]
	public CurveDefinedValue ExitWaveDelayMin
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "ExitWaveDelayMax")]
	public CurveDefinedValue ExitWaveDelayMax
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "DungeonRoomDustLootMin")]
	public CurveDefinedValue DungeonRoomDustLootMin
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "DungeonRoomDustLootMax")]
	public CurveDefinedValue DungeonRoomDustLootMax
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "RoomDustLootProbWeight")]
	public CurveDefinedValue RoomDustLootProbWeight
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "RoomDustLootMin")]
	public CurveDefinedValue RoomDustLootMin
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "RoomDustLootMax")]
	public CurveDefinedValue RoomDustLootMax
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "EMPDuration")]
	public CurveDefinedValue EMPDuration
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "EMPRoomCount")]
	public CurveDefinedValue EMPRoomCount
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "ActionDoorFISBonus")]
	public CurveDefinedValue ActionDoorFISBonus
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "FreeHeroMinLevel")]
	public CurveDefinedValue FreeHeroMinLevel
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "FreeHeroMaxLevel")]
	public CurveDefinedValue FreeHeroMaxLevel
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "ResetResearchesCost")]
	public CurveDefinedValue ResetResearchesCost
	{
		get;
		private set;
	}

	[XmlAttribute("EMPSelectionPct")]
	public float EMPSelectionPct
	{
		get;
		private set;
	}

	[XmlAttribute("MultiplayerMinPlayerCount")]
	public int MultiplayerMinPlayerCount
	{
		get;
		private set;
	}

	[XmlAttribute("MultiplayerMaxPlayerCount")]
	public int MultiplayerMaxPlayerCount
	{
		get;
		private set;
	}

	[XmlAttribute("MaxHeroCount")]
	public int MaxHeroCount
	{
		get;
		private set;
	}

	[XmlAttribute("BackPackCapacity")]
	public int BackPackCapacity
	{
		get;
		private set;
	}

	[XmlArrayItem("StaticRoomEventConfig")]
	[XmlArray("StaticRoomEventConfigs")]
	public StaticRoomEventConfig[] StaticRoomEventConfigs
	{
		get;
		private set;
	}

	[XmlArrayItem("DynamicEventCombinationConfig")]
	[XmlArray("DynamicEventCombinationConfigs")]
	public DynamicEventCombinationConfig[] DynamicEventCombinationConfigs
	{
		get;
		private set;
	}

	[XmlArray("DynamicRoomEventConfigs")]
	[XmlArrayItem("DynamicRoomEventConfig")]
	public DynamicRoomEventConfig[] DynamicRoomEventConfigs
	{
		get;
		private set;
	}

	[XmlArray("DynamicDungeonEventConfigs")]
	[XmlArrayItem("DynamicDungeonEventConfig")]
	public DynamicDungeonEventConfig[] DynamicDungeonEventConfigs
	{
		get;
		private set;
	}

	[XmlArray("SteleTypeEventConfigs")]
	[XmlArrayItem("SteleTypeEventConfig")]
	public SteleTypeEventConfig[] SteleTypeEventConfigs
	{
		get;
		private set;
	}

	public static GameConfig GetGameConfig()
	{
		GameConfig gameConfig = Databases.GetDatabase<GameConfig>().GetValues()[0];
		if (gameConfig.FilteredMobConfigs == null)
		{
			DLCController dlcManager = SingletonManager.Get<DLCController>();
			gameConfig.FilteredMobConfigs = gameConfig.MobConfigs.Where((MobConfig mob) => dlcManager.IsObjectAvailable(DLCObjectType.Mob, mob.Name)).ToArray();
		}
		return gameConfig;
	}

	public static void ResetRandomTileset()
	{
		Diagnostics.Log("ResetRandomTileset");
		randomTileset = Tileset.Random;
	}

	public Tileset GetTileset()
	{
		Tileset tileset = ((int)XmlSerializableTileset.GetValue()).ToEnum<Tileset>();
		if (tileset == Tileset.Random)
		{
			tileset = GetRandomTileset();
		}
		return tileset;
	}

	private static Tileset PickRandomTileset()
	{
		Tileset[] enumValues = GenericUtilities.GetEnumValues<Tileset>();
		return enumValues[RandomGenerator.RangeInt(1, enumValues.Length)];
	}

	private static Tileset GetRandomTileset()
	{
		if (randomTileset == Tileset.Random)
		{
			randomTileset = PickRandomTileset();
		}
		return randomTileset;
	}

	public TilesetConfig GetTilesetConfig()
	{
		return Databases.GetDatabase<TilesetConfig>().GetValue(GetTileset().ToString());
	}
}
public class HeroConfig : IDatatableElement
{
	public enum HeroFaction
	{
		Other,
		Guard,
		Prisoner,
		Native
	}

	private static PrivateGameConfigManager privateGameConfig;

	private SimulationObject heroSimObj;

	private bool isSimObjCached;

	private bool isInitialized;

	private bool isHidden;

	private float randomSelectionWeight = 1f;

	private bool isCommunityEventHero;

	private bool isCommunityEventActive;

	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlIgnore]
	public Dictionary<StaticString, int> SituationDialogCount
	{
		get;
		set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute]
	public string SpriteAnimationsPath
	{
		get;
		private set;
	}

	[XmlAttribute("RecruitmentFoodCost")]
	public float RecruitmentFoodCost
	{
		get;
		private set;
	}

	[XmlAttribute("AITargetType")]
	public string XmlSerializableAITargetType
	{
		get
		{
			return AITargetType.ToString();
		}
		set
		{
			AITargetType = value.ToEnum<AITargetType>();
		}
	}

	[XmlIgnore]
	public AITargetType AITargetType
	{
		get;
		private set;
	}

	[XmlAttribute("AttackType")]
	public string AttackType
	{
		get;
		private set;
	}

	[XmlAttribute("Archetype")]
	public string Archetype
	{
		get;
		private set;
	}

	[XmlAttribute("UnlockLevelCount")]
	public int UnlockLevelCount
	{
		get;
		private set;
	}

	[XmlAttribute("Faction")]
	public HeroFaction Faction
	{
		get;
		private set;
	}

	[XmlArray("IntroDialogs")]
	[XmlArrayItem(Type = typeof(DialogConfig), ElementName = "Dialog")]
	public DialogConfig[] IntroDialogs
	{
		get;
		set;
	}

	[XmlArrayItem(Type = typeof(EquipmentSlotConfig), ElementName = "EquipmentSlot")]
	[XmlArray("EquipmentSlots")]
	public EquipmentSlotConfig[] EquipmentSlots
	{
		get;
		set;
	}

	public SimulationObject GetHeroSimObj()
	{
		if (!isSimObjCached)
		{
			IDatabase<SimulationDescriptor> simDescDatabase = SimMonoBehaviour.GetSimDescDatabase();
			heroSimObj = new SimulationObject(Name);
			heroSimObj.AddDescriptor(simDescDatabase.GetValue("Hero"));
			heroSimObj.AddDescriptor(simDescDatabase.GetValue(Name));
			heroSimObj.Refresh();
			isSimObjCached = true;
		}
		return heroSimObj;
	}

	public float GetDamagesStat()
	{
		SimulationObject simulationObject = GetHeroSimObj();
		return simulationObject.GetPropertyValue(SimulationProperties.AttackPower) / simulationObject.GetPropertyValue(SimulationProperties.AttackCooldown);
	}

	public float GetLifeStat()
	{
		SimulationObject simulationObject = GetHeroSimObj();
		return simulationObject.GetPropertyValue(SimulationProperties.MaxHealth) * (1f + simulationObject.GetPropertyValue(SimulationProperties.Defense) / (simulationObject.GetPropertyValue(SimulationProperties.Defense) + 100f));
	}

	public float GetSpeedStat()
	{
		SimulationObject simulationObject = GetHeroSimObj();
		return simulationObject.GetPropertyValue(SimulationProperties.MoveSpeed);
	}

	public float GetWitStat()
	{
		SimulationObject simulationObject = GetHeroSimObj();
		return simulationObject.GetPropertyValue(SimulationProperties.Wit);
	}

	public bool IsHidden()
	{
		AssertIsInitialized();
		return isHidden;
	}

	public float GetRandomSelectionWeight()
	{
		AssertIsInitialized();
		return randomSelectionWeight;
	}

	public bool IsCommunityEventHero()
	{
		AssertIsInitialized();
		return isCommunityEventHero;
	}

	public bool IsCommunityEventActive()
	{
		AssertIsInitialized();
		return isCommunityEventActive;
	}

	private void AssertIsInitialized()
	{
		if (!isInitialized)
		{
			Initialize();
		}
	}

	private void Initialize()
	{
		if (privateGameConfig == null)
		{
			privateGameConfig = SingletonManager.Get<PrivateGameConfigManager>();
		}
		for (int i = 0; i < privateGameConfig.HiddenHeroes.Length; i++)
		{
			HiddenHeroConfig hiddenHeroConfig = privateGameConfig.HiddenHeroes[i];
			if (hiddenHeroConfig.HeroName == Name)
			{
				isHidden = true;
				randomSelectionWeight = hiddenHeroConfig.RandomSelectionWeight;
				break;
			}
		}
		for (int j = 0; j < privateGameConfig.CommunityEventHeroes.Length; j++)
		{
			CommunityEventHeroConfig communityEventHeroConfig = privateGameConfig.CommunityEventHeroes[j];
			if (communityEventHeroConfig.HeroName == Name)
			{
				isCommunityEventHero = true;
				isCommunityEventActive = privateGameConfig.IsCommunityEventActive(communityEventHeroConfig.CommunityEvent);
				break;
			}
		}
		isInitialized = true;
	}
}
public class HeroLevelConfig : IDatatableElement
{
	[XmlIgnore]
	public bool HasPassiveSkills;

	[XmlIgnore]
	public bool HasActiveSkills;

	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("FoodCost")]
	public float FoodCost
	{
		get;
		private set;
	}

	[XmlArrayItem("Skill")]
	[XmlArray("Skills")]
	public string[] Skills
	{
		get;
		private set;
	}
}
public class InventoryConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlArrayItem(Type = typeof(ItemDatatableReference), ElementName = "Item")]
	[XmlArray("Items")]
	public ItemDatatableReference[] DefaultItems
	{
		get;
		private set;
	}
}
public enum ItemType
{
	FIDS = 0,
	ItemHero = 5,
	Chest = 6
}
public class ItemConfig : MaxedProbabilityConfig
{
	[Serializable]
	public struct ItemConfigPrefab
	{
		public ItemType Type;

		public GameObject Prefab;
	}

	[XmlIgnore]
	public ItemType Type
	{
		get;
		protected set;
	}

	[XmlAttribute("ItemType")]
	public string XmlType
	{
		get
		{
			return Type.ToString();
		}
		set
		{
			try
			{
				Type = value.ToEnum<ItemType>();
			}
			catch
			{
				Type = ItemType.FIDS;
				Diagnostics.LogError("[ItemConfig] Unknown type (" + value + ")");
			}
		}
	}

	[XmlAttribute("FlatSprite")]
	public bool FlatSprite
	{
		get;
		set;
	}
}
public class ItemDatatableReference
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlIgnore]
	public StaticString RarityName
	{
		get;
		private set;
	}

	[XmlAttribute("Rarity")]
	public string XmlSerializableRarityName
	{
		get
		{
			return RarityName;
		}
		set
		{
			RarityName = value;
		}
	}
}
public class ItemHeroCategoryConfig : IDatatableElement
{
	[XmlType("AvailableType")]
	public class ItemHeroType
	{
		[XmlIgnore]
		public StaticString Name
		{
			get;
			private set;
		}

		[XmlAttribute("Name")]
		public string XmlSerializableName
		{
			get
			{
				return Name;
			}
			set
			{
				Name = value;
			}
		}
	}

	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlArray("AvailableTypes")]
	[XmlArrayItem(Type = typeof(ItemHeroType), ElementName = "AvailableType")]
	public ItemHeroType[] AvailableTypes
	{
		get;
		private set;
	}

	public ItemHeroType GetItemHeroTypeByName(StaticString name)
	{
		if (AvailableTypes == null || AvailableTypes.Length == 0)
		{
			return null;
		}
		for (int i = 0; i < AvailableTypes.Length; i++)
		{
			if (name == AvailableTypes[i].Name)
			{
				return AvailableTypes[i];
			}
		}
		return null;
	}

	public bool IsItemHeroTypeValid(ItemHeroType type)
	{
		if (type == null)
		{
			return true;
		}
		if (AvailableTypes == null || AvailableTypes.Length == 0)
		{
			return false;
		}
		for (int i = 0; i < AvailableTypes.Length; i++)
		{
			if (type == AvailableTypes[i])
			{
				return true;
			}
		}
		return false;
	}

	public bool IsItemHeroTypeValid(StaticString name)
	{
		if (name == null)
		{
			return true;
		}
		return GetItemHeroTypeByName(name) != null;
	}
}
public class ItemHeroConfig : ItemConfig
{
	public class ItemHeroCategoryParameters
	{
		public static readonly StaticString WeaponCategory = "ItemHero_Weapon";

		[XmlIgnore]
		public StaticString CategoryName
		{
			get;
			private set;
		}

		[XmlIgnore]
		public StaticString TypeName
		{
			get;
			private set;
		}

		[XmlAttribute("Name")]
		public string XmlSerializableCategoryName
		{
			get
			{
				return CategoryName;
			}
			set
			{
				CategoryName = value;
			}
		}

		[XmlAttribute("Type")]
		public string XmlSerializableTypeName
		{
			get
			{
				return (!(TypeName == null)) ? TypeName.ToString() : null;
			}
			set
			{
				TypeName = ((value != null) ? new StaticString(value) : null);
			}
		}

		public bool IsCategoryMatching(ItemHeroCategoryParameters category)
		{
			if (CategoryName == category.CategoryName && (TypeName == null || category.TypeName == null || TypeName == category.TypeName))
			{
				return true;
			}
			return false;
		}
	}

	public static StaticString CommonRarityName = "Common";

	[XmlArrayItem("Skill")]
	[XmlArray("Skills")]
	public string[] Skills
	{
		get;
		private set;
	}

	[XmlArray("Rarities")]
	[XmlArrayItem(Type = typeof(RarityConfig), ElementName = "Rarity")]
	public RarityConfig[] RarityParameters
	{
		get;
		set;
	}

	[XmlElement(Type = typeof(ItemHeroCategoryParameters), ElementName = "Category")]
	public ItemHeroCategoryParameters CategoryParameters
	{
		get;
		set;
	}

	[XmlAttribute("DestroyOnDeath")]
	public bool DestroyOnDeath
	{
		get;
		private set;
	}

	[XmlAttribute("CannotBeUnequipped")]
	public bool CannotBeUnequipped
	{
		get;
		private set;
	}

	[XmlIgnore]
	public StaticString AttackTypeConfigName
	{
		get;
		private set;
	}

	[XmlAttribute("AttackType")]
	public string XmlSerializableAttackType
	{
		get
		{
			return AttackTypeConfigName;
		}
		set
		{
			AttackTypeConfigName = value;
		}
	}

	public ItemHeroConfig()
	{
		base.Type = ItemType.ItemHero;
	}

	public void GetEquipmentCategoryAndType(out ItemHeroCategoryConfig category, out ItemHeroCategoryConfig.ItemHeroType type)
	{
		category = null;
		type = null;
		IDatabase<ItemHeroCategoryConfig> database = Databases.GetDatabase<ItemHeroCategoryConfig>();
		Diagnostics.Assert(database != null);
		if (CategoryParameters != null && CategoryParameters.CategoryName != null)
		{
			category = database.GetValue(CategoryParameters.CategoryName);
			if (category != null)
			{
				type = category.GetItemHeroTypeByName(CategoryParameters.TypeName);
			}
		}
	}

	public RarityConfig PickRandomRarityParameters(int roomOpeningNumber = 0, int roomSurface = 0, int dungeonLevel = 0)
	{
		RarityConfig rarityConfig = ProbabilityConfig.PickRandomElement(RarityParameters, roomOpeningNumber, roomSurface, dungeonLevel);
		if (rarityConfig.Name == CommonRarityName)
		{
			rarityConfig = null;
		}
		return rarityConfig;
	}

	public RarityConfig PickRandomRarityParametersByLevelRange(int roomOpeningNumber = 0, int roomSurface = 0, int dungeonLevelFrom = 0, int dungeonLevelTo = 0)
	{
		RarityConfig rarityConfig = ProbabilityConfig.PickRandomElementByLevelRange(RarityParameters, roomOpeningNumber, roomSurface, dungeonLevelFrom, dungeonLevelTo);
		if (rarityConfig.Name == CommonRarityName)
		{
			rarityConfig = null;
		}
		return rarityConfig;
	}

	public RarityConfig GetRandomRarityParametersByName(StaticString rarityName)
	{
		if (rarityName == null || rarityName == CommonRarityName)
		{
			return null;
		}
		for (int i = 0; i < RarityParameters.Length; i++)
		{
			if (RarityParameters[i].Name == rarityName)
			{
				return RarityParameters[i];
			}
		}
		return null;
	}
}
public class ItemHeroRarityConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlIgnore]
	public Color ColorValue
	{
		get;
		set;
	}

	[XmlAttribute]
	public float Red
	{
		get
		{
			Color colorValue = ColorValue;
			return colorValue.r;
		}
		set
		{
			Color colorValue = ColorValue;
			float g = colorValue.g;
			Color colorValue2 = ColorValue;
			ColorValue = new Color(value, g, colorValue2.b);
		}
	}

	[XmlAttribute]
	public float Green
	{
		get
		{
			Color colorValue = ColorValue;
			return colorValue.g;
		}
		set
		{
			Color colorValue = ColorValue;
			float r = colorValue.r;
			Color colorValue2 = ColorValue;
			ColorValue = new Color(r, value, colorValue2.b);
		}
	}

	[XmlAttribute]
	public float Blue
	{
		get
		{
			Color colorValue = ColorValue;
			return colorValue.b;
		}
		set
		{
			Color colorValue = ColorValue;
			float r = colorValue.r;
			Color colorValue2 = ColorValue;
			ColorValue = new Color(r, colorValue2.g, value);
		}
	}
}
public class LevelRangeConfig
{
	[XmlAttribute("LevelMin")]
	public int LevelMin
	{
		get;
		private set;
	}

	[XmlAttribute("LevelMax")]
	public int LevelMax
	{
		get;
		private set;
	}

	public LevelRangeConfig()
	{
		LevelMin = -1;
		LevelMax = -1;
	}

	public virtual bool IsMatching(int dungeonLevel)
	{
		if (LevelMin < 0 || LevelMin <= dungeonLevel)
		{
			return LevelMax < 0 || dungeonLevel <= LevelMax;
		}
		return false;
	}

	public virtual bool IsMatching(int dungeonLevelFrom, int dungeonLevelTo)
	{
		if (dungeonLevelFrom < 0)
		{
			dungeonLevelFrom = 0;
		}
		if (dungeonLevelTo < dungeonLevelFrom)
		{
			dungeonLevelTo = dungeonLevelFrom;
		}
		if (dungeonLevelFrom == dungeonLevelTo)
		{
			return IsMatching(dungeonLevelFrom);
		}
		if ((LevelMin < 0 || LevelMin < dungeonLevelFrom) && (LevelMax < 0 || dungeonLevelFrom < LevelMax))
		{
			return true;
		}
		return (LevelMin < 0 || LevelMin < dungeonLevelTo) && (LevelMax < 0 || dungeonLevelTo < LevelMax);
	}
}
public class MaxTotalValueDepthRangesConfig<T> : DepthRangesConfig<T> where T : DepthRangeConfig
{
	[XmlAttribute("MaxTotalValue")]
	public float MaxTotalValue
	{
		get;
		private set;
	}

	public override float GetValue(int roomOpeningNumber = 0, float roomSurface = 0f, float currentTotalValue = 0f, int dungeonLevelFrom = 0, int dungeonLevelTo = 0)
	{
		float num = base.GetValue(roomOpeningNumber, roomSurface, currentTotalValue, dungeonLevelFrom, dungeonLevelTo);
		if (MaxTotalValue >= 0f)
		{
			float num2 = MaxTotalValue - currentTotalValue;
			if (num > num2)
			{
				num = num2;
			}
		}
		return num;
	}
}
public class MaxedProbabilityConfig : ProbabilityConfig
{
	public static Dictionary<StaticString, Dictionary<StaticString, int>> PickedElementCounts
	{
		get;
		private set;
	}

	[XmlAttribute("MaxCount")]
	public int MaxCount
	{
		get;
		private set;
	}

	public static T PickLimitedRandomElement<T>(int roomOpeningNumber = 0, float roomSurface = 0f, int dungeonLevel = 0, T[] dbElements = null) where T : MaxedProbabilityConfig
	{
		Type typeFromHandle = typeof(T);
		string fullName = typeFromHandle.FullName;
		AssetPickedElementCountIsDefined(fullName);
		IDatabase<T> database = Databases.GetDatabase<T>();
		if (dbElements == null)
		{
			dbElements = database.GetValues();
		}
		List<T> list = new List<T>();
		T[] array = dbElements;
		for (int i = 0; i < array.Length; i++)
		{
			T item = array[i];
			if (!PickedElementCounts[fullName].ContainsKey(item.Name))
			{
				PickedElementCounts[fullName].Add(item.Name, 0);
			}
			if (item.MaxCount < 0 || PickedElementCounts[fullName][item.Name] < item.MaxCount)
			{
				list.Add(item);
			}
		}
		if (list.Count < 1)
		{
			Diagnostics.LogWarning("No more pickable " + typeFromHandle.ToString());
			return (T)null;
		}
		T result = ProbabilityConfig.PickRandomElement(list.ToArray(), roomOpeningNumber, roomSurface, dungeonLevel);
		Dictionary<StaticString, int> dictionary;
		Dictionary<StaticString, int> dictionary2 = dictionary = PickedElementCounts[fullName];
		StaticString name;
		StaticString key = name = result.Name;
		int num = dictionary[name];
		dictionary2[key] = num + 1;
		return result;
	}

	public static void ResetAllPickedElementCounts()
	{
		PickedElementCounts = null;
	}

	public static void SetPickedElementCount(string typeName, StaticString name, int count)
	{
		AssetPickedElementCountIsDefined(typeName, name);
		PickedElementCounts[typeName][name] = count;
	}

	private static void AssetPickedElementCountIsDefined(string typeName)
	{
		if (PickedElementCounts == null)
		{
			PickedElementCounts = new Dictionary<StaticString, Dictionary<StaticString, int>>();
		}
		if (!PickedElementCounts.ContainsKey(typeName))
		{
			PickedElementCounts.Add(typeName, new Dictionary<StaticString, int>());
		}
	}

	private static void AssetPickedElementCountIsDefined(string typeName, StaticString name)
	{
		AssetPickedElementCountIsDefined(typeName);
		if (!PickedElementCounts[typeName].ContainsKey(name))
		{
			PickedElementCounts[typeName].Add(name, 0);
		}
	}
}
public class MinMaxValueConfig
{
	[XmlAttribute("MinValue")]
	public float MinValue
	{
		get;
		private set;
	}

	[XmlAttribute("MaxValue")]
	public float MaxValue
	{
		get;
		private set;
	}

	public MinMaxValueConfig()
	{
		MaxValue = -1f;
	}

	public float GetRandomValueInRange()
	{
		return RandomGenerator.RangeFloat(MinValue, MaxValue);
	}

	public override string ToString()
	{
		return $"({MinValue},{MaxValue})";
	}
}
public class MinMaxValueDepthRangeConfig : DepthRangeConfig
{
	[XmlElement(Type = typeof(EvolutiveValueConfig), ElementName = "MinValue")]
	public EvolutiveValueConfig MinValue
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(EvolutiveValueConfig), ElementName = "MaxValue")]
	public EvolutiveValueConfig MaxValue
	{
		get;
		private set;
	}

	public override float GetValue(int roomOpeningNumber = 0, float roomSurface = 0f, float currentTotalValue = 0f)
	{
		roomOpeningNumber -= base.Start;
		return RandomGenerator.RangeFloat(MinValue.GetValue(roomOpeningNumber, roomSurface), MaxValue.GetValue(roomOpeningNumber, roomSurface));
	}
}
public class MinRoomSurfaceMaxTotalValueDepthRangesConfig<T> : MaxTotalValueDepthRangesConfig<T> where T : DepthRangeConfig
{
	[XmlAttribute("MinRoomSurface")]
	public int MinRoomSurface
	{
		get;
		private set;
	}

	public override float GetValue(int roomOpeningNumber = 0, float roomSurface = 0f, float currentTotalValue = 0f, int dungeonLevelFrom = 0, int dungeonLevelTo = 0)
	{
		if (MinRoomSurface >= 0 && roomSurface < (float)MinRoomSurface)
		{
			return 0f;
		}
		return base.GetValue(roomOpeningNumber, roomSurface, currentTotalValue, dungeonLevelFrom, dungeonLevelTo);
	}
}
public class MobClassConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("DifficultyValue")]
	public int DifficultyValue
	{
		get;
		private set;
	}

	[XmlAttribute("AITargetType")]
	public string XmlSerializableAITargetType
	{
		get
		{
			return AITargetType.ToString();
		}
		set
		{
			AITargetType = value.ToEnum<AITargetType>();
		}
	}

	[XmlIgnore]
	public AITargetType AITargetType
	{
		get;
		private set;
	}

	[XmlAttribute("AttackType")]
	public string AttackType
	{
		get;
		private set;
	}

	[XmlAttribute("DeathSFXPath")]
	public string DeathSFXPath
	{
		get;
		private set;
	}

	[XmlAttribute("SpawnCenter")]
	public bool SpawnCenter
	{
		get;
		private set;
	}

	[XmlAttribute("MaxLevel")]
	public int MaxLevel
	{
		get;
		private set;
	}

	[XmlAttribute("SelfLight")]
	public bool SelfLight
	{
		get;
		private set;
	}

	[XmlAttribute("AlwaysVisible")]
	public bool AlwaysVisible
	{
		get;
		private set;
	}

	[XmlAttribute("NotificationIcon")]
	public string NotificationIcon
	{
		get;
		private set;
	}

	[XmlAttribute("NotificationDuration")]
	public float NotificationDuration
	{
		get;
		private set;
	}

	[XmlAttribute("MinRoomOpeningIndex")]
	public int MinRoomOpeningIndex
	{
		get;
		private set;
	}

	[XmlAttribute("MinRoomOpeningIndexIfNew")]
	public int MinRoomOpeningIndexIfNew
	{
		get;
		private set;
	}

	[XmlAttribute("MaxPerWave")]
	public int MaxPerWave
	{
		get;
		private set;
	}

	[XmlAttribute("MaxPerRoom")]
	public int MaxPerRoom
	{
		get;
		private set;
	}

	[XmlAttribute("IsElligibleForExitWave")]
	public bool IsElligibleForExitWave
	{
		get;
		private set;
	}

	[XmlAttribute("Immobile")]
	public bool Immobile
	{
		get;
		private set;
	}

	public MobClassConfig()
	{
		MinRoomOpeningIndex = 0;
		MinRoomOpeningIndexIfNew = 0;
		MaxPerWave = int.MaxValue;
		MaxPerRoom = int.MaxValue;
		IsElligibleForExitWave = true;
	}
}
public class MobConfig
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "SelectProbWeight")]
	public CurveDefinedValue SelectProbWeight
	{
		get;
		private set;
	}

	[XmlElement(Type = typeof(CurveDefinedValue), ElementName = "SpawnProbWeight")]
	public CurveDefinedValue SpawnProbWeight
	{
		get;
		private set;
	}
}
public class ModuleConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("SimClass")]
	public string SimClass
	{
		get;
		private set;
	}

	[XmlAttribute("BuildBaseIndustryCost")]
	public float BuildBaseIndustryCost
	{
		get;
		private set;
	}

	[XmlAttribute("BuildIndustryCostIncrement")]
	public float BuildIndustryCostIncrement
	{
		get;
		private set;
	}

	[XmlAttribute("BuildDuration")]
	public float BuildDuration
	{
		get;
		private set;
	}

	[XmlAttribute("AttackType")]
	public string AttackType
	{
		get;
		private set;
	}

	[XmlAttribute("AITargetType")]
	public string XmlSerializableAITargetType
	{
		get
		{
			return AITargetType.ToString();
		}
		set
		{
			AITargetType = value.ToEnum<AITargetType>();
		}
	}

	[XmlIgnore]
	public AITargetType AITargetType
	{
		get;
		private set;
	}

	[XmlAttribute("NeedRoomPower")]
	public bool NeedRoomPower
	{
		get;
		private set;
	}

	[XmlAttribute("AttractMerchant")]
	public bool AttractMerchant
	{
		get;
		private set;
	}

	[XmlAttribute("Rotate")]
	public bool Rotate
	{
		get;
		private set;
	}

	[XmlAttribute("Unremovable")]
	public bool Unremovable
	{
		get;
		private set;
	}

	[XmlAttribute("HasSpecialBase")]
	public bool HasSpecialBase
	{
		get;
		private set;
	}

	[XmlAttribute("PowersRoom")]
	public bool PowersRoom
	{
		get;
		private set;
	}

	public ModuleConfig()
	{
		NeedRoomPower = true;
	}

	public float GetIndustryCost()
	{
		float num = BuildBaseIndustryCost;
		if (BuildIndustryCostIncrement > 0f)
		{
			Dungeon dungeon = SingletonManager.Get<Dungeon>();
			int aliveMajorModuleCount = dungeon.AliveMajorModuleCount;
			if (aliveMajorModuleCount > 0)
			{
				num += BuildIndustryCostIncrement * (float)aliveMajorModuleCount;
			}
		}
		return num;
	}
}
public class MultiplayerConfig
{
	public static bool OneCrystalPerPlayer;

	public static bool AllPlayersMustSurvive;

	public static bool SplitRoomPowering;

	public static float RoomPowerChangeCooldown = 1f;

	public static bool SplitBluePrints;

	public static bool SplitInventory = true;

	public static bool SplitFIS = true;

	public static bool SplitDust;

	public static bool SplitFISIncome = true;
}
public enum NPCTypeEnum
{
	Default,
	Merchant,
	DeathMerchant
}
public class NPCConfig : MaxedProbabilityConfig
{
	[Serializable]
	public struct NPCConfigPrefab
	{
		public NPCTypeEnum Type;

		public GameObject Prefab;
	}

	public static StaticString NPCDialog_BeginInteraction = "BeginInteraction";

	public static StaticString NPCDialog_EndInteraction = "EndInteraction";

	[XmlAttribute("NPCType")]
	public NPCTypeEnum NPCType
	{
		get;
		protected set;
	}

	[XmlArrayItem(Type = typeof(DialogConfig), ElementName = "Dialog")]
	[XmlArray("Dialogs")]
	public DialogConfig[] Dialogs
	{
		get;
		set;
	}

	[XmlAttribute("AttackType")]
	public string AttackType
	{
		get;
		private set;
	}

	public DialogConfig GetDialogByName(StaticString dialogName)
	{
		for (int i = 0; i < Dialogs.Length; i++)
		{
			if (Dialogs[i].Name == dialogName)
			{
				return Dialogs[i];
			}
		}
		return null;
	}
}
public class NPCMerchantConfig : NPCConfig
{
	public static StaticString NPCDialog_Merchant_PurchaseIntroduction = "PurchaseIntroduction";

	public static StaticString NPCDialog_Merchant_PurchaseItemSelected = "PurchaseItemSelected";

	public static StaticString NPCDialog_Merchant_PurchaseNotEnoughResource = "PurchaseNotEnough";

	public static StaticString NPCDialog_Merchant_PurchaseDone = "PurchaseDone";

	public static StaticString NPCDialog_Merchant_SaleIntroduction = "SaleIntroduction";

	public static StaticString NPCDialog_Merchant_SaleItemSelected = "SaleItemSelected";

	public static StaticString NPCDialog_Merchant_SaleDone = "SaleDone";

	[XmlAttribute("ItemsCountMin")]
	public int ItemsCountMin
	{
		get;
		private set;
	}

	[XmlAttribute("ItemsCountMax")]
	public int ItemsCountMax
	{
		get;
		private set;
	}

	[XmlAttribute("ItemsRelativeLevelMin")]
	public int ItemsRelativeLevelMin
	{
		get;
		private set;
	}

	[XmlAttribute("ItemsRelativeLevelMax")]
	public int ItemsRelativeLevelMax
	{
		get;
		private set;
	}

	[XmlAttribute("IsLimited")]
	public bool IsLimited
	{
		get;
		private set;
	}

	[XmlAttribute("SellsGiftItems")]
	public bool SellsGiftItems
	{
		get;
		private set;
	}

	[XmlArray("IntroDialogs")]
	[XmlArrayItem(Type = typeof(DialogConfig), ElementName = "Dialog")]
	public DialogConfig[] IntroDialogs
	{
		get;
		set;
	}

	[XmlArray("ConstantItems")]
	[XmlArrayItem(Type = typeof(NPCMerchantItemData), ElementName = "Item")]
	public NPCMerchantItemData[] ConstantItems
	{
		get;
		set;
	}

	public NPCMerchantConfig()
	{
		ItemsCountMin = 1;
		ItemsCountMax = 1;
		ItemsRelativeLevelMin = 0;
		ItemsRelativeLevelMax = 0;
	}
}
public class NPCMerchantItemData : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("Rarity")]
	public string Rarity
	{
		get;
		private set;
	}
}
public class ProbabilityConfig : DepthRangesConfig<ProbabilityWeightDepthRangeConfig>, IDatatableElement
{
	public static Dictionary<StaticString, Dictionary<StaticString, int>> OccurrenceCounts
	{
		get;
		private set;
	}

	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("MaxOccurrenceCount")]
	public int MaxOccurrenceCount
	{
		get;
		private set;
	}

	public ProbabilityConfig()
	{
		MaxOccurrenceCount = -1;
	}

	public static T PickRandomElement<T>(int roomOpeningNumber = 0, int roomSurface = 0, int dungeonLevel = 0) where T : ProbabilityConfig
	{
		IDatabase<T> database = Databases.GetDatabase<T>();
		return PickRandomElement(database.GetValues(), roomOpeningNumber, roomSurface, dungeonLevel);
	}

	public static T PickRandomElementByLevelRange<T>(T[] elements, int roomOpeningNumber = 0, float roomSurface = 0f, int dungeonLevelFrom = 0, int dungeonLevelTo = 0) where T : ProbabilityConfig
	{
		string fullName = typeof(T).FullName;
		if (elements.Length < 1)
		{
			Diagnostics.LogError("PickRandomElementByLevelRange<" + fullName + ">: empty element list!");
			return (T)null;
		}
		Dictionary<ProbabilityConfig, float> dictionary = new Dictionary<ProbabilityConfig, float>();
		int num = elements.Length;
		for (int i = 0; i < num; i++)
		{
			T key = elements[i];
			if ((key.MaxOccurrenceCount < 0 || GetOccurrenceCount(fullName, key.Name) < key.MaxOccurrenceCount) && key.IsMatching(dungeonLevelFrom, dungeonLevelTo))
			{
				dictionary.Add(key, key.GetValue(roomOpeningNumber, roomSurface, 0f, dungeonLevelFrom, dungeonLevelTo));
			}
		}
		T result = dictionary.GetWeightedRandom() as T;
		IncrementOccurrenceCount<T>(result.Name);
		return result;
	}

	public static T PickRandomElement<T>(T[] elementArray, int roomOpeningNumber = 0, float roomSurface = 0f, int dungeonLevel = 0) where T : ProbabilityConfig
	{
		return PickRandomElementByLevelRange(elementArray, roomOpeningNumber, roomSurface, dungeonLevel, dungeonLevel);
	}

	public static void SetOccurrenceCount(string typeName, string name, int count)
	{
		AssetOccurrenceCountIsDefined(typeName, name);
		OccurrenceCounts[typeName][name] = count;
	}

	public static void ResetAllOccurrenceCounts()
	{
		OccurrenceCounts = null;
	}

	public static void ResetOccurrenceCountsByType<T>() where T : ProbabilityConfig
	{
		string fullName = typeof(T).FullName;
		if (OccurrenceCounts != null && OccurrenceCounts.ContainsKey(fullName))
		{
			OccurrenceCounts.Remove(fullName);
		}
	}

	public static void IncrementOccurrenceCount<T>(string name, int incrementValue = 1) where T : ProbabilityConfig
	{
		string fullName = typeof(T).FullName;
		AssetOccurrenceCountIsDefined(fullName, name);
		Dictionary<StaticString, int> dictionary;
		Dictionary<StaticString, int> dictionary2 = dictionary = OccurrenceCounts[fullName];
		StaticString key;
		StaticString key2 = key = name;
		int num = dictionary[key];
		dictionary2[key2] = num + incrementValue;
	}

	private static void AssetOccurrenceCountIsDefined(string typeName, string name)
	{
		if (OccurrenceCounts == null)
		{
			OccurrenceCounts = new Dictionary<StaticString, Dictionary<StaticString, int>>();
		}
		if (!OccurrenceCounts.ContainsKey(typeName))
		{
			OccurrenceCounts.Add(typeName, new Dictionary<StaticString, int>());
		}
		if (!OccurrenceCounts[typeName].ContainsKey(name))
		{
			OccurrenceCounts[typeName].Add(name, 0);
		}
	}

	private static int GetOccurrenceCount(string typeName, string name)
	{
		AssetOccurrenceCountIsDefined(typeName, name);
		return OccurrenceCounts[typeName][name];
	}

	public override string ToString()
	{
		return Name;
	}
}
public class ProbabilityWeightDepthRangeConfig : DepthRangeConfig
{
	[XmlElement(Type = typeof(EvolutiveValueConfig), ElementName = "ProbabilityWeight")]
	public EvolutiveValueConfig ProbabilityWeight
	{
		get;
		private set;
	}

	public override float GetValue(int roomOpeningNumber = 0, float roomSurface = 0f, float currentTotalValue = 0f)
	{
		return ProbabilityWeight.GetValue(roomOpeningNumber, roomSurface);
	}
}
[XmlType("Rarity")]
public class RarityConfig : ProbabilityConfig
{
	[XmlAttribute("Cost")]
	public float Cost
	{
		get;
		private set;
	}

	public ItemHeroRarityConfig GetItemHeroRarityConfig()
	{
		IDatabase<ItemHeroRarityConfig> database = Databases.GetDatabase<ItemHeroRarityConfig>();
		Diagnostics.Assert(database != null);
		ItemHeroRarityConfig value = null;
		database.TryGetValue(Name, out value);
		return value;
	}

	public string GetRarityColorHexaValue()
	{
		string hexaKey = string.Empty;
		ItemHeroRarityConfig itemHeroRarityConfig = GetItemHeroRarityConfig();
		if (itemHeroRarityConfig != null)
		{
			AgeUtils.ColorToHexaKey(itemHeroRarityConfig.ColorValue, out hexaKey);
		}
		return hexaKey;
	}
}
public class ShipConfig : IDatatableElement
{
	public class ItemDatatableReference
	{
		[XmlIgnore]
		public StaticString Name
		{
			get;
			private set;
		}

		[XmlAttribute("Name")]
		public string XmlSerializableName
		{
			get
			{
				return Name;
			}
			set
			{
				Name = value;
			}
		}

		[XmlIgnore]
		public StaticString RarityName
		{
			get;
			private set;
		}

		[XmlAttribute("Rarity")]
		public string XmlSerializableRarityName
		{
			get
			{
				return RarityName;
			}
			set
			{
				RarityName = value;
			}
		}
	}

	private string[] filteredUnavailableBluePrints;

	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("AbscissaValue")]
	public int AbscissaValue
	{
		get;
		private set;
	}

	[XmlAttribute("LevelCount")]
	public int LevelCount
	{
		get;
		private set;
	}

	[XmlAttribute("CrystalType")]
	public string CrystalType
	{
		get;
		private set;
	}

	[XmlAttribute("ForbidPause")]
	public bool ForbidPause
	{
		get;
		private set;
	}

	[XmlAttribute("ForbidHeal")]
	public bool ForbidHeal
	{
		get;
		private set;
	}

	[XmlAttribute("ForbidStrategyHealthRegen")]
	public bool ForbidStrategyHealthRegen
	{
		get;
		private set;
	}

	[XmlAttribute("ForbiddenAITarget")]
	public string ForbiddenAITarget
	{
		get;
		private set;
	}

	[XmlAttribute("ForbidMultiplayer")]
	public bool ForbidMultiplayer
	{
		get;
		private set;
	}

	[XmlAttribute("ForbidUnpower")]
	public bool ForbidUnpower
	{
		get;
		private set;
	}

	[XmlAttribute("UseWallProps")]
	public bool UseWallProps
	{
		get;
		private set;
	}

	[XmlAttribute("UseAlternativePulseFX")]
	public bool UseAlternativePulseFX
	{
		get;
		private set;
	}

	[XmlAttribute("UseLightColorShift")]
	public bool UseLightColorShift
	{
		get;
		private set;
	}

	[XmlArrayItem("BluePrint")]
	[XmlArray("InitialBluePrints")]
	public string[] InitBluePrints
	{
		get;
		private set;
	}

	[XmlArray("UnavailableBluePrints")]
	[XmlArrayItem("BluePrint")]
	public string[] UnavailableBluePrints
	{
		get;
		private set;
	}

	[XmlIgnore]
	public string[] FilteredUnavailableBluePrints
	{
		get
		{
			if (filteredUnavailableBluePrints == null)
			{
				DLCController dlcManager = SingletonManager.Get<DLCController>();
				List<string> list = (from bp in Databases.GetDatabase<BluePrintConfig>().GetValues()
					where !dlcManager.IsObjectAvailable(DLCObjectType.BluePrint, bp.Name)
					select bp.Name.ToString()).ToList();
				list.AddRange(UnavailableBluePrints);
				filteredUnavailableBluePrints = list.ToArray();
			}
			return filteredUnavailableBluePrints;
		}
	}

	[XmlArray("UnavailableItems")]
	[XmlArrayItem("Item")]
	public string[] UnavailableItems
	{
		get;
		private set;
	}

	[XmlArrayItem(Type = typeof(ItemDatatableReference), ElementName = "Item")]
	[XmlArray("InitialItems")]
	public ItemDatatableReference[] InitialItems
	{
		get;
		private set;
	}

	public ShipConfig()
	{
		CrystalType = "Normal";
	}

	public string GetLocalizedName(bool locked = false)
	{
		return AgeLocalizer.Instance.LocalizeString("%ShipTitle_" + ((!locked) ? string.Empty : "Locked_") + Name);
	}

	public string GetLocalizedDescription()
	{
		return AgeLocalizer.Instance.LocalizeString("%ShipDescription_" + Name);
	}

	public string GetLocalizedUnlockDescription()
	{
		return AgeLocalizer.Instance.LocalizeString("%ShipDescription_Locked_" + Name);
	}
}
public class SkillConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("IsActive")]
	public bool IsActive
	{
		get;
		private set;
	}

	[XmlAttribute("Duration")]
	public float Duration
	{
		get;
		private set;
	}

	[XmlAttribute("DeactivateOnNewTurn")]
	public bool DeactivateOnNewTurn
	{
		get;
		private set;
	}

	[XmlAttribute("CooldownTurnsCount")]
	public int CooldownTurnsCount
	{
		get;
		private set;
	}

	[XmlAttribute("OwnerVFXPath")]
	public string OwnerVFXPath
	{
		get;
		private set;
	}

	[XmlAttribute("TargetVFXPath")]
	public string TargetVFXPath
	{
		get;
		private set;
	}

	[XmlAttribute("OwnerSFXPath")]
	public string OwnerSFXPath
	{
		get;
		private set;
	}

	[XmlAttribute("TargetSFXPath")]
	public string TargetSFXPath
	{
		get;
		private set;
	}

	[XmlAttribute("DialogVFXPath")]
	public string DialogVFXPath
	{
		get;
		private set;
	}

	[XmlAttribute("Damages")]
	public float Damages
	{
		get;
		private set;
	}

	[XmlAttribute("DamagesRatio")]
	public float DamagesRatio
	{
		get;
		private set;
	}

	[XmlAttribute("DamagesMaxValue")]
	public float DamagesMaxValue
	{
		get;
		private set;
	}

	[XmlAttribute("DamagesTargetsPath")]
	public string DamagesTargetsPath
	{
		get;
		private set;
	}

	[XmlAttribute("AdditionalLocalizationKey")]
	public string AdditionalLocalizationKey
	{
		get;
		private set;
	}

	[XmlIgnore]
	public string BaseName
	{
		get;
		private set;
	}

	[XmlIgnore]
	public int Level
	{
		get;
		private set;
	}

	public SkillConfig()
	{
		DamagesMaxValue = float.PositiveInfinity;
	}

	public void Init()
	{
		if (BaseName == null)
		{
			string text = Name.ToString();
			int num = text.IndexOf("_LVL");
			if (num != -1)
			{
				BaseName = text.Substring(0, num);
				int.TryParse(text[text.Length - 1].ToString(), out int result);
				Level = result;
			}
			else
			{
				BaseName = text;
				Level = 1;
			}
		}
	}
}
public class SpawnableElement : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("SpawnProb")]
	public int SpawnProb
	{
		get;
		private set;
	}

	[XmlAttribute("MaxCount")]
	public int MaxCount
	{
		get;
		private set;
	}
}
public class TilesetConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("AmbianceSFXPath")]
	public string AmbianceSFXPath
	{
		get;
		private set;
	}

	[XmlAttribute("DoorOpeningSFXPath")]
	public string DoorOpeningSFXPath
	{
		get;
		private set;
	}
}
public class TutorialStepConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Text")]
	public string Text
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}

	[XmlAttribute("Condition")]
	public TutorialCondition Condition
	{
		get;
		private set;
	}

	[XmlAttribute("ArrowTarget3D")]
	public string ArrowTarget3D
	{
		get;
		private set;
	}

	[XmlAttribute("ArrowTarget2D")]
	public string ArrowTarget2D
	{
		get;
		private set;
	}
}
public class UnlockConfig : IDatatableElement
{
	[XmlIgnore]
	public StaticString Name
	{
		get;
		private set;
	}

	[XmlAttribute("Type")]
	public string Type
	{
		get;
		private set;
	}

	[XmlAttribute("Name")]
	public string XmlSerializableName
	{
		get
		{
			return Name;
		}
		set
		{
			Name = value;
		}
	}
}
[RequireComponent(typeof(UniqueID))]
public abstract class SimMonoBehaviour : MonoBehaviour
{
	private class TimedSimulationDescriptor
	{
		public SimulationDescriptor simDesc;

		public float timer;

		public TimedSimulationDescriptor(SimulationDescriptor simDesc, float timer)
		{
			this.simDesc = simDesc;
			this.timer = timer;
		}
	}

	public delegate void SimRefreshedHandler();

	public delegate void SimChildAddedHandler(SimulationObject simObj);

	public delegate void SimChildRemovedHandler(SimulationObject simObj);

	private static IDatabase<SimulationDescriptor> simDescDB;

	private static Dictionary<StaticString, SimMonoBehaviour> simMonoBhvsByName = new Dictionary<StaticString, SimMonoBehaviour>();

	private bool isLoaded;

	private SimulationObject simObj;

	private SimulationObjectWrapper simWrapper;

	private List<SimMonoBehaviour> children = new List<SimMonoBehaviour>();

	private List<TimedSimulationDescriptor> timedDescriptors;

	public static List<TemporarySimDescriptor> TempSimDescs
	{
		get;
		private set;
	}

	public SimMonoBehaviour SimParent
	{
		get;
		private set;
	}

	public List<SimMonoBehaviour> SimChildren => children;

	public UniqueID UniqueID
	{
		get;
		protected set;
	}

	public event SimRefreshedHandler OnSimRefreshed;

	public event SimChildAddedHandler OnSimChildAdded;

	public event SimChildRemovedHandler OnSimChildRemoved;

	public static SimulationDescriptor[] GetDBDescriptorsByType(StaticString descType)
	{
		SimulationDescriptor[] values = GetSimDescDatabase().GetValues();
		List<SimulationDescriptor> list = new List<SimulationDescriptor>();
		SimulationDescriptor[] array = values;
		foreach (SimulationDescriptor simulationDescriptor in array)
		{
			if (simulationDescriptor.Type == descType)
			{
				list.Add(simulationDescriptor);
			}
		}
		return list.ToArray();
	}

	public static SimulationDescriptor GetDBDescriptorByName(StaticString descType)
	{
		return GetSimDescDatabase().GetValue(descType);
	}

	public static IDatabase<SimulationDescriptor> GetSimDescDatabase()
	{
		if (simDescDB == null)
		{
			simDescDB = Databases.GetDatabase<SimulationDescriptor>();
		}
		return simDescDB;
	}

	public static SimMonoBehaviour GetSimMonoBhvByName(StaticString name)
	{
		if (!simMonoBhvsByName.ContainsKey(name))
		{
			Diagnostics.LogError("No SimMonoBehaviour named \"" + name + "\" found!");
			return null;
		}
		return simMonoBhvsByName[name];
	}

	public static void ClearSimMonoBhvsByName()
	{
		simMonoBhvsByName.Clear();
	}

	public static void ClearTemporarySimDescriptors()
	{
		if (TempSimDescs != null)
		{
			TempSimDescs.Clear();
		}
	}

	public static void RestoreTempSimDescs(TemporarySimDescriptor[] tempSimDescs)
	{
		for (int i = 0; i < tempSimDescs.Length; i++)
		{
			TemporarySimDescriptor temporarySimDescriptor = tempSimDescs[i];
			SimMonoBehaviour simMonoBehaviour = UniqueIDManager.Get(UniqueIDManager.GetTypeIDByName(temporarySimDescriptor.SimObjType).ToString(), temporarySimDescriptor.SimObjID) as SimMonoBehaviour;
			if (simMonoBehaviour != null)
			{
				simMonoBehaviour.AddTemporarySimDescriptor(temporarySimDescriptor.DescName, temporarySimDescriptor.EndTurn);
			}
			else
			{
				Diagnostics.LogError("RestoreTempSimDescs: Unable to get {0}#{1}!", temporarySimDescriptor.SimObjType, temporarySimDescriptor.SimObjID);
			}
		}
	}

	public static float ApplyDescModifier(float value, StaticString simPropName, SimulationDescriptor simDesc, string path = null)
	{
		if (simDesc != null)
		{
			for (int i = 0; i < simDesc.SimulationModifierDescriptors.Length; i++)
			{
				SingleSimulationModifierDescriptor singleSimulationModifierDescriptor = simDesc.SimulationModifierDescriptors[i] as SingleSimulationModifierDescriptor;
				if (singleSimulationModifierDescriptor != null && singleSimulationModifierDescriptor.TargetPropertyName == simPropName && (path == null || string.IsNullOrEmpty(singleSimulationModifierDescriptor.Path.ToString()) || singleSimulationModifierDescriptor.Path.ToString().Contains(path)) && float.TryParse(singleSimulationModifierDescriptor.Value, out float result))
				{
					switch (singleSimulationModifierDescriptor.Operation)
					{
					case SimulationModifierDescriptor.ModifierOperation.Addition:
						return value + result;
					case SimulationModifierDescriptor.ModifierOperation.Division:
						return value / result;
					case SimulationModifierDescriptor.ModifierOperation.Power:
						return Mathf.Pow(value, result);
					case SimulationModifierDescriptor.ModifierOperation.Multiplication:
						return value * result;
					case SimulationModifierDescriptor.ModifierOperation.Subtraction:
						return value - result;
					}
					Diagnostics.LogWarning("Unsuported ModifierOperation: " + singleSimulationModifierDescriptor.Operation);
				}
			}
		}
		return value;
	}

	public SimulationObject GetSimObj()
	{
		AssertIsLoaded();
		return simObj;
	}

	public SimulationObjectWrapper GetSimWrapper()
	{
		AssertIsLoaded();
		return simWrapper;
	}

	public void AssertIsLoaded()
	{
		if (!isLoaded)
		{
			LoadSimObj();
		}
	}

	public List<SimulationObject> GetChildrenSimObj()
	{
		AssertIsLoaded();
		return simObj.Children;
	}

	public List<SimulationObject> GetChildrenSimObjByType(StaticString type)
	{
		AssertIsLoaded();
		return simObj.Children.FindAll((SimulationObject child) => child.GetDescriptorFromType(type) != null);
	}

	public List<SimMonoBehaviour> GetSimChildrenByType(StaticString type)
	{
		AssertIsLoaded();
		return children.FindAll((SimMonoBehaviour child) => child.GetSimDescriptorByType(type) != null);
	}

	public void AddSimChild(SimMonoBehaviour simMB, bool refresh = true)
	{
		AssertIsLoaded();
		simMB.AssertIsLoaded();
		simObj.AddChild(simMB.simObj);
		if (refresh)
		{
			simMB.RefreshSim(refreshParent: false);
			RefreshSim();
		}
		simMB.SimParent = this;
		children.Add(simMB);
		if (this.OnSimChildAdded != null)
		{
			this.OnSimChildAdded(simMB.simObj);
		}
	}

	public void AddSimChild(SimulationObjectWrapper simObjWrapper, bool refresh = true)
	{
		AssertIsLoaded();
		simObj.AddChild(simObjWrapper);
		if (refresh)
		{
			RefreshSim();
		}
		if (this.OnSimChildAdded != null)
		{
			this.OnSimChildAdded(simObjWrapper.SimulationObject);
		}
	}

	public void RemoveSimChild(SimMonoBehaviour simMB, bool refresh = true)
	{
		AssertIsLoaded();
		simMB.AssertIsLoaded();
		simObj.RemoveChild(simMB.simObj);
		if (refresh)
		{
			simMB.RefreshSim(refreshParent: false);
			RefreshSim();
		}
		simMB.SimParent = null;
		children.Remove(simMB);
		if (this.OnSimChildRemoved != null)
		{
			this.OnSimChildRemoved(simMB.simObj);
		}
	}

	public void RemoveSimChild(SimulationObjectWrapper simObjWrapper, bool refresh = true)
	{
		AssertIsLoaded();
		simObj.RemoveChild(simObjWrapper);
		if (refresh)
		{
			RefreshSim();
		}
		if (this.OnSimChildRemoved != null)
		{
			this.OnSimChildRemoved(simObjWrapper.SimulationObject);
		}
	}

	public void RefreshSim(bool refreshParent = true, bool refreshChildren = false)
	{
		AssertIsLoaded();
		simObj.Refresh();
		if (refreshParent && SimParent != null)
		{
			SimParent.RefreshSim();
		}
		if (refreshChildren && children != null)
		{
			foreach (SimMonoBehaviour child in children)
			{
				child.RefreshSim(refreshParent: false);
			}
		}
		if (this.OnSimRefreshed != null)
		{
			this.OnSimRefreshed();
		}
	}

	public void AddSimDescriptor(string descName, bool refresh = true)
	{
		AddSimDescriptor(GetSimDescDatabase().GetValue(descName), refresh);
	}

	public void AddSimDescriptor(SimulationDescriptor simDescriptor, bool refresh = true)
	{
		AssertIsLoaded();
		bool flag = true;
		if (simDescriptor != null && simDescriptor.SimulationPropertyDescriptors != null)
		{
			for (int i = 0; i < simDescriptor.SimulationPropertyDescriptors.Length; i++)
			{
				if (!(simDescriptor.SimulationPropertyDescriptors[i].Name == SimulationProperties.Duration))
				{
					continue;
				}
				SimulationPropertyDescriptor simulationPropertyDescriptor = simDescriptor.SimulationPropertyDescriptors[i];
				TimedSimulationDescriptor timedSimulationDescriptor = null;
				for (int j = 0; j < timedDescriptors.Count; j++)
				{
					if (timedDescriptors[j].simDesc.Name == simDescriptor.Name)
					{
						timedSimulationDescriptor = timedDescriptors[j];
						timedSimulationDescriptor.timer = simulationPropertyDescriptor.BaseValue;
						flag = false;
						break;
					}
				}
				if (timedSimulationDescriptor == null)
				{
					timedDescriptors.Add(new TimedSimulationDescriptor(simDescriptor, simulationPropertyDescriptor.BaseValue));
				}
				break;
			}
		}
		if (flag)
		{
			simObj.AddDescriptor(simDescriptor);
		}
		if (refresh)
		{
			RefreshSim();
		}
	}

	public void AddTemporarySimDescriptor(string descName, int endTurn, bool refresh = true)
	{
		AddSimDescriptor(descName, refresh);
		if (TempSimDescs == null)
		{
			TempSimDescs = new List<TemporarySimDescriptor>();
		}
		TempSimDescs.Add(new TemporarySimDescriptor
		{
			SimObjType = GetSimClass().ToString(),
			SimObjID = UniqueID.ID,
			DescName = descName,
			EndTurn = endTurn
		});
		if (TempSimDescs.Count == 1)
		{
			IGameEventService service = Services.GetService<IGameEventService>();
			service.OnDungeonTurnChanged -= OnDungeonTurnChanged;
			service.OnDungeonTurnChanged += OnDungeonTurnChanged;
		}
	}

	private static void OnDungeonTurnChanged()
	{
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		for (int i = 0; i < TempSimDescs.Count; i++)
		{
			TemporarySimDescriptor item = TempSimDescs[i];
			if (dungeon.Turn >= item.EndTurn)
			{
				SimMonoBehaviour simMonoBehaviour = (SimMonoBehaviour)UniqueIDManager.Get(UniqueIDManager.GetTypeIDByName(item.SimObjType).ToString(), item.SimObjID);
				simMonoBehaviour.RemoveSimDescriptor(item.DescName);
				TempSimDescs.Remove(item);
				i--;
			}
		}
		if (TempSimDescs.Count < 1)
		{
			Services.GetService<IGameEventService>().OnDungeonTurnChanged -= OnDungeonTurnChanged;
		}
	}

	public void RemoveSimDescriptor(string descName, bool refresh = true)
	{
		AssertIsLoaded();
		simObj.RemoveDescriptorByName(descName);
		if (refresh)
		{
			RefreshSim();
		}
	}

	public void RemoveSimDescriptor(SimulationDescriptor simDescriptor, bool refresh = true)
	{
		RemoveSimDescriptor(simDescriptor.Name, refresh);
	}

	public float GetSimPropertyValue(StaticString name)
	{
		AssertIsLoaded();
		return simObj.GetPropertyValue(name);
	}

	public void SetSimPropertyBaseValue(StaticString name, float value, bool refresh = true)
	{
		AssertIsLoaded();
		simObj.SetPropertyBaseValue(name, value);
		if (refresh)
		{
			RefreshSim();
		}
	}

	public SimulationDescriptor GetSimDescriptorByType(StaticString descType)
	{
		AssertIsLoaded();
		return simObj.GetDescriptorFromType(descType);
	}

	protected virtual void Awake()
	{
		UniqueID = GetComponent<UniqueID>();
		timedDescriptors = new List<TimedSimulationDescriptor>();
	}

	protected virtual void Update()
	{
		for (int i = 0; i < timedDescriptors.Count; i++)
		{
			timedDescriptors[i].timer -= Time.deltaTime;
			if (timedDescriptors[i].timer <= 0f)
			{
				RemoveSimDescriptor(timedDescriptors[i].simDesc);
				timedDescriptors.RemoveAt(i);
				i--;
			}
		}
	}

	protected virtual Type GetSimClass()
	{
		return GetType();
	}

	private void LoadSimObj()
	{
		if (isLoaded)
		{
			Diagnostics.LogError("Simulation data already loaded!");
			return;
		}
		if (UniqueID.ID == 0)
		{
			Diagnostics.LogError(base.name + " > LoadSimObj: requesting unique ID (shouldn't be needed!)");
			UniqueID.RequestUniqueID();
		}
		StaticString staticString = (string)UniqueID.GetCategoryClearName() + "#" + UniqueID.ID;
		simObj = new SimulationObject(staticString);
		simWrapper = new SimulationObjectWrapper(simObj);
		simObj.AddDescriptor(GetSimDescDatabase().GetValue(GetSimClass().ToString()));
		simObj.Refresh();
		isLoaded = true;
		simMonoBhvsByName.Add(staticString, this);
	}
}
public static class SimulationProperties
{
	public static readonly StaticString SimDescTypeClass = "Class";

	public static readonly StaticString SimDescTypeHero = "Hero";

	public static readonly StaticString SimDescTypeRoom = "Room";

	public static readonly StaticString SimDescTypeMob = "Mob";

	public static readonly StaticString SimDescTypeItem = "Item";

	public static readonly StaticString SimDescTypeItemHero = "ItemHero";

	public static readonly StaticString SimDescTypeMajorModule = "MajorModule";

	public static readonly StaticString SimDescTypeMinorModule_Support = "MinorModule_Support";

	public static readonly StaticString SimDescTypeMinorModule_Offense = "MinorModule_Offense";

	public static readonly StaticString SimDescTypeMinorModule_Debuff = "MinorModule_Debuff";

	public static readonly StaticString Duration = "Duration";

	public static readonly StaticString MaxHealth = "MaxHealth";

	public static readonly StaticString HealthBarHeight = "HealthBarHeight";

	public static readonly StaticString HealFoodCostCoeff = "HealFoodCostCoeff";

	public static readonly StaticString Defense = "Defense";

	public static readonly StaticString MoveSpeed = "MoveSpeed";

	public static readonly StaticString MoveSpeedReal = "MoveSpeedReal";

	public static readonly StaticString AttackRange = "AttackRange";

	public static readonly StaticString AttackPower = "AttackPower";

	public static readonly StaticString MaximumAttackPower = "MaximumAttackPower";

	public static readonly StaticString ScienceAttackPowerBonus = "ScienceAttackPowerBonus";

	public static readonly StaticString AttackHitCount = "AttackHitCount";

	public static readonly StaticString AttackCooldown = "AttackCooldown";

	public static readonly StaticString AttackBurnDamage = "AttackBurnDamage";

	public static readonly StaticString AttackBurnDuration = "AttackBurnDuration";

	public static readonly StaticString ZoneAttackRadius = "ZoneAttackRadius";

	public static readonly StaticString ZoneAttackPowerOnMobs = "ZoneAttackPowerOnMobs";

	public static readonly StaticString ZoneAttackPowerOnHeroes = "ZoneAttackPowerOnHeroes";

	public static readonly StaticString ZoneAttackPowerOnModules = "ZoneAttackPowerOnModules";

	public static readonly StaticString ZoneAttackPowerOnNPCs = "ZoneAttackPowerOnNPCs";

	public static readonly StaticString AttackPowerOnDoors = "AttackPowerOnDoors";

	public static readonly StaticString ModuleOperatorWit = "ModuleOperatorWit";

	public static readonly StaticString HPByKill = "HPByKill";

	public static readonly StaticString FIDSQuantityPerKill = "FIDSQuantityPerKill";

	public static readonly StaticString FIDSResourcePerKill = "FIDSResourcePerKill";

	public static readonly StaticString FIDSRewardKillCount = "FIDSRewardKillCount";

	public static readonly StaticString TameKillCountForLevelUp = "TameKillCountForLevelUp";

	public static readonly StaticString SelfDamage = "SelfDamage";

	public static readonly StaticString SelfDestructDelayMin = "SelfDestructDelayMin";

	public static readonly StaticString SelfDestructDelayMax = "SelfDestructDelayMax";

	public static readonly StaticString HeatCooling = "HeatCooling";

	public static readonly StaticString HeatMaximum = "HeatMaximum";

	public static readonly StaticString OverheatingDuration = "OverheatingDuration";

	public static readonly StaticString LureMaxEnergy = "LureMaxEnergy";

	public static readonly StaticString LureActivationDelay = "LureActivationDelay";

	public static readonly StaticString DustLootAmountMin = "DustLootAmount";

	public static readonly StaticString DustLootAmountMax = "DustLootAmountMax";

	public static readonly StaticString DustLootProbability = "DustLootProbability";

	public static readonly StaticString DelayUp = "DelayUp";

	public static readonly StaticString RoomDustBonus = "RoomDustBonus";

	public static readonly StaticString FoodBonusPerMobKilled = "FoodBonusPerMobKilled";

	public static readonly StaticString IndustryBonusPerMobKilled = "IndustryBonusPerMobKilled";

	public static readonly StaticString DefenseBonusPerMobKilled = "DefenseBonusPerMobKilled";

	public static readonly StaticString DefenseBonusPerMobKilled_Max = "DefenseBonusPerMobKilled_Max";

	public static readonly StaticString DefenseBonusPerMobKilled_TimeMalus = "DefenseBonusPerMobKilled_TimeMalus";

	public static readonly StaticString DefenseBonusFromMobKills = "DefenseBonusFromMobKills";

	public static readonly StaticString AttackBonusPerMobKilled = "AttackBonusPerMobKilled";

	public static readonly StaticString AttackBonusPerMobKilled_Max = "AttackBonusPerMobKilled_Max";

	public static readonly StaticString AttackBonusPerMobKilled_TimeMalus = "AttackBonusPerMobKilled_TimeMalus";

	public static readonly StaticString AttackBonusFromMobKills = "AttackBonusFromMobKills";

	public static readonly StaticString FISBonusPerRoomMobKilled = "FISBonusPerRoomMobKilled";

	public static readonly StaticString IsAttackedByOneMob = "IsAttackedByOneMob";

	public static readonly StaticString MobsAggro = "MobsAggro";

	public static readonly StaticString Stealth = "Stealth";

	public static readonly StaticString RepairFirst = "RepairFirst";

	public static readonly StaticString Troubled = "Troubled";

	public static readonly StaticString InflictTroubledChance = "InflictTroubledChance";

	public static readonly StaticString Poison = "Poison";

	public static readonly StaticString InflictPoisonChance = "InflictPoisonChance";

	public static readonly StaticString MobTaming = "MobTaming";

	public static readonly StaticString MobTamedHealPct = "MobTamedHealPct";

	public static readonly StaticString IsTamed = "IsTamed";

	public static readonly StaticString NoCrystalCarryDescriptor = "NoCrystalCarryDescriptor";

	public static readonly StaticString RespawnRoomCount = "RespawnRoomCount";

	public static readonly StaticString LifeHealPctOnRespawn = "LifeHealPctOnRespawn";

	public static readonly StaticString Wit = "Wit";

	public static readonly StaticString OperateWit = "OperateWit";

	public static readonly StaticString RepairWit = "RepairWit";

	public static readonly StaticString RuinAnalysisWit = "RuinAnalysisWit";

	public static readonly StaticString ReparationRate = "ReparationRate";

	public static readonly StaticString RepairCapacity = "RepairCapacity";

	public static readonly StaticString OperateCapacity = "OperateCapacity";

	public static readonly StaticString SupportHealingEffect = "SupportHealingEffect";

	public static readonly StaticString SupportBoosterEffect = "SupportBoosterEffect";

	public static readonly StaticString SupportSonarEffect = "SupportSonarEffect";

	public static readonly StaticString DebuffSpeedReducerEffect = "DebuffSpeedReducerEffect";

	public static readonly StaticString StayInRoom = "StayInRoom";

	public static readonly StaticString SuicideTimer = "SuicideTimer";

	public static readonly StaticString HealthRegen = "HealthRegen";

	public static readonly StaticString HealthRegenGamePhaseIndependent = "HealthRegenGamePhaseIndependent";

	public static readonly StaticString DamageOverTime = "DamageOverTime";

	public static readonly StaticString Food = "Food";

	public static readonly StaticString MinFood = "MinFood";

	public static readonly StaticString MaxFood = "MaxFood";

	public static readonly StaticString Industry = "Industry";

	public static readonly StaticString MinIndustry = "MinIndustry";

	public static readonly StaticString MaxIndustry = "MaxIndustry";

	public static readonly StaticString Dust = "Dust";

	public static readonly StaticString MinDust = "MinDust";

	public static readonly StaticString MaxDust = "MaxDust";

	public static readonly StaticString Science = "Science";

	public static readonly StaticString MinScience = "MinScience";

	public static readonly StaticString MaxScience = "MaxScience";

	public static readonly StaticString Skill_A0039_Effect = "Skill_A0039_Effect";

	public static readonly StaticString Skill_A0039_ZoneAttackRadius = "Skill_A0039_ZoneAttackRadius";

	public static readonly StaticString Skill_A0039_AttackPower = "Skill_A0039_AttackPower";

	public static readonly StaticString InitFoodStock = "InitFoodStock";

	public static readonly StaticString InitIndustryStock = "InitIndustryStock";

	public static readonly StaticString InitDustStock = "InitDustStock";

	public static readonly StaticString InitScienceStock = "InitScienceStock";

	public static readonly StaticString ScoreModifier = "ScoreModifier";

	public static readonly StaticString InitDustStockPctBonus = "InitDustStockPctBonus";

	public static readonly StaticString InitDustStockBonusMax = "InitDustStockBonusMax";

	public static readonly StaticString FoodProd = "FoodProd";

	public static readonly StaticString IndustryProd = "IndustryProd";

	public static readonly StaticString DustProd = "DustProd";

	public static readonly StaticString ScienceProd = "ScienceProd";

	public static readonly StaticString RoomPowerDustCost = "RoomPowerDustCost";

	public static readonly StaticString DustHealthValue = "DustHealthValue";

	public static readonly StaticString MaxDustStock = "MaxDustStock";

	public static readonly StaticString OperatorWit = "OperatorWit";

	public static readonly StaticString ReparatorWit = "ReparatorWit";

	public static readonly StaticString WeaponSlot = "WeaponSlot";

	public static readonly StaticString ArmorSlot = "ArmorSlot";

	public static readonly StaticString HeadSlot = "HeadSlot";

	public static readonly StaticString Cost = "Cost";

	public static readonly StaticString SellingCost = "SellingCost";

	public static readonly StaticString GiftItemCost = "GiftItemCost";

	public static readonly StaticString ModuleDamagePerTurn = "ModuleDamagePerTurn";

	public static readonly StaticString ResearchingBP = "ResearchingBP";

	public static readonly StaticString UpcomingPositiveEvents = "UpcomingPositiveEvents";

	public static readonly StaticString ToxicCloud = "ToxicCloud";

	public static readonly StaticString PopulationWeight = "PopulationWeight";

	public static readonly StaticString SimDescDungeonResearchingBP = "Dungeon_ResearchingBP";

	public static readonly StaticString SimDescLevelEndless = "Dungeon_Endless";

	public static readonly StaticString SimDescHeroHasCrystal = "HeroHasCrystal";

	public static readonly StaticString SimDescMobWaveMod = "Mob_WaveMod";

	public static readonly StaticString SimDescMobExitWaveMod = "Mob_ExitWaveMod";

	public static readonly StaticString SimDescRoomIsPowered = "RoomIsPowered";

	public static readonly StaticString SimDescRoomIsPoweredByAnotherPlayer = "RoomIsPoweredByAnotherPlayer";

	public static readonly StaticString SimDescRoomToxicCloud = "RoomToxicCloud";

	public static readonly StaticString SimDescMajorModuleUnpowered = "MajorModule_Unpowered";

	public static readonly StaticString SimDescMinorModuleUnpowered = "MinorModule_Unpowered";

	public static readonly StaticString SpecialModule_Crystal = "SpecialModule_Crystal";

	public static readonly StaticString SpecialModule_Artifact = "SpecialModule_Artifact";

	public static readonly StaticString SpecialModule_Stele = "SpecialModule_Stele";

	public static readonly StaticString SpecialModule_DustFactory = "SpecialModule_DustFactory";

	public static readonly StaticString SpecialModule_CryoCapsule = "SpecialModule_CryoCapsule";

	public static readonly StaticString AttackBurnSuffix = "_AttackBurn";

	public static readonly StaticString SkillEffectPrefix = "Skill_";

	public static readonly StaticString SkillEffectSuffix = "_Effect";
}
public abstract class SpawnableSimMonoBehaviour<T> : SimMonoBehaviour where T : SpawnableElement
{
	private static Dictionary<Type, Dictionary<float, StaticString>> elementSpawnProbsByType = new Dictionary<Type, Dictionary<float, StaticString>>();

	private static Dictionary<Type, float> totalSpawnProbByType = new Dictionary<Type, float>();

	private static Dictionary<Type, Dictionary<StaticString, int>> spawnCountByType = new Dictionary<Type, Dictionary<StaticString, int>>();

	public static StaticString PickRandomElementName()
	{
		Type typeFromHandle = typeof(T);
		IDatabase<T> database = Databases.GetDatabase<T>();
		if (!elementSpawnProbsByType.ContainsKey(typeFromHandle) || elementSpawnProbsByType[typeFromHandle] == null)
		{
			elementSpawnProbsByType[typeFromHandle] = new Dictionary<float, StaticString>();
			totalSpawnProbByType[typeFromHandle] = 0f;
			spawnCountByType[typeFromHandle] = new Dictionary<StaticString, int>();
			T[] values = database.GetValues();
			for (int i = 0; i < values.Length; i++)
			{
				T val = values[i];
				Dictionary<Type, float> dictionary;
				Dictionary<Type, float> dictionary2 = dictionary = totalSpawnProbByType;
				Type key;
				Type key2 = key = typeFromHandle;
				float num = dictionary[key];
				dictionary2[key2] = num + (float)val.SpawnProb;
				elementSpawnProbsByType[typeFromHandle].Add(totalSpawnProbByType[typeFromHandle], val.Name);
				spawnCountByType[typeFromHandle].Add(val.Name, 0);
			}
		}
		float num2 = RandomGenerator.RangeFloat(0f, totalSpawnProbByType[typeFromHandle]);
		StaticString staticString = null;
		foreach (KeyValuePair<float, StaticString> item in elementSpawnProbsByType[typeFromHandle])
		{
			StaticString value = item.Value;
			T value2 = database.GetValue(value);
			int maxCount = value2.MaxCount;
			if ((maxCount < 0 || spawnCountByType[typeFromHandle][value] < maxCount) && num2 <= item.Key)
			{
				staticString = value;
				break;
			}
		}
		if (staticString != null)
		{
			Dictionary<StaticString, int> dictionary3;
			Dictionary<StaticString, int> dictionary4 = dictionary3 = spawnCountByType[typeFromHandle];
			StaticString key3;
			StaticString key4 = key3 = staticString;
			int num3 = dictionary3[key3];
			dictionary4[key4] = num3 + 1;
		}
		return staticString;
	}
}
public struct TemporarySimDescriptor
{
	public string SimObjType;

	public int SimObjID;

	public StaticString DescName;

	public int EndTurn;
}
[Serializable]
public class NoSteamManager : Manager, IPlatformService, IService
{
	public bool IsPlatformSpecificRunning => false;

	public ulong UserId
	{
		get;
		private set;
	}

	public Steamworks.SteamUser SteamUser
	{
		get;
		private set;
	}

	public event EventHandler<UserChangedEventArgs> OnUserSignedIn;

	public event EventHandler<UserChangedEventArgs> OnUserChanged;

	public event EventHandler<UserChangedEventArgs> OnUserSignOutStarted;

	public event EventHandler<UserChangedEventArgs> OnUserSignedOut;

	public event EventHandler<SignInCompleteEventArgs> OnUserSignInMenuClosed;

	public event EventHandler<EventArgs> OnCurrentUserChanged;

	public event EventHandler<EventArgs> OnXboxUserProfileLoaded;

	public event EventHandler<SteamGameOverlayActivatedEventArgs> SteamGameOverlayActivated;

	public event EventHandler<SteamGameLobbyJoinRequestedEventArgs> SteamGameLobbyJoinRequested;

	public event EventHandler<SteamGameRichPresenceJoinRequestedEventArgs> SteamGameRichPresenceJoinRequested;

	public event EventHandler<SteamShutdownRequestedEventArgs> SteamShutdownRequested;

	public event EventHandler<SteamShutdownEventArgs> SteamShutdown;

	public string GetCurrentGameLanguage()
	{
		return string.Empty;
	}

	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		Services.AddService((IPlatformService)this);
		SetLastError(0, "Skipping the Steam API...");
	}
}
[Serializable]
public class NoSteamNetworkingManager : Manager, INetworkingService, IService
{
	public bool IsMultiplayerAvailable => false;

	public event EventHandler<NetworkingMessageReceivedEventArgs> MessageReceived;

	public event EventHandler<NetworkingMessageReceivedEventArgs> GameServerMessageReceived;

	public event EventHandler<ConnectionStateChangedEventArgs> ConnectionStateChanged;

	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		Services.AddService((INetworkingService)this);
		SetLastError(0, "Skipping the Steam API...");
	}

	public bool IsOnline()
	{
		return true;
	}

	public void RegisterMessageClass<T>() where T : Message, new()
	{
	}

	public void UnregisterMessageClass<T>() where T : Message, new()
	{
	}

	public void OpenP2PSessionWithUser(ulong userID)
	{
	}

	public void CloseP2PSessionWithUser(ulong steamID, bool isHost)
	{
	}

	public bool SendP2PMessage(ulong steamIDRemote, byte[] message, Steamworks.SteamNetworking.EP2PSend sendMode, bool isHost)
	{
		return false;
	}

	public void AcceptP2PSessionWithUser(ulong id, bool isHost)
	{
	}
}
[Serializable]
public class SteamManager : Amplitude.Unity.Steam.SteamManager
{
}
[Serializable]
public class SteamNetworkingManager : Amplitude.Unity.Steam.SteamNetworkingManager
{
}
public class AgeTransformAutoCenter : MonoBehaviour
{
	private AgeTransform tfm;

	private void Awake()
	{
		tfm = GetComponent<AgeTransform>();
	}

	private void Update()
	{
		if (tfm.AutoResizeWidth)
		{
			tfm.PixelOffsetLeft = (0f - tfm.Width) / 2f;
		}
		if (tfm.AutoResizeHeight)
		{
			tfm.PixelOffsetTop = (0f - tfm.Height) / 2f;
		}
	}
}
[Serializable]
public class ControlSchemeAgeTfmConfig
{
	public ControlScheme ControlScheme;

	public bool Visible;

	public float WidthBonus;

	public float HeightBonus;

	public float LeftMarginBonus;

	public float RightMarginBonus;

	public float TopMarginBonus;

	public float BottomMarginBonus;
}
public class AgeTransformConfigSwitchByControlScheme : MonoBehaviour
{
	[SerializeField]
	private ControlSchemeAgeTfmConfig[] configs;

	private IEnumerator Start()
	{
		IInputService inputManager = null;
		while (inputManager == null)
		{
			inputManager = Services.GetService<IInputService>();
			yield return null;
		}
		IGuiSettingsService guiSettingsManager = null;
		while (guiSettingsManager == null)
		{
			guiSettingsManager = Services.GetService<IGuiSettingsService>();
			yield return null;
		}
		float guiScale = (!guiSettingsManager.HighDefinitionUI) ? 1f : 1.5f;
		AgeTransform ageTfm = GetComponent<AgeTransform>();
		ControlSchemeAgeTfmConfig[] array = configs;
		int num = 0;
		ControlSchemeAgeTfmConfig ageTfmConfig;
		while (true)
		{
			if (num < array.Length)
			{
				ageTfmConfig = array[num];
				if (ageTfmConfig.ControlScheme == inputManager.CurrentControlScheme)
				{
					break;
				}
				num++;
				continue;
			}
			yield break;
		}
		ageTfm.Visible = ageTfmConfig.Visible;
		ageTfm.Width += ageTfmConfig.WidthBonus * guiScale;
		ageTfm.Height += ageTfmConfig.HeightBonus * guiScale;
		ageTfm.PixelMarginLeft += ageTfmConfig.LeftMarginBonus * guiScale;
		ageTfm.PixelMarginRight += ageTfmConfig.RightMarginBonus * guiScale;
		ageTfm.PixelMarginTop += ageTfmConfig.TopMarginBonus * guiScale;
		ageTfm.PixelMarginBottom += ageTfmConfig.BottomMarginBonus * guiScale;
		if (ageTfmConfig.Visible)
		{
			yield break;
		}
		AgeTransform ageParent = ageTfm.GetParent();
		if (ageParent != null)
		{
			if (ageParent.AutoResizeWidth)
			{
				ageParent.Width = 0f;
			}
			if (ageParent.AutoResizeHeight)
			{
				ageParent.Height = 0f;
			}
		}
	}
}
public enum BuildPlatform
{
	Windows,
	Mac,
	Linux,
	iPad,
	XBoxOne
}
[Serializable]
public class PlatformAgeTfmConfig
{
	public BuildPlatform Platform;

	public bool Visible;

	public float WidthBonus;

	public float HeightBonus;

	public float LeftMarginBonus;

	public float RightMarginBonus;

	public float TopMarginBonus;

	public float BottomMarginBonus;
}
public class AgeTransformConfigSwitchByPlatform : MonoBehaviour
{
	[SerializeField]
	private PlatformAgeTfmConfig[] configs;

	private IEnumerator Start()
	{
		IInputService inputManager = null;
		while (inputManager == null)
		{
			inputManager = Services.GetService<IInputService>();
			yield return null;
		}
		IGuiSettingsService guiSettingsManager = null;
		while (guiSettingsManager == null)
		{
			guiSettingsManager = Services.GetService<IGuiSettingsService>();
			yield return null;
		}
		float guiScale = (!guiSettingsManager.HighDefinitionUI) ? 1f : 1.5f;
		AgeTransform ageTfm = GetComponent<AgeTransform>();
		PlatformAgeTfmConfig[] array = configs;
		int num = 0;
		PlatformAgeTfmConfig ageTfmConfig;
		while (true)
		{
			if (num < array.Length)
			{
				ageTfmConfig = array[num];
				if (ageTfmConfig.Platform == BuildPlatform.Windows)
				{
					break;
				}
				num++;
				continue;
			}
			yield break;
		}
		ageTfm.Visible = ageTfmConfig.Visible;
		ageTfm.Width += ageTfmConfig.WidthBonus * guiScale;
		ageTfm.Height += ageTfmConfig.HeightBonus * guiScale;
		ageTfm.PixelMarginLeft += ageTfmConfig.LeftMarginBonus * guiScale;
		ageTfm.PixelMarginRight += ageTfmConfig.RightMarginBonus * guiScale;
		ageTfm.PixelMarginTop += ageTfmConfig.TopMarginBonus * guiScale;
		ageTfm.PixelMarginBottom += ageTfmConfig.BottomMarginBonus * guiScale;
		if (ageTfmConfig.Visible)
		{
			yield break;
		}
		AgeTransform ageParent = ageTfm.GetParent();
		if (ageParent != null)
		{
			if (ageParent.AutoResizeWidth)
			{
				ageParent.Width = 0f;
			}
			if (ageParent.AutoResizeHeight)
			{
				ageParent.Height = 0f;
			}
		}
	}
}
public abstract class AgeTransformModifier : MonoBehaviour
{
	[SerializeField]
	public bool setVisibility;

	[SerializeField]
	public bool visible;

	[SerializeField]
	public float widthOffset;

	[SerializeField]
	public float heightOffset;

	[SerializeField]
	public float leftMarginOffset;

	[SerializeField]
	public float rightMarginOffset;

	[SerializeField]
	public float topMarginOffset;

	[SerializeField]
	public float bottomMarginOffset;

	protected bool isApplied;

	protected void SetModifierApplication(bool apply)
	{
		float num = 0f;
		if (isApplied && !apply)
		{
			num = -1f;
		}
		else
		{
			if (isApplied || !apply)
			{
				return;
			}
			num = 1f;
		}
		IGuiSettingsService service = Services.GetService<IGuiSettingsService>();
		float num2 = (!service.HighDefinitionUI) ? 1f : 1.5f;
		AgeTransform component = GetComponent<AgeTransform>();
		if (setVisibility)
		{
			component.Visible = ((!(num > 0f)) ? (!visible) : visible);
		}
		component.Width += widthOffset * num2 * num;
		component.Height += heightOffset * num2 * num;
		component.PixelMarginLeft += leftMarginOffset * num2 * num;
		component.PixelMarginRight += rightMarginOffset * num2 * num;
		component.PixelMarginTop += topMarginOffset * num2 * num;
		component.PixelMarginBottom += bottomMarginOffset * num2 * num;
		if (!component.Visible)
		{
			AgeTransform parent = component.GetParent();
			if (parent != null)
			{
				if (parent.AutoResizeWidth)
				{
					parent.Width = 0f;
				}
				if (parent.AutoResizeHeight)
				{
					parent.Height = 0f;
				}
			}
		}
		isApplied = apply;
	}
}
public class AssetPreloader : MonoBehaviour
{
	[SerializeField]
	private UnityEngine.Object[] manualAssets;

	[SerializeField]
	private AssetSearch[] searches;

	[SerializeField]
	private UnityEngine.Object[] searchedAssets;
}
[Serializable]
public struct AssetSearch
{
	public string Path;

	public string Pattern;

	public bool Disabled;
}
public abstract class DestroyerByCondition : MonoBehaviour
{
	[SerializeField]
	private UnityEngine.Object[] targets;

	[SerializeField]
	private bool destroyOnAwake;

	protected abstract bool CheckCondition();

	private void Awake()
	{
		if (destroyOnAwake)
		{
			Init();
		}
	}

	private void Start()
	{
		if (!destroyOnAwake)
		{
			Init();
		}
	}

	protected virtual void Init()
	{
		CheckDestruction();
	}

	protected void CheckDestruction()
	{
		if (CheckCondition())
		{
			DestroyTargets();
		}
	}

	private void DestroyTargets()
	{
		if (targets == null || targets.Length < 1)
		{
			targets = new UnityEngine.Object[1]
			{
				base.gameObject
			};
		}
		int num = targets.Length;
		for (int i = 0; i < num; i++)
		{
			UnityEngine.Object @object = targets[i];
			if (@object is GameObject)
			{
				GameObject gameObject = (GameObject)@object;
				AgeTransform component = gameObject.GetComponent<AgeTransform>();
				if (component != null)
				{
					AgeTransform parent = component.GetParent();
					if (parent != null)
					{
						if (parent.AutoResizeWidth)
						{
							parent.Width = 0f;
						}
						if (parent.AutoResizeHeight)
						{
							parent.Height = 0f;
						}
					}
				}
			}
			UnityEngine.Object.Destroy(@object);
		}
	}
}
public abstract class DestroyerByControlScheme : DestroyerByCondition
{
	private IInputService inputManager;

	protected ControlScheme currentControlScheme;

	protected override void Init()
	{
		StartCoroutine(RetrieveControlSchemeCoroutine());
	}

	private IEnumerator RetrieveControlSchemeCoroutine()
	{
		while (inputManager == null)
		{
			inputManager = Services.GetService<IInputService>();
			yield return null;
		}
		currentControlScheme = inputManager.CurrentControlScheme;
		CheckDestruction();
	}
}
public class DestroyerIfMouseKeyboard : DestroyerByControlScheme
{
	protected override bool CheckCondition()
	{
		return currentControlScheme == ControlScheme.MouseAndKeyboard;
	}
}
public class DestroyerIfNoAlbum : DestroyerByCondition
{
	protected override bool CheckCondition()
	{
		return false;
	}
}
public class DestroyerIfNoMultiplayer : DestroyerByCondition
{
	protected override bool CheckCondition()
	{
		return false;
	}
}
public class DestroyerIfNotSteam : DestroyerByCondition
{
	protected override bool CheckCondition()
	{
		return false;
	}
}
public class DestroyerIfNotXBoxOne : DestroyerByCondition
{
	protected override bool CheckCondition()
	{
		return true;
	}
}
public class DestroyerIfXB1Controller : DestroyerByControlScheme
{
	protected override bool CheckCondition()
	{
		return currentControlScheme == ControlScheme.XBoxOneController;
	}
}
public class DestroyerIfXBoxOne : DestroyerByCondition
{
	protected override bool CheckCondition()
	{
		return false;
	}
}
public class GameObjectPoolManager : MonoBehaviour
{
	private struct DelayedRecycle
	{
		public GameObject PoolGO;

		public float Time;
	}

	private Transform tfm;

	private Dictionary<GameObject, List<GameObject>> goPoolByPfb = new Dictionary<GameObject, List<GameObject>>();

	private Dictionary<GameObject, GameObject> goRecyclingPrefabs = new Dictionary<GameObject, GameObject>();

	private List<DelayedRecycle> delayedRecycles = new List<DelayedRecycle>();

	private void Awake()
	{
		tfm = GetComponent<Transform>();
	}

	public GameObject Instantiate(GameObject prefab, Vector3 position, Quaternion rotation, Transform parentTfm = null)
	{
		List<GameObject> value = null;
		if (!goPoolByPfb.TryGetValue(prefab, out value))
		{
			value = new List<GameObject>();
			goPoolByPfb.Add(prefab, value);
		}
		GameObject gameObject = null;
		bool flag = value.Count == 0;
		gameObject = ((!flag) ? value.PullAt(0) : ((GameObject)UnityEngine.Object.Instantiate(prefab, position, rotation)));
		Transform transform = gameObject.transform;
		if (!flag)
		{
			transform.position = position;
			transform.rotation = rotation;
		}
		transform.localScale = prefab.transform.lossyScale;
		transform.SetParent(parentTfm);
		gameObject.SetActive(value: true);
		if (flag)
		{
			goRecyclingPrefabs.Add(gameObject, prefab);
		}
		return gameObject;
	}

	public void Recycle(GameObject poolGO)
	{
		if (poolGO == null)
		{
			Diagnostics.LogError("Unable to recycle: game object is null! (destroyed?)");
			return;
		}
		GameObject value = null;
		if (!goRecyclingPrefabs.TryGetValue(poolGO, out value))
		{
			Diagnostics.LogError("Unable to recycle {0}: no recycling prefab found! > destroying game object...", poolGO.name);
			UnityEngine.Object.Destroy(poolGO);
			return;
		}
		Transform transform = poolGO.transform;
		transform.SetParent(tfm);
		poolGO.SetActive(value: false);
		List<GameObject> value2 = null;
		if (!goPoolByPfb.TryGetValue(value, out value2))
		{
			value2 = new List<GameObject>();
			goPoolByPfb.Add(value, value2);
		}
		value2.Add(poolGO);
	}

	public void Clear()
	{
		Dictionary<GameObject, List<GameObject>>.Enumerator enumerator = goPoolByPfb.GetEnumerator();
		while (enumerator.MoveNext())
		{
			List<GameObject> value = enumerator.Current.Value;
			for (int i = 0; i < value.Count; i++)
			{
				GameObject gameObject = value[i];
				if (gameObject != null)
				{
					UnityEngine.Object.Destroy(gameObject);
				}
			}
			value.Clear();
		}
		goRecyclingPrefabs.Clear();
	}

	public void DelayRecycle(GameObject poolGO, float delay)
	{
		delayedRecycles.Add(new DelayedRecycle
		{
			PoolGO = poolGO,
			Time = Time.realtimeSinceStartup + delay
		});
	}

	private void Update()
	{
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		for (int i = 0; i < delayedRecycles.Count; i++)
		{
			DelayedRecycle delayedRecycle = delayedRecycles[i];
			if (realtimeSinceStartup >= delayedRecycle.Time)
			{
				Recycle(delayedRecycle.PoolGO);
				delayedRecycles.RemoveAt(i--);
			}
		}
	}
}
public class HashManager : Manager, IService, IHashService
{
	public static bool IsHashDifferent;

	private static string hashRootDirectory = "Public";

	private static string[] hashDirectories = new string[2]
	{
		hashRootDirectory + "/Configuration",
		hashRootDirectory + "/Simulation"
	};

	private static MD5 cryptography;

	private static MemoryStream binary = new MemoryStream();

	private static string currentHash;

	[Service]
	private IRuntimeService runtimeService;

	private static MD5 Cryptography
	{
		get
		{
			if (cryptography == null)
			{
				cryptography = MD5.Create();
			}
			return cryptography;
		}
	}

	string IHashService.HashGame(bool resetHash)
	{
		return HashGame(resetHash);
	}

	string IHashService.GetCurrentHash()
	{
		return GetCurrentHash();
	}

	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		yield return BindService(delegate(IRuntimeService service)
		{
			runtimeService = service;
		});
		runtimeService.RuntimeChange += RuntimeService_RuntimeChange;
	}

	private void RuntimeService_RuntimeChange(object sender, RuntimeChangeEventArgs e)
	{
		if (e.Action == RuntimeChangeAction.Loaded)
		{
			HashGame();
			Diagnostics.Log("Hash is: " + currentHash);
			IsHashDifferent = (currentHash != DungeonsApplication.Hash);
			if (IsHashDifferent)
			{
				Diagnostics.LogWarning("Hash (" + currentHash + ") is different from expected hash (" + DungeonsApplication.Hash + ")");
			}
		}
	}

	public static string HashGame(bool resetHash = true)
	{
		if (resetHash)
		{
			ResetHash();
		}
		string[] array = hashDirectories;
		foreach (string path in array)
		{
			string[] files = Directory.GetFiles(path, "*", SearchOption.AllDirectories);
			string[] array2 = files;
			foreach (string fileName in array2)
			{
				HashFile(fileName);
			}
		}
		return currentHash;
	}

	private static string HashFile(string fileName)
	{
		if (!File.Exists(fileName))
		{
			return string.Empty;
		}
		string empty = string.Empty;
		using (Stream stream = File.OpenRead(fileName))
		{
			byte[] buffer = new byte[stream.Length];
			if (stream.Length != stream.Read(buffer, 0, (int)stream.Length))
			{
				return empty;
			}
			byte[] array = Cryptography.ComputeHash(buffer);
			empty = "0x";
			byte[] array2 = array;
			foreach (byte b in array2)
			{
				empty += b.ToString("X2");
			}
			binary.Write(array, 0, array.Length);
			buffer = binary.ToArray();
			array = Cryptography.ComputeHash(buffer, 0, buffer.Length);
			currentHash = "0x";
			byte[] array3 = array;
			foreach (byte b2 in array3)
			{
				currentHash += b2.ToString("X2");
			}
			return empty;
		}
	}

	public static void ResetHash()
	{
		currentHash = string.Empty;
	}

	public static string GetCurrentHash()
	{
		return currentHash;
	}
}
public abstract class InstantiatorByCondition : MonoBehaviour
{
	[SerializeField]
	private GameObject prefab;

	[SerializeField]
	private string prefabPath;

	protected abstract bool CheckCondition();

	private void Awake()
	{
		Init();
	}

	protected virtual void Init()
	{
		CheckInstantiation();
	}

	protected void CheckInstantiation()
	{
		if (CheckCondition())
		{
			InstantiatePrefab();
		}
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void InstantiatePrefab()
	{
		Transform transform = base.transform;
		if (prefab == null && !string.IsNullOrEmpty(prefabPath))
		{
			prefab = (GameObject)Resources.Load(prefabPath, typeof(GameObject));
		}
		if (prefab == null)
		{
			UnityEngine.Debug.LogError("Unable to find asset at path " + prefabPath);
			return;
		}
		GameObject gameObject = (GameObject)UnityEngine.Object.Instantiate(prefab, transform.position, transform.rotation);
		gameObject.transform.parent = transform.parent;
		gameObject.transform.localScale = transform.localScale;
		GuiPanel component = gameObject.GetComponent<GuiPanel>();
		if (component != null)
		{
			component.Initialize();
			component.Load();
			component.Hide();
		}
	}
}
public abstract class InstantiatorByControlScheme : InstantiatorByCondition
{
	private IInputService inputManager;

	protected ControlScheme currentControlScheme;

	protected override void Init()
	{
		StartCoroutine(RetrieveControlSchemeCoroutine());
	}

	private IEnumerator RetrieveControlSchemeCoroutine()
	{
		while (inputManager == null)
		{
			inputManager = Services.GetService<IInputService>();
			yield return null;
		}
		currentControlScheme = inputManager.CurrentControlScheme;
		CheckInstantiation();
	}
}
public class InstantiatorIfAlbum : InstantiatorByCondition
{
	protected override bool CheckCondition()
	{
		return true;
	}
}
public class InstantiatorIfMouseKeyboard : InstantiatorByControlScheme
{
	protected override bool CheckCondition()
	{
		return currentControlScheme == ControlScheme.MouseAndKeyboard;
	}
}
public class InstantiatorIfNotXBoxOne : InstantiatorByCondition
{
	protected override bool CheckCondition()
	{
		return true;
	}
}
public class InstantiatorIfSteam : InstantiatorByCondition
{
	protected override bool CheckCondition()
	{
		return true;
	}
}
public class InstantiatorIfXB1Controller : InstantiatorByControlScheme
{
	protected override bool CheckCondition()
	{
		return currentControlScheme == ControlScheme.XBoxOneController;
	}
}
public class InstantiatorIfXBoxOne : InstantiatorByCondition
{
	protected override bool CheckCondition()
	{
		return false;
	}
}
public class MaterialRenderQueueSetter : MonoBehaviour
{
}
public class MultiplayerAgeTransformModifier : AgeTransformModifier
{
	[SerializeField]
	public bool multiplayer = true;

	private void Start()
	{
		IGameEventService service = Services.GetService<IGameEventService>();
		service.OnGameStarted += OnGameStarted;
	}

	private void OnGameStarted()
	{
		GameNetworkManager gameNetworkManager = SingletonManager.Get<GameNetworkManager>();
		bool flag = gameNetworkManager.IsMultiplayerSession();
		SetModifierApplication(flag == multiplayer);
	}

	private void OnDestroy()
	{
		IGameEventService service = Services.GetService<IGameEventService>();
		service.OnGameStarted -= OnGameStarted;
	}
}
public class OffscreenMarker : MonoBehaviour
{
	[Serializable]
	public struct OffscreenMarkerData
	{
		public AnimationClip IconAnim;

		public float Duration;

		public int Priority;

		public bool AutoStopWhenSafe;

		public bool OnlyArrow;

		public AnimationClip TacticalMapElementAnim;

		public bool AlwaysVisible;

		public bool ShowTimer;
	}

	public delegate void HideEventHandler(OffscreenMarker marker);

	[SerializeField]
	private float topMargin;

	[SerializeField]
	private float bottomMargin;

	[SerializeField]
	private float leftMargin;

	[SerializeField]
	private float rightMargin;

	[SerializeField]
	private float camDist;

	[SerializeField]
	private Transform arrowContainerTfm;

	[SerializeField]
	private SpriteAnimationRuntime2 arrowAnim;

	[SerializeField]
	private SpriteAnimationRuntime2 iconAnim;

	[SerializeField]
	private SpriteAnimationRuntime2 tacticalMapElementAnim;

	[SerializeField]
	private Transform timerGUIPrefab;

	private float displayDuration;

	private float timerDuration;

	private Vector3 trackedPos;

	private Transform trackedTfm;

	private IGameCameraService gameCamManager;

	private Renderer iconRnd;

	private bool onlyArrowWhenOutside;

	private Transform timer;

	private Material timerMaterial;

	public SpriteAnimationRuntime2 IconAnim => iconAnim;

	public bool AutoStopWhenSafe
	{
		get;
		set;
	}

	public event HideEventHandler OnHide;

	public void Init(Transform trackedTfm, OffscreenMarkerData markerData)
	{
		this.trackedTfm = trackedTfm;
		InitCommon(markerData);
	}

	public void Init(Vector3 trackedPos, OffscreenMarkerData markerData)
	{
		this.trackedPos = trackedPos;
		InitCommon(markerData);
	}

	private void InitCommon(OffscreenMarkerData markerData)
	{
		gameCamManager = Services.GetService<IGameCameraService>();
		iconRnd = iconAnim.GetComponent<Renderer>();
		displayDuration = markerData.Duration;
		onlyArrowWhenOutside = markerData.OnlyArrow;
		if (markerData.IconAnim != null)
		{
			iconAnim.OverrideClip("Default", markerData.IconAnim);
			iconAnim.Play();
		}
		if (markerData.TacticalMapElementAnim != null)
		{
			tacticalMapElementAnim.OverrideClip("Default", markerData.TacticalMapElementAnim);
			tacticalMapElementAnim.Play();
		}
		if (displayDuration >= 0f)
		{
			Invoke("Hide", displayDuration);
			if (markerData.ShowTimer)
			{
				Transform transform = UnityEngine.Object.Instantiate(timerGUIPrefab);
				transform.parent = base.transform;
				transform.localScale = timerGUIPrefab.localScale;
				transform.localPosition = timerGUIPrefab.localPosition;
				timer = transform.GetComponentInChildren<HealthValue>().transform;
				timerMaterial = timer.GetComponentInChildren<Renderer>().material;
				timerDuration = displayDuration;
			}
		}
	}

	public void UpdateTrackedTfm(Transform trackedTfm)
	{
		this.trackedTfm = trackedTfm;
	}

	public void Hide()
	{
		UnityEngine.Object.Destroy(base.gameObject);
		if (timer != null)
		{
			UnityEngine.Object.Destroy(timer.gameObject);
		}
		if (this.OnHide != null)
		{
			this.OnHide(this);
		}
	}

	public void Show(bool show)
	{
		if (show)
		{
			arrowAnim.Play();
			iconAnim.Play();
		}
		else
		{
			arrowAnim.Stop();
			iconAnim.Stop();
		}
	}

	public void UpdateDisplayDuration(float newDuration)
	{
		displayDuration = newDuration;
		CancelInvoke("Hide");
		if (newDuration != -1f)
		{
			Invoke("Hide", displayDuration);
		}
	}

	private Vector3 GetTrackedPos()
	{
		return (!(trackedTfm != null)) ? trackedPos : trackedTfm.position;
	}

	private void Update()
	{
		displayDuration -= Time.deltaTime;
		IGameResolutionService service = Services.GetService<IGameResolutionService>();
		ScreenResolution currentDisplayResolution = service.GetCurrentDisplayResolution();
		Rect rect = new Rect(leftMargin, topMargin, (float)currentDisplayResolution.Width - (leftMargin + rightMargin), (float)currentDisplayResolution.Height - (topMargin + bottomMargin));
		Vector3 vector = GetTrackedPos();
		Vector2 a = gameCamManager.WorldToScreenPoint(vector);
		Vector2 vector2 = new Vector2((float)currentDisplayResolution.Width / 2f, (float)currentDisplayResolution.Height / 2f);
		Vector2 b = a - vector2;
		bool flag = false;
		if (a.x < rect.xMin || a.x > rect.xMax)
		{
			b *= rect.width / 2f / Mathf.Abs(b.x);
			a = vector2 + b;
			flag = true;
		}
		if (a.y < rect.yMin || a.y > rect.yMax)
		{
			b *= rect.height / 2f / Mathf.Abs(b.y);
			a = vector2 + b;
			flag = true;
		}
		base.transform.position = gameCamManager.ScreenToWorldPoint(new Vector3(a.x, a.y, camDist));
		if (flag)
		{
			arrowContainerTfm.forward = vector - gameCamManager.GetCamSupportPosition();
			if (iconRnd.enabled || onlyArrowWhenOutside)
			{
				arrowAnim.Play();
			}
			else
			{
				arrowAnim.Stop();
			}
		}
		else
		{
			arrowAnim.Stop();
		}
		if (onlyArrowWhenOutside)
		{
			iconAnim.GetComponent<Renderer>().enabled = !flag;
		}
		if (timer != null)
		{
			float num = displayDuration / timerDuration;
			timer.localScale = new Vector3(num, 1f, 1f);
			timerMaterial.color = Color.Lerp(Color.red, Color.green, num);
		}
	}

	private void OnLeftClickDown(ClickDownInfo clickInfo)
	{
		gameCamManager.Focus(GetTrackedPos(), LerpType.Smoothed, -1f);
	}
}
public class SingletonByControllerScheme : Singleton
{
	[SerializeField]
	private ControlScheme controlScheme;

	private IInputService inputService;

	protected override void Register()
	{
		inputService = Services.GetService<IInputService>();
		if (inputService.CurrentControlScheme == controlScheme)
		{
			base.Register();
		}
	}

	protected override void Unregister()
	{
		if (inputService.CurrentControlScheme == controlScheme)
		{
			base.Unregister();
		}
	}
}
public class SteleParticleColor : MonoBehaviour
{
	public Color32 basicColor;

	public bool bonus = true;
}
public class UniqueID : MonoBehaviour
{
	private static readonly char CATEGORY_FOR_PLAYER_NAME_SEPARATOR = '_';

	[SerializeField]
	private UnityEngine.Component instance;

	[SerializeField]
	protected bool requestUniqueIDOnAwake;

	[SerializeField]
	protected bool uniqueName;

	private StaticString category;

	private StaticString categoryClearName;

	private GameNetworkManager gameNetManager;

	public int ID
	{
		get;
		private set;
	}

	public StaticString GetCategory()
	{
		if (category == null)
		{
			category = GetTypeIDStr();
		}
		return category;
	}

	public StaticString GetCategoryClearName()
	{
		if (categoryClearName == null)
		{
			string text = GetCategory().ToString();
			int num = text.IndexOf(CATEGORY_FOR_PLAYER_NAME_SEPARATOR);
			if (num >= 0)
			{
				string[] array = text.Split(CATEGORY_FOR_PLAYER_NAME_SEPARATOR);
				text = $"{array[0]}{CATEGORY_FOR_PLAYER_NAME_SEPARATOR}{int.Parse(array[1]).ToEnum<UniqueIDType>().ToString()}";
			}
			else
			{
				text = int.Parse(text).ToEnum<UniqueIDType>().ToString();
			}
			categoryClearName = new StaticString(text);
		}
		return categoryClearName;
	}

	private StaticString GetTypeIDStr()
	{
		Type type = instance.GetType();
		string x = UniqueIDManager.GetTypeID(type).ToString();
		return x;
	}

	public void RequestUniqueIDForPlayer(ulong playerID)
	{
		if (gameNetManager == null)
		{
			gameNetManager = SingletonManager.Get<GameNetworkManager>();
		}
		int playerSlotIndex = gameNetManager.GetPlayerSlotIndex(playerID);
		string arg = GetTypeIDStr();
		category = $"{playerSlotIndex}{CATEGORY_FOR_PLAYER_NAME_SEPARATOR}{arg}";
		RequestUniqueID();
	}

	public void RequestUniqueID()
	{
		if (ID > 0)
		{
			Diagnostics.LogError(base.name + " > RequestUniqueID: ID already set to " + ID);
			return;
		}
		StaticString x = GetCategory();
		ID = UniqueIDManager.RequestUniqueID(instance, x);
		if (uniqueName)
		{
			if (base.name.Contains("#"))
			{
				Diagnostics.LogError(this.GetScenePath() + " > name already contains a unique ID!");
			}
			string name = base.name;
			base.name = name + "[" + (string)x + "#" + ID + "]";
		}
	}

	protected virtual void Awake()
	{
		if (requestUniqueIDOnAwake)
		{
			RequestUniqueID();
		}
	}

	private void OnDestroy()
	{
		if (ID > 0)
		{
			UniqueIDManager.UnregisterUniqueID(GetCategory(), ID);
		}
		if (instance != null)
		{
			if (gameNetManager == null)
			{
				gameNetManager = SingletonManager.Get<GameNetworkManager>();
			}
			if (gameNetManager != null)
			{
				gameNetManager.ClearCachedComponents(instance);
			}
		}
	}
}
public enum UniqueIDGetError
{
	NoError,
	CategoryNeverUsed,
	CategoryIsNull,
	IDOutOfRange,
	ObjectIsNull
}
public enum UniqueIDType
{
	Game = 0,
	Door = 1,
	Hero = 2,
	ItemAnimated = 3,
	ItemHero = 4,
	Mob = 5,
	Artifact = 6,
	CryoCapsule = 7,
	Crystal = 8,
	CrystalModuleSlot = 9,
	DustFactory = 10,
	MajorModule = 11,
	MajorModuleSlot = 12,
	MinorModule = 13,
	MinorModuleSlot = 14,
	Stele = 0xF,
	NPCMerchant = 0x10,
	Player = 17,
	Room = 18,
	RoomDefenseSpot = 19,
	ActiveSkill = 20,
	PassiveSkill = 21,
	Dungeon = 22,
	INVALID_TYPE = 1000
}
public class UniqueIDManager
{
	private static Dictionary<StaticString, List<object>> uniqueIDObjectsByCategory = new Dictionary<StaticString, List<object>>();

	private static bool reset = true;

	public static int RegisteredCount
	{
		get;
		private set;
	}

	public static int GetTypeID(Type type)
	{
		string typeName = type.ToString();
		return GetTypeID(typeName);
	}

	public static int GetTypeID(string typeName)
	{
		return GetTypeIDByName(typeName);
	}

	public static UniqueIDType GetTypeEnum(Type type)
	{
		string typeName = type.ToString();
		return GetTypeEnum(typeName);
	}

	public static UniqueIDType GetTypeEnum(string typeName)
	{
		//Discarded unreachable code: IL_002c
		try
		{
			return typeName.ToEnum<UniqueIDType>();
		}
		catch
		{
			Diagnostics.LogError("UniqueIDType.{0} not defined!", typeName);
			return UniqueIDType.INVALID_TYPE;
		}
	}

	public static int GetTypeIDByName(string typeName)
	{
		return (int)GetTypeEnum(typeName);
	}

	public static int RequestUniqueID(object obj, StaticString category)
	{
		if (!uniqueIDObjectsByCategory.ContainsKey(category))
		{
			uniqueIDObjectsByCategory[category] = new List<object>();
		}
		uniqueIDObjectsByCategory[category].Add(obj);
		RegisteredCount++;
		reset = false;
		return uniqueIDObjectsByCategory[category].Count;
	}

	public static void UnregisterUniqueID(StaticString category, int ID)
	{
		if (!reset)
		{
			if (!uniqueIDObjectsByCategory.ContainsKey(category))
			{
				Diagnostics.LogError("UniqueIDManager.UnregisterUniqueID: {0} category never used!", category);
				return;
			}
			if (uniqueIDObjectsByCategory[category].Count < ID)
			{
				Diagnostics.LogError("UniqueIDManager.UnregisterUniqueID: {0} ID out or range for {1} category!", ID, category);
				return;
			}
			if (uniqueIDObjectsByCategory[category][ID - 1] == null)
			{
				Diagnostics.LogError("UniqueIDManager.UnregisterUniqueID: {1}#{0} is already null (==)!", ID, category);
				return;
			}
			if (uniqueIDObjectsByCategory[category][ID - 1].Equals(null))
			{
				Diagnostics.LogError("UniqueIDManager.UnregisterUniqueID: {1}#{0} is already null (Equals)!", ID, category);
				return;
			}
			uniqueIDObjectsByCategory[category][ID - 1] = null;
			RegisteredCount--;
		}
	}

	public static T Get<T>(int uniqueID) where T : UnityEngine.Component
	{
		Type typeFromHandle = typeof(T);
		StaticString category = GetTypeID(typeFromHandle).ToString();
		return (T)Get(category, uniqueID);
	}

	public static object GetObject(StaticString category, int uniqueID, out UniqueIDGetError error, bool logError = true)
	{
		if (!uniqueIDObjectsByCategory.ContainsKey(category))
		{
			if (logError)
			{
				Diagnostics.LogError("Unable to find unique ID {0} of category {1}: category never used", uniqueID, category);
			}
			error = UniqueIDGetError.CategoryNeverUsed;
			return null;
		}
		if (uniqueIDObjectsByCategory[category] == null)
		{
			if (logError)
			{
				Diagnostics.LogError("Unable to find unique ID {0} of category {1}: category is empty", uniqueID, category);
			}
			error = UniqueIDGetError.CategoryIsNull;
			return null;
		}
		if (uniqueIDObjectsByCategory[category].Count < uniqueID || uniqueID < 0)
		{
			if (logError)
			{
				Diagnostics.LogError("Unable to find unique ID {0} of category {1}: ID is out of range", uniqueID, category);
			}
			error = UniqueIDGetError.IDOutOfRange;
			return null;
		}
		if (uniqueIDObjectsByCategory[category][uniqueID - 1] == null)
		{
			if (logError)
			{
				Diagnostics.LogError("Unable to find unique ID {0} of category {1}: object is now null(==)", uniqueID, category);
			}
			error = UniqueIDGetError.ObjectIsNull;
			return null;
		}
		if (uniqueIDObjectsByCategory[category][uniqueID - 1].Equals(null))
		{
			if (logError)
			{
				Diagnostics.LogError("Unable to find unique ID {0} of category {1}: object is now null (Equals)", uniqueID, category);
			}
			error = UniqueIDGetError.ObjectIsNull;
			return null;
		}
		if (object.ReferenceEquals(uniqueIDObjectsByCategory[category][uniqueID - 1], null))
		{
			if (logError)
			{
				Diagnostics.LogError("Unable to find unique ID {0} of category {1}: object is now null (ReferenceEquals)", uniqueID, category);
			}
			error = UniqueIDGetError.ObjectIsNull;
			return null;
		}
		error = UniqueIDGetError.NoError;
		return uniqueIDObjectsByCategory[category][uniqueID - 1];
	}

	public static object GetObject(StaticString category, int uniqueID)
	{
		UniqueIDGetError error;
		return GetObject(category, uniqueID, out error);
	}

	public static UnityEngine.Component Get(StaticString category, int uniqueID, out UniqueIDGetError error, bool logError = true)
	{
		return GetObject(category, uniqueID, out error, logError) as UnityEngine.Component;
	}

	public static UnityEngine.Component Get(StaticString category, int uniqueID)
	{
		return GetObject(category, uniqueID) as UnityEngine.Component;
	}

	public static void ResetIDs()
	{
		uniqueIDObjectsByCategory.Clear();
		reset = true;
		RegisteredCount = 0;
	}
}
public class UpdateGenerator : MonoBehaviour
{
	[Serializable]
	private struct UpdateConfig
	{
		public string Name;

		public float Period;

		public float RandomStart;

		public bool IgnoreTimeScale;

		[HideInInspector]
		public float PreviousUpdateTime;

		[HideInInspector]
		public float NextUpdateTime;
	}

	private const string _method_HealthRegenUpdate = "HealthRegenUpdate";

	private const string _method_HealthSyncUpdate = "HealthSyncUpdate";

	private const string _method_HealthDOTUpdate = "HealthDOTUpdate";

	private const string _method_CheckControllerStatuses = "CheckControllerStatuses";

	private const string _method_CheckOnlineState = "CheckOnlineState";

	private const string _method_BuildingUpdate = "BuildingUpdate";

	private const string _method_SimEffectUpdate = "SimEffectUpdate";

	[SerializeField]
	private UpdateConfig[] configs;

	private Module moduleCpnt;

	private XboxOneManager xboxOneManagerCpnt;

	private XboxOneNetworkingManager xboxOneNetworkingManagerCpnt;

	private string _methodName;

	private void Awake()
	{
		float time = Time.time;
		for (int i = 0; i < configs.Length; i++)
		{
			configs[i].PreviousUpdateTime = time;
			if (configs[i].RandomStart > 0f)
			{
				configs[i].NextUpdateTime = time + RandomGenerator.RangeFloat(0f, configs[i].RandomStart);
			}
			else
			{
				configs[i].NextUpdateTime = time;
			}
		}
	}

	private void OnEnable()
	{
		UpdateManager updateManager = SingletonManager.Get<UpdateManager>();
		updateManager.RegisterUpdateGenerator(this);
	}

	private void OnDisable()
	{
		UpdateManager updateManager = SingletonManager.Get<UpdateManager>();
		updateManager.UnregisterUpdateGenerator(this);
	}

	public void GenerateUpdate()
	{
		for (int i = 0; i < configs.Length; i++)
		{
			float num = (!configs[i].IgnoreTimeScale) ? Time.time : Time.realtimeSinceStartup;
			if (!(num >= configs[i].NextUpdateTime))
			{
				continue;
			}
			_methodName = configs[i].Name;
			float num2 = num - configs[i].PreviousUpdateTime;
			switch (_methodName)
			{
			case "CheckControllerStatuses":
				if (xboxOneManagerCpnt == null)
				{
					xboxOneManagerCpnt = GetComponent<XboxOneManager>();
				}
				break;
			case "CheckOnlineState":
				if (xboxOneNetworkingManagerCpnt == null)
				{
					xboxOneNetworkingManagerCpnt = GetComponent<XboxOneNetworkingManager>();
				}
				break;
			case "BuildingUpdate":
				if (moduleCpnt == null)
				{
					moduleCpnt = GetComponent<Module>();
				}
				break;
			}
			switch (_methodName)
			{
			case "CheckControllerStatuses":
				xboxOneManagerCpnt.CheckControllerStatuses();
				break;
			case "CheckOnlineState":
				xboxOneNetworkingManagerCpnt.CheckOnlineState();
				break;
			case "BuildingUpdate":
				moduleCpnt.BuildingUpdate(num2);
				break;
			default:
				SendMessage(_methodName, num2, SendMessageOptions.DontRequireReceiver);
				break;
			}
			configs[i].PreviousUpdateTime = num;
			configs[i].NextUpdateTime += configs[i].Period;
		}
	}
}
public class UpdateManager : MonoBehaviour
{
	private List<UpdateGenerator> updateGenerators = new List<UpdateGenerator>();

	public void RegisterUpdateGenerator(UpdateGenerator updateGenerator)
	{
		updateGenerators.Add(updateGenerator);
	}

	public void UnregisterUpdateGenerator(UpdateGenerator updateGenerator)
	{
		updateGenerators.Remove(updateGenerator);
	}

	private void Update()
	{
		int count = updateGenerators.Count;
		for (int i = 0; i < count; i++)
		{
			UpdateGenerator updateGenerator = updateGenerators[i];
			updateGenerator.GenerateUpdate();
		}
	}
}
public class XboxVideoBootstrapper : Bootstrapper
{
	public string VideoFilePath;

	private bool isMovieCompleted;

	protected override IEnumerator Start()
	{
		SingletonManager.Get<XboxMoviePanel>().StartVideo(VideoFilePath, OnMovieComplete);
		while (!isMovieCompleted)
		{
			yield return null;
		}
		yield return StartCoroutine(base.Start());
	}

	private void OnMovieComplete()
	{
		isMovieCompleted = true;
	}
}
public class YLocalPositionAutoSetter : MonoBehaviour
{
	[SerializeField]
	private float yLocalPosition;

	private void Awake()
	{
		Transform transform = base.transform;
		Vector3 localPosition = transform.localPosition;
		float num = yLocalPosition;
		Vector3 localPosition2 = base.transform.localPosition;
		transform.localPosition = localPosition + (num - localPosition2.y) * Vector3.up;
	}
}
public class CamDragSupportCursorTarget : CursorTarget
{
	protected override void OnCursorDown(MouseButton mouseButton)
	{
		base.OnCursorDown(mouseButton);
		IGameEventService service = Services.GetService<IGameEventService>();
		service.TriggerInGameClickDownEvent(mouseButton);
	}
}
[Serializable]
public class CameraManager : Amplitude.Unity.View.CameraManager
{
}
public class GameResolutionAgeScaler : MonoBehaviour
{
	private AgeTransform ageTfm;

	private IGameResolutionService gameResolutionManager;

	private void Awake()
	{
		ageTfm = GetComponent<AgeTransform>();
	}

	private IEnumerator Start()
	{
		for (gameResolutionManager = Services.GetService<IGameResolutionService>(); gameResolutionManager == null; gameResolutionManager = Services.GetService<IGameResolutionService>())
		{
			yield return null;
		}
		ApplyCurrentGameResolution();
		gameResolutionManager.OnGameResolutionChanged += OnGameResolutionChanged;
	}

	private void OnGameResolutionChanged()
	{
		ApplyCurrentGameResolution();
	}

	private void ApplyCurrentGameResolution()
	{
		ScreenResolution currentDisplayResolution = gameResolutionManager.GetCurrentDisplayResolution();
		int width = currentDisplayResolution.Width;
		int height = currentDisplayResolution.Height;
		ageTfm.Width = width;
		ageTfm.Height = height;
		ageTfm.PixelOffsetLeft = -width / 2;
		ageTfm.PixelOffsetTop = -height / 2;
	}

	private void OnApplyHighDefinition(float scale)
	{
		ApplyCurrentGameResolution();
	}
}
public class GameResolutionCamera : MonoBehaviour
{
	[SerializeField]
	private bool monitorOrthoSizeChanges;

	private Camera cam;

	private bool differentRatio;

	private float currentRatio;

	private float previousCamOrthoSize;

	private IGameResolutionService gameResolutionManager;

	private void Awake()
	{
		cam = GetComponent<Camera>();
		previousCamOrthoSize = cam.orthographicSize;
	}

	private IEnumerator Start()
	{
		for (gameResolutionManager = Services.GetService<IGameResolutionService>(); gameResolutionManager == null; gameResolutionManager = Services.GetService<IGameResolutionService>())
		{
			yield return null;
		}
		ApplyCurrentGameResolution();
		gameResolutionManager.OnGameResolutionChanged += OnGameResolutionChanged;
	}

	private void OnGameResolutionChanged()
	{
		ApplyCurrentGameResolution();
	}

	private void ApplyCurrentGameResolution()
	{
		ScreenResolution currentDisplayResolution = gameResolutionManager.GetCurrentDisplayResolution();
		GameResolution currentGameResolution = gameResolutionManager.CurrentGameResolution;
		ScreenResolution screenResolution = currentGameResolution.ScreenResolution;
		currentRatio = currentDisplayResolution.GetRatio();
		if (currentDisplayResolution.Width != screenResolution.Width || currentDisplayResolution.Height != screenResolution.Height)
		{
			float num = (float)currentDisplayResolution.Width / (float)screenResolution.Width;
			float num2 = (float)currentDisplayResolution.Height / (float)screenResolution.Height;
			cam.rect = new Rect((1f - num) / 2f, (1f - num2) / 2f, num, num2);
		}
		else
		{
			cam.rect = new Rect(0f, 0f, 1f, 1f);
		}
		float ratio = gameResolutionManager.GameplayResolution.GetRatio();
		differentRatio = (currentRatio != ratio);
		if (differentRatio)
		{
			UpdateCamProjectionMatrix();
		}
		else
		{
			cam.ResetProjectionMatrix();
		}
	}

	private void UpdateCamProjectionMatrix()
	{
		float ratio = gameResolutionManager.GameplayResolution.GetRatio();
		float num = (0f - cam.orthographicSize) * ratio;
		float right = 0f - num;
		float num2 = 0f - cam.orthographicSize;
		float top = 0f - num2;
		cam.projectionMatrix = Matrix4x4.Ortho(num, right, num2, top, cam.nearClipPlane, cam.farClipPlane);
	}

	private void Update()
	{
		if (previousCamOrthoSize != cam.orthographicSize)
		{
			if (monitorOrthoSizeChanges && differentRatio)
			{
				UpdateCamProjectionMatrix();
			}
			previousCamOrthoSize = cam.orthographicSize;
		}
	}
}
public class GameResolutionManager : Manager, IService, IGameResolutionService
{
	private readonly StaticString registryWidthValue = "Settings/Video/Resolution/Width";

	private readonly StaticString registryHeightValue = "Settings/Video/Resolution/Height";

	private readonly StaticString registryFullscreenValue = "Settings/Video/Resolution/Fullscreen";

	private readonly StaticString registryResolutionModeValue = "Settings/Video/Resolution/Mode";

	private readonly StaticString registryVSyncValue = "Settings/Video/VSync";

	[SerializeField]
	private ScreenResolution gameplayResolution;

	[SerializeField]
	private ScreenResolution minResolution;

	private ScreenResolution[] availableScreenResolutions;

	public GameResolution CurrentGameResolution
	{
		get;
		private set;
	}

	public ScreenResolution GameplayResolution => gameplayResolution;

	public bool VSync => QualitySettings.vSyncCount == 1;

	public event OnGameResolutionChangedEventHandler OnGameResolutionChanged;

	public event OnVSyncChangedEventHandler OnVSyncChanged;

	public override IEnumerator BindServices()
	{
		yield return base.BindServices();
		RestoreSavedResolution();
		RestoreSavedVSync();
		Services.AddService((IGameResolutionService)this);
	}

	public ScreenResolution[] GetAvailableScreenResolutions()
	{
		if (availableScreenResolutions == null)
		{
			Resolution[] resolutions = Screen.resolutions;
			availableScreenResolutions = new ScreenResolution[resolutions.Length];
			ScreenResolution screenResolution = default(ScreenResolution);
			List<ScreenResolution> list = new List<ScreenResolution>();
			for (int num = resolutions.Length - 1; num >= 0; num--)
			{
				screenResolution.Width = resolutions[num].width;
				screenResolution.Height = resolutions[num].height;
				if (IsResolutionHighEnough(screenResolution))
				{
					list.Add(screenResolution);
				}
			}
			availableScreenResolutions = list.ToArray();
		}
		return availableScreenResolutions;
	}

	public void SetGameResolution(GameResolution resolution)
	{
		CurrentGameResolution = resolution;
		object[] array = new object[4];
		GameResolution currentGameResolution = CurrentGameResolution;
		array[0] = currentGameResolution.ScreenResolution.Width;
		GameResolution currentGameResolution2 = CurrentGameResolution;
		array[1] = currentGameResolution2.ScreenResolution.Height;
		GameResolution currentGameResolution3 = CurrentGameResolution;
		array[2] = currentGameResolution3.Fullscreen;
		GameResolution currentGameResolution4 = CurrentGameResolution;
		array[3] = currentGameResolution4.Mode;
		Diagnostics.Log("SetGameResolution {0}x{1} FS={2} M={3}", array);
		GameResolution currentGameResolution5 = CurrentGameResolution;
		int width = currentGameResolution5.ScreenResolution.Width;
		GameResolution currentGameResolution6 = CurrentGameResolution;
		int height = currentGameResolution6.ScreenResolution.Height;
		GameResolution currentGameResolution7 = CurrentGameResolution;
		Screen.SetResolution(width, height, currentGameResolution7.Fullscreen);
		if (this.OnGameResolutionChanged != null)
		{
			this.OnGameResolutionChanged();
		}
	}

	public void SetScreenResolution(ScreenResolution screenResolution)
	{
		GameResolution currentGameResolution = CurrentGameResolution;
		currentGameResolution.ScreenResolution = screenResolution;
		SetGameResolution(currentGameResolution);
	}

	public void SetFullscreen(bool fullscreen)
	{
		GameResolution currentGameResolution = CurrentGameResolution;
		currentGameResolution.Fullscreen = fullscreen;
		SetGameResolution(currentGameResolution);
	}

	public void SetVSync(bool vSync)
	{
		QualitySettings.vSyncCount = (vSync ? 1 : 0);
	}

	public void RestoreSavedVSync()
	{
		bool value = Amplitude.Unity.Framework.Application.Registry.GetValue(registryVSyncValue, defaultValue: true);
		SetVSync(value);
		if (this.OnVSyncChanged != null)
		{
			this.OnVSyncChanged();
		}
	}

	public void SaveVSync()
	{
		Amplitude.Unity.Framework.Application.Registry.SetValue(registryVSyncValue, VSync);
	}

	public void SetResolutionMode(ResolutionMode mode)
	{
		GameResolution currentGameResolution = CurrentGameResolution;
		currentGameResolution.Mode = mode;
		SetGameResolution(currentGameResolution);
	}

	public void RestoreSavedResolution()
	{
		GameResolution gameResolution = default(GameResolution);
		gameResolution.ScreenResolution.Width = Amplitude.Unity.Framework.Application.Registry.GetValue(registryWidthValue, Screen.width);
		gameResolution.ScreenResolution.Height = Amplitude.Unity.Framework.Application.Registry.GetValue(registryHeightValue, Screen.height);
		gameResolution.Fullscreen = Amplitude.Unity.Framework.Application.Registry.GetValue(registryFullscreenValue, Screen.fullScreen);
		gameResolution.Mode = Amplitude.Unity.Framework.Application.Registry.GetValue(registryResolutionModeValue, "NoBorders").ToEnum<ResolutionMode>();
		SetGameResolution(gameResolution);
	}

	public void SaveCurrentGameResolution()
	{
		Registry registry = Amplitude.Unity.Framework.Application.Registry;
		StaticString key = registryWidthValue;
		GameResolution currentGameResolution = CurrentGameResolution;
		registry.SetValue(key, currentGameResolution.ScreenResolution.Width);
		Registry registry2 = Amplitude.Unity.Framework.Application.Registry;
		StaticString key2 = registryHeightValue;
		GameResolution currentGameResolution2 = CurrentGameResolution;
		registry2.SetValue(key2, currentGameResolution2.ScreenResolution.Height);
		Registry registry3 = Amplitude.Unity.Framework.Application.Registry;
		StaticString key3 = registryFullscreenValue;
		GameResolution currentGameResolution3 = CurrentGameResolution;
		registry3.SetValue(key3, currentGameResolution3.Fullscreen);
		Registry registry4 = Amplitude.Unity.Framework.Application.Registry;
		StaticString key4 = registryResolutionModeValue;
		GameResolution currentGameResolution4 = CurrentGameResolution;
		registry4.SetValue(key4, currentGameResolution4.Mode);
	}

	public ScreenResolution GetCurrentDisplayResolution()
	{
		return GetDisplayResolution(CurrentGameResolution);
	}

	private ScreenResolution GetDisplayResolution(GameResolution gameResolution)
	{
		if (!IsResolutionHighEnough(gameResolution.ScreenResolution))
		{
			return gameResolution.ScreenResolution;
		}
		switch (gameResolution.Mode)
		{
		case ResolutionMode.PixelPerfect:
		{
			if (TryGetBestPixelPerfectResolution(gameResolution.ScreenResolution, out ScreenResolution pixelPerfectResolution))
			{
				return pixelPerfectResolution;
			}
			Diagnostics.LogError("No pixel perfect resolution found for {0}x{1}", gameResolution.ScreenResolution.Width, gameResolution.ScreenResolution.Height);
			return gameResolution.ScreenResolution;
		}
		case ResolutionMode.SameRatio:
			return GetBestSameRatioResolution(gameResolution.ScreenResolution);
		default:
			return gameResolution.ScreenResolution;
		}
	}

	public Vector2 GetCurrentResolutionBorders()
	{
		return GetGameResolutionBorders(CurrentGameResolution);
	}

	private Vector2 GetGameResolutionBorders(GameResolution gameResolution)
	{
		return GetBordersBetweenResolutions(GetDisplayResolution(gameResolution), gameResolution.ScreenResolution);
	}

	private Vector2 GetBordersBetweenResolutions(ScreenResolution resolution1, ScreenResolution resolution2)
	{
		return new Vector2(((float)resolution2.Width - (float)resolution1.Width) / 2f, ((float)resolution2.Height - (float)resolution1.Height) / 2f);
	}

	public bool IsResolutionPixelPerfect(ScreenResolution screenResolution)
	{
		if (!IsResolutionSameRatio(screenResolution))
		{
			return false;
		}
		return screenResolution.Width / gameplayResolution.Width >= 1 && screenResolution.Width % gameplayResolution.Width == 0;
	}

	public bool IsResolutionSameRatio(ScreenResolution screenResolution)
	{
		float ratio = gameplayResolution.GetRatio();
		float ratio2 = screenResolution.GetRatio();
		return ratio2 == ratio;
	}

	public bool IsResolutionHighEnough(ScreenResolution screenResolution)
	{
		if (screenResolution.Width < minResolution.Width || screenResolution.Height < minResolution.Height)
		{
			return false;
		}
		return true;
	}

	public bool TryGetBestPixelPerfectResolution(ScreenResolution screenResolution, out ScreenResolution pixelPerfectResolution)
	{
		if (IsResolutionPixelPerfect(screenResolution))
		{
			pixelPerfectResolution = screenResolution;
			return true;
		}
		pixelPerfectResolution = default(ScreenResolution);
		int num = 1;
		bool result = false;
		ScreenResolution screenResolution2 = default(ScreenResolution);
		while (true)
		{
			screenResolution2.Width = num * gameplayResolution.Width;
			screenResolution2.Height = num * gameplayResolution.Height;
			if (screenResolution2.Width > screenResolution.Width || screenResolution2.Height > screenResolution.Height)
			{
				break;
			}
			pixelPerfectResolution = screenResolution2;
			result = true;
			num++;
		}
		return result;
	}

	public ScreenResolution GetBestSameRatioResolution(ScreenResolution screenResolution)
	{
		float a = (float)screenResolution.Width / (float)gameplayResolution.Width;
		float b = (float)screenResolution.Height / (float)gameplayResolution.Height;
		float num = Mathf.Min(a, b);
		ScreenResolution result = default(ScreenResolution);
		result.Width = Mathf.Min(GenericUtilities.RoundHalfAwayFromZeroToInt((float)gameplayResolution.Width * num), screenResolution.Width);
		result.Height = Mathf.Min(GenericUtilities.RoundHalfAwayFromZeroToInt((float)gameplayResolution.Height * num), screenResolution.Height);
		return result;
	}
}
public enum ResolutionMode
{
	PixelPerfect,
	SameRatio,
	NoBorders
}
[Serializable]
public struct ScreenResolution
{
	public int Width;

	public int Height;

	public float GetRatio()
	{
		return (float)Width / (float)Height;
	}
}
[Serializable]
public struct GameResolution
{
	public ScreenResolution ScreenResolution;

	public bool Fullscreen;

	public ResolutionMode Mode;
}
public interface IGameResolutionService : IService
{
	GameResolution CurrentGameResolution
	{
		get;
	}

	ScreenResolution GameplayResolution
	{
		get;
	}

	bool VSync
	{
		get;
	}

	event OnGameResolutionChangedEventHandler OnGameResolutionChanged;

	event OnVSyncChangedEventHandler OnVSyncChanged;

	ScreenResolution[] GetAvailableScreenResolutions();

	void SetGameResolution(GameResolution resolution);

	void SetScreenResolution(ScreenResolution screenResolution);

	void SetFullscreen(bool fullscreen);

	void SetVSync(bool vSync);

	void RestoreSavedVSync();

	void SaveVSync();

	void SetResolutionMode(ResolutionMode mode);

	void RestoreSavedResolution();

	void SaveCurrentGameResolution();

	ScreenResolution GetCurrentDisplayResolution();

	Vector2 GetCurrentResolutionBorders();

	bool IsResolutionPixelPerfect(ScreenResolution screenResolution);

	bool IsResolutionSameRatio(ScreenResolution screenResolution);

	bool IsResolutionHighEnough(ScreenResolution screenResolution);

	bool TryGetBestPixelPerfectResolution(ScreenResolution screenResolution, out ScreenResolution pixelPerfectResolution);

	ScreenResolution GetBestSameRatioResolution(ScreenResolution screenResolution);
}
[Serializable]
public class ViewManager : Amplitude.Unity.View.ViewManager
{
}
public class GameLoadingView : Amplitude.Unity.View.View
{
	[SerializeField]
	private string screenName;

	public GameLoadingView()
	{
		base.Static = true;
	}

	public override void Focus(bool focused)
	{
		base.Focus(focused);
		IGuiService service = Services.GetService<IGuiService>();
		if (service != null)
		{
			if (focused)
			{
				service.Show(screenName);
			}
			else
			{
				service.Hide(screenName);
			}
		}
	}
}
public class GameView : Amplitude.Unity.View.View
{
	[SerializeField]
	private string screenName;

	public GameView()
	{
		base.Static = true;
	}

	public override void Focus(bool focused)
	{
		base.Focus(focused);
		IGuiService service = Services.GetService<IGuiService>();
		if (service != null)
		{
			if (focused)
			{
				service.Show(screenName);
			}
			else
			{
				service.Hide(screenName);
			}
		}
	}
}
public class OutGameView : Amplitude.Unity.View.View
{
	[SerializeField]
	private string screenName;

	private IInputService inputManager;

	private MoviePanel moviePanel;

	private Album album;

	private SelectableManager selectableManager;

	public OutGameView()
	{
		base.Static = true;
	}

	public override void Focus(bool focused)
	{
		base.Focus(focused);
		IGuiService service = Services.GetService<IGuiService>();
		if (focused)
		{
			service?.Show(screenName);
			EndLevelPanel endLevelPanel = SingletonManager.Get<EndLevelPanel>(mandatory: false);
			if (endLevelPanel != null)
			{
				endLevelPanel.Hide(instant: true);
			}
			VictoryPanel victoryPanel = SingletonManager.Get<VictoryPanel>(mandatory: false);
			if (victoryPanel != null)
			{
				victoryPanel.Hide(instant: true);
			}
			GameOverPanel gameOverPanel = SingletonManager.Get<GameOverPanel>(mandatory: false);
			if (gameOverPanel != null)
			{
				gameOverPanel.Hide(instant: true);
			}
			GameSelectionPanel gameSelectionPanel = SingletonManager.Get<GameSelectionPanel>(mandatory: false);
			if (gameSelectionPanel != null)
			{
				gameSelectionPanel.Hide(instant: true);
			}
			Ending ending = SingletonManager.Get<Ending>();
			if (ending != null)
			{
				ending.Hide();
			}
			Time.timeScale = 1f;
			SingletonManager.Get<MainMenuCamera>().GetComponent<Camera>().enabled = true;
		}
		else
		{
			service?.Hide(screenName);
		}
	}

	private void Update()
	{
		if (!IsFocused)
		{
			return;
		}
		if (moviePanel == null)
		{
			moviePanel = SingletonManager.Get<MoviePanel>(mandatory: false);
		}
		if (!(moviePanel != null) || moviePanel.AgeTransform.Visible)
		{
			return;
		}
		if (inputManager == null)
		{
			inputManager = Services.GetService<IInputService>();
		}
		if (!inputManager.KeyboardShortcutEnabled)
		{
			return;
		}
		if (PopupMenuPanel.GetTopPopupMenuPanel() != null && (AgeManager.Instance.FocusedControl == null || !(AgeManager.Instance.FocusedControl is KeyBindingTextField)) && inputManager.GetControlDown(Control.EscapeBehavior))
		{
			PopupMenuPanel.CloseTopPopupMenuPanelForEscapeBehavior();
		}
		if (selectableManager == null)
		{
			selectableManager = SingletonManager.Get<SelectableManager>();
		}
		if (inputManager.CurrentControlScheme != 0)
		{
			if (!(selectableManager != null))
			{
				return;
			}
			SelectionCategoryData currentCategory = selectableManager.CurrentCategory;
			if (currentCategory.Category != SelectionCategory.MainMenu)
			{
				return;
			}
		}
		if (inputManager.GetControlDown(Control.EscapeBehavior))
		{
			SingletonManager.Get<MainMenuPanel>().DisplayGameQuitDialogue();
		}
	}
}
public class View : Amplitude.Unity.View.View
{
	[Service]
	private IRuntimeService RuntimeService
	{
		get;
		set;
	}

	[Service]
	private ISessionService SessionService
	{
		get;
		set;
	}

	public View()
	{
		base.Static = true;
	}

	protected override IEnumerator Load()
	{
		yield return base.Load();
		RuntimeService = Services.GetService<IRuntimeService>();
		SessionService = Services.GetService<ISessionService>();
		if (SessionService != null)
		{
			SessionService.SessionChange += SessionService_SessionChange;
		}
	}

	private void SessionService_SessionChange(object sender, SessionChangeEventArgs e)
	{
		switch (e.Action)
		{
		case SessionChangeAction.Created:
			break;
		case SessionChangeAction.Releasing:
		case SessionChangeAction.Opening:
		case SessionChangeAction.Opened:
			break;
		case SessionChangeAction.Released:
		case SessionChangeAction.Closed:
			break;
		}
	}
}
public class RoomRoof : MonoBehaviour
{
	private void Awake()
	{
		Dungeon dungeon = SingletonManager.Get<Dungeon>();
		if (dungeon == null || !dungeon.ShipConfig.UseWallProps)
		{
			UnityEngine.Object.Destroy(this);
			return;
		}
		TemplateManager templateManager = SingletonManager.Get<TemplateManager>();
		Renderer component = GetComponent<Renderer>();
		float[] array = new float[3];
		Vector3 size = component.bounds.size;
		array[0] = size.x;
		Vector3 size2 = component.bounds.size;
		array[1] = size2.y;
		Vector3 size3 = component.bounds.size;
		array[2] = size3.z;
		int num = (int)Mathf.Max(array);
		int num2 = 0;
		WallPropData wallPropData = default(WallPropData);
		List<SpriteAnimationRuntime2> list = new List<SpriteAnimationRuntime2>();
		do
		{
			List<WallPropData> list2 = new List<WallPropData>();
			for (int i = 0; i < templateManager.WallPropsData.Count; i++)
			{
				WallPropData wallPropData2 = templateManager.WallPropsData[i];
				if (wallPropData2.Length <= num - num2)
				{
					WallPropData wallPropData3 = templateManager.WallPropsData[i];
					if (wallPropData3.Length != 32 || (wallPropData.Length != 32 && num - num2 - 64 != 0))
					{
						list2.Add(templateManager.WallPropsData[i]);
					}
				}
			}
			if (list2.Count == 0)
			{
				break;
			}
			WallPropData wallPropData4 = list2[UnityEngine.Random.Range(0, list2.Count - 1)];
			wallPropData = wallPropData4;
			float d = wallPropData4.Length / 2 + num2 - num / 2;
			Vector3 a = base.transform.parent.InverseTransformDirection(base.transform.right);
			Vector3 position = component.bounds.center + a * d;
			GameObject gameObject = UnityEngine.Object.Instantiate(wallPropData4.Prefab, position, base.transform.rotation) as GameObject;
			gameObject.transform.parent = base.transform;
			gameObject.transform.localPosition += wallPropData4.Prefab.transform.localPosition;
			int num3 = (UnityEngine.Random.Range(0, 2) % 2 == 0) ? 1 : (-1);
			int num4 = (UnityEngine.Random.Range(0, 2) % 2 == 0) ? 1 : (-1);
			Transform transform = gameObject.transform;
			Vector3 localScale = gameObject.transform.localScale;
			float x = localScale.x * (float)num3;
			Vector3 localScale2 = gameObject.transform.localScale;
			float y = localScale2.y * (float)num4;
			Vector3 localScale3 = gameObject.transform.localScale;
			transform.localScale = new Vector3(x, y, localScale3.z);
			num2 += wallPropData4.Length;
			list.Add(gameObject.GetComponent<SpriteAnimationRuntime2>());
		}
		while (num2 < num);
		for (int j = 0; j < list.Count; j++)
		{
			list[j].OverrideClipsFromPath("SpriteAnimations/Props/OrganicProps/" + list[j].name.Replace("(Clone)", string.Empty) + "/");
		}
	}
}
public class iTween : MonoBehaviour
{
	public enum EaseType
	{
		easeInQuad,
		easeOutQuad,
		easeInOutQuad,
		easeInCubic,
		easeOutCubic,
		easeInOutCubic,
		easeInQuart,
		easeOutQuart,
		easeInOutQuart,
		easeInQuint,
		easeOutQuint,
		easeInOutQuint,
		easeInSine,
		easeOutSine,
		easeInOutSine,
		easeInExpo,
		easeOutExpo,
		easeInOutExpo,
		easeInCirc,
		easeOutCirc,
		easeInOutCirc,
		linear,
		spring,
		easeInBounce,
		easeOutBounce,
		easeInOutBounce,
		easeInBack,
		easeOutBack,
		easeInOutBack,
		easeInElastic,
		easeOutElastic,
		easeInOutElastic,
		punch
	}

	public enum LoopType
	{
		none,
		loop,
		pingPong
	}

	public enum NamedValueColor
	{
		_Color,
		_SpecColor,
		_Emission,
		_ReflectColor
	}

	public static class Defaults
	{
		public static float time = 1f;

		public static float delay = 0f;

		public static NamedValueColor namedColorValue = NamedValueColor._Color;

		public static LoopType loopType = LoopType.none;

		public static EaseType easeType = EaseType.easeOutExpo;

		public static float lookSpeed = 3f;

		public static bool isLocal = false;

		public static Space space = Space.Self;

		public static bool orientToPath = false;

		public static Color color = Color.white;

		public static float updateTimePercentage = 0.05f;

		public static float updateTime = 1f * updateTimePercentage;

		public static int cameraFadeDepth = 999999;

		public static float lookAhead = 0.05f;

		public static bool useRealTime = false;

		public static Vector3 up = Vector3.up;
	}

	private class CRSpline
	{
		public Vector3[] pts;

		public CRSpline(params Vector3[] pts)
		{
			this.pts = new Vector3[pts.Length];
			Array.Copy(pts, this.pts, pts.Length);
		}

		public Vector3 Interp(float t)
		{
			int num = pts.Length - 3;
			int num2 = Mathf.Min(Mathf.FloorToInt(t * (float)num), num - 1);
			float num3 = t * (float)num - (float)num2;
			Vector3 a = pts[num2];
			Vector3 a2 = pts[num2 + 1];
			Vector3 vector = pts[num2 + 2];
			Vector3 b = pts[num2 + 3];
			return 0.5f * ((-a + 3f * a2 - 3f * vector + b) * (num3 * num3 * num3) + (2f * a - 5f * a2 + 4f * vector - b) * (num3 * num3) + (-a + vector) * num3 + 2f * a2);
		}
	}

	private delegate float EasingFunction(float start, float end, float value);

	private delegate void ApplyTween();

	public static ArrayList tweens = new ArrayList();

	private static GameObject cameraFade;

	public string id;

	public string type;

	public string method;

	public EaseType easeType;

	public float time;

	public float delay;

	public LoopType loopType;

	public bool isRunning;

	public bool isPaused;

	public string _name;

	private float runningTime;

	private float percentage;

	private float delayStarted;

	private bool kinematic;

	private bool isLocal;

	private bool loop;

	private bool reverse;

	private bool wasPaused;

	private bool physics;

	private Hashtable tweenArguments;

	private Space space;

	private EasingFunction ease;

	private ApplyTween apply;

	private AudioSource audioSource;

	private Vector3[] vector3s;

	private Vector2[] vector2s;

	private Color[,] colors;

	private float[] floats;

	private Rect[] rects;

	private CRSpline path;

	private Vector3 preUpdate;

	private Vector3 postUpdate;

	private NamedValueColor namedcolorvalue;

	private float lastRealTime;

	private bool useRealTime;

	public static void Init(GameObject target)
	{
		MoveBy(target, Vector3.zero, 0f);
	}

	public static void CameraFadeFrom(float amount, float time)
	{
		if ((bool)cameraFade)
		{
			CameraFadeFrom(Hash("amount", amount, "time", time));
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void CameraFadeFrom(Hashtable args)
	{
		if ((bool)cameraFade)
		{
			ColorFrom(cameraFade, args);
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void CameraFadeTo(float amount, float time)
	{
		if ((bool)cameraFade)
		{
			CameraFadeTo(Hash("amount", amount, "time", time));
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void CameraFadeTo(Hashtable args)
	{
		if ((bool)cameraFade)
		{
			ColorTo(cameraFade, args);
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void ValueTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("onupdate") || !args.Contains("from") || !args.Contains("to"))
		{
			UnityEngine.Debug.LogError("iTween Error: ValueTo() requires an 'onupdate' callback function and a 'from' and 'to' property.  The supplied 'onupdate' callback must accept a single argument that is the same type as the supplied 'from' and 'to' properties!");
			return;
		}
		args["type"] = "value";
		if (args["from"].GetType() == typeof(Vector2))
		{
			args["method"] = "vector2";
		}
		else if (args["from"].GetType() == typeof(Vector3))
		{
			args["method"] = "vector3";
		}
		else if (args["from"].GetType() == typeof(Rect))
		{
			args["method"] = "rect";
		}
		else if (args["from"].GetType() == typeof(float))
		{
			args["method"] = "float";
		}
		else
		{
			if (args["from"].GetType() != typeof(Color))
			{
				UnityEngine.Debug.LogError("iTween Error: ValueTo() only works with interpolating Vector3s, Vector2s, floats, ints, Rects and Colors!");
				return;
			}
			args["method"] = "color";
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		Launch(target, args);
	}

	public static void FadeFrom(GameObject target, float alpha, float time)
	{
		FadeFrom(target, Hash("alpha", alpha, "time", time));
	}

	public static void FadeFrom(GameObject target, Hashtable args)
	{
		ColorFrom(target, args);
	}

	public static void FadeTo(GameObject target, float alpha, float time)
	{
		FadeTo(target, Hash("alpha", alpha, "time", time));
	}

	public static void FadeTo(GameObject target, Hashtable args)
	{
		ColorTo(target, args);
	}

	public static void ColorFrom(GameObject target, Color color, float time)
	{
		ColorFrom(target, Hash("color", color, "time", time));
	}

	public static void ColorFrom(GameObject target, Hashtable args)
	{
		Color color = default(Color);
		Color color2 = default(Color);
		args = CleanArgs(args);
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				Hashtable hashtable = (Hashtable)args.Clone();
				hashtable["ischild"] = true;
				ColorFrom(item.gameObject, hashtable);
			}
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		if ((bool)target.GetComponent(typeof(GUITexture)))
		{
			color2 = (color = target.GetComponent<GUITexture>().color);
		}
		else if ((bool)target.GetComponent(typeof(GUIText)))
		{
			color2 = (color = target.GetComponent<GUIText>().material.color);
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			color2 = (color = target.GetComponent<Renderer>().material.color);
		}
		else if ((bool)target.GetComponent<Light>())
		{
			color2 = (color = target.GetComponent<Light>().color);
		}
		if (args.Contains("color"))
		{
			color = (Color)args["color"];
		}
		else
		{
			if (args.Contains("r"))
			{
				color.r = (float)args["r"];
			}
			if (args.Contains("g"))
			{
				color.g = (float)args["g"];
			}
			if (args.Contains("b"))
			{
				color.b = (float)args["b"];
			}
			if (args.Contains("a"))
			{
				color.a = (float)args["a"];
			}
		}
		if (args.Contains("amount"))
		{
			color.a = (float)args["amount"];
			args.Remove("amount");
		}
		else if (args.Contains("alpha"))
		{
			color.a = (float)args["alpha"];
			args.Remove("alpha");
		}
		if ((bool)target.GetComponent(typeof(GUITexture)))
		{
			target.GetComponent<GUITexture>().color = color;
		}
		else if ((bool)target.GetComponent(typeof(GUIText)))
		{
			target.GetComponent<GUIText>().material.color = color;
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			target.GetComponent<Renderer>().material.color = color;
		}
		else if ((bool)target.GetComponent<Light>())
		{
			target.GetComponent<Light>().color = color;
		}
		args["color"] = color2;
		args["type"] = "color";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ColorTo(GameObject target, Color color, float time)
	{
		ColorTo(target, Hash("color", color, "time", time));
	}

	public static void ColorTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				Hashtable hashtable = (Hashtable)args.Clone();
				hashtable["ischild"] = true;
				ColorTo(item.gameObject, hashtable);
			}
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "color";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void AudioFrom(GameObject target, float volume, float pitch, float time)
	{
		AudioFrom(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void AudioFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		AudioSource audioSource;
		if (args.Contains("audiosource"))
		{
			audioSource = (AudioSource)args["audiosource"];
		}
		else
		{
			if (!target.GetComponent(typeof(AudioSource)))
			{
				UnityEngine.Debug.LogError("iTween Error: AudioFrom requires an AudioSource.");
				return;
			}
			audioSource = target.GetComponent<AudioSource>();
		}
		Vector2 vector = default(Vector2);
		Vector2 vector2 = default(Vector2);
		vector.x = (vector2.x = audioSource.volume);
		vector.y = (vector2.y = audioSource.pitch);
		if (args.Contains("volume"))
		{
			vector2.x = (float)args["volume"];
		}
		if (args.Contains("pitch"))
		{
			vector2.y = (float)args["pitch"];
		}
		audioSource.volume = vector2.x;
		audioSource.pitch = vector2.y;
		args["volume"] = vector.x;
		args["pitch"] = vector.y;
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "audio";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void AudioTo(GameObject target, float volume, float pitch, float time)
	{
		AudioTo(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void AudioTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "audio";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void Stab(GameObject target, AudioClip audioclip, float delay)
	{
		Stab(target, Hash("audioclip", audioclip, "delay", delay));
	}

	public static void Stab(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "stab";
		Launch(target, args);
	}

	public static void LookFrom(GameObject target, Vector3 looktarget, float time)
	{
		LookFrom(target, Hash("looktarget", looktarget, "time", time));
	}

	public static void LookFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		Vector3 eulerAngles = target.transform.eulerAngles;
		if (args["looktarget"].GetType() == typeof(Transform))
		{
			Transform transform = target.transform;
			Transform target2 = (Transform)args["looktarget"];
			Vector3? vector = (Vector3?)args["up"];
			transform.LookAt(target2, (!vector.HasValue) ? Defaults.up : vector.Value);
		}
		else if (args["looktarget"].GetType() == typeof(Vector3))
		{
			Transform transform2 = target.transform;
			Vector3 worldPosition = (Vector3)args["looktarget"];
			Vector3? vector2 = (Vector3?)args["up"];
			transform2.LookAt(worldPosition, (!vector2.HasValue) ? Defaults.up : vector2.Value);
		}
		if (args.Contains("axis"))
		{
			Vector3 eulerAngles2 = target.transform.eulerAngles;
			switch ((string)args["axis"])
			{
			case "x":
				eulerAngles2.y = eulerAngles.y;
				eulerAngles2.z = eulerAngles.z;
				break;
			case "y":
				eulerAngles2.x = eulerAngles.x;
				eulerAngles2.z = eulerAngles.z;
				break;
			case "z":
				eulerAngles2.x = eulerAngles.x;
				eulerAngles2.y = eulerAngles.y;
				break;
			}
			target.transform.eulerAngles = eulerAngles2;
		}
		args["rotation"] = eulerAngles;
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void LookTo(GameObject target, Vector3 looktarget, float time)
	{
		LookTo(target, Hash("looktarget", looktarget, "time", time));
	}

	public static void LookTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("looktarget") && args["looktarget"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["looktarget"];
			Hashtable hashtable = args;
			Vector3 position = transform.position;
			float x = position.x;
			Vector3 position2 = transform.position;
			float y = position2.y;
			Vector3 position3 = transform.position;
			hashtable["position"] = new Vector3(x, y, position3.z);
			Hashtable hashtable2 = args;
			Vector3 eulerAngles = transform.eulerAngles;
			float x2 = eulerAngles.x;
			Vector3 eulerAngles2 = transform.eulerAngles;
			float y2 = eulerAngles2.y;
			Vector3 eulerAngles3 = transform.eulerAngles;
			hashtable2["rotation"] = new Vector3(x2, y2, eulerAngles3.z);
		}
		args["type"] = "look";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveTo(GameObject target, Vector3 position, float time)
	{
		MoveTo(target, Hash("position", position, "time", time));
	}

	public static void MoveTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("position") && args["position"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["position"];
			Hashtable hashtable = args;
			Vector3 position = transform.position;
			float x = position.x;
			Vector3 position2 = transform.position;
			float y = position2.y;
			Vector3 position3 = transform.position;
			hashtable["position"] = new Vector3(x, y, position3.z);
			Hashtable hashtable2 = args;
			Vector3 eulerAngles = transform.eulerAngles;
			float x2 = eulerAngles.x;
			Vector3 eulerAngles2 = transform.eulerAngles;
			float y2 = eulerAngles2.y;
			Vector3 eulerAngles3 = transform.eulerAngles;
			hashtable2["rotation"] = new Vector3(x2, y2, eulerAngles3.z);
			Hashtable hashtable3 = args;
			Vector3 localScale = transform.localScale;
			float x3 = localScale.x;
			Vector3 localScale2 = transform.localScale;
			float y3 = localScale2.y;
			Vector3 localScale3 = transform.localScale;
			hashtable3["scale"] = new Vector3(x3, y3, localScale3.z);
		}
		args["type"] = "move";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveFrom(GameObject target, Vector3 position, float time)
	{
		MoveFrom(target, Hash("position", position, "time", time));
	}

	public static void MoveFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		bool flag = (!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]);
		if (args.Contains("path"))
		{
			Vector3[] array2;
			if (args["path"].GetType() == typeof(Vector3[]))
			{
				Vector3[] array = (Vector3[])args["path"];
				array2 = new Vector3[array.Length];
				Array.Copy(array, array2, array.Length);
			}
			else
			{
				Transform[] array3 = (Transform[])args["path"];
				array2 = new Vector3[array3.Length];
				for (int i = 0; i < array3.Length; i++)
				{
					array2[i] = array3[i].position;
				}
			}
			if (array2[array2.Length - 1] != target.transform.position)
			{
				Vector3[] array4 = new Vector3[array2.Length + 1];
				Array.Copy(array2, array4, array2.Length);
				if (flag)
				{
					array4[array4.Length - 1] = target.transform.localPosition;
					target.transform.localPosition = array4[0];
				}
				else
				{
					array4[array4.Length - 1] = target.transform.position;
					target.transform.position = array4[0];
				}
				args["path"] = array4;
			}
			else
			{
				if (flag)
				{
					target.transform.localPosition = array2[0];
				}
				else
				{
					target.transform.position = array2[0];
				}
				args["path"] = array2;
			}
		}
		else
		{
			Vector3 vector;
			Vector3 vector2 = (!flag) ? (vector = target.transform.position) : (vector = target.transform.localPosition);
			if (args.Contains("position"))
			{
				if (args["position"].GetType() == typeof(Transform))
				{
					Transform transform = (Transform)args["position"];
					vector = transform.position;
				}
				else if (args["position"].GetType() == typeof(Vector3))
				{
					vector = (Vector3)args["position"];
				}
			}
			else
			{
				if (args.Contains("x"))
				{
					vector.x = (float)args["x"];
				}
				if (args.Contains("y"))
				{
					vector.y = (float)args["y"];
				}
				if (args.Contains("z"))
				{
					vector.z = (float)args["z"];
				}
			}
			if (flag)
			{
				target.transform.localPosition = vector;
			}
			else
			{
				target.transform.position = vector;
			}
			args["position"] = vector2;
		}
		args["type"] = "move";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveAdd(GameObject target, Vector3 amount, float time)
	{
		MoveAdd(target, Hash("amount", amount, "time", time));
	}

	public static void MoveAdd(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "move";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void MoveBy(GameObject target, Vector3 amount, float time)
	{
		MoveBy(target, Hash("amount", amount, "time", time));
	}

	public static void MoveBy(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "move";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void ScaleTo(GameObject target, Vector3 scale, float time)
	{
		ScaleTo(target, Hash("scale", scale, "time", time));
	}

	public static void ScaleTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("scale") && args["scale"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["scale"];
			Hashtable hashtable = args;
			Vector3 position = transform.position;
			float x = position.x;
			Vector3 position2 = transform.position;
			float y = position2.y;
			Vector3 position3 = transform.position;
			hashtable["position"] = new Vector3(x, y, position3.z);
			Hashtable hashtable2 = args;
			Vector3 eulerAngles = transform.eulerAngles;
			float x2 = eulerAngles.x;
			Vector3 eulerAngles2 = transform.eulerAngles;
			float y2 = eulerAngles2.y;
			Vector3 eulerAngles3 = transform.eulerAngles;
			hashtable2["rotation"] = new Vector3(x2, y2, eulerAngles3.z);
			Hashtable hashtable3 = args;
			Vector3 localScale = transform.localScale;
			float x3 = localScale.x;
			Vector3 localScale2 = transform.localScale;
			float y3 = localScale2.y;
			Vector3 localScale3 = transform.localScale;
			hashtable3["scale"] = new Vector3(x3, y3, localScale3.z);
		}
		args["type"] = "scale";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ScaleFrom(GameObject target, Vector3 scale, float time)
	{
		ScaleFrom(target, Hash("scale", scale, "time", time));
	}

	public static void ScaleFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		Vector3 localScale;
		Vector3 vector = localScale = target.transform.localScale;
		if (args.Contains("scale"))
		{
			if (args["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["scale"];
				localScale = transform.localScale;
			}
			else if (args["scale"].GetType() == typeof(Vector3))
			{
				localScale = (Vector3)args["scale"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				localScale.x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				localScale.y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				localScale.z = (float)args["z"];
			}
		}
		target.transform.localScale = localScale;
		args["scale"] = vector;
		args["type"] = "scale";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ScaleAdd(GameObject target, Vector3 amount, float time)
	{
		ScaleAdd(target, Hash("amount", amount, "time", time));
	}

	public static void ScaleAdd(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "scale";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void ScaleBy(GameObject target, Vector3 amount, float time)
	{
		ScaleBy(target, Hash("amount", amount, "time", time));
	}

	public static void ScaleBy(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "scale";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void RotateTo(GameObject target, Vector3 rotation, float time)
	{
		RotateTo(target, Hash("rotation", rotation, "time", time));
	}

	public static void RotateTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("rotation") && args["rotation"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["rotation"];
			Hashtable hashtable = args;
			Vector3 position = transform.position;
			float x = position.x;
			Vector3 position2 = transform.position;
			float y = position2.y;
			Vector3 position3 = transform.position;
			hashtable["position"] = new Vector3(x, y, position3.z);
			Hashtable hashtable2 = args;
			Vector3 eulerAngles = transform.eulerAngles;
			float x2 = eulerAngles.x;
			Vector3 eulerAngles2 = transform.eulerAngles;
			float y2 = eulerAngles2.y;
			Vector3 eulerAngles3 = transform.eulerAngles;
			hashtable2["rotation"] = new Vector3(x2, y2, eulerAngles3.z);
			Hashtable hashtable3 = args;
			Vector3 localScale = transform.localScale;
			float x3 = localScale.x;
			Vector3 localScale2 = transform.localScale;
			float y3 = localScale2.y;
			Vector3 localScale3 = transform.localScale;
			hashtable3["scale"] = new Vector3(x3, y3, localScale3.z);
		}
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void RotateFrom(GameObject target, Vector3 rotation, float time)
	{
		RotateFrom(target, Hash("rotation", rotation, "time", time));
	}

	public static void RotateFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		bool flag = (!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]);
		Vector3 vector;
		Vector3 vector2 = (!flag) ? (vector = target.transform.eulerAngles) : (vector = target.transform.localEulerAngles);
		if (args.Contains("rotation"))
		{
			if (args["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["rotation"];
				vector = transform.eulerAngles;
			}
			else if (args["rotation"].GetType() == typeof(Vector3))
			{
				vector = (Vector3)args["rotation"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				vector.x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				vector.y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				vector.z = (float)args["z"];
			}
		}
		if (flag)
		{
			target.transform.localEulerAngles = vector;
		}
		else
		{
			target.transform.eulerAngles = vector;
		}
		args["rotation"] = vector2;
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void RotateAdd(GameObject target, Vector3 amount, float time)
	{
		RotateAdd(target, Hash("amount", amount, "time", time));
	}

	public static void RotateAdd(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "rotate";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void RotateBy(GameObject target, Vector3 amount, float time)
	{
		RotateBy(target, Hash("amount", amount, "time", time));
	}

	public static void RotateBy(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "rotate";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void ShakePosition(GameObject target, Vector3 amount, float time)
	{
		ShakePosition(target, Hash("amount", amount, "time", time));
	}

	public static void ShakePosition(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "position";
		Launch(target, args);
	}

	public static void ShakeScale(GameObject target, Vector3 amount, float time)
	{
		ShakeScale(target, Hash("amount", amount, "time", time));
	}

	public static void ShakeScale(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "scale";
		Launch(target, args);
	}

	public static void ShakeRotation(GameObject target, Vector3 amount, float time)
	{
		ShakeRotation(target, Hash("amount", amount, "time", time));
	}

	public static void ShakeRotation(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "rotation";
		Launch(target, args);
	}

	public static void PunchPosition(GameObject target, Vector3 amount, float time)
	{
		PunchPosition(target, Hash("amount", amount, "time", time));
	}

	public static void PunchPosition(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "position";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	public static void PunchRotation(GameObject target, Vector3 amount, float time)
	{
		PunchRotation(target, Hash("amount", amount, "time", time));
	}

	public static void PunchRotation(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "rotation";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	public static void PunchScale(GameObject target, Vector3 amount, float time)
	{
		PunchScale(target, Hash("amount", amount, "time", time));
	}

	public static void PunchScale(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "scale";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	private void GenerateTargets()
	{
		switch (type)
		{
		case "value":
			switch (method)
			{
			case "float":
				GenerateFloatTargets();
				apply = ApplyFloatTargets;
				break;
			case "vector2":
				GenerateVector2Targets();
				apply = ApplyVector2Targets;
				break;
			case "vector3":
				GenerateVector3Targets();
				apply = ApplyVector3Targets;
				break;
			case "color":
				GenerateColorTargets();
				apply = ApplyColorTargets;
				break;
			case "rect":
				GenerateRectTargets();
				apply = ApplyRectTargets;
				break;
			}
			break;
		case "color":
			switch (method)
			{
			case "to":
				GenerateColorToTargets();
				apply = ApplyColorToTargets;
				break;
			}
			break;
		case "audio":
			switch (method)
			{
			case "to":
				GenerateAudioToTargets();
				apply = ApplyAudioToTargets;
				break;
			}
			break;
		case "move":
			switch (method)
			{
			case "to":
				if (tweenArguments.Contains("path"))
				{
					GenerateMoveToPathTargets();
					apply = ApplyMoveToPathTargets;
				}
				else
				{
					GenerateMoveToTargets();
					apply = ApplyMoveToTargets;
				}
				break;
			case "by":
			case "add":
				GenerateMoveByTargets();
				apply = ApplyMoveByTargets;
				break;
			}
			break;
		case "scale":
			switch (method)
			{
			case "to":
				GenerateScaleToTargets();
				apply = ApplyScaleToTargets;
				break;
			case "by":
				GenerateScaleByTargets();
				apply = ApplyScaleToTargets;
				break;
			case "add":
				GenerateScaleAddTargets();
				apply = ApplyScaleToTargets;
				break;
			}
			break;
		case "rotate":
			switch (method)
			{
			case "to":
				GenerateRotateToTargets();
				apply = ApplyRotateToTargets;
				break;
			case "add":
				GenerateRotateAddTargets();
				apply = ApplyRotateAddTargets;
				break;
			case "by":
				GenerateRotateByTargets();
				apply = ApplyRotateAddTargets;
				break;
			}
			break;
		case "shake":
			switch (method)
			{
			case "position":
				GenerateShakePositionTargets();
				apply = ApplyShakePositionTargets;
				break;
			case "scale":
				GenerateShakeScaleTargets();
				apply = ApplyShakeScaleTargets;
				break;
			case "rotation":
				GenerateShakeRotationTargets();
				apply = ApplyShakeRotationTargets;
				break;
			}
			break;
		case "punch":
			switch (method)
			{
			case "position":
				GeneratePunchPositionTargets();
				apply = ApplyPunchPositionTargets;
				break;
			case "rotation":
				GeneratePunchRotationTargets();
				apply = ApplyPunchRotationTargets;
				break;
			case "scale":
				GeneratePunchScaleTargets();
				apply = ApplyPunchScaleTargets;
				break;
			}
			break;
		case "look":
			switch (method)
			{
			case "to":
				GenerateLookToTargets();
				apply = ApplyLookToTargets;
				break;
			}
			break;
		case "stab":
			GenerateStabTargets();
			apply = ApplyStabTargets;
			break;
		}
	}

	private void GenerateRectTargets()
	{
		rects = new Rect[3];
		rects[0] = (Rect)tweenArguments["from"];
		rects[1] = (Rect)tweenArguments["to"];
	}

	private void GenerateColorTargets()
	{
		colors = new Color[1, 3];
		colors[0, 0] = (Color)tweenArguments["from"];
		colors[0, 1] = (Color)tweenArguments["to"];
	}

	private void GenerateVector3Targets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = (Vector3)tweenArguments["from"];
		vector3s[1] = (Vector3)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateVector2Targets()
	{
		vector2s = new Vector2[3];
		vector2s[0] = (Vector2)tweenArguments["from"];
		vector2s[1] = (Vector2)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			Vector3 a = new Vector3(vector2s[0].x, vector2s[0].y, 0f);
			Vector3 b = new Vector3(vector2s[1].x, vector2s[1].y, 0f);
			float num = Math.Abs(Vector3.Distance(a, b));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateFloatTargets()
	{
		floats = new float[3];
		floats[0] = (float)tweenArguments["from"];
		floats[1] = (float)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(floats[0] - floats[1]);
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateColorToTargets()
	{
		if ((bool)GetComponent(typeof(GUITexture)))
		{
			colors = new Color[1, 3];
			colors[0, 0] = (colors[0, 1] = GetComponent<GUITexture>().color);
		}
		else if ((bool)GetComponent(typeof(GUIText)))
		{
			colors = new Color[1, 3];
			colors[0, 0] = (colors[0, 1] = GetComponent<GUIText>().material.color);
		}
		else if ((bool)GetComponent<Renderer>())
		{
			colors = new Color[GetComponent<Renderer>().materials.Length, 3];
			for (int i = 0; i < GetComponent<Renderer>().materials.Length; i++)
			{
				colors[i, 0] = GetComponent<Renderer>().materials[i].GetColor(namedcolorvalue.ToString());
				colors[i, 1] = GetComponent<Renderer>().materials[i].GetColor(namedcolorvalue.ToString());
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			colors = new Color[1, 3];
			colors[0, 0] = (colors[0, 1] = GetComponent<Light>().color);
		}
		else
		{
			colors = new Color[1, 3];
		}
		if (tweenArguments.Contains("color"))
		{
			for (int j = 0; j < colors.GetLength(0); j++)
			{
				colors[j, 1] = (Color)tweenArguments["color"];
			}
		}
		else
		{
			if (tweenArguments.Contains("r"))
			{
				for (int k = 0; k < colors.GetLength(0); k++)
				{
					colors[k, 1].r = (float)tweenArguments["r"];
				}
			}
			if (tweenArguments.Contains("g"))
			{
				for (int l = 0; l < colors.GetLength(0); l++)
				{
					colors[l, 1].g = (float)tweenArguments["g"];
				}
			}
			if (tweenArguments.Contains("b"))
			{
				for (int m = 0; m < colors.GetLength(0); m++)
				{
					colors[m, 1].b = (float)tweenArguments["b"];
				}
			}
			if (tweenArguments.Contains("a"))
			{
				for (int n = 0; n < colors.GetLength(0); n++)
				{
					colors[n, 1].a = (float)tweenArguments["a"];
				}
			}
		}
		if (tweenArguments.Contains("amount"))
		{
			for (int num = 0; num < colors.GetLength(0); num++)
			{
				colors[num, 1].a = (float)tweenArguments["amount"];
			}
		}
		else if (tweenArguments.Contains("alpha"))
		{
			for (int num2 = 0; num2 < colors.GetLength(0); num2++)
			{
				colors[num2, 1].a = (float)tweenArguments["alpha"];
			}
		}
	}

	private void GenerateAudioToTargets()
	{
		vector2s = new Vector2[3];
		if (tweenArguments.Contains("audiosource"))
		{
			audioSource = (AudioSource)tweenArguments["audiosource"];
		}
		else if ((bool)GetComponent(typeof(AudioSource)))
		{
			audioSource = GetComponent<AudioSource>();
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: AudioTo requires an AudioSource.");
			Dispose();
		}
		vector2s[0] = (vector2s[1] = new Vector2(audioSource.volume, audioSource.pitch));
		if (tweenArguments.Contains("volume"))
		{
			vector2s[1].x = (float)tweenArguments["volume"];
		}
		if (tweenArguments.Contains("pitch"))
		{
			vector2s[1].y = (float)tweenArguments["pitch"];
		}
	}

	private void GenerateStabTargets()
	{
		if (tweenArguments.Contains("audiosource"))
		{
			audioSource = (AudioSource)tweenArguments["audiosource"];
		}
		else if ((bool)GetComponent(typeof(AudioSource)))
		{
			audioSource = GetComponent<AudioSource>();
		}
		else
		{
			base.gameObject.AddComponent(typeof(AudioSource));
			audioSource = GetComponent<AudioSource>();
			audioSource.playOnAwake = false;
		}
		audioSource.clip = (AudioClip)tweenArguments["audioclip"];
		if (tweenArguments.Contains("pitch"))
		{
			audioSource.pitch = (float)tweenArguments["pitch"];
		}
		if (tweenArguments.Contains("volume"))
		{
			audioSource.volume = (float)tweenArguments["volume"];
		}
		time = audioSource.clip.length / audioSource.pitch;
	}

	private void GenerateLookToTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = base.transform.eulerAngles;
		if (tweenArguments.Contains("looktarget"))
		{
			if (tweenArguments["looktarget"].GetType() == typeof(Transform))
			{
				Transform transform = base.transform;
				Transform target = (Transform)tweenArguments["looktarget"];
				Vector3? vector = (Vector3?)tweenArguments["up"];
				transform.LookAt(target, (!vector.HasValue) ? Defaults.up : vector.Value);
			}
			else if (tweenArguments["looktarget"].GetType() == typeof(Vector3))
			{
				Transform transform2 = base.transform;
				Vector3 worldPosition = (Vector3)tweenArguments["looktarget"];
				Vector3? vector2 = (Vector3?)tweenArguments["up"];
				transform2.LookAt(worldPosition, (!vector2.HasValue) ? Defaults.up : vector2.Value);
			}
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: LookTo needs a 'looktarget' property!");
			Dispose();
		}
		vector3s[1] = base.transform.eulerAngles;
		base.transform.eulerAngles = vector3s[0];
		if (tweenArguments.Contains("axis"))
		{
			switch ((string)tweenArguments["axis"])
			{
			case "x":
				vector3s[1].y = vector3s[0].y;
				vector3s[1].z = vector3s[0].z;
				break;
			case "y":
				vector3s[1].x = vector3s[0].x;
				vector3s[1].z = vector3s[0].z;
				break;
			case "z":
				vector3s[1].x = vector3s[0].x;
				vector3s[1].y = vector3s[0].y;
				break;
			}
		}
		vector3s[1] = new Vector3(clerp(vector3s[0].x, vector3s[1].x, 1f), clerp(vector3s[0].y, vector3s[1].y, 1f), clerp(vector3s[0].z, vector3s[1].z, 1f));
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveToPathTargets()
	{
		Vector3[] array2;
		if (tweenArguments["path"].GetType() == typeof(Vector3[]))
		{
			Vector3[] array = (Vector3[])tweenArguments["path"];
			if (array.Length == 1)
			{
				UnityEngine.Debug.LogError("iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!");
				Dispose();
			}
			array2 = new Vector3[array.Length];
			Array.Copy(array, array2, array.Length);
		}
		else
		{
			Transform[] array3 = (Transform[])tweenArguments["path"];
			if (array3.Length == 1)
			{
				UnityEngine.Debug.LogError("iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!");
				Dispose();
			}
			array2 = new Vector3[array3.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array2[i] = array3[i].position;
			}
		}
		bool flag;
		int num;
		if (base.transform.position != array2[0])
		{
			if (!tweenArguments.Contains("movetopath") || (bool)tweenArguments["movetopath"])
			{
				flag = true;
				num = 3;
			}
			else
			{
				flag = false;
				num = 2;
			}
		}
		else
		{
			flag = false;
			num = 2;
		}
		vector3s = new Vector3[array2.Length + num];
		if (flag)
		{
			vector3s[1] = base.transform.position;
			num = 2;
		}
		else
		{
			num = 1;
		}
		Array.Copy(array2, 0, vector3s, num, array2.Length);
		vector3s[0] = vector3s[1] + (vector3s[1] - vector3s[2]);
		vector3s[vector3s.Length - 1] = vector3s[vector3s.Length - 2] + (vector3s[vector3s.Length - 2] - vector3s[vector3s.Length - 3]);
		if (vector3s[1] == vector3s[vector3s.Length - 2])
		{
			Vector3[] array4 = new Vector3[vector3s.Length];
			Array.Copy(vector3s, array4, vector3s.Length);
			array4[0] = array4[array4.Length - 3];
			array4[array4.Length - 1] = array4[2];
			vector3s = new Vector3[array4.Length];
			Array.Copy(array4, vector3s, array4.Length);
		}
		path = new CRSpline(vector3s);
		if (tweenArguments.Contains("speed"))
		{
			float num2 = PathLength(vector3s);
			time = num2 / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveToTargets()
	{
		vector3s = new Vector3[3];
		if (isLocal)
		{
			vector3s[0] = (vector3s[1] = base.transform.localPosition);
		}
		else
		{
			vector3s[0] = (vector3s[1] = base.transform.position);
		}
		if (tweenArguments.Contains("position"))
		{
			if (tweenArguments["position"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["position"];
				vector3s[1] = transform.position;
			}
			else if (tweenArguments["position"].GetType() == typeof(Vector3))
			{
				vector3s[1] = (Vector3)tweenArguments["position"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			tweenArguments["looktarget"] = vector3s[1];
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveByTargets()
	{
		vector3s = new Vector3[6];
		vector3s[4] = base.transform.eulerAngles;
		vector3s[0] = (vector3s[1] = (vector3s[3] = base.transform.position));
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = vector3s[0] + (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = vector3s[0].x + (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = vector3s[0].y + (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = vector3s[0].z + (float)tweenArguments["z"];
			}
		}
		base.transform.Translate(vector3s[1], space);
		vector3s[5] = base.transform.position;
		base.transform.position = vector3s[0];
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			tweenArguments["looktarget"] = vector3s[1];
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleToTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = (vector3s[1] = base.transform.localScale);
		if (tweenArguments.Contains("scale"))
		{
			if (tweenArguments["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["scale"];
				vector3s[1] = transform.localScale;
			}
			else if (tweenArguments["scale"].GetType() == typeof(Vector3))
			{
				vector3s[1] = (Vector3)tweenArguments["scale"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleByTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = (vector3s[1] = base.transform.localScale);
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = Vector3.Scale(vector3s[1], (Vector3)tweenArguments["amount"]);
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x *= (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y *= (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z *= (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleAddTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = (vector3s[1] = base.transform.localScale);
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateToTargets()
	{
		vector3s = new Vector3[3];
		if (isLocal)
		{
			vector3s[0] = (vector3s[1] = base.transform.localEulerAngles);
		}
		else
		{
			vector3s[0] = (vector3s[1] = base.transform.eulerAngles);
		}
		if (tweenArguments.Contains("rotation"))
		{
			if (tweenArguments["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["rotation"];
				vector3s[1] = transform.eulerAngles;
			}
			else if (tweenArguments["rotation"].GetType() == typeof(Vector3))
			{
				vector3s[1] = (Vector3)tweenArguments["rotation"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		vector3s[1] = new Vector3(clerp(vector3s[0].x, vector3s[1].x, 1f), clerp(vector3s[0].y, vector3s[1].y, 1f), clerp(vector3s[0].z, vector3s[1].z, 1f));
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateAddTargets()
	{
		vector3s = new Vector3[5];
		vector3s[0] = (vector3s[1] = (vector3s[3] = base.transform.eulerAngles));
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateByTargets()
	{
		vector3s = new Vector3[4];
		vector3s[0] = (vector3s[1] = (vector3s[3] = base.transform.eulerAngles));
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += Vector3.Scale((Vector3)tweenArguments["amount"], new Vector3(360f, 360f, 360f));
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += 360f * (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += 360f * (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += 360f * (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateShakePositionTargets()
	{
		vector3s = new Vector3[4];
		vector3s[3] = base.transform.eulerAngles;
		vector3s[0] = base.transform.position;
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GenerateShakeScaleTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = base.transform.localScale;
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GenerateShakeRotationTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = base.transform.eulerAngles;
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchPositionTargets()
	{
		vector3s = new Vector3[5];
		vector3s[4] = base.transform.eulerAngles;
		vector3s[0] = base.transform.position;
		vector3s[1] = (vector3s[3] = Vector3.zero);
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchRotationTargets()
	{
		vector3s = new Vector3[4];
		vector3s[0] = base.transform.eulerAngles;
		vector3s[1] = (vector3s[3] = Vector3.zero);
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchScaleTargets()
	{
		vector3s = new Vector3[3];
		vector3s[0] = base.transform.localScale;
		vector3s[1] = Vector3.zero;
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void ApplyRectTargets()
	{
		rects[2].x = ease(rects[0].x, rects[1].x, percentage);
		rects[2].y = ease(rects[0].y, rects[1].y, percentage);
		rects[2].width = ease(rects[0].width, rects[1].width, percentage);
		rects[2].height = ease(rects[0].height, rects[1].height, percentage);
		tweenArguments["onupdateparams"] = rects[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = rects[1];
		}
	}

	private void ApplyColorTargets()
	{
		colors[0, 2].r = ease(colors[0, 0].r, colors[0, 1].r, percentage);
		colors[0, 2].g = ease(colors[0, 0].g, colors[0, 1].g, percentage);
		colors[0, 2].b = ease(colors[0, 0].b, colors[0, 1].b, percentage);
		colors[0, 2].a = ease(colors[0, 0].a, colors[0, 1].a, percentage);
		tweenArguments["onupdateparams"] = colors[0, 2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = colors[0, 1];
		}
	}

	private void ApplyVector3Targets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		tweenArguments["onupdateparams"] = vector3s[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = vector3s[1];
		}
	}

	private void ApplyVector2Targets()
	{
		vector2s[2].x = ease(vector2s[0].x, vector2s[1].x, percentage);
		vector2s[2].y = ease(vector2s[0].y, vector2s[1].y, percentage);
		tweenArguments["onupdateparams"] = vector2s[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = vector2s[1];
		}
	}

	private void ApplyFloatTargets()
	{
		floats[2] = ease(floats[0], floats[1], percentage);
		tweenArguments["onupdateparams"] = floats[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = floats[1];
		}
	}

	private void ApplyColorToTargets()
	{
		for (int i = 0; i < colors.GetLength(0); i++)
		{
			colors[i, 2].r = ease(colors[i, 0].r, colors[i, 1].r, percentage);
			colors[i, 2].g = ease(colors[i, 0].g, colors[i, 1].g, percentage);
			colors[i, 2].b = ease(colors[i, 0].b, colors[i, 1].b, percentage);
			colors[i, 2].a = ease(colors[i, 0].a, colors[i, 1].a, percentage);
		}
		if ((bool)GetComponent(typeof(GUITexture)))
		{
			GetComponent<GUITexture>().color = colors[0, 2];
		}
		else if ((bool)GetComponent(typeof(GUIText)))
		{
			GetComponent<GUIText>().material.color = colors[0, 2];
		}
		else if ((bool)GetComponent<Renderer>())
		{
			for (int j = 0; j < colors.GetLength(0); j++)
			{
				GetComponent<Renderer>().materials[j].SetColor(namedcolorvalue.ToString(), colors[j, 2]);
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			GetComponent<Light>().color = colors[0, 2];
		}
		if (percentage != 1f)
		{
			return;
		}
		if ((bool)GetComponent(typeof(GUITexture)))
		{
			GetComponent<GUITexture>().color = colors[0, 1];
		}
		else if ((bool)GetComponent(typeof(GUIText)))
		{
			GetComponent<GUIText>().material.color = colors[0, 1];
		}
		else if ((bool)GetComponent<Renderer>())
		{
			for (int k = 0; k < colors.GetLength(0); k++)
			{
				GetComponent<Renderer>().materials[k].SetColor(namedcolorvalue.ToString(), colors[k, 1]);
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			GetComponent<Light>().color = colors[0, 1];
		}
	}

	private void ApplyAudioToTargets()
	{
		vector2s[2].x = ease(vector2s[0].x, vector2s[1].x, percentage);
		vector2s[2].y = ease(vector2s[0].y, vector2s[1].y, percentage);
		audioSource.volume = vector2s[2].x;
		audioSource.pitch = vector2s[2].y;
		if (percentage == 1f)
		{
			audioSource.volume = vector2s[1].x;
			audioSource.pitch = vector2s[1].y;
		}
	}

	private void ApplyStabTargets()
	{
	}

	private void ApplyMoveToPathTargets()
	{
		preUpdate = base.transform.position;
		float value = ease(0f, 1f, percentage);
		if (isLocal)
		{
			base.transform.localPosition = path.Interp(Mathf.Clamp(value, 0f, 1f));
		}
		else
		{
			base.transform.position = path.Interp(Mathf.Clamp(value, 0f, 1f));
		}
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			float num = (!tweenArguments.Contains("lookahead")) ? Defaults.lookAhead : ((float)tweenArguments["lookahead"]);
			float value2 = ease(0f, 1f, Mathf.Min(1f, percentage + num));
			tweenArguments["looktarget"] = path.Interp(Mathf.Clamp(value2, 0f, 1f));
		}
		postUpdate = base.transform.position;
		if (physics)
		{
			base.transform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyMoveToTargets()
	{
		preUpdate = base.transform.position;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			base.transform.localPosition = vector3s[2];
		}
		else
		{
			base.transform.position = vector3s[2];
		}
		if (percentage == 1f)
		{
			if (isLocal)
			{
				base.transform.localPosition = vector3s[1];
			}
			else
			{
				base.transform.position = vector3s[1];
			}
		}
		postUpdate = base.transform.position;
		if (physics)
		{
			base.transform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyMoveByTargets()
	{
		preUpdate = base.transform.position;
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = base.transform.eulerAngles;
			base.transform.eulerAngles = vector3s[4];
		}
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		base.transform.Translate(vector3s[2] - vector3s[3], space);
		vector3s[3] = vector3s[2];
		if (tweenArguments.Contains("looktarget"))
		{
			base.transform.eulerAngles = eulerAngles;
		}
		postUpdate = base.transform.position;
		if (physics)
		{
			base.transform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyScaleToTargets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		base.transform.localScale = vector3s[2];
		if (percentage == 1f)
		{
			base.transform.localScale = vector3s[1];
		}
	}

	private void ApplyLookToTargets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			base.transform.localRotation = Quaternion.Euler(vector3s[2]);
		}
		else
		{
			base.transform.rotation = Quaternion.Euler(vector3s[2]);
		}
	}

	private void ApplyRotateToTargets()
	{
		preUpdate = base.transform.eulerAngles;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			base.transform.localRotation = Quaternion.Euler(vector3s[2]);
		}
		else
		{
			base.transform.rotation = Quaternion.Euler(vector3s[2]);
		}
		if (percentage == 1f)
		{
			if (isLocal)
			{
				base.transform.localRotation = Quaternion.Euler(vector3s[1]);
			}
			else
			{
				base.transform.rotation = Quaternion.Euler(vector3s[1]);
			}
		}
		postUpdate = base.transform.eulerAngles;
		if (physics)
		{
			base.transform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyRotateAddTargets()
	{
		preUpdate = base.transform.eulerAngles;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		base.transform.Rotate(vector3s[2] - vector3s[3], space);
		vector3s[3] = vector3s[2];
		postUpdate = base.transform.eulerAngles;
		if (physics)
		{
			base.transform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyShakePositionTargets()
	{
		if (isLocal)
		{
			preUpdate = base.transform.localPosition;
		}
		else
		{
			preUpdate = base.transform.position;
		}
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = base.transform.eulerAngles;
			base.transform.eulerAngles = vector3s[3];
		}
		if (percentage == 0f)
		{
			base.transform.Translate(vector3s[1], space);
		}
		if (isLocal)
		{
			base.transform.localPosition = vector3s[0];
		}
		else
		{
			base.transform.position = vector3s[0];
		}
		float num = 1f - percentage;
		vector3s[2].x = UnityEngine.Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = UnityEngine.Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = UnityEngine.Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		if (isLocal)
		{
			base.transform.localPosition += vector3s[2];
		}
		else
		{
			base.transform.position += vector3s[2];
		}
		if (tweenArguments.Contains("looktarget"))
		{
			base.transform.eulerAngles = eulerAngles;
		}
		postUpdate = base.transform.position;
		if (physics)
		{
			base.transform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyShakeScaleTargets()
	{
		if (percentage == 0f)
		{
			base.transform.localScale = vector3s[1];
		}
		base.transform.localScale = vector3s[0];
		float num = 1f - percentage;
		vector3s[2].x = UnityEngine.Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = UnityEngine.Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = UnityEngine.Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		base.transform.localScale += vector3s[2];
	}

	private void ApplyShakeRotationTargets()
	{
		preUpdate = base.transform.eulerAngles;
		if (percentage == 0f)
		{
			base.transform.Rotate(vector3s[1], space);
		}
		base.transform.eulerAngles = vector3s[0];
		float num = 1f - percentage;
		vector3s[2].x = UnityEngine.Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = UnityEngine.Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = UnityEngine.Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		base.transform.Rotate(vector3s[2], space);
		postUpdate = base.transform.eulerAngles;
		if (physics)
		{
			base.transform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyPunchPositionTargets()
	{
		preUpdate = base.transform.position;
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = base.transform.eulerAngles;
			base.transform.eulerAngles = vector3s[4];
		}
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		base.transform.Translate(vector3s[2] - vector3s[3], space);
		vector3s[3] = vector3s[2];
		if (tweenArguments.Contains("looktarget"))
		{
			base.transform.eulerAngles = eulerAngles;
		}
		postUpdate = base.transform.position;
		if (physics)
		{
			base.transform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyPunchRotationTargets()
	{
		preUpdate = base.transform.eulerAngles;
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		base.transform.Rotate(vector3s[2] - vector3s[3], space);
		vector3s[3] = vector3s[2];
		postUpdate = base.transform.eulerAngles;
		if (physics)
		{
			base.transform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyPunchScaleTargets()
	{
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		base.transform.localScale = vector3s[0] + vector3s[2];
	}

	private IEnumerator TweenDelay()
	{
		delayStarted = Time.time;
		yield return new WaitForSeconds(delay);
		if (wasPaused)
		{
			wasPaused = false;
			TweenStart();
		}
	}

	private void TweenStart()
	{
		CallBack("onstart");
		if (!loop)
		{
			ConflictCheck();
			GenerateTargets();
		}
		if (type == "stab")
		{
			audioSource.PlayOneShot(audioSource.clip);
		}
		if (type == "move" || type == "scale" || type == "rotate" || type == "punch" || type == "shake" || type == "curve" || type == "look")
		{
			EnableKinematic();
		}
		isRunning = true;
	}

	private IEnumerator TweenRestart()
	{
		if (delay > 0f)
		{
			delayStarted = Time.time;
			yield return new WaitForSeconds(delay);
		}
		loop = true;
		TweenStart();
	}

	private void TweenUpdate()
	{
		apply();
		CallBack("onupdate");
		UpdatePercentage();
	}

	private void TweenComplete()
	{
		isRunning = false;
		if (percentage > 0.5f)
		{
			percentage = 1f;
		}
		else
		{
			percentage = 0f;
		}
		apply();
		if (type == "value")
		{
			CallBack("onupdate");
		}
		if (loopType == LoopType.none)
		{
			Dispose();
		}
		else
		{
			TweenLoop();
		}
		CallBack("oncomplete");
	}

	private void TweenLoop()
	{
		DisableKinematic();
		switch (loopType)
		{
		case LoopType.loop:
			percentage = 0f;
			runningTime = 0f;
			apply();
			StartCoroutine("TweenRestart");
			break;
		case LoopType.pingPong:
			reverse = !reverse;
			runningTime = 0f;
			StartCoroutine("TweenRestart");
			break;
		}
	}

	public static Rect RectUpdate(Rect currentValue, Rect targetValue, float speed)
	{
		return new Rect(FloatUpdate(currentValue.x, targetValue.x, speed), FloatUpdate(currentValue.y, targetValue.y, speed), FloatUpdate(currentValue.width, targetValue.width, speed), FloatUpdate(currentValue.height, targetValue.height, speed));
	}

	public static Vector3 Vector3Update(Vector3 currentValue, Vector3 targetValue, float speed)
	{
		Vector3 a = targetValue - currentValue;
		currentValue += a * speed * Time.deltaTime;
		return currentValue;
	}

	public static Vector2 Vector2Update(Vector2 currentValue, Vector2 targetValue, float speed)
	{
		Vector2 a = targetValue - currentValue;
		currentValue += a * speed * Time.deltaTime;
		return currentValue;
	}

	public static float FloatUpdate(float currentValue, float targetValue, float speed)
	{
		float num = targetValue - currentValue;
		currentValue += num * speed * Time.deltaTime;
		return currentValue;
	}

	public static void FadeUpdate(GameObject target, Hashtable args)
	{
		args["a"] = args["alpha"];
		ColorUpdate(target, args);
	}

	public static void FadeUpdate(GameObject target, float alpha, float time)
	{
		FadeUpdate(target, Hash("alpha", alpha, "time", time));
	}

	public static void ColorUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Color[] array = new Color[4];
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				ColorUpdate(item.gameObject, args);
			}
		}
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		if ((bool)target.GetComponent(typeof(GUITexture)))
		{
			array[0] = (array[1] = target.GetComponent<GUITexture>().color);
		}
		else if ((bool)target.GetComponent(typeof(GUIText)))
		{
			array[0] = (array[1] = target.GetComponent<GUIText>().material.color);
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			array[0] = (array[1] = target.GetComponent<Renderer>().material.color);
		}
		else if ((bool)target.GetComponent<Light>())
		{
			array[0] = (array[1] = target.GetComponent<Light>().color);
		}
		if (args.Contains("color"))
		{
			array[1] = (Color)args["color"];
		}
		else
		{
			if (args.Contains("r"))
			{
				array[1].r = (float)args["r"];
			}
			if (args.Contains("g"))
			{
				array[1].g = (float)args["g"];
			}
			if (args.Contains("b"))
			{
				array[1].b = (float)args["b"];
			}
			if (args.Contains("a"))
			{
				array[1].a = (float)args["a"];
			}
		}
		array[3].r = Mathf.SmoothDamp(array[0].r, array[1].r, ref array[2].r, num);
		array[3].g = Mathf.SmoothDamp(array[0].g, array[1].g, ref array[2].g, num);
		array[3].b = Mathf.SmoothDamp(array[0].b, array[1].b, ref array[2].b, num);
		array[3].a = Mathf.SmoothDamp(array[0].a, array[1].a, ref array[2].a, num);
		if ((bool)target.GetComponent(typeof(GUITexture)))
		{
			target.GetComponent<GUITexture>().color = array[3];
		}
		else if ((bool)target.GetComponent(typeof(GUIText)))
		{
			target.GetComponent<GUIText>().material.color = array[3];
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			target.GetComponent<Renderer>().material.color = array[3];
		}
		else if ((bool)target.GetComponent<Light>())
		{
			target.GetComponent<Light>().color = array[3];
		}
	}

	public static void ColorUpdate(GameObject target, Color color, float time)
	{
		ColorUpdate(target, Hash("color", color, "time", time));
	}

	public static void AudioUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector2[] array = new Vector2[4];
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		AudioSource audioSource;
		if (args.Contains("audiosource"))
		{
			audioSource = (AudioSource)args["audiosource"];
		}
		else
		{
			if (!target.GetComponent(typeof(AudioSource)))
			{
				UnityEngine.Debug.LogError("iTween Error: AudioUpdate requires an AudioSource.");
				return;
			}
			audioSource = target.GetComponent<AudioSource>();
		}
		array[0] = (array[1] = new Vector2(audioSource.volume, audioSource.pitch));
		if (args.Contains("volume"))
		{
			array[1].x = (float)args["volume"];
		}
		if (args.Contains("pitch"))
		{
			array[1].y = (float)args["pitch"];
		}
		array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
		audioSource.volume = array[3].x;
		audioSource.pitch = array[3].y;
	}

	public static void AudioUpdate(GameObject target, float volume, float pitch, float time)
	{
		AudioUpdate(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void RotateUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		Vector3 eulerAngles = target.transform.eulerAngles;
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		bool flag = (!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]);
		if (flag)
		{
			array[0] = target.transform.localEulerAngles;
		}
		else
		{
			array[0] = target.transform.eulerAngles;
		}
		if (args.Contains("rotation"))
		{
			if (args["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["rotation"];
				array[1] = transform.eulerAngles;
			}
			else if (args["rotation"].GetType() == typeof(Vector3))
			{
				array[1] = (Vector3)args["rotation"];
			}
		}
		array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDampAngle(array[0].z, array[1].z, ref array[2].z, num);
		if (flag)
		{
			target.transform.localEulerAngles = array[3];
		}
		else
		{
			target.transform.eulerAngles = array[3];
		}
		if (target.GetComponent<Rigidbody>() != null)
		{
			Vector3 eulerAngles2 = target.transform.eulerAngles;
			target.transform.eulerAngles = eulerAngles;
			target.GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(eulerAngles2));
		}
	}

	public static void RotateUpdate(GameObject target, Vector3 rotation, float time)
	{
		RotateUpdate(target, Hash("rotation", rotation, "time", time));
	}

	public static void ScaleUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		array[0] = (array[1] = target.transform.localScale);
		if (args.Contains("scale"))
		{
			if (args["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["scale"];
				array[1] = transform.localScale;
			}
			else if (args["scale"].GetType() == typeof(Vector3))
			{
				array[1] = (Vector3)args["scale"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				array[1].x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				array[1].y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				array[1].z = (float)args["z"];
			}
		}
		array[3].x = Mathf.SmoothDamp(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDamp(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDamp(array[0].z, array[1].z, ref array[2].z, num);
		target.transform.localScale = array[3];
	}

	public static void ScaleUpdate(GameObject target, Vector3 scale, float time)
	{
		ScaleUpdate(target, Hash("scale", scale, "time", time));
	}

	public static void MoveUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		Vector3 position = target.transform.position;
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		bool flag = (!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]);
		if (flag)
		{
			array[0] = (array[1] = target.transform.localPosition);
		}
		else
		{
			array[0] = (array[1] = target.transform.position);
		}
		if (args.Contains("position"))
		{
			if (args["position"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["position"];
				array[1] = transform.position;
			}
			else if (args["position"].GetType() == typeof(Vector3))
			{
				array[1] = (Vector3)args["position"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				array[1].x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				array[1].y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				array[1].z = (float)args["z"];
			}
		}
		array[3].x = Mathf.SmoothDamp(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDamp(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDamp(array[0].z, array[1].z, ref array[2].z, num);
		if (args.Contains("orienttopath") && (bool)args["orienttopath"])
		{
			args["looktarget"] = array[3];
		}
		if (args.Contains("looktarget"))
		{
			LookUpdate(target, args);
		}
		if (flag)
		{
			target.transform.localPosition = array[3];
		}
		else
		{
			target.transform.position = array[3];
		}
		if (target.GetComponent<Rigidbody>() != null)
		{
			Vector3 position2 = target.transform.position;
			target.transform.position = position;
			target.GetComponent<Rigidbody>().MovePosition(position2);
		}
	}

	public static void MoveUpdate(GameObject target, Vector3 position, float time)
	{
		MoveUpdate(target, Hash("position", position, "time", time));
	}

	public static void LookUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[5];
		float num;
		if (args.Contains("looktime"))
		{
			num = (float)args["looktime"];
			num *= Defaults.updateTimePercentage;
		}
		else if (args.Contains("time"))
		{
			num = (float)args["time"] * 0.15f;
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		array[0] = target.transform.eulerAngles;
		if (args.Contains("looktarget"))
		{
			if (args["looktarget"].GetType() == typeof(Transform))
			{
				Transform transform = target.transform;
				Transform target2 = (Transform)args["looktarget"];
				Vector3? vector = (Vector3?)args["up"];
				transform.LookAt(target2, (!vector.HasValue) ? Defaults.up : vector.Value);
			}
			else if (args["looktarget"].GetType() == typeof(Vector3))
			{
				Transform transform2 = target.transform;
				Vector3 worldPosition = (Vector3)args["looktarget"];
				Vector3? vector2 = (Vector3?)args["up"];
				transform2.LookAt(worldPosition, (!vector2.HasValue) ? Defaults.up : vector2.Value);
			}
			array[1] = target.transform.eulerAngles;
			target.transform.eulerAngles = array[0];
			array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
			array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
			array[3].z = Mathf.SmoothDampAngle(array[0].z, array[1].z, ref array[2].z, num);
			target.transform.eulerAngles = array[3];
			if (args.Contains("axis"))
			{
				array[4] = target.transform.eulerAngles;
				switch ((string)args["axis"])
				{
				case "x":
					array[4].y = array[0].y;
					array[4].z = array[0].z;
					break;
				case "y":
					array[4].x = array[0].x;
					array[4].z = array[0].z;
					break;
				case "z":
					array[4].x = array[0].x;
					array[4].y = array[0].y;
					break;
				}
				target.transform.eulerAngles = array[4];
			}
		}
		else
		{
			UnityEngine.Debug.LogError("iTween Error: LookUpdate needs a 'looktarget' property!");
		}
	}

	public static void LookUpdate(GameObject target, Vector3 looktarget, float time)
	{
		LookUpdate(target, Hash("looktarget", looktarget, "time", time));
	}

	public static float PathLength(Transform[] path)
	{
		Vector3[] array = new Vector3[path.Length];
		float num = 0f;
		for (int i = 0; i < path.Length; i++)
		{
			array[i] = path[i].position;
		}
		Vector3[] pts = PathControlPointGenerator(array);
		Vector3 a = Interp(pts, 0f);
		int num2 = path.Length * 20;
		for (int j = 1; j <= num2; j++)
		{
			float t = (float)j / (float)num2;
			Vector3 vector = Interp(pts, t);
			num += Vector3.Distance(a, vector);
			a = vector;
		}
		return num;
	}

	public static float PathLength(Vector3[] path)
	{
		float num = 0f;
		Vector3[] pts = PathControlPointGenerator(path);
		Vector3 a = Interp(pts, 0f);
		int num2 = path.Length * 20;
		for (int i = 1; i <= num2; i++)
		{
			float t = (float)i / (float)num2;
			Vector3 vector = Interp(pts, t);
			num += Vector3.Distance(a, vector);
			a = vector;
		}
		return num;
	}

	public static Texture2D CameraTexture(Color color)
	{
		Texture2D texture2D = new Texture2D(Screen.width, Screen.height, TextureFormat.ARGB32, mipmap: false);
		Color[] array = new Color[Screen.width * Screen.height];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = color;
		}
		texture2D.SetPixels(array);
		texture2D.Apply();
		return texture2D;
	}

	public static void PutOnPath(GameObject target, Vector3[] path, float percent)
	{
		target.transform.position = Interp(PathControlPointGenerator(path), percent);
	}

	public static void PutOnPath(Transform target, Vector3[] path, float percent)
	{
		target.position = Interp(PathControlPointGenerator(path), percent);
	}

	public static void PutOnPath(GameObject target, Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			array[i] = path[i].position;
		}
		target.transform.position = Interp(PathControlPointGenerator(array), percent);
	}

	public static void PutOnPath(Transform target, Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			array[i] = path[i].position;
		}
		target.position = Interp(PathControlPointGenerator(array), percent);
	}

	public static Vector3 PointOnPath(Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			array[i] = path[i].position;
		}
		return Interp(PathControlPointGenerator(array), percent);
	}

	public static void DrawLine(Vector3[] line)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, Defaults.color, "gizmos");
		}
	}

	public static void DrawLine(Vector3[] line, Color color)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, color, "gizmos");
		}
	}

	public static void DrawLine(Transform[] line)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawLine(Transform[] line, Color color)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Vector3[] line)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, Defaults.color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Vector3[] line, Color color)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Transform[] line)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Transform[] line, Color color)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, color, "gizmos");
		}
	}

	public static void DrawLineHandles(Vector3[] line)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, Defaults.color, "handles");
		}
	}

	public static void DrawLineHandles(Vector3[] line, Color color)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, color, "handles");
		}
	}

	public static void DrawLineHandles(Transform[] line)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "handles");
		}
	}

	public static void DrawLineHandles(Transform[] line, Color color)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				array[i] = line[i].position;
			}
			DrawLineHelper(array, color, "handles");
		}
	}

	public static Vector3 PointOnPath(Vector3[] path, float percent)
	{
		return Interp(PathControlPointGenerator(path), percent);
	}

	public static void DrawPath(Vector3[] path)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, Defaults.color, "gizmos");
		}
	}

	public static void DrawPath(Vector3[] path, Color color)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, color, "gizmos");
		}
	}

	public static void DrawPath(Transform[] path)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawPath(Transform[] path, Color color)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Vector3[] path)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, Defaults.color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Vector3[] path, Color color)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Transform[] path)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Transform[] path, Color color)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, color, "gizmos");
		}
	}

	public static void DrawPathHandles(Vector3[] path)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, Defaults.color, "handles");
		}
	}

	public static void DrawPathHandles(Vector3[] path, Color color)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, color, "handles");
		}
	}

	public static void DrawPathHandles(Transform[] path)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "handles");
		}
	}

	public static void DrawPathHandles(Transform[] path, Color color)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				array[i] = path[i].position;
			}
			DrawPathHelper(array, color, "handles");
		}
	}

	public static void CameraFadeDepth(int depth)
	{
		if ((bool)cameraFade)
		{
			Transform transform = cameraFade.transform;
			Vector3 position = cameraFade.transform.position;
			float x = position.x;
			Vector3 position2 = cameraFade.transform.position;
			transform.position = new Vector3(x, position2.y, depth);
		}
	}

	public static void CameraFadeDestroy()
	{
		if ((bool)cameraFade)
		{
			UnityEngine.Object.Destroy(cameraFade);
		}
	}

	public static void CameraFadeSwap(Texture2D texture)
	{
		if ((bool)cameraFade)
		{
			cameraFade.GetComponent<GUITexture>().texture = texture;
		}
	}

	public static GameObject CameraFadeAdd(Texture2D texture, int depth)
	{
		if ((bool)cameraFade)
		{
			return null;
		}
		cameraFade = new GameObject("iTween Camera Fade");
		cameraFade.transform.position = new Vector3(0.5f, 0.5f, depth);
		cameraFade.AddComponent<GUITexture>();
		cameraFade.GetComponent<GUITexture>().texture = texture;
		cameraFade.GetComponent<GUITexture>().color = new Color(0.5f, 0.5f, 0.5f, 0f);
		return cameraFade;
	}

	public static GameObject CameraFadeAdd(Texture2D texture)
	{
		if ((bool)cameraFade)
		{
			return null;
		}
		cameraFade = new GameObject("iTween Camera Fade");
		cameraFade.transform.position = new Vector3(0.5f, 0.5f, Defaults.cameraFadeDepth);
		cameraFade.AddComponent<GUITexture>();
		cameraFade.GetComponent<GUITexture>().texture = texture;
		cameraFade.GetComponent<GUITexture>().color = new Color(0.5f, 0.5f, 0.5f, 0f);
		return cameraFade;
	}

	public static GameObject CameraFadeAdd()
	{
		if ((bool)cameraFade)
		{
			return null;
		}
		cameraFade = new GameObject("iTween Camera Fade");
		cameraFade.transform.position = new Vector3(0.5f, 0.5f, Defaults.cameraFadeDepth);
		cameraFade.AddComponent<GUITexture>();
		cameraFade.GetComponent<GUITexture>().texture = CameraTexture(Color.black);
		cameraFade.GetComponent<GUITexture>().color = new Color(0.5f, 0.5f, 0.5f, 0f);
		return cameraFade;
	}

	public static void Resume(GameObject target)
	{
		UnityEngine.Component[] components = target.GetComponents(typeof(iTween));
		UnityEngine.Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween = (iTween)array[i];
			iTween.enabled = true;
		}
	}

	public static void Resume(GameObject target, bool includechildren)
	{
		Resume(target);
		if (includechildren)
		{
			foreach (Transform item in target.transform)
			{
				Resume(item.gameObject, includechildren: true);
			}
		}
	}

	public static void Resume(GameObject target, string type)
	{
		UnityEngine.Component[] components = target.GetComponents(typeof(iTween));
		UnityEngine.Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween = (iTween)array[i];
			string text = iTween.type + iTween.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween.enabled = true;
			}
		}
	}

	public static void Resume(GameObject target, string type, bool includechildren)
	{
		UnityEngine.Component[] components = target.GetComponents(typeof(iTween));
		UnityEngine.Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween = (iTween)array[i];
			string text = iTween.type + iTween.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween.enabled = true;
			}
		}
		if (includechildren)
		{
			foreach (Transform item in target.transform)
			{
				Resume(item.gameObject, type, includechildren: true);
			}
		}
	}

	public static void Resume()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject target = (GameObject)hashtable["target"];
			Resume(target);
		}
	}

	public static void Resume(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Resume((GameObject)arrayList[j], type);
		}
	}

	public static void Pause(GameObject target)
	{
		UnityEngine.Component[] components = target.GetComponents(typeof(iTween));
		UnityEngine.Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween = (iTween)array[i];
			if (iTween.delay > 0f)
			{
				iTween.delay -= Time.time - iTween.delayStarted;
				iTween.StopCoroutine("TweenDelay");
			}
			iTween.isPaused = true;
			iTween.enabled = false;
		}
	}

	public static void Pause(GameObject target, bool includechildren)
	{
		Pause(target);
		if (includechildren)
		{
			foreach (Transform item in target.transform)
			{
				Pause(item.gameObject, includechildren: true);
			}
		}
	}

	public static void Pause(GameObject target, string type)
	{
		UnityEngine.Component[] components = target.GetComponents(typeof(iTween));
		UnityEngine.Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween = (iTween)array[i];
			string text = iTween.type + iTween.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				if (iTween.delay > 0f)
				{
					iTween.delay -= Time.time - iTween.delayStarted;
					iTween.StopCoroutine("TweenDelay");
				}
				iTween.isPaused = true;
				iTween.enabled = false;
			}
		}
	}

	public static void Pause(GameObject target, string type, bool includechildren)
	{
		UnityEngine.Component[] components = target.GetComponents(typeof(iTween));
		UnityEngine.Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween = (iTween)array[i];
			string text = iTween.type + iTween.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				if (iTween.delay > 0f)
				{
					iTween.delay -= Time.time - iTween.delayStarted;
					iTween.StopCoroutine("TweenDelay");
				}
				iTween.isPaused = true;
				iTween.enabled = false;
			}
		}
		if (includechildren)
		{
			foreach (Transform item in target.transform)
			{
				Pause(item.gameObject, type, includechildren: true);
			}
		}
	}

	public static void Pause()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject target = (GameObject)hashtable["target"];
			Pause(target);
		}
	}

	public static void Pause(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Pause((GameObject)arrayList[j], type);
		}
	}

	public static int Count()
	{
		return tweens.Count;
	}

	public static int Count(string type)
	{
		int num = 0;
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			string text = (string)hashtable["type"] + (string)hashtable["method"];
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				num++;
			}
		}
		return num;
	}

	public static int Count(GameObject target)
	{
		UnityEngine.Component[] components = target.GetComponents(typeof(iTween));
		return components.Length;
	}

	public static int Count(GameObject target, string type)
	{
		int num = 0;
		UnityEngine.Component[] components = target.GetComponents(typeof(iTween));
		UnityEngine.Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween = (iTween)array[i];
			string text = iTween.type + iTween.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				num++;
			}
		}
		return num;
	}

	public static void Stop()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject target = (GameObject)hashtable["target"];
			Stop(target);
		}
		tweens.Clear();
	}

	public static void Stop(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Stop((GameObject)arrayList[j], type);
		}
	}

	public static void StopByName(string name)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			StopByName((GameObject)arrayList[j], name);
		}
	}

	public static void Stop(GameObject target)
	{
		UnityEngine.Component[] components = target.GetComponents(typeof(iTween));
		UnityEngine.Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween = (iTween)array[i];
			iTween.Dispose();
		}
	}

	public static void Stop(GameObject target, bool includechildren)
	{
		Stop(target);
		if (includechildren)
		{
			foreach (Transform item in target.transform)
			{
				Stop(item.gameObject, includechildren: true);
			}
		}
	}

	public static void Stop(GameObject target, string type)
	{
		UnityEngine.Component[] components = target.GetComponents(typeof(iTween));
		UnityEngine.Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween = (iTween)array[i];
			string text = iTween.type + iTween.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween.Dispose();
			}
		}
	}

	public static void StopByName(GameObject target, string name)
	{
		UnityEngine.Component[] components = target.GetComponents(typeof(iTween));
		UnityEngine.Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween = (iTween)array[i];
			if (iTween._name == name)
			{
				iTween.Dispose();
			}
		}
	}

	public static void Stop(GameObject target, string type, bool includechildren)
	{
		UnityEngine.Component[] components = target.GetComponents(typeof(iTween));
		UnityEngine.Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween = (iTween)array[i];
			string text = iTween.type + iTween.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween.Dispose();
			}
		}
		if (includechildren)
		{
			foreach (Transform item in target.transform)
			{
				Stop(item.gameObject, type, includechildren: true);
			}
		}
	}

	public static void StopByName(GameObject target, string name, bool includechildren)
	{
		UnityEngine.Component[] components = target.GetComponents(typeof(iTween));
		UnityEngine.Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween = (iTween)array[i];
			if (iTween._name == name)
			{
				iTween.Dispose();
			}
		}
		if (includechildren)
		{
			foreach (Transform item in target.transform)
			{
				StopByName(item.gameObject, name, includechildren: true);
			}
		}
	}

	public static Hashtable Hash(params object[] args)
	{
		Hashtable hashtable = new Hashtable(args.Length / 2);
		if (args.Length % 2 != 0)
		{
			UnityEngine.Debug.LogError("Tween Error: Hash requires an even number of arguments!");
			return null;
		}
		for (int i = 0; i < args.Length - 1; i += 2)
		{
			hashtable.Add(args[i], args[i + 1]);
		}
		return hashtable;
	}

	private void Awake()
	{
		RetrieveArgs();
		lastRealTime = Time.realtimeSinceStartup;
	}

	private IEnumerator Start()
	{
		if (delay > 0f)
		{
			yield return StartCoroutine("TweenDelay");
		}
		TweenStart();
	}

	private void Update()
	{
		if (!isRunning || physics)
		{
			return;
		}
		if (!reverse)
		{
			if (percentage < 1f)
			{
				TweenUpdate();
			}
			else
			{
				TweenComplete();
			}
		}
		else if (percentage > 0f)
		{
			TweenUpdate();
		}
		else
		{
			TweenComplete();
		}
	}

	private void FixedUpdate()
	{
		if (!isRunning || !physics)
		{
			return;
		}
		if (!reverse)
		{
			if (percentage < 1f)
			{
				TweenUpdate();
			}
			else
			{
				TweenComplete();
			}
		}
		else if (percentage > 0f)
		{
			TweenUpdate();
		}
		else
		{
			TweenComplete();
		}
	}

	private void LateUpdate()
	{
		if (tweenArguments.Contains("looktarget") && isRunning && (type == "move" || type == "shake" || type == "punch"))
		{
			LookUpdate(base.gameObject, tweenArguments);
		}
	}

	private void OnEnable()
	{
		if (isRunning)
		{
			EnableKinematic();
		}
		if (isPaused)
		{
			isPaused = false;
			if (delay > 0f)
			{
				wasPaused = true;
				ResumeDelay();
			}
		}
	}

	private void OnDisable()
	{
		DisableKinematic();
	}

	private static void DrawLineHelper(Vector3[] line, Color color, string method)
	{
		Gizmos.color = color;
		for (int i = 0; i < line.Length - 1; i++)
		{
			if (method == "gizmos")
			{
				Gizmos.DrawLine(line[i], line[i + 1]);
			}
			else if (method == "handles")
			{
				UnityEngine.Debug.LogError("iTween Error: Drawing a line with Handles is temporarily disabled because of compatability issues with Unity 2.6!");
			}
		}
	}

	private static void DrawPathHelper(Vector3[] path, Color color, string method)
	{
		Vector3[] pts = PathControlPointGenerator(path);
		Vector3 to = Interp(pts, 0f);
		Gizmos.color = color;
		int num = path.Length * 20;
		for (int i = 1; i <= num; i++)
		{
			float t = (float)i / (float)num;
			Vector3 vector = Interp(pts, t);
			if (method == "gizmos")
			{
				Gizmos.DrawLine(vector, to);
			}
			else if (method == "handles")
			{
				UnityEngine.Debug.LogError("iTween Error: Drawing a path with Handles is temporarily disabled because of compatability issues with Unity 2.6!");
			}
			to = vector;
		}
	}

	private static Vector3[] PathControlPointGenerator(Vector3[] path)
	{
		int num = 2;
		Vector3[] array = new Vector3[path.Length + num];
		Array.Copy(path, 0, array, 1, path.Length);
		array[0] = array[1] + (array[1] - array[2]);
		array[array.Length - 1] = array[array.Length - 2] + (array[array.Length - 2] - array[array.Length - 3]);
		if (array[1] == array[array.Length - 2])
		{
			Vector3[] array2 = new Vector3[array.Length];
			Array.Copy(array, array2, array.Length);
			array2[0] = array2[array2.Length - 3];
			array2[array2.Length - 1] = array2[2];
			array = new Vector3[array2.Length];
			Array.Copy(array2, array, array2.Length);
		}
		return array;
	}

	private static Vector3 Interp(Vector3[] pts, float t)
	{
		int num = pts.Length - 3;
		int num2 = Mathf.Min(Mathf.FloorToInt(t * (float)num), num - 1);
		float num3 = t * (float)num - (float)num2;
		Vector3 a = pts[num2];
		Vector3 a2 = pts[num2 + 1];
		Vector3 vector = pts[num2 + 2];
		Vector3 b = pts[num2 + 3];
		return 0.5f * ((-a + 3f * a2 - 3f * vector + b) * (num3 * num3 * num3) + (2f * a - 5f * a2 + 4f * vector - b) * (num3 * num3) + (-a + vector) * num3 + 2f * a2);
	}

	private static void Launch(GameObject target, Hashtable args)
	{
		if (!args.Contains("id"))
		{
			args["id"] = GenerateID();
		}
		if (!args.Contains("target"))
		{
			args["target"] = target;
		}
		tweens.Insert(0, args);
		target.AddComponent<iTween>();
	}

	private static Hashtable CleanArgs(Hashtable args)
	{
		Hashtable hashtable = new Hashtable(args.Count);
		Hashtable hashtable2 = new Hashtable(args.Count);
		foreach (DictionaryEntry arg in args)
		{
			hashtable.Add(arg.Key, arg.Value);
		}
		foreach (DictionaryEntry item in hashtable)
		{
			if (item.Value.GetType() == typeof(int))
			{
				int num = (int)item.Value;
				float num2 = num;
				args[item.Key] = num2;
			}
			if (item.Value.GetType() == typeof(double))
			{
				double num3 = (double)item.Value;
				float num4 = (float)num3;
				args[item.Key] = num4;
			}
		}
		foreach (DictionaryEntry arg2 in args)
		{
			hashtable2.Add(arg2.Key.ToString().ToLower(), arg2.Value);
		}
		args = hashtable2;
		return args;
	}

	private static string GenerateID()
	{
		int num = 15;
		char[] array = new char[61]
		{
			'a',
			'b',
			'c',
			'd',
			'e',
			'f',
			'g',
			'h',
			'i',
			'j',
			'k',
			'l',
			'm',
			'n',
			'o',
			'p',
			'q',
			'r',
			's',
			't',
			'u',
			'v',
			'w',
			'x',
			'y',
			'z',
			'A',
			'B',
			'C',
			'D',
			'E',
			'F',
			'G',
			'H',
			'I',
			'J',
			'K',
			'L',
			'M',
			'N',
			'O',
			'P',
			'Q',
			'R',
			'S',
			'T',
			'U',
			'V',
			'W',
			'X',
			'Y',
			'Z',
			'0',
			'1',
			'2',
			'3',
			'4',
			'5',
			'6',
			'7',
			'8'
		};
		int max = array.Length - 1;
		string text = string.Empty;
		for (int i = 0; i < num; i++)
		{
			text += array[(int)Mathf.Floor(UnityEngine.Random.Range(0, max))];
		}
		return text;
	}

	private void RetrieveArgs()
	{
		foreach (Hashtable tween in tweens)
		{
			if ((GameObject)tween["target"] == base.gameObject)
			{
				tweenArguments = tween;
				break;
			}
		}
		id = (string)tweenArguments["id"];
		type = (string)tweenArguments["type"];
		_name = (string)tweenArguments["name"];
		method = (string)tweenArguments["method"];
		if (tweenArguments.Contains("time"))
		{
			time = (float)tweenArguments["time"];
		}
		else
		{
			time = Defaults.time;
		}
		if (GetComponent<Rigidbody>() != null)
		{
			physics = true;
		}
		if (tweenArguments.Contains("delay"))
		{
			delay = (float)tweenArguments["delay"];
		}
		else
		{
			delay = Defaults.delay;
		}
		if (tweenArguments.Contains("namedcolorvalue"))
		{
			if (tweenArguments["namedcolorvalue"].GetType() == typeof(NamedValueColor))
			{
				namedcolorvalue = (NamedValueColor)(int)tweenArguments["namedcolorvalue"];
			}
			else
			{
				try
				{
					namedcolorvalue = (NamedValueColor)(int)Enum.Parse(typeof(NamedValueColor), (string)tweenArguments["namedcolorvalue"], ignoreCase: true);
				}
				catch
				{
					UnityEngine.Debug.LogWarning("iTween: Unsupported namedcolorvalue supplied! Default will be used.");
					namedcolorvalue = NamedValueColor._Color;
				}
			}
		}
		else
		{
			namedcolorvalue = Defaults.namedColorValue;
		}
		if (tweenArguments.Contains("looptype"))
		{
			if (tweenArguments["looptype"].GetType() == typeof(LoopType))
			{
				loopType = (LoopType)(int)tweenArguments["looptype"];
			}
			else
			{
				try
				{
					loopType = (LoopType)(int)Enum.Parse(typeof(LoopType), (string)tweenArguments["looptype"], ignoreCase: true);
				}
				catch
				{
					UnityEngine.Debug.LogWarning("iTween: Unsupported loopType supplied! Default will be used.");
					loopType = LoopType.none;
				}
			}
		}
		else
		{
			loopType = LoopType.none;
		}
		if (tweenArguments.Contains("easetype"))
		{
			if (tweenArguments["easetype"].GetType() == typeof(EaseType))
			{
				easeType = (EaseType)(int)tweenArguments["easetype"];
			}
			else
			{
				try
				{
					easeType = (EaseType)(int)Enum.Parse(typeof(EaseType), (string)tweenArguments["easetype"], ignoreCase: true);
				}
				catch
				{
					UnityEngine.Debug.LogWarning("iTween: Unsupported easeType supplied! Default will be used.");
					easeType = Defaults.easeType;
				}
			}
		}
		else
		{
			easeType = Defaults.easeType;
		}
		if (tweenArguments.Contains("space"))
		{
			if (tweenArguments["space"].GetType() == typeof(Space))
			{
				space = (Space)(int)tweenArguments["space"];
			}
			else
			{
				try
				{
					space = (Space)(int)Enum.Parse(typeof(Space), (string)tweenArguments["space"], ignoreCase: true);
				}
				catch
				{
					UnityEngine.Debug.LogWarning("iTween: Unsupported space supplied! Default will be used.");
					space = Defaults.space;
				}
			}
		}
		else
		{
			space = Defaults.space;
		}
		if (tweenArguments.Contains("islocal"))
		{
			isLocal = (bool)tweenArguments["islocal"];
		}
		else
		{
			isLocal = Defaults.isLocal;
		}
		if (tweenArguments.Contains("ignoretimescale"))
		{
			useRealTime = (bool)tweenArguments["ignoretimescale"];
		}
		else
		{
			useRealTime = Defaults.useRealTime;
		}
		GetEasingFunction();
	}

	private void GetEasingFunction()
	{
		switch (easeType)
		{
		case EaseType.easeInQuad:
			ease = easeInQuad;
			break;
		case EaseType.easeOutQuad:
			ease = easeOutQuad;
			break;
		case EaseType.easeInOutQuad:
			ease = easeInOutQuad;
			break;
		case EaseType.easeInCubic:
			ease = easeInCubic;
			break;
		case EaseType.easeOutCubic:
			ease = easeOutCubic;
			break;
		case EaseType.easeInOutCubic:
			ease = easeInOutCubic;
			break;
		case EaseType.easeInQuart:
			ease = easeInQuart;
			break;
		case EaseType.easeOutQuart:
			ease = easeOutQuart;
			break;
		case EaseType.easeInOutQuart:
			ease = easeInOutQuart;
			break;
		case EaseType.easeInQuint:
			ease = easeInQuint;
			break;
		case EaseType.easeOutQuint:
			ease = easeOutQuint;
			break;
		case EaseType.easeInOutQuint:
			ease = easeInOutQuint;
			break;
		case EaseType.easeInSine:
			ease = easeInSine;
			break;
		case EaseType.easeOutSine:
			ease = easeOutSine;
			break;
		case EaseType.easeInOutSine:
			ease = easeInOutSine;
			break;
		case EaseType.easeInExpo:
			ease = easeInExpo;
			break;
		case EaseType.easeOutExpo:
			ease = easeOutExpo;
			break;
		case EaseType.easeInOutExpo:
			ease = easeInOutExpo;
			break;
		case EaseType.easeInCirc:
			ease = easeInCirc;
			break;
		case EaseType.easeOutCirc:
			ease = easeOutCirc;
			break;
		case EaseType.easeInOutCirc:
			ease = easeInOutCirc;
			break;
		case EaseType.linear:
			ease = linear;
			break;
		case EaseType.spring:
			ease = spring;
			break;
		case EaseType.easeInBounce:
			ease = easeInBounce;
			break;
		case EaseType.easeOutBounce:
			ease = easeOutBounce;
			break;
		case EaseType.easeInOutBounce:
			ease = easeInOutBounce;
			break;
		case EaseType.easeInBack:
			ease = easeInBack;
			break;
		case EaseType.easeOutBack:
			ease = easeOutBack;
			break;
		case EaseType.easeInOutBack:
			ease = easeInOutBack;
			break;
		case EaseType.easeInElastic:
			ease = easeInElastic;
			break;
		case EaseType.easeOutElastic:
			ease = easeOutElastic;
			break;
		case EaseType.easeInOutElastic:
			ease = easeInOutElastic;
			break;
		}
	}

	private void UpdatePercentage()
	{
		if (useRealTime)
		{
			runningTime += Time.realtimeSinceStartup - lastRealTime;
		}
		else
		{
			runningTime += Time.deltaTime;
		}
		if (reverse)
		{
			percentage = 1f - runningTime / time;
		}
		else
		{
			percentage = runningTime / time;
		}
		lastRealTime = Time.realtimeSinceStartup;
	}

	private void CallBack(string callbackType)
	{
		if (tweenArguments.Contains(callbackType) && !tweenArguments.Contains("ischild"))
		{
			GameObject gameObject = (!tweenArguments.Contains(callbackType + "target")) ? base.gameObject : ((GameObject)tweenArguments[callbackType + "target"]);
			if (tweenArguments[callbackType].GetType() == typeof(string))
			{
				gameObject.SendMessage((string)tweenArguments[callbackType], tweenArguments[callbackType + "params"], SendMessageOptions.DontRequireReceiver);
				return;
			}
			UnityEngine.Debug.LogError("iTween Error: Callback method references must be passed as a String!");
			UnityEngine.Object.Destroy(this);
		}
	}

	private void Dispose()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			if ((string)hashtable["id"] == id)
			{
				tweens.RemoveAt(i);
				break;
			}
		}
		UnityEngine.Object.Destroy(this);
	}

	private void ConflictCheck()
	{
		UnityEngine.Component[] components = GetComponents(typeof(iTween));
		UnityEngine.Component[] array = components;
		int num = 0;
		iTween iTween;
		while (true)
		{
			if (num >= array.Length)
			{
				return;
			}
			iTween = (iTween)array[num];
			if (iTween.type == "value")
			{
				return;
			}
			if (iTween.isRunning && iTween.type == type)
			{
				if (iTween.method != method)
				{
					return;
				}
				if (iTween.tweenArguments.Count != tweenArguments.Count)
				{
					break;
				}
				foreach (DictionaryEntry tweenArgument in tweenArguments)
				{
					if (!iTween.tweenArguments.Contains(tweenArgument.Key))
					{
						iTween.Dispose();
						return;
					}
					if (!iTween.tweenArguments[tweenArgument.Key].Equals(tweenArguments[tweenArgument.Key]) && (string)tweenArgument.Key != "id")
					{
						iTween.Dispose();
						return;
					}
				}
				Dispose();
			}
			num++;
		}
		iTween.Dispose();
	}

	private void EnableKinematic()
	{
	}

	private void DisableKinematic()
	{
	}

	private void ResumeDelay()
	{
		StartCoroutine("TweenDelay");
	}

	private float linear(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, value);
	}

	private float clerp(float start, float end, float value)
	{
		float num = 0f;
		float num2 = 360f;
		float num3 = Mathf.Abs((num2 - num) / 2f);
		float num4 = 0f;
		float num5 = 0f;
		if (end - start < 0f - num3)
		{
			num5 = (num2 - start + end) * value;
			return start + num5;
		}
		if (end - start > num3)
		{
			num5 = (0f - (num2 - end + start)) * value;
			return start + num5;
		}
		return start + (end - start) * value;
	}

	private float spring(float start, float end, float value)
	{
		value = Mathf.Clamp01(value);
		value = (Mathf.Sin(value * (float)Math.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + 1.2f * (1f - value));
		return start + (end - start) * value;
	}

	private float easeInQuad(float start, float end, float value)
	{
		end -= start;
		return end * value * value + start;
	}

	private float easeOutQuad(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * value * (value - 2f) + start;
	}

	private float easeInOutQuad(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * value * value + start;
		}
		value -= 1f;
		return (0f - end) / 2f * (value * (value - 2f) - 1f) + start;
	}

	private float easeInCubic(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value + start;
	}

	private float easeOutCubic(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value + 1f) + start;
	}

	private float easeInOutCubic(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * value * value * value + start;
		}
		value -= 2f;
		return end / 2f * (value * value * value + 2f) + start;
	}

	private float easeInQuart(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value * value + start;
	}

	private float easeOutQuart(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return (0f - end) * (value * value * value * value - 1f) + start;
	}

	private float easeInOutQuart(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * value * value * value * value + start;
		}
		value -= 2f;
		return (0f - end) / 2f * (value * value * value * value - 2f) + start;
	}

	private float easeInQuint(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value * value * value + start;
	}

	private float easeOutQuint(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value * value * value + 1f) + start;
	}

	private float easeInOutQuint(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * value * value * value * value * value + start;
		}
		value -= 2f;
		return end / 2f * (value * value * value * value * value + 2f) + start;
	}

	private float easeInSine(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * Mathf.Cos(value / 1f * ((float)Math.PI / 2f)) + end + start;
	}

	private float easeOutSine(float start, float end, float value)
	{
		end -= start;
		return end * Mathf.Sin(value / 1f * ((float)Math.PI / 2f)) + start;
	}

	private float easeInOutSine(float start, float end, float value)
	{
		end -= start;
		return (0f - end) / 2f * (Mathf.Cos((float)Math.PI * value / 1f) - 1f) + start;
	}

	private float easeInExpo(float start, float end, float value)
	{
		end -= start;
		return end * Mathf.Pow(2f, 10f * (value / 1f - 1f)) + start;
	}

	private float easeOutExpo(float start, float end, float value)
	{
		end -= start;
		return end * (0f - Mathf.Pow(2f, -10f * value / 1f) + 1f) + start;
	}

	private float easeInOutExpo(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * Mathf.Pow(2f, 10f * (value - 1f)) + start;
		}
		value -= 1f;
		return end / 2f * (0f - Mathf.Pow(2f, -10f * value) + 2f) + start;
	}

	private float easeInCirc(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * (Mathf.Sqrt(1f - value * value) - 1f) + start;
	}

	private float easeOutCirc(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * Mathf.Sqrt(1f - value * value) + start;
	}

	private float easeInOutCirc(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return (0f - end) / 2f * (Mathf.Sqrt(1f - value * value) - 1f) + start;
		}
		value -= 2f;
		return end / 2f * (Mathf.Sqrt(1f - value * value) + 1f) + start;
	}

	private float easeInBounce(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		return end - easeOutBounce(0f, end, num - value) + start;
	}

	private float easeOutBounce(float start, float end, float value)
	{
		value /= 1f;
		end -= start;
		if (value < 0.363636374f)
		{
			return end * (7.5625f * value * value) + start;
		}
		if (value < 0.727272749f)
		{
			value -= 0.545454562f;
			return end * (7.5625f * value * value + 0.75f) + start;
		}
		if ((double)value < 0.90909090909090906)
		{
			value -= 0.8181818f;
			return end * (7.5625f * value * value + 0.9375f) + start;
		}
		value -= 21f / 22f;
		return end * (7.5625f * value * value + 63f / 64f) + start;
	}

	private float easeInOutBounce(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		if (value < num / 2f)
		{
			return easeInBounce(0f, end, value * 2f) * 0.5f + start;
		}
		return easeOutBounce(0f, end, value * 2f - num) * 0.5f + end * 0.5f + start;
	}

	private float easeInBack(float start, float end, float value)
	{
		end -= start;
		value /= 1f;
		float num = 1.70158f;
		return end * value * value * ((num + 1f) * value - num) + start;
	}

	private float easeOutBack(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value = value / 1f - 1f;
		return end * (value * value * ((num + 1f) * value + num) + 1f) + start;
	}

	private float easeInOutBack(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value /= 0.5f;
		if (value < 1f)
		{
			num *= 1.525f;
			return end / 2f * (value * value * ((num + 1f) * value - num)) + start;
		}
		value -= 2f;
		num *= 1.525f;
		return end / 2f * (value * value * ((num + 1f) * value + num) + 2f) + start;
	}

	private float punch(float amplitude, float value)
	{
		float num = 9f;
		if (value == 0f)
		{
			return 0f;
		}
		if (value == 1f)
		{
			return 0f;
		}
		float num2 = 0.3f;
		num = num2 / ((float)Math.PI * 2f) * Mathf.Asin(0f);
		return amplitude * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * 1f - num) * ((float)Math.PI * 2f) / num2);
	}

	private float easeInElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 / 4f;
		}
		else
		{
			num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
		}
		return 0f - num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) + start;
	}

	private float easeOutElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 / 4f;
		}
		else
		{
			num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
		}
		return num4 * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) + end + start;
	}

	private float easeInOutElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num / 2f) == 2f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 / 4f;
		}
		else
		{
			num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
		}
		if (value < 1f)
		{
			return -0.5f * (num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2)) + start;
		}
		return num4 * Mathf.Pow(2f, -10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) * 0.5f + end + start;
	}
}
namespace Pathfinding
{
	public delegate void GraphNodeDelegate(GraphNode node);
	public delegate bool GraphNodeDelegateCancelable(GraphNode node);
}
public delegate void OnPathDelegate(Pathfinding.Path p);
public delegate Vector3[] GetNextTargetDelegate(Pathfinding.Path p, Vector3 currentPosition);
public delegate void NodeDelegate(GraphNode node);
public delegate void OnGraphDelegate(NavGraph graph);
public delegate void OnScanDelegate(AstarPath script);
public delegate void OnVoidDelegate();
public delegate void OnScanStatus(Progress progress);
public delegate void OnAudioVolumesChangedEventHandler();
public delegate void RoomPowerModeChangedEventHandler(bool on);
public delegate void HeroStatsPanelChangedEventHandler(bool on);
public delegate void InGameClickDownEventHandler(MouseButton mouseButton);
public delegate void DungeonFIDSChangedEventHandler();
public delegate void DungeonTurnChangedEventHandler();
public delegate void LastDoorOpenedEventHandler();
public delegate void GamePhaseChangedEventHandler();
public delegate void HeroSelectionEventHandler();
public delegate void RoomSelectionEventHandler(Room selectedRoom);
public delegate void ModuleBuiltEventHandler(BluePrintConfig bpConfig);
public delegate void DisplayedHeroStatsRefreshedEventHandler(Hero displayedHero);
public delegate void ItemListSelectedEventHandler(InventoryListPanel sender, InventoryGuiItem inventoryGuiItem);
public delegate void GameVictoryEventHandler();
public delegate void GameStoppedEventHandler(bool killAutoSave);
public delegate void GameStartedEventHandler();
public delegate void HeroListChangedEventHandler();
public delegate void MajorModuleCategorySelectedEventHandler();
public delegate void MajorModuleCategoryUnselectedEventHandler();
public delegate void MinorModuleCategorySelectedEventHandler();
public delegate void MinorModuleCategoryUnselectedEventHandler();
public delegate void DoorOpenedByHeroTutorialEventHandler();
public delegate void HeroMovedToRoomTutorialEventHandler();
public delegate void RoomPoweredTutorialEventHandler();
public delegate void BuiltModuleTutorialEventHandler();
public delegate void SelectionCategoryChangedHandler(SelectionCategoryData newCategoryData);
public delegate void MoveTargetReachedHandler();
public delegate void ILightManagerServiceOnUpdateEvent(Camera camera, Vector3 minBBox, Vector3 maxBBox);
public delegate void NotificationClickHandler();
public delegate void ZoomEndHandler();
public delegate void OnGameResolutionChangedEventHandler();
public delegate void OnVSyncChangedEventHandler();
